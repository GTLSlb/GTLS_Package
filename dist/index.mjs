import * as React from "react";
import React__default, { useRef, useEffect, createContext, useState, useMemo, useContext, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef, useCallback } from "react";
import "tailwindcss/tailwind.css";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(L) {
  return L && L.__esModule && Object.prototype.hasOwnProperty.call(L, "default") ? L.default : L;
}
function getAugmentedNamespace(L) {
  if (L.__esModule)
    return L;
  var ne = L.default;
  if (typeof ne == "function") {
    var oe = function pe() {
      return this instanceof pe ? Reflect.construct(ne, arguments, this.constructor) : ne.apply(this, arguments);
    };
    oe.prototype = ne.prototype;
  } else
    oe = {};
  return Object.defineProperty(oe, "__esModule", { value: !0 }), Object.keys(L).forEach(function(pe) {
    var me = Object.getOwnPropertyDescriptor(L, pe);
    Object.defineProperty(oe, pe, me.get ? me : {
      enumerable: !0,
      get: function() {
        return L[pe];
      }
    });
  }), oe;
}
var lottie$1 = { exports: {} };
(function(module, exports) {
  typeof navigator < "u" && function(L, ne) {
    module.exports = ne();
  }(commonjsGlobal, function() {
    var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function(ne) {
      _useWebWorker = !!ne;
    }, getWebWorker = function() {
      return _useWebWorker;
    }, setLocationHref = function(ne) {
      locationHref = ne;
    }, getLocationHref = function() {
      return locationHref;
    };
    function createTag(L) {
      return document.createElement(L);
    }
    function extendPrototype(L, ne) {
      var oe, pe = L.length, me;
      for (oe = 0; oe < pe; oe += 1) {
        me = L[oe].prototype;
        for (var ge in me)
          Object.prototype.hasOwnProperty.call(me, ge) && (ne.prototype[ge] = me[ge]);
      }
    }
    function getDescriptor(L, ne) {
      return Object.getOwnPropertyDescriptor(L, ne);
    }
    function createProxyFunction(L) {
      function ne() {
      }
      return ne.prototype = L, ne;
    }
    var audioControllerFactory = function() {
      function L(ne) {
        this.audios = [], this.audioFactory = ne, this._volume = 1, this._isMuted = !1;
      }
      return L.prototype = {
        addAudio: function(oe) {
          this.audios.push(oe);
        },
        pause: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].pause();
        },
        resume: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].resume();
        },
        setRate: function(oe) {
          var pe, me = this.audios.length;
          for (pe = 0; pe < me; pe += 1)
            this.audios[pe].setRate(oe);
        },
        createAudio: function(oe) {
          return this.audioFactory ? this.audioFactory(oe) : window.Howl ? new window.Howl({
            src: [oe]
          }) : {
            isPlaying: !1,
            play: function() {
              this.isPlaying = !0;
            },
            seek: function() {
              this.isPlaying = !1;
            },
            playing: function() {
            },
            rate: function() {
            },
            setVolume: function() {
            }
          };
        },
        setAudioFactory: function(oe) {
          this.audioFactory = oe;
        },
        setVolume: function(oe) {
          this._volume = oe, this._updateVolume();
        },
        mute: function() {
          this._isMuted = !0, this._updateVolume();
        },
        unmute: function() {
          this._isMuted = !1, this._updateVolume();
        },
        getVolume: function() {
          return this._volume;
        },
        _updateVolume: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].volume(this._volume * (this._isMuted ? 0 : 1));
        }
      }, function() {
        return new L();
      };
    }(), createTypedArray = /* @__PURE__ */ function() {
      function L(oe, pe) {
        var me = 0, ge = [], be;
        switch (oe) {
          case "int16":
          case "uint8c":
            be = 1;
            break;
          default:
            be = 1.1;
            break;
        }
        for (me = 0; me < pe; me += 1)
          ge.push(be);
        return ge;
      }
      function ne(oe, pe) {
        return oe === "float32" ? new Float32Array(pe) : oe === "int16" ? new Int16Array(pe) : oe === "uint8c" ? new Uint8ClampedArray(pe) : L(oe, pe);
      }
      return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? ne : L;
    }();
    function createSizedArray(L) {
      return Array.apply(null, {
        length: L
      });
    }
    function _typeof$6(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(oe) {
        return typeof oe;
      } : _typeof$6 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$6(L);
    }
    var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {};
    (function() {
      var L = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        BMMath[L[ne]] = Math[L[ne]];
    })(), BMMath.random = Math.random, BMMath.abs = function(L) {
      var ne = _typeof$6(L);
      if (ne === "object" && L.length) {
        var oe = createSizedArray(L.length), pe, me = L.length;
        for (pe = 0; pe < me; pe += 1)
          oe[pe] = Math.abs(L[pe]);
        return oe;
      }
      return Math.abs(L);
    };
    var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = 0.5519;
    function styleDiv(L) {
      L.style.position = "absolute", L.style.top = 0, L.style.left = 0, L.style.display = "block", L.style.transformOrigin = "0 0", L.style.webkitTransformOrigin = "0 0", L.style.backfaceVisibility = "visible", L.style.webkitBackfaceVisibility = "visible", L.style.transformStyle = "preserve-3d", L.style.webkitTransformStyle = "preserve-3d", L.style.mozTransformStyle = "preserve-3d";
    }
    function BMEnterFrameEvent(L, ne, oe, pe) {
      this.type = L, this.currentTime = ne, this.totalTime = oe, this.direction = pe < 0 ? -1 : 1;
    }
    function BMCompleteEvent(L, ne) {
      this.type = L, this.direction = ne < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(L, ne, oe, pe) {
      this.type = L, this.currentLoop = oe, this.totalLoops = ne, this.direction = pe < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(L, ne, oe) {
      this.type = L, this.firstFrame = ne, this.totalFrames = oe;
    }
    function BMDestroyEvent(L, ne) {
      this.type = L, this.target = ne;
    }
    function BMRenderFrameErrorEvent(L, ne) {
      this.type = "renderFrameError", this.nativeError = L, this.currentTime = ne;
    }
    function BMConfigErrorEvent(L) {
      this.type = "configError", this.nativeError = L;
    }
    var createElementID = /* @__PURE__ */ function() {
      var L = 0;
      return function() {
        return L += 1, idPrefix$1 + "__lottie_element_" + L;
      };
    }();
    function HSVtoRGB(L, ne, oe) {
      var pe, me, ge, be, Ie, Ae, rt, st;
      switch (be = Math.floor(L * 6), Ie = L * 6 - be, Ae = oe * (1 - ne), rt = oe * (1 - Ie * ne), st = oe * (1 - (1 - Ie) * ne), be % 6) {
        case 0:
          pe = oe, me = st, ge = Ae;
          break;
        case 1:
          pe = rt, me = oe, ge = Ae;
          break;
        case 2:
          pe = Ae, me = oe, ge = st;
          break;
        case 3:
          pe = Ae, me = rt, ge = oe;
          break;
        case 4:
          pe = st, me = Ae, ge = oe;
          break;
        case 5:
          pe = oe, me = Ae, ge = rt;
          break;
      }
      return [pe, me, ge];
    }
    function RGBtoHSV(L, ne, oe) {
      var pe = Math.max(L, ne, oe), me = Math.min(L, ne, oe), ge = pe - me, be, Ie = pe === 0 ? 0 : ge / pe, Ae = pe / 255;
      switch (pe) {
        case me:
          be = 0;
          break;
        case L:
          be = ne - oe + ge * (ne < oe ? 6 : 0), be /= 6 * ge;
          break;
        case ne:
          be = oe - L + ge * 2, be /= 6 * ge;
          break;
        case oe:
          be = L - ne + ge * 4, be /= 6 * ge;
          break;
      }
      return [be, Ie, Ae];
    }
    function addSaturationToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[1] += ne, oe[1] > 1 ? oe[1] = 1 : oe[1] <= 0 && (oe[1] = 0), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    function addBrightnessToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[2] += ne, oe[2] > 1 ? oe[2] = 1 : oe[2] < 0 && (oe[2] = 0), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    function addHueToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[0] += ne / 360, oe[0] > 1 ? oe[0] -= 1 : oe[0] < 0 && (oe[0] += 1), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    var rgbToHex = function() {
      var L = [], ne, oe;
      for (ne = 0; ne < 256; ne += 1)
        oe = ne.toString(16), L[ne] = oe.length === 1 ? "0" + oe : oe;
      return function(pe, me, ge) {
        return pe < 0 && (pe = 0), me < 0 && (me = 0), ge < 0 && (ge = 0), "#" + L[pe] + L[me] + L[ge];
      };
    }(), setSubframeEnabled = function(ne) {
      subframeEnabled = !!ne;
    }, getSubframeEnabled = function() {
      return subframeEnabled;
    }, setExpressionsPlugin = function(ne) {
      expressionsPlugin = ne;
    }, getExpressionsPlugin = function() {
      return expressionsPlugin;
    }, setExpressionInterfaces = function(ne) {
      expressionsInterfaces = ne;
    }, getExpressionInterfaces = function() {
      return expressionsInterfaces;
    }, setDefaultCurveSegments = function(ne) {
      defaultCurveSegments = ne;
    }, getDefaultCurveSegments = function() {
      return defaultCurveSegments;
    }, setIdPrefix = function(ne) {
      idPrefix$1 = ne;
    };
    function createNS(L) {
      return document.createElementNS(svgNS, L);
    }
    function _typeof$5(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(oe) {
        return typeof oe;
      } : _typeof$5 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$5(L);
    }
    var dataManager = /* @__PURE__ */ function() {
      var L = 1, ne = [], oe, pe, me = {
        onmessage: function() {
        },
        postMessage: function(ht) {
          oe({
            data: ht
          });
        }
      }, ge = {
        postMessage: function(ht) {
          me.onmessage({
            data: ht
          });
        }
      };
      function be(ut) {
        if (window.Worker && window.Blob && getWebWorker()) {
          var ht = new Blob(["var _workerSelf = self; self.onmessage = ", ut.toString()], {
            type: "text/javascript"
          }), it = URL.createObjectURL(ht);
          return new Worker(it);
        }
        return oe = ut, me;
      }
      function Ie() {
        pe || (pe = be(function(ht) {
          function it() {
            function St(Qt, wt) {
              var Ft, yt, Et = Qt.length, Dt, Ot, nr, yr;
              for (yt = 0; yt < Et; yt += 1)
                if (Ft = Qt[yt], "ks" in Ft && !Ft.completed) {
                  if (Ft.completed = !0, Ft.hasMask) {
                    var mr = Ft.masksProperties;
                    for (Ot = mr.length, Dt = 0; Dt < Ot; Dt += 1)
                      if (mr[Dt].pt.k.i)
                        xt(mr[Dt].pt.k);
                      else
                        for (yr = mr[Dt].pt.k.length, nr = 0; nr < yr; nr += 1)
                          mr[Dt].pt.k[nr].s && xt(mr[Dt].pt.k[nr].s[0]), mr[Dt].pt.k[nr].e && xt(mr[Dt].pt.k[nr].e[0]);
                  }
                  Ft.ty === 0 ? (Ft.layers = ft(Ft.refId, wt), St(Ft.layers, wt)) : Ft.ty === 4 ? vt(Ft.shapes) : Ft.ty === 5 && Jt(Ft);
                }
            }
            function ot(Qt, wt) {
              if (Qt) {
                var Ft = 0, yt = Qt.length;
                for (Ft = 0; Ft < yt; Ft += 1)
                  Qt[Ft].t === 1 && (Qt[Ft].data.layers = ft(Qt[Ft].data.refId, wt), St(Qt[Ft].data.layers, wt));
              }
            }
            function pt(Qt, wt) {
              for (var Ft = 0, yt = wt.length; Ft < yt; ) {
                if (wt[Ft].id === Qt)
                  return wt[Ft];
                Ft += 1;
              }
              return null;
            }
            function ft(Qt, wt) {
              var Ft = pt(Qt, wt);
              return Ft ? Ft.layers.__used ? JSON.parse(JSON.stringify(Ft.layers)) : (Ft.layers.__used = !0, Ft.layers) : null;
            }
            function vt(Qt) {
              var wt, Ft = Qt.length, yt, Et;
              for (wt = Ft - 1; wt >= 0; wt -= 1)
                if (Qt[wt].ty === "sh")
                  if (Qt[wt].ks.k.i)
                    xt(Qt[wt].ks.k);
                  else
                    for (Et = Qt[wt].ks.k.length, yt = 0; yt < Et; yt += 1)
                      Qt[wt].ks.k[yt].s && xt(Qt[wt].ks.k[yt].s[0]), Qt[wt].ks.k[yt].e && xt(Qt[wt].ks.k[yt].e[0]);
                else
                  Qt[wt].ty === "gr" && vt(Qt[wt].it);
            }
            function xt(Qt) {
              var wt, Ft = Qt.i.length;
              for (wt = 0; wt < Ft; wt += 1)
                Qt.i[wt][0] += Qt.v[wt][0], Qt.i[wt][1] += Qt.v[wt][1], Qt.o[wt][0] += Qt.v[wt][0], Qt.o[wt][1] += Qt.v[wt][1];
            }
            function Ct(Qt, wt) {
              var Ft = wt ? wt.split(".") : [100, 100, 100];
              return Qt[0] > Ft[0] ? !0 : Ft[0] > Qt[0] ? !1 : Qt[1] > Ft[1] ? !0 : Ft[1] > Qt[1] ? !1 : Qt[2] > Ft[2] ? !0 : Ft[2] > Qt[2] ? !1 : null;
            }
            var At = /* @__PURE__ */ function() {
              var Qt = [4, 4, 14];
              function wt(yt) {
                var Et = yt.t.d;
                yt.t.d = {
                  k: [{
                    s: Et,
                    t: 0
                  }]
                };
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 5 && wt(yt[Et]);
              }
              return function(yt) {
                if (Ct(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), kt = /* @__PURE__ */ function() {
              var Qt = [4, 7, 99];
              return function(wt) {
                if (wt.chars && !Ct(Qt, wt.v)) {
                  var Ft, yt = wt.chars.length;
                  for (Ft = 0; Ft < yt; Ft += 1) {
                    var Et = wt.chars[Ft];
                    Et.data && Et.data.shapes && (vt(Et.data.shapes), Et.data.ip = 0, Et.data.op = 99999, Et.data.st = 0, Et.data.sr = 1, Et.data.ks = {
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      }
                    }, wt.chars[Ft].t || (Et.data.shapes.push({
                      ty: "no"
                    }), Et.data.shapes[0].it.push({
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      },
                      sk: {
                        k: 0,
                        a: 0
                      },
                      sa: {
                        k: 0,
                        a: 0
                      },
                      ty: "tr"
                    })));
                  }
                }
              };
            }(), Vt = /* @__PURE__ */ function() {
              var Qt = [5, 7, 15];
              function wt(yt) {
                var Et = yt.t.p;
                typeof Et.a == "number" && (Et.a = {
                  a: 0,
                  k: Et.a
                }), typeof Et.p == "number" && (Et.p = {
                  a: 0,
                  k: Et.p
                }), typeof Et.r == "number" && (Et.r = {
                  a: 0,
                  k: Et.r
                });
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 5 && wt(yt[Et]);
              }
              return function(yt) {
                if (Ct(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), ir = /* @__PURE__ */ function() {
              var Qt = [4, 1, 9];
              function wt(yt) {
                var Et, Dt = yt.length, Ot, nr;
                for (Et = 0; Et < Dt; Et += 1)
                  if (yt[Et].ty === "gr")
                    wt(yt[Et].it);
                  else if (yt[Et].ty === "fl" || yt[Et].ty === "st")
                    if (yt[Et].c.k && yt[Et].c.k[0].i)
                      for (nr = yt[Et].c.k.length, Ot = 0; Ot < nr; Ot += 1)
                        yt[Et].c.k[Ot].s && (yt[Et].c.k[Ot].s[0] /= 255, yt[Et].c.k[Ot].s[1] /= 255, yt[Et].c.k[Ot].s[2] /= 255, yt[Et].c.k[Ot].s[3] /= 255), yt[Et].c.k[Ot].e && (yt[Et].c.k[Ot].e[0] /= 255, yt[Et].c.k[Ot].e[1] /= 255, yt[Et].c.k[Ot].e[2] /= 255, yt[Et].c.k[Ot].e[3] /= 255);
                    else
                      yt[Et].c.k[0] /= 255, yt[Et].c.k[1] /= 255, yt[Et].c.k[2] /= 255, yt[Et].c.k[3] /= 255;
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 4 && wt(yt[Et].shapes);
              }
              return function(yt) {
                if (Ct(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), er = /* @__PURE__ */ function() {
              var Qt = [4, 4, 18];
              function wt(yt) {
                var Et, Dt = yt.length, Ot, nr;
                for (Et = Dt - 1; Et >= 0; Et -= 1)
                  if (yt[Et].ty === "sh")
                    if (yt[Et].ks.k.i)
                      yt[Et].ks.k.c = yt[Et].closed;
                    else
                      for (nr = yt[Et].ks.k.length, Ot = 0; Ot < nr; Ot += 1)
                        yt[Et].ks.k[Ot].s && (yt[Et].ks.k[Ot].s[0].c = yt[Et].closed), yt[Et].ks.k[Ot].e && (yt[Et].ks.k[Ot].e[0].c = yt[Et].closed);
                  else
                    yt[Et].ty === "gr" && wt(yt[Et].it);
              }
              function Ft(yt) {
                var Et, Dt, Ot = yt.length, nr, yr, mr, Tr;
                for (Dt = 0; Dt < Ot; Dt += 1) {
                  if (Et = yt[Dt], Et.hasMask) {
                    var Nr = Et.masksProperties;
                    for (yr = Nr.length, nr = 0; nr < yr; nr += 1)
                      if (Nr[nr].pt.k.i)
                        Nr[nr].pt.k.c = Nr[nr].cl;
                      else
                        for (Tr = Nr[nr].pt.k.length, mr = 0; mr < Tr; mr += 1)
                          Nr[nr].pt.k[mr].s && (Nr[nr].pt.k[mr].s[0].c = Nr[nr].cl), Nr[nr].pt.k[mr].e && (Nr[nr].pt.k[mr].e[0].c = Nr[nr].cl);
                  }
                  Et.ty === 4 && wt(Et.shapes);
                }
              }
              return function(yt) {
                if (Ct(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }();
            function Yt(Qt) {
              Qt.__complete || (ir(Qt), At(Qt), kt(Qt), Vt(Qt), er(Qt), St(Qt.layers, Qt.assets), ot(Qt.chars, Qt.assets), Qt.__complete = !0);
            }
            function Jt(Qt) {
              Qt.t.a.length === 0 && "m" in Qt.t.p;
            }
            var rr = {};
            return rr.completeData = Yt, rr.checkColors = ir, rr.checkChars = kt, rr.checkPathProperties = Vt, rr.checkShapes = er, rr.completeLayers = St, rr;
          }
          if (ge.dataManager || (ge.dataManager = it()), ge.assetLoader || (ge.assetLoader = /* @__PURE__ */ function() {
            function St(pt) {
              var ft = pt.getResponseHeader("content-type");
              return ft && pt.responseType === "json" && ft.indexOf("json") !== -1 || pt.response && _typeof$5(pt.response) === "object" ? pt.response : pt.response && typeof pt.response == "string" ? JSON.parse(pt.response) : pt.responseText ? JSON.parse(pt.responseText) : null;
            }
            function ot(pt, ft, vt, xt) {
              var Ct, At = new XMLHttpRequest();
              try {
                At.responseType = "json";
              } catch {
              }
              At.onreadystatechange = function() {
                if (At.readyState === 4)
                  if (At.status === 200)
                    Ct = St(At), vt(Ct);
                  else
                    try {
                      Ct = St(At), vt(Ct);
                    } catch (kt) {
                      xt && xt(kt);
                    }
              };
              try {
                At.open(["G", "E", "T"].join(""), pt, !0);
              } catch {
                At.open(["G", "E", "T"].join(""), ft + "/" + pt, !0);
              }
              At.send();
            }
            return {
              load: ot
            };
          }()), ht.data.type === "loadAnimation")
            ge.assetLoader.load(ht.data.path, ht.data.fullPath, function(St) {
              ge.dataManager.completeData(St), ge.postMessage({
                id: ht.data.id,
                payload: St,
                status: "success"
              });
            }, function() {
              ge.postMessage({
                id: ht.data.id,
                status: "error"
              });
            });
          else if (ht.data.type === "complete") {
            var lt = ht.data.animation;
            ge.dataManager.completeData(lt), ge.postMessage({
              id: ht.data.id,
              payload: lt,
              status: "success"
            });
          } else
            ht.data.type === "loadData" && ge.assetLoader.load(ht.data.path, ht.data.fullPath, function(St) {
              ge.postMessage({
                id: ht.data.id,
                payload: St,
                status: "success"
              });
            }, function() {
              ge.postMessage({
                id: ht.data.id,
                status: "error"
              });
            });
        }), pe.onmessage = function(ut) {
          var ht = ut.data, it = ht.id, lt = ne[it];
          ne[it] = null, ht.status === "success" ? lt.onComplete(ht.payload) : lt.onError && lt.onError();
        });
      }
      function Ae(ut, ht) {
        L += 1;
        var it = "processId_" + L;
        return ne[it] = {
          onComplete: ut,
          onError: ht
        }, it;
      }
      function rt(ut, ht, it) {
        Ie();
        var lt = Ae(ht, it);
        pe.postMessage({
          type: "loadAnimation",
          path: ut,
          fullPath: window.location.origin + window.location.pathname,
          id: lt
        });
      }
      function st(ut, ht, it) {
        Ie();
        var lt = Ae(ht, it);
        pe.postMessage({
          type: "loadData",
          path: ut,
          fullPath: window.location.origin + window.location.pathname,
          id: lt
        });
      }
      function dt(ut, ht, it) {
        Ie();
        var lt = Ae(ht, it);
        pe.postMessage({
          type: "complete",
          animation: ut,
          id: lt
        });
      }
      return {
        loadAnimation: rt,
        loadData: st,
        completeAnimation: dt
      };
    }(), ImagePreloader = function() {
      var L = function() {
        var ot = createTag("canvas");
        ot.width = 1, ot.height = 1;
        var pt = ot.getContext("2d");
        return pt.fillStyle = "rgba(0,0,0,0)", pt.fillRect(0, 0, 1, 1), ot;
      }();
      function ne() {
        this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function oe() {
        this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function pe(ot, pt, ft) {
        var vt = "";
        if (ot.e)
          vt = ot.p;
        else if (pt) {
          var xt = ot.p;
          xt.indexOf("images/") !== -1 && (xt = xt.split("/")[1]), vt = pt + xt;
        } else
          vt = ft, vt += ot.u ? ot.u : "", vt += ot.p;
        return vt;
      }
      function me(ot) {
        var pt = 0, ft = setInterval((function() {
          var vt = ot.getBBox();
          (vt.width || pt > 500) && (this._imageLoaded(), clearInterval(ft)), pt += 1;
        }).bind(this), 50);
      }
      function ge(ot) {
        var pt = pe(ot, this.assetsPath, this.path), ft = createNS("image");
        isSafari ? this.testImageLoaded(ft) : ft.addEventListener("load", this._imageLoaded, !1), ft.addEventListener("error", (function() {
          vt.img = L, this._imageLoaded();
        }).bind(this), !1), ft.setAttributeNS("http://www.w3.org/1999/xlink", "href", pt), this._elementHelper.append ? this._elementHelper.append(ft) : this._elementHelper.appendChild(ft);
        var vt = {
          img: ft,
          assetData: ot
        };
        return vt;
      }
      function be(ot) {
        var pt = pe(ot, this.assetsPath, this.path), ft = createTag("img");
        ft.crossOrigin = "anonymous", ft.addEventListener("load", this._imageLoaded, !1), ft.addEventListener("error", (function() {
          vt.img = L, this._imageLoaded();
        }).bind(this), !1), ft.src = pt;
        var vt = {
          img: ft,
          assetData: ot
        };
        return vt;
      }
      function Ie(ot) {
        var pt = {
          assetData: ot
        }, ft = pe(ot, this.assetsPath, this.path);
        return dataManager.loadData(ft, (function(vt) {
          pt.img = vt, this._footageLoaded();
        }).bind(this), (function() {
          pt.img = {}, this._footageLoaded();
        }).bind(this)), pt;
      }
      function Ae(ot, pt) {
        this.imagesLoadedCb = pt;
        var ft, vt = ot.length;
        for (ft = 0; ft < vt; ft += 1)
          ot[ft].layers || (!ot[ft].t || ot[ft].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(ot[ft]))) : ot[ft].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(ot[ft]))));
      }
      function rt(ot) {
        this.path = ot || "";
      }
      function st(ot) {
        this.assetsPath = ot || "";
      }
      function dt(ot) {
        for (var pt = 0, ft = this.images.length; pt < ft; ) {
          if (this.images[pt].assetData === ot)
            return this.images[pt].img;
          pt += 1;
        }
        return null;
      }
      function ut() {
        this.imagesLoadedCb = null, this.images.length = 0;
      }
      function ht() {
        return this.totalImages === this.loadedAssets;
      }
      function it() {
        return this.totalFootages === this.loadedFootagesCount;
      }
      function lt(ot, pt) {
        ot === "svg" ? (this._elementHelper = pt, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this);
      }
      function St() {
        this._imageLoaded = ne.bind(this), this._footageLoaded = oe.bind(this), this.testImageLoaded = me.bind(this), this.createFootageData = Ie.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [];
      }
      return St.prototype = {
        loadAssets: Ae,
        setAssetsPath: st,
        setPath: rt,
        loadedImages: ht,
        loadedFootages: it,
        destroy: ut,
        getAsset: dt,
        createImgData: be,
        createImageData: ge,
        imageLoaded: ne,
        footageLoaded: oe,
        setCacheType: lt
      }, St;
    }();
    function BaseEvent() {
    }
    BaseEvent.prototype = {
      triggerEvent: function(ne, oe) {
        if (this._cbs[ne])
          for (var pe = this._cbs[ne], me = 0; me < pe.length; me += 1)
            pe[me](oe);
      },
      addEventListener: function(ne, oe) {
        return this._cbs[ne] || (this._cbs[ne] = []), this._cbs[ne].push(oe), (function() {
          this.removeEventListener(ne, oe);
        }).bind(this);
      },
      removeEventListener: function(ne, oe) {
        if (!oe)
          this._cbs[ne] = null;
        else if (this._cbs[ne]) {
          for (var pe = 0, me = this._cbs[ne].length; pe < me; )
            this._cbs[ne][pe] === oe && (this._cbs[ne].splice(pe, 1), pe -= 1, me -= 1), pe += 1;
          this._cbs[ne].length || (this._cbs[ne] = null);
        }
      }
    };
    var markerParser = /* @__PURE__ */ function() {
      function L(ne) {
        for (var oe = ne.split(`\r
`), pe = {}, me, ge = 0, be = 0; be < oe.length; be += 1)
          me = oe[be].split(":"), me.length === 2 && (pe[me[0]] = me[1].trim(), ge += 1);
        if (ge === 0)
          throw new Error();
        return pe;
      }
      return function(ne) {
        for (var oe = [], pe = 0; pe < ne.length; pe += 1) {
          var me = ne[pe], ge = {
            time: me.tm,
            duration: me.dr
          };
          try {
            ge.payload = JSON.parse(ne[pe].cm);
          } catch {
            try {
              ge.payload = L(ne[pe].cm);
            } catch {
              ge.payload = {
                name: ne[pe].cm
              };
            }
          }
          oe.push(ge);
        }
        return oe;
      };
    }(), ProjectInterface = /* @__PURE__ */ function() {
      function L(ne) {
        this.compositions.push(ne);
      }
      return function() {
        function ne(oe) {
          for (var pe = 0, me = this.compositions.length; pe < me; ) {
            if (this.compositions[pe].data && this.compositions[pe].data.nm === oe)
              return this.compositions[pe].prepareFrame && this.compositions[pe].data.xt && this.compositions[pe].prepareFrame(this.currentFrame), this.compositions[pe].compInterface;
            pe += 1;
          }
          return null;
        }
        return ne.compositions = [], ne.currentFrame = 0, ne.registerComposition = L, ne;
      };
    }(), renderers = {}, registerRenderer = function(ne, oe) {
      renderers[ne] = oe;
    };
    function getRenderer(L) {
      return renderers[L];
    }
    function getRegisteredRenderer() {
      if (renderers.canvas)
        return "canvas";
      for (var L in renderers)
        if (renderers[L])
          return L;
      return "";
    }
    function _typeof$4(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(oe) {
        return typeof oe;
      } : _typeof$4 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$4(L);
    }
    var AnimationItem = function() {
      this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader(), this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin();
    };
    extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(L) {
      (L.wrapper || L.container) && (this.wrapper = L.wrapper || L.container);
      var ne = "svg";
      L.animType ? ne = L.animType : L.renderer && (ne = L.renderer);
      var oe = getRenderer(ne);
      this.renderer = new oe(this, L.rendererSettings), this.imagePreloader.setCacheType(ne, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = ne, L.loop === "" || L.loop === null || L.loop === void 0 || L.loop === !0 ? this.loop = !0 : L.loop === !1 ? this.loop = !1 : this.loop = parseInt(L.loop, 10), this.autoplay = "autoplay" in L ? L.autoplay : !0, this.name = L.name ? L.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(L, "autoloadSegments") ? L.autoloadSegments : !0, this.assetsPath = L.assetsPath, this.initialSegment = L.initialSegment, L.audioFactory && this.audioController.setAudioFactory(L.audioFactory), L.animationData ? this.setupAnimation(L.animationData) : L.path && (L.path.lastIndexOf("\\") !== -1 ? this.path = L.path.substr(0, L.path.lastIndexOf("\\") + 1) : this.path = L.path.substr(0, L.path.lastIndexOf("/") + 1), this.fileName = L.path.substr(L.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(L.path, this.configAnimation, this.onSetupError));
    }, AnimationItem.prototype.onSetupError = function() {
      this.trigger("data_failed");
    }, AnimationItem.prototype.setupAnimation = function(L) {
      dataManager.completeAnimation(L, this.configAnimation);
    }, AnimationItem.prototype.setData = function(L, ne) {
      ne && _typeof$4(ne) !== "object" && (ne = JSON.parse(ne));
      var oe = {
        wrapper: L,
        animationData: ne
      }, pe = L.attributes;
      oe.path = pe.getNamedItem("data-animation-path") ? pe.getNamedItem("data-animation-path").value : pe.getNamedItem("data-bm-path") ? pe.getNamedItem("data-bm-path").value : pe.getNamedItem("bm-path") ? pe.getNamedItem("bm-path").value : "", oe.animType = pe.getNamedItem("data-anim-type") ? pe.getNamedItem("data-anim-type").value : pe.getNamedItem("data-bm-type") ? pe.getNamedItem("data-bm-type").value : pe.getNamedItem("bm-type") ? pe.getNamedItem("bm-type").value : pe.getNamedItem("data-bm-renderer") ? pe.getNamedItem("data-bm-renderer").value : pe.getNamedItem("bm-renderer") ? pe.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
      var me = pe.getNamedItem("data-anim-loop") ? pe.getNamedItem("data-anim-loop").value : pe.getNamedItem("data-bm-loop") ? pe.getNamedItem("data-bm-loop").value : pe.getNamedItem("bm-loop") ? pe.getNamedItem("bm-loop").value : "";
      me === "false" ? oe.loop = !1 : me === "true" ? oe.loop = !0 : me !== "" && (oe.loop = parseInt(me, 10));
      var ge = pe.getNamedItem("data-anim-autoplay") ? pe.getNamedItem("data-anim-autoplay").value : pe.getNamedItem("data-bm-autoplay") ? pe.getNamedItem("data-bm-autoplay").value : pe.getNamedItem("bm-autoplay") ? pe.getNamedItem("bm-autoplay").value : !0;
      oe.autoplay = ge !== "false", oe.name = pe.getNamedItem("data-name") ? pe.getNamedItem("data-name").value : pe.getNamedItem("data-bm-name") ? pe.getNamedItem("data-bm-name").value : pe.getNamedItem("bm-name") ? pe.getNamedItem("bm-name").value : "";
      var be = pe.getNamedItem("data-anim-prerender") ? pe.getNamedItem("data-anim-prerender").value : pe.getNamedItem("data-bm-prerender") ? pe.getNamedItem("data-bm-prerender").value : pe.getNamedItem("bm-prerender") ? pe.getNamedItem("bm-prerender").value : "";
      be === "false" && (oe.prerender = !1), oe.path ? this.setParams(oe) : this.trigger("destroy");
    }, AnimationItem.prototype.includeLayers = function(L) {
      L.op > this.animationData.op && (this.animationData.op = L.op, this.totalFrames = Math.floor(L.op - this.animationData.ip));
      var ne = this.animationData.layers, oe, pe = ne.length, me = L.layers, ge, be = me.length;
      for (ge = 0; ge < be; ge += 1)
        for (oe = 0; oe < pe; ) {
          if (ne[oe].id === me[ge].id) {
            ne[oe] = me[ge];
            break;
          }
          oe += 1;
        }
      if ((L.chars || L.fonts) && (this.renderer.globalData.fontManager.addChars(L.chars), this.renderer.globalData.fontManager.addFonts(L.fonts, this.renderer.globalData.defs)), L.assets)
        for (pe = L.assets.length, oe = 0; oe < pe; oe += 1)
          this.animationData.assets.push(L.assets[oe]);
      this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    }, AnimationItem.prototype.onSegmentComplete = function(L) {
      this.animationData = L;
      var ne = getExpressionsPlugin();
      ne && ne.initExpressions(this), this.loadNextSegment();
    }, AnimationItem.prototype.loadNextSegment = function() {
      var L = this.animationData.segments;
      if (!L || L.length === 0 || !this.autoloadSegments) {
        this.trigger("data_ready"), this.timeCompleted = this.totalFrames;
        return;
      }
      var ne = L.shift();
      this.timeCompleted = ne.time * this.frameRate;
      var oe = this.path + this.fileName + "_" + this.segmentPos + ".json";
      this.segmentPos += 1, dataManager.loadData(oe, this.includeLayers.bind(this), (function() {
        this.trigger("data_failed");
      }).bind(this));
    }, AnimationItem.prototype.loadSegments = function() {
      var L = this.animationData.segments;
      L || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
    }, AnimationItem.prototype.imagesLoaded = function() {
      this.trigger("loaded_images"), this.checkLoaded();
    }, AnimationItem.prototype.preloadImages = function() {
      this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    }, AnimationItem.prototype.configAnimation = function(L) {
      if (this.renderer)
        try {
          this.animationData = L, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(L), L.assets || (L.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(L.assets), this.markers = markerParser(L.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause();
        } catch (ne) {
          this.triggerConfigError(ne);
        }
    }, AnimationItem.prototype.waitForFontsLoaded = function() {
      this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20));
    }, AnimationItem.prototype.checkLoaded = function() {
      if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
        this.isLoaded = !0;
        var L = getExpressionsPlugin();
        L && L.initExpressions(this), this.renderer.initItems(), setTimeout((function() {
          this.trigger("DOMLoaded");
        }).bind(this), 0), this.gotoFrame(), this.autoplay && this.play();
      }
    }, AnimationItem.prototype.resize = function(L, ne) {
      var oe = typeof L == "number" ? L : void 0, pe = typeof ne == "number" ? ne : void 0;
      this.renderer.updateContainerSize(oe, pe);
    }, AnimationItem.prototype.setSubframe = function(L) {
      this.isSubframeEnabled = !!L;
    }, AnimationItem.prototype.gotoFrame = function() {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame");
    }, AnimationItem.prototype.renderFrame = function() {
      if (!(this.isLoaded === !1 || !this.renderer))
        try {
          this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (L) {
          this.triggerRenderFrameError(L);
        }
    }, AnimationItem.prototype.play = function(L) {
      L && this.name !== L || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")));
    }, AnimationItem.prototype.pause = function(L) {
      L && this.name !== L || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause());
    }, AnimationItem.prototype.togglePause = function(L) {
      L && this.name !== L || (this.isPaused === !0 ? this.play() : this.pause());
    }, AnimationItem.prototype.stop = function(L) {
      L && this.name !== L || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0));
    }, AnimationItem.prototype.getMarkerData = function(L) {
      for (var ne, oe = 0; oe < this.markers.length; oe += 1)
        if (ne = this.markers[oe], ne.payload && ne.payload.name === L)
          return ne;
      return null;
    }, AnimationItem.prototype.goToAndStop = function(L, ne, oe) {
      if (!(oe && this.name !== oe)) {
        var pe = Number(L);
        if (isNaN(pe)) {
          var me = this.getMarkerData(L);
          me && this.goToAndStop(me.time, !0);
        } else
          ne ? this.setCurrentRawFrameValue(L) : this.setCurrentRawFrameValue(L * this.frameModifier);
        this.pause();
      }
    }, AnimationItem.prototype.goToAndPlay = function(L, ne, oe) {
      if (!(oe && this.name !== oe)) {
        var pe = Number(L);
        if (isNaN(pe)) {
          var me = this.getMarkerData(L);
          me && (me.duration ? this.playSegments([me.time, me.time + me.duration], !0) : this.goToAndStop(me.time, !0));
        } else
          this.goToAndStop(pe, ne, oe);
        this.play();
      }
    }, AnimationItem.prototype.advanceTime = function(L) {
      if (!(this.isPaused === !0 || this.isLoaded === !1)) {
        var ne = this.currentRawFrame + L * this.frameModifier, oe = !1;
        ne >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(ne > this.totalFrames ? ne % this.totalFrames : 0) || (oe = !0, ne = this.totalFrames - 1) : ne >= this.totalFrames ? (this.playCount += 1, this.checkSegments(ne % this.totalFrames) || (this.setCurrentRawFrameValue(ne % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(ne) : ne < 0 ? this.checkSegments(ne % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + ne % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (oe = !0, ne = 0)) : this.setCurrentRawFrameValue(ne), oe && (this.setCurrentRawFrameValue(ne), this.pause(), this.trigger("complete"));
      }
    }, AnimationItem.prototype.adjustSegment = function(L, ne) {
      this.playCount = 0, L[1] < L[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = L[0] - L[1], this.timeCompleted = this.totalFrames, this.firstFrame = L[1], this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - ne)) : L[1] > L[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = L[1] - L[0], this.timeCompleted = this.totalFrames, this.firstFrame = L[0], this.setCurrentRawFrameValue(1e-3 + ne)), this.trigger("segmentStart");
    }, AnimationItem.prototype.setSegment = function(L, ne) {
      var oe = -1;
      this.isPaused && (this.currentRawFrame + this.firstFrame < L ? oe = L : this.currentRawFrame + this.firstFrame > ne && (oe = ne - L)), this.firstFrame = L, this.totalFrames = ne - L, this.timeCompleted = this.totalFrames, oe !== -1 && this.goToAndStop(oe, !0);
    }, AnimationItem.prototype.playSegments = function(L, ne) {
      if (ne && (this.segments.length = 0), _typeof$4(L[0]) === "object") {
        var oe, pe = L.length;
        for (oe = 0; oe < pe; oe += 1)
          this.segments.push(L[oe]);
      } else
        this.segments.push(L);
      this.segments.length && ne && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play();
    }, AnimationItem.prototype.resetSegments = function(L) {
      this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), L && this.checkSegments(0);
    }, AnimationItem.prototype.checkSegments = function(L) {
      return this.segments.length ? (this.adjustSegment(this.segments.shift(), L), !0) : !1;
    }, AnimationItem.prototype.destroy = function(L) {
      L && this.name !== L || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null);
    }, AnimationItem.prototype.setCurrentRawFrameValue = function(L) {
      this.currentRawFrame = L, this.gotoFrame();
    }, AnimationItem.prototype.setSpeed = function(L) {
      this.playSpeed = L, this.updaFrameModifier();
    }, AnimationItem.prototype.setDirection = function(L) {
      this.playDirection = L < 0 ? -1 : 1, this.updaFrameModifier();
    }, AnimationItem.prototype.setLoop = function(L) {
      this.loop = L;
    }, AnimationItem.prototype.setVolume = function(L, ne) {
      ne && this.name !== ne || this.audioController.setVolume(L);
    }, AnimationItem.prototype.getVolume = function() {
      return this.audioController.getVolume();
    }, AnimationItem.prototype.mute = function(L) {
      L && this.name !== L || this.audioController.mute();
    }, AnimationItem.prototype.unmute = function(L) {
      L && this.name !== L || this.audioController.unmute();
    }, AnimationItem.prototype.updaFrameModifier = function() {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection);
    }, AnimationItem.prototype.getPath = function() {
      return this.path;
    }, AnimationItem.prototype.getAssetsPath = function(L) {
      var ne = "";
      if (L.e)
        ne = L.p;
      else if (this.assetsPath) {
        var oe = L.p;
        oe.indexOf("images/") !== -1 && (oe = oe.split("/")[1]), ne = this.assetsPath + oe;
      } else
        ne = this.path, ne += L.u ? L.u : "", ne += L.p;
      return ne;
    }, AnimationItem.prototype.getAssetData = function(L) {
      for (var ne = 0, oe = this.assets.length; ne < oe; ) {
        if (L === this.assets[ne].id)
          return this.assets[ne];
        ne += 1;
      }
      return null;
    }, AnimationItem.prototype.hide = function() {
      this.renderer.hide();
    }, AnimationItem.prototype.show = function() {
      this.renderer.show();
    }, AnimationItem.prototype.getDuration = function(L) {
      return L ? this.totalFrames : this.totalFrames / this.frameRate;
    }, AnimationItem.prototype.updateDocumentData = function(L, ne, oe) {
      try {
        var pe = this.renderer.getElementByPath(L);
        pe.updateDocumentData(ne, oe);
      } catch {
      }
    }, AnimationItem.prototype.trigger = function(L) {
      if (this._cbs && this._cbs[L])
        switch (L) {
          case "enterFrame":
            this.triggerEvent(L, new BMEnterFrameEvent(L, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case "drawnFrame":
            this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(L, this.drawnFrameEvent);
            break;
          case "loopComplete":
            this.triggerEvent(L, new BMCompleteLoopEvent(L, this.loop, this.playCount, this.frameMult));
            break;
          case "complete":
            this.triggerEvent(L, new BMCompleteEvent(L, this.frameMult));
            break;
          case "segmentStart":
            this.triggerEvent(L, new BMSegmentStartEvent(L, this.firstFrame, this.totalFrames));
            break;
          case "destroy":
            this.triggerEvent(L, new BMDestroyEvent(L, this));
            break;
          default:
            this.triggerEvent(L);
        }
      L === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(L, this.currentFrame, this.totalFrames, this.frameMult)), L === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(L, this.loop, this.playCount, this.frameMult)), L === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(L, this.frameMult)), L === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(L, this.firstFrame, this.totalFrames)), L === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(L, this));
    }, AnimationItem.prototype.triggerRenderFrameError = function(L) {
      var ne = new BMRenderFrameErrorEvent(L, this.currentFrame);
      this.triggerEvent("error", ne), this.onError && this.onError.call(this, ne);
    }, AnimationItem.prototype.triggerConfigError = function(L) {
      var ne = new BMConfigErrorEvent(L, this.currentFrame);
      this.triggerEvent("error", ne), this.onError && this.onError.call(this, ne);
    };
    var animationManager = function() {
      var L = {}, ne = [], oe = 0, pe = 0, me = 0, ge = !0, be = !1;
      function Ie(wt) {
        for (var Ft = 0, yt = wt.target; Ft < pe; )
          ne[Ft].animation === yt && (ne.splice(Ft, 1), Ft -= 1, pe -= 1, yt.isPaused || dt()), Ft += 1;
      }
      function Ae(wt, Ft) {
        if (!wt)
          return null;
        for (var yt = 0; yt < pe; ) {
          if (ne[yt].elem === wt && ne[yt].elem !== null)
            return ne[yt].animation;
          yt += 1;
        }
        var Et = new AnimationItem();
        return ut(Et, wt), Et.setData(wt, Ft), Et;
      }
      function rt() {
        var wt, Ft = ne.length, yt = [];
        for (wt = 0; wt < Ft; wt += 1)
          yt.push(ne[wt].animation);
        return yt;
      }
      function st() {
        me += 1, ir();
      }
      function dt() {
        me -= 1;
      }
      function ut(wt, Ft) {
        wt.addEventListener("destroy", Ie), wt.addEventListener("_active", st), wt.addEventListener("_idle", dt), ne.push({
          elem: Ft,
          animation: wt
        }), pe += 1;
      }
      function ht(wt) {
        var Ft = new AnimationItem();
        return ut(Ft, null), Ft.setParams(wt), Ft;
      }
      function it(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setSpeed(wt, Ft);
      }
      function lt(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setDirection(wt, Ft);
      }
      function St(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.play(wt);
      }
      function ot(wt) {
        var Ft = wt - oe, yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.advanceTime(Ft);
        oe = wt, me && !be ? window.requestAnimationFrame(ot) : ge = !0;
      }
      function pt(wt) {
        oe = wt, window.requestAnimationFrame(ot);
      }
      function ft(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.pause(wt);
      }
      function vt(wt, Ft, yt) {
        var Et;
        for (Et = 0; Et < pe; Et += 1)
          ne[Et].animation.goToAndStop(wt, Ft, yt);
      }
      function xt(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.stop(wt);
      }
      function Ct(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.togglePause(wt);
      }
      function At(wt) {
        var Ft;
        for (Ft = pe - 1; Ft >= 0; Ft -= 1)
          ne[Ft].animation.destroy(wt);
      }
      function kt(wt, Ft, yt) {
        var Et = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Dt, Ot = Et.length;
        for (Dt = 0; Dt < Ot; Dt += 1)
          yt && Et[Dt].setAttribute("data-bm-type", yt), Ae(Et[Dt], wt);
        if (Ft && Ot === 0) {
          yt || (yt = "svg");
          var nr = document.getElementsByTagName("body")[0];
          nr.innerText = "";
          var yr = createTag("div");
          yr.style.width = "100%", yr.style.height = "100%", yr.setAttribute("data-bm-type", yt), nr.appendChild(yr), Ae(yr, wt);
        }
      }
      function Vt() {
        var wt;
        for (wt = 0; wt < pe; wt += 1)
          ne[wt].animation.resize();
      }
      function ir() {
        !be && me && ge && (window.requestAnimationFrame(pt), ge = !1);
      }
      function er() {
        be = !0;
      }
      function Yt() {
        be = !1, ir();
      }
      function Jt(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setVolume(wt, Ft);
      }
      function rr(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.mute(wt);
      }
      function Qt(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.unmute(wt);
      }
      return L.registerAnimation = Ae, L.loadAnimation = ht, L.setSpeed = it, L.setDirection = lt, L.play = St, L.pause = ft, L.stop = xt, L.togglePause = Ct, L.searchAnimations = kt, L.resize = Vt, L.goToAndStop = vt, L.destroy = At, L.freeze = er, L.unfreeze = Yt, L.setVolume = Jt, L.mute = rr, L.unmute = Qt, L.getRegisteredAnimations = rt, L;
    }(), BezierFactory = function() {
      var L = {};
      L.getBezierEasing = oe;
      var ne = {};
      function oe(pt, ft, vt, xt, Ct) {
        var At = Ct || ("bez_" + pt + "_" + ft + "_" + vt + "_" + xt).replace(/\./g, "p");
        if (ne[At])
          return ne[At];
        var kt = new ot([pt, ft, vt, xt]);
        return ne[At] = kt, kt;
      }
      var pe = 4, me = 1e-3, ge = 1e-7, be = 10, Ie = 11, Ae = 1 / (Ie - 1), rt = typeof Float32Array == "function";
      function st(pt, ft) {
        return 1 - 3 * ft + 3 * pt;
      }
      function dt(pt, ft) {
        return 3 * ft - 6 * pt;
      }
      function ut(pt) {
        return 3 * pt;
      }
      function ht(pt, ft, vt) {
        return ((st(ft, vt) * pt + dt(ft, vt)) * pt + ut(ft)) * pt;
      }
      function it(pt, ft, vt) {
        return 3 * st(ft, vt) * pt * pt + 2 * dt(ft, vt) * pt + ut(ft);
      }
      function lt(pt, ft, vt, xt, Ct) {
        var At, kt, Vt = 0;
        do
          kt = ft + (vt - ft) / 2, At = ht(kt, xt, Ct) - pt, At > 0 ? vt = kt : ft = kt;
        while (Math.abs(At) > ge && ++Vt < be);
        return kt;
      }
      function St(pt, ft, vt, xt) {
        for (var Ct = 0; Ct < pe; ++Ct) {
          var At = it(ft, vt, xt);
          if (At === 0)
            return ft;
          var kt = ht(ft, vt, xt) - pt;
          ft -= kt / At;
        }
        return ft;
      }
      function ot(pt) {
        this._p = pt, this._mSampleValues = rt ? new Float32Array(Ie) : new Array(Ie), this._precomputed = !1, this.get = this.get.bind(this);
      }
      return ot.prototype = {
        get: function(ft) {
          var vt = this._p[0], xt = this._p[1], Ct = this._p[2], At = this._p[3];
          return this._precomputed || this._precompute(), vt === xt && Ct === At ? ft : ft === 0 ? 0 : ft === 1 ? 1 : ht(this._getTForX(ft), xt, At);
        },
        // Private part
        _precompute: function() {
          var ft = this._p[0], vt = this._p[1], xt = this._p[2], Ct = this._p[3];
          this._precomputed = !0, (ft !== vt || xt !== Ct) && this._calcSampleValues();
        },
        _calcSampleValues: function() {
          for (var ft = this._p[0], vt = this._p[2], xt = 0; xt < Ie; ++xt)
            this._mSampleValues[xt] = ht(xt * Ae, ft, vt);
        },
        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function(ft) {
          for (var vt = this._p[0], xt = this._p[2], Ct = this._mSampleValues, At = 0, kt = 1, Vt = Ie - 1; kt !== Vt && Ct[kt] <= ft; ++kt)
            At += Ae;
          --kt;
          var ir = (ft - Ct[kt]) / (Ct[kt + 1] - Ct[kt]), er = At + ir * Ae, Yt = it(er, vt, xt);
          return Yt >= me ? St(ft, er, vt, xt) : Yt === 0 ? er : lt(ft, At, At + Ae, vt, xt);
        }
      }, L;
    }(), pooling = /* @__PURE__ */ function() {
      function L(ne) {
        return ne.concat(createSizedArray(ne.length));
      }
      return {
        double: L
      };
    }(), poolFactory = /* @__PURE__ */ function() {
      return function(L, ne, oe) {
        var pe = 0, me = L, ge = createSizedArray(me), be = {
          newElement: Ie,
          release: Ae
        };
        function Ie() {
          var rt;
          return pe ? (pe -= 1, rt = ge[pe]) : rt = ne(), rt;
        }
        function Ae(rt) {
          pe === me && (ge = pooling.double(ge), me *= 2), oe && oe(rt), ge[pe] = rt, pe += 1;
        }
        return be;
      };
    }(), bezierLengthPool = function() {
      function L() {
        return {
          addedLength: 0,
          percents: createTypedArray("float32", getDefaultCurveSegments()),
          lengths: createTypedArray("float32", getDefaultCurveSegments())
        };
      }
      return poolFactory(8, L);
    }(), segmentsLengthPool = function() {
      function L() {
        return {
          lengths: [],
          totalLength: 0
        };
      }
      function ne(oe) {
        var pe, me = oe.lengths.length;
        for (pe = 0; pe < me; pe += 1)
          bezierLengthPool.release(oe.lengths[pe]);
        oe.lengths.length = 0;
      }
      return poolFactory(8, L, ne);
    }();
    function bezFunction() {
      var L = Math;
      function ne(ut, ht, it, lt, St, ot) {
        var pt = ut * lt + ht * St + it * ot - St * lt - ot * ut - it * ht;
        return pt > -1e-3 && pt < 1e-3;
      }
      function oe(ut, ht, it, lt, St, ot, pt, ft, vt) {
        if (it === 0 && ot === 0 && vt === 0)
          return ne(ut, ht, lt, St, pt, ft);
        var xt = L.sqrt(L.pow(lt - ut, 2) + L.pow(St - ht, 2) + L.pow(ot - it, 2)), Ct = L.sqrt(L.pow(pt - ut, 2) + L.pow(ft - ht, 2) + L.pow(vt - it, 2)), At = L.sqrt(L.pow(pt - lt, 2) + L.pow(ft - St, 2) + L.pow(vt - ot, 2)), kt;
        return xt > Ct ? xt > At ? kt = xt - Ct - At : kt = At - Ct - xt : At > Ct ? kt = At - Ct - xt : kt = Ct - xt - At, kt > -1e-4 && kt < 1e-4;
      }
      var pe = /* @__PURE__ */ function() {
        return function(ut, ht, it, lt) {
          var St = getDefaultCurveSegments(), ot, pt, ft, vt, xt, Ct = 0, At, kt = [], Vt = [], ir = bezierLengthPool.newElement();
          for (ft = it.length, ot = 0; ot < St; ot += 1) {
            for (xt = ot / (St - 1), At = 0, pt = 0; pt < ft; pt += 1)
              vt = bmPow(1 - xt, 3) * ut[pt] + 3 * bmPow(1 - xt, 2) * xt * it[pt] + 3 * (1 - xt) * bmPow(xt, 2) * lt[pt] + bmPow(xt, 3) * ht[pt], kt[pt] = vt, Vt[pt] !== null && (At += bmPow(kt[pt] - Vt[pt], 2)), Vt[pt] = kt[pt];
            At && (At = bmSqrt(At), Ct += At), ir.percents[ot] = xt, ir.lengths[ot] = Ct;
          }
          return ir.addedLength = Ct, ir;
        };
      }();
      function me(ut) {
        var ht = segmentsLengthPool.newElement(), it = ut.c, lt = ut.v, St = ut.o, ot = ut.i, pt, ft = ut._length, vt = ht.lengths, xt = 0;
        for (pt = 0; pt < ft - 1; pt += 1)
          vt[pt] = pe(lt[pt], lt[pt + 1], St[pt], ot[pt + 1]), xt += vt[pt].addedLength;
        return it && ft && (vt[pt] = pe(lt[pt], lt[0], St[pt], ot[0]), xt += vt[pt].addedLength), ht.totalLength = xt, ht;
      }
      function ge(ut) {
        this.segmentLength = 0, this.points = new Array(ut);
      }
      function be(ut, ht) {
        this.partialLength = ut, this.point = ht;
      }
      var Ie = /* @__PURE__ */ function() {
        var ut = {};
        return function(ht, it, lt, St) {
          var ot = (ht[0] + "_" + ht[1] + "_" + it[0] + "_" + it[1] + "_" + lt[0] + "_" + lt[1] + "_" + St[0] + "_" + St[1]).replace(/\./g, "p");
          if (!ut[ot]) {
            var pt = getDefaultCurveSegments(), ft, vt, xt, Ct, At, kt = 0, Vt, ir, er = null;
            ht.length === 2 && (ht[0] !== it[0] || ht[1] !== it[1]) && ne(ht[0], ht[1], it[0], it[1], ht[0] + lt[0], ht[1] + lt[1]) && ne(ht[0], ht[1], it[0], it[1], it[0] + St[0], it[1] + St[1]) && (pt = 2);
            var Yt = new ge(pt);
            for (xt = lt.length, ft = 0; ft < pt; ft += 1) {
              for (ir = createSizedArray(xt), At = ft / (pt - 1), Vt = 0, vt = 0; vt < xt; vt += 1)
                Ct = bmPow(1 - At, 3) * ht[vt] + 3 * bmPow(1 - At, 2) * At * (ht[vt] + lt[vt]) + 3 * (1 - At) * bmPow(At, 2) * (it[vt] + St[vt]) + bmPow(At, 3) * it[vt], ir[vt] = Ct, er !== null && (Vt += bmPow(ir[vt] - er[vt], 2));
              Vt = bmSqrt(Vt), kt += Vt, Yt.points[ft] = new be(Vt, ir), er = ir;
            }
            Yt.segmentLength = kt, ut[ot] = Yt;
          }
          return ut[ot];
        };
      }();
      function Ae(ut, ht) {
        var it = ht.percents, lt = ht.lengths, St = it.length, ot = bmFloor((St - 1) * ut), pt = ut * ht.addedLength, ft = 0;
        if (ot === St - 1 || ot === 0 || pt === lt[ot])
          return it[ot];
        for (var vt = lt[ot] > pt ? -1 : 1, xt = !0; xt; )
          if (lt[ot] <= pt && lt[ot + 1] > pt ? (ft = (pt - lt[ot]) / (lt[ot + 1] - lt[ot]), xt = !1) : ot += vt, ot < 0 || ot >= St - 1) {
            if (ot === St - 1)
              return it[ot];
            xt = !1;
          }
        return it[ot] + (it[ot + 1] - it[ot]) * ft;
      }
      function rt(ut, ht, it, lt, St, ot) {
        var pt = Ae(St, ot), ft = 1 - pt, vt = L.round((ft * ft * ft * ut[0] + (pt * ft * ft + ft * pt * ft + ft * ft * pt) * it[0] + (pt * pt * ft + ft * pt * pt + pt * ft * pt) * lt[0] + pt * pt * pt * ht[0]) * 1e3) / 1e3, xt = L.round((ft * ft * ft * ut[1] + (pt * ft * ft + ft * pt * ft + ft * ft * pt) * it[1] + (pt * pt * ft + ft * pt * pt + pt * ft * pt) * lt[1] + pt * pt * pt * ht[1]) * 1e3) / 1e3;
        return [vt, xt];
      }
      var st = createTypedArray("float32", 8);
      function dt(ut, ht, it, lt, St, ot, pt) {
        St < 0 ? St = 0 : St > 1 && (St = 1);
        var ft = Ae(St, pt);
        ot = ot > 1 ? 1 : ot;
        var vt = Ae(ot, pt), xt, Ct = ut.length, At = 1 - ft, kt = 1 - vt, Vt = At * At * At, ir = ft * At * At * 3, er = ft * ft * At * 3, Yt = ft * ft * ft, Jt = At * At * kt, rr = ft * At * kt + At * ft * kt + At * At * vt, Qt = ft * ft * kt + At * ft * vt + ft * At * vt, wt = ft * ft * vt, Ft = At * kt * kt, yt = ft * kt * kt + At * vt * kt + At * kt * vt, Et = ft * vt * kt + At * vt * vt + ft * kt * vt, Dt = ft * vt * vt, Ot = kt * kt * kt, nr = vt * kt * kt + kt * vt * kt + kt * kt * vt, yr = vt * vt * kt + kt * vt * vt + vt * kt * vt, mr = vt * vt * vt;
        for (xt = 0; xt < Ct; xt += 1)
          st[xt * 4] = L.round((Vt * ut[xt] + ir * it[xt] + er * lt[xt] + Yt * ht[xt]) * 1e3) / 1e3, st[xt * 4 + 1] = L.round((Jt * ut[xt] + rr * it[xt] + Qt * lt[xt] + wt * ht[xt]) * 1e3) / 1e3, st[xt * 4 + 2] = L.round((Ft * ut[xt] + yt * it[xt] + Et * lt[xt] + Dt * ht[xt]) * 1e3) / 1e3, st[xt * 4 + 3] = L.round((Ot * ut[xt] + nr * it[xt] + yr * lt[xt] + mr * ht[xt]) * 1e3) / 1e3;
        return st;
      }
      return {
        getSegmentsLength: me,
        getNewSegment: dt,
        getPointInSegment: rt,
        buildBezierData: Ie,
        pointOnLine2D: ne,
        pointOnLine3D: oe
      };
    }
    var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs;
    function interpolateValue(L, ne) {
      var oe = this.offsetTime, pe;
      this.propType === "multidimensional" && (pe = createTypedArray("float32", this.pv.length));
      for (var me = ne.lastIndex, ge = me, be = this.keyframes.length - 1, Ie = !0, Ae, rt, st; Ie; ) {
        if (Ae = this.keyframes[ge], rt = this.keyframes[ge + 1], ge === be - 1 && L >= rt.t - oe) {
          Ae.h && (Ae = rt), me = 0;
          break;
        }
        if (rt.t - oe > L) {
          me = ge;
          break;
        }
        ge < be - 1 ? ge += 1 : (me = 0, Ie = !1);
      }
      st = this.keyframesMetadata[ge] || {};
      var dt, ut, ht, it, lt, St, ot = rt.t - oe, pt = Ae.t - oe, ft;
      if (Ae.to) {
        st.bezierData || (st.bezierData = bez.buildBezierData(Ae.s, rt.s || Ae.e, Ae.to, Ae.ti));
        var vt = st.bezierData;
        if (L >= ot || L < pt) {
          var xt = L >= ot ? vt.points.length - 1 : 0;
          for (ut = vt.points[xt].point.length, dt = 0; dt < ut; dt += 1)
            pe[dt] = vt.points[xt].point[dt];
        } else {
          st.__fnct ? St = st.__fnct : (St = BezierFactory.getBezierEasing(Ae.o.x, Ae.o.y, Ae.i.x, Ae.i.y, Ae.n).get, st.__fnct = St), ht = St((L - pt) / (ot - pt));
          var Ct = vt.segmentLength * ht, At, kt = ne.lastFrame < L && ne._lastKeyframeIndex === ge ? ne._lastAddedLength : 0;
          for (lt = ne.lastFrame < L && ne._lastKeyframeIndex === ge ? ne._lastPoint : 0, Ie = !0, it = vt.points.length; Ie; ) {
            if (kt += vt.points[lt].partialLength, Ct === 0 || ht === 0 || lt === vt.points.length - 1) {
              for (ut = vt.points[lt].point.length, dt = 0; dt < ut; dt += 1)
                pe[dt] = vt.points[lt].point[dt];
              break;
            } else if (Ct >= kt && Ct < kt + vt.points[lt + 1].partialLength) {
              for (At = (Ct - kt) / vt.points[lt + 1].partialLength, ut = vt.points[lt].point.length, dt = 0; dt < ut; dt += 1)
                pe[dt] = vt.points[lt].point[dt] + (vt.points[lt + 1].point[dt] - vt.points[lt].point[dt]) * At;
              break;
            }
            lt < it - 1 ? lt += 1 : Ie = !1;
          }
          ne._lastPoint = lt, ne._lastAddedLength = kt - vt.points[lt].partialLength, ne._lastKeyframeIndex = ge;
        }
      } else {
        var Vt, ir, er, Yt, Jt;
        if (be = Ae.s.length, ft = rt.s || Ae.e, this.sh && Ae.h !== 1)
          if (L >= ot)
            pe[0] = ft[0], pe[1] = ft[1], pe[2] = ft[2];
          else if (L <= pt)
            pe[0] = Ae.s[0], pe[1] = Ae.s[1], pe[2] = Ae.s[2];
          else {
            var rr = createQuaternion(Ae.s), Qt = createQuaternion(ft), wt = (L - pt) / (ot - pt);
            quaternionToEuler(pe, slerp(rr, Qt, wt));
          }
        else
          for (ge = 0; ge < be; ge += 1)
            Ae.h !== 1 && (L >= ot ? ht = 1 : L < pt ? ht = 0 : (Ae.o.x.constructor === Array ? (st.__fnct || (st.__fnct = []), st.__fnct[ge] ? St = st.__fnct[ge] : (Vt = Ae.o.x[ge] === void 0 ? Ae.o.x[0] : Ae.o.x[ge], ir = Ae.o.y[ge] === void 0 ? Ae.o.y[0] : Ae.o.y[ge], er = Ae.i.x[ge] === void 0 ? Ae.i.x[0] : Ae.i.x[ge], Yt = Ae.i.y[ge] === void 0 ? Ae.i.y[0] : Ae.i.y[ge], St = BezierFactory.getBezierEasing(Vt, ir, er, Yt).get, st.__fnct[ge] = St)) : st.__fnct ? St = st.__fnct : (Vt = Ae.o.x, ir = Ae.o.y, er = Ae.i.x, Yt = Ae.i.y, St = BezierFactory.getBezierEasing(Vt, ir, er, Yt).get, Ae.keyframeMetadata = St), ht = St((L - pt) / (ot - pt)))), ft = rt.s || Ae.e, Jt = Ae.h === 1 ? Ae.s[ge] : Ae.s[ge] + (ft[ge] - Ae.s[ge]) * ht, this.propType === "multidimensional" ? pe[ge] = Jt : pe = Jt;
      }
      return ne.lastIndex = me, pe;
    }
    function slerp(L, ne, oe) {
      var pe = [], me = L[0], ge = L[1], be = L[2], Ie = L[3], Ae = ne[0], rt = ne[1], st = ne[2], dt = ne[3], ut, ht, it, lt, St;
      return ht = me * Ae + ge * rt + be * st + Ie * dt, ht < 0 && (ht = -ht, Ae = -Ae, rt = -rt, st = -st, dt = -dt), 1 - ht > 1e-6 ? (ut = Math.acos(ht), it = Math.sin(ut), lt = Math.sin((1 - oe) * ut) / it, St = Math.sin(oe * ut) / it) : (lt = 1 - oe, St = oe), pe[0] = lt * me + St * Ae, pe[1] = lt * ge + St * rt, pe[2] = lt * be + St * st, pe[3] = lt * Ie + St * dt, pe;
    }
    function quaternionToEuler(L, ne) {
      var oe = ne[0], pe = ne[1], me = ne[2], ge = ne[3], be = Math.atan2(2 * pe * ge - 2 * oe * me, 1 - 2 * pe * pe - 2 * me * me), Ie = Math.asin(2 * oe * pe + 2 * me * ge), Ae = Math.atan2(2 * oe * ge - 2 * pe * me, 1 - 2 * oe * oe - 2 * me * me);
      L[0] = be / degToRads, L[1] = Ie / degToRads, L[2] = Ae / degToRads;
    }
    function createQuaternion(L) {
      var ne = L[0] * degToRads, oe = L[1] * degToRads, pe = L[2] * degToRads, me = Math.cos(ne / 2), ge = Math.cos(oe / 2), be = Math.cos(pe / 2), Ie = Math.sin(ne / 2), Ae = Math.sin(oe / 2), rt = Math.sin(pe / 2), st = me * ge * be - Ie * Ae * rt, dt = Ie * Ae * be + me * ge * rt, ut = Ie * ge * be + me * Ae * rt, ht = me * Ae * be - Ie * ge * rt;
      return [dt, ut, ht, st];
    }
    function getValueAtCurrentTime() {
      var L = this.comp.renderedFrame - this.offsetTime, ne = this.keyframes[0].t - this.offsetTime, oe = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      if (!(L === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= oe && L >= oe || this._caching.lastFrame < ne && L < ne))) {
        this._caching.lastFrame >= L && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
        var pe = this.interpolateValue(L, this._caching);
        this.pv = pe;
      }
      return this._caching.lastFrame = L, this.pv;
    }
    function setVValue(L) {
      var ne;
      if (this.propType === "unidimensional")
        ne = L * this.mult, mathAbs(this.v - ne) > 1e-5 && (this.v = ne, this._mdf = !0);
      else
        for (var oe = 0, pe = this.v.length; oe < pe; )
          ne = L[oe] * this.mult, mathAbs(this.v[oe] - ne) > 1e-5 && (this.v[oe] = ne, this._mdf = !0), oe += 1;
    }
    function processEffectsSequence() {
      if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = !0, this._mdf = this._isFirstFrame;
        var L, ne = this.effectsSequence.length, oe = this.kf ? this.pv : this.data.k;
        for (L = 0; L < ne; L += 1)
          oe = this.effectsSequence[L](oe);
        this.setVValue(oe), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }
    function addEffect(L) {
      this.effectsSequence.push(L), this.container.addDynamicProperty(this);
    }
    function ValueProperty(L, ne, oe, pe) {
      this.propType = "unidimensional", this.mult = oe || 1, this.data = ne, this.v = oe ? ne.k * oe : ne.k, this.pv = ne.k, this._mdf = !1, this.elem = L, this.container = pe, this.comp = L.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function MultiDimensionalProperty(L, ne, oe, pe) {
      this.propType = "multidimensional", this.mult = oe || 1, this.data = ne, this._mdf = !1, this.elem = L, this.container = pe, this.comp = L.comp, this.k = !1, this.kf = !1, this.frameId = -1;
      var me, ge = ne.k.length;
      for (this.v = createTypedArray("float32", ge), this.pv = createTypedArray("float32", ge), this.vel = createTypedArray("float32", ge), me = 0; me < ge; me += 1)
        this.v[me] = ne.k[me] * this.mult, this.pv[me] = ne.k[me];
      this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function KeyframedValueProperty(L, ne, oe, pe) {
      this.propType = "unidimensional", this.keyframes = ne.k, this.keyframesMetadata = [], this.offsetTime = L.data.st, this.frameId = -1, this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      }, this.k = !0, this.kf = !0, this.data = ne, this.mult = oe || 1, this.elem = L, this.container = pe, this.comp = L.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect;
    }
    function KeyframedMultidimensionalProperty(L, ne, oe, pe) {
      this.propType = "multidimensional";
      var me, ge = ne.k.length, be, Ie, Ae, rt;
      for (me = 0; me < ge - 1; me += 1)
        ne.k[me].to && ne.k[me].s && ne.k[me + 1] && ne.k[me + 1].s && (be = ne.k[me].s, Ie = ne.k[me + 1].s, Ae = ne.k[me].to, rt = ne.k[me].ti, (be.length === 2 && !(be[0] === Ie[0] && be[1] === Ie[1]) && bez.pointOnLine2D(be[0], be[1], Ie[0], Ie[1], be[0] + Ae[0], be[1] + Ae[1]) && bez.pointOnLine2D(be[0], be[1], Ie[0], Ie[1], Ie[0] + rt[0], Ie[1] + rt[1]) || be.length === 3 && !(be[0] === Ie[0] && be[1] === Ie[1] && be[2] === Ie[2]) && bez.pointOnLine3D(be[0], be[1], be[2], Ie[0], Ie[1], Ie[2], be[0] + Ae[0], be[1] + Ae[1], be[2] + Ae[2]) && bez.pointOnLine3D(be[0], be[1], be[2], Ie[0], Ie[1], Ie[2], Ie[0] + rt[0], Ie[1] + rt[1], Ie[2] + rt[2])) && (ne.k[me].to = null, ne.k[me].ti = null), be[0] === Ie[0] && be[1] === Ie[1] && Ae[0] === 0 && Ae[1] === 0 && rt[0] === 0 && rt[1] === 0 && (be.length === 2 || be[2] === Ie[2] && Ae[2] === 0 && rt[2] === 0) && (ne.k[me].to = null, ne.k[me].ti = null));
      this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = ne, this.keyframes = ne.k, this.keyframesMetadata = [], this.offsetTime = L.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = oe || 1, this.elem = L, this.container = pe, this.comp = L.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
      var st = ne.k[0].s.length;
      for (this.v = createTypedArray("float32", st), this.pv = createTypedArray("float32", st), me = 0; me < st; me += 1)
        this.v[me] = initFrame, this.pv[me] = initFrame;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray("float32", st)
      }, this.addEffect = addEffect;
    }
    var PropertyFactory = /* @__PURE__ */ function() {
      function L(oe, pe, me, ge, be) {
        pe.sid && (pe = oe.globalData.slotManager.getProp(pe));
        var Ie;
        if (!pe.k.length)
          Ie = new ValueProperty(oe, pe, ge, be);
        else if (typeof pe.k[0] == "number")
          Ie = new MultiDimensionalProperty(oe, pe, ge, be);
        else
          switch (me) {
            case 0:
              Ie = new KeyframedValueProperty(oe, pe, ge, be);
              break;
            case 1:
              Ie = new KeyframedMultidimensionalProperty(oe, pe, ge, be);
              break;
          }
        return Ie.effectsSequence.length && be.addDynamicProperty(Ie), Ie;
      }
      var ne = {
        getProp: L
      };
      return ne;
    }();
    function DynamicPropertyContainer() {
    }
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function(ne) {
        this.dynamicProperties.indexOf(ne) === -1 && (this.dynamicProperties.push(ne), this.container.addDynamicProperty(this), this._isAnimated = !0);
      },
      iterateDynamicProperties: function() {
        this._mdf = !1;
        var ne, oe = this.dynamicProperties.length;
        for (ne = 0; ne < oe; ne += 1)
          this.dynamicProperties[ne].getValue(), this.dynamicProperties[ne]._mdf && (this._mdf = !0);
      },
      initDynamicPropertyContainer: function(ne) {
        this.container = ne, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1;
      }
    };
    var pointPool = function() {
      function L() {
        return createTypedArray("float32", 2);
      }
      return poolFactory(8, L);
    }();
    function ShapePath() {
      this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function(L, ne) {
      this.c = L, this.setLength(ne);
      for (var oe = 0; oe < ne; )
        this.v[oe] = pointPool.newElement(), this.o[oe] = pointPool.newElement(), this.i[oe] = pointPool.newElement(), oe += 1;
    }, ShapePath.prototype.setLength = function(L) {
      for (; this._maxLength < L; )
        this.doubleArrayLength();
      this._length = L;
    }, ShapePath.prototype.doubleArrayLength = function() {
      this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2;
    }, ShapePath.prototype.setXYAt = function(L, ne, oe, pe, me) {
      var ge;
      switch (this._length = Math.max(this._length, pe + 1), this._length >= this._maxLength && this.doubleArrayLength(), oe) {
        case "v":
          ge = this.v;
          break;
        case "i":
          ge = this.i;
          break;
        case "o":
          ge = this.o;
          break;
        default:
          ge = [];
          break;
      }
      (!ge[pe] || ge[pe] && !me) && (ge[pe] = pointPool.newElement()), ge[pe][0] = L, ge[pe][1] = ne;
    }, ShapePath.prototype.setTripleAt = function(L, ne, oe, pe, me, ge, be, Ie) {
      this.setXYAt(L, ne, "v", be, Ie), this.setXYAt(oe, pe, "o", be, Ie), this.setXYAt(me, ge, "i", be, Ie);
    }, ShapePath.prototype.reverse = function() {
      var L = new ShapePath();
      L.setPathData(this.c, this._length);
      var ne = this.v, oe = this.o, pe = this.i, me = 0;
      this.c && (L.setTripleAt(ne[0][0], ne[0][1], pe[0][0], pe[0][1], oe[0][0], oe[0][1], 0, !1), me = 1);
      var ge = this._length - 1, be = this._length, Ie;
      for (Ie = me; Ie < be; Ie += 1)
        L.setTripleAt(ne[ge][0], ne[ge][1], pe[ge][0], pe[ge][1], oe[ge][0], oe[ge][1], Ie, !1), ge -= 1;
      return L;
    }, ShapePath.prototype.length = function() {
      return this._length;
    };
    var shapePool = function() {
      function L() {
        return new ShapePath();
      }
      function ne(me) {
        var ge = me._length, be;
        for (be = 0; be < ge; be += 1)
          pointPool.release(me.v[be]), pointPool.release(me.i[be]), pointPool.release(me.o[be]), me.v[be] = null, me.i[be] = null, me.o[be] = null;
        me._length = 0, me.c = !1;
      }
      function oe(me) {
        var ge = pe.newElement(), be, Ie = me._length === void 0 ? me.v.length : me._length;
        for (ge.setLength(Ie), ge.c = me.c, be = 0; be < Ie; be += 1)
          ge.setTripleAt(me.v[be][0], me.v[be][1], me.o[be][0], me.o[be][1], me.i[be][0], me.i[be][1], be);
        return ge;
      }
      var pe = poolFactory(4, L, ne);
      return pe.clone = oe, pe;
    }();
    function ShapeCollection() {
      this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function(L) {
      this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = L, this._length += 1;
    }, ShapeCollection.prototype.releaseShapes = function() {
      var L;
      for (L = 0; L < this._length; L += 1)
        shapePool.release(this.shapes[L]);
      this._length = 0;
    };
    var shapeCollectionPool = function() {
      var L = {
        newShapeCollection: me,
        release: ge
      }, ne = 0, oe = 4, pe = createSizedArray(oe);
      function me() {
        var be;
        return ne ? (ne -= 1, be = pe[ne]) : be = new ShapeCollection(), be;
      }
      function ge(be) {
        var Ie, Ae = be._length;
        for (Ie = 0; Ie < Ae; Ie += 1)
          shapePool.release(be.shapes[Ie]);
        be._length = 0, ne === oe && (pe = pooling.double(pe), oe *= 2), pe[ne] = be, ne += 1;
      }
      return L;
    }(), ShapePropertyFactory = function() {
      var L = -999999;
      function ne(ot, pt, ft) {
        var vt = ft.lastIndex, xt, Ct, At, kt, Vt, ir, er, Yt, Jt, rr = this.keyframes;
        if (ot < rr[0].t - this.offsetTime)
          xt = rr[0].s[0], At = !0, vt = 0;
        else if (ot >= rr[rr.length - 1].t - this.offsetTime)
          xt = rr[rr.length - 1].s ? rr[rr.length - 1].s[0] : rr[rr.length - 2].e[0], At = !0;
        else {
          for (var Qt = vt, wt = rr.length - 1, Ft = !0, yt, Et, Dt; Ft && (yt = rr[Qt], Et = rr[Qt + 1], !(Et.t - this.offsetTime > ot)); )
            Qt < wt - 1 ? Qt += 1 : Ft = !1;
          if (Dt = this.keyframesMetadata[Qt] || {}, At = yt.h === 1, vt = Qt, !At) {
            if (ot >= Et.t - this.offsetTime)
              Yt = 1;
            else if (ot < yt.t - this.offsetTime)
              Yt = 0;
            else {
              var Ot;
              Dt.__fnct ? Ot = Dt.__fnct : (Ot = BezierFactory.getBezierEasing(yt.o.x, yt.o.y, yt.i.x, yt.i.y).get, Dt.__fnct = Ot), Yt = Ot((ot - (yt.t - this.offsetTime)) / (Et.t - this.offsetTime - (yt.t - this.offsetTime)));
            }
            Ct = Et.s ? Et.s[0] : yt.e[0];
          }
          xt = yt.s[0];
        }
        for (ir = pt._length, er = xt.i[0].length, ft.lastIndex = vt, kt = 0; kt < ir; kt += 1)
          for (Vt = 0; Vt < er; Vt += 1)
            Jt = At ? xt.i[kt][Vt] : xt.i[kt][Vt] + (Ct.i[kt][Vt] - xt.i[kt][Vt]) * Yt, pt.i[kt][Vt] = Jt, Jt = At ? xt.o[kt][Vt] : xt.o[kt][Vt] + (Ct.o[kt][Vt] - xt.o[kt][Vt]) * Yt, pt.o[kt][Vt] = Jt, Jt = At ? xt.v[kt][Vt] : xt.v[kt][Vt] + (Ct.v[kt][Vt] - xt.v[kt][Vt]) * Yt, pt.v[kt][Vt] = Jt;
      }
      function oe() {
        var ot = this.comp.renderedFrame - this.offsetTime, pt = this.keyframes[0].t - this.offsetTime, ft = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, vt = this._caching.lastFrame;
        return vt !== L && (vt < pt && ot < pt || vt > ft && ot > ft) || (this._caching.lastIndex = vt < ot ? this._caching.lastIndex : 0, this.interpolateShape(ot, this.pv, this._caching)), this._caching.lastFrame = ot, this.pv;
      }
      function pe() {
        this.paths = this.localShapeCollection;
      }
      function me(ot, pt) {
        if (ot._length !== pt._length || ot.c !== pt.c)
          return !1;
        var ft, vt = ot._length;
        for (ft = 0; ft < vt; ft += 1)
          if (ot.v[ft][0] !== pt.v[ft][0] || ot.v[ft][1] !== pt.v[ft][1] || ot.o[ft][0] !== pt.o[ft][0] || ot.o[ft][1] !== pt.o[ft][1] || ot.i[ft][0] !== pt.i[ft][0] || ot.i[ft][1] !== pt.i[ft][1])
            return !1;
        return !0;
      }
      function ge(ot) {
        me(this.v, ot) || (this.v = shapePool.clone(ot), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection);
      }
      function be() {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (!this.effectsSequence.length) {
            this._mdf = !1;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = !0, this._mdf = !1;
          var ot;
          this.kf ? ot = this.pv : this.data.ks ? ot = this.data.ks.k : ot = this.data.pt.k;
          var pt, ft = this.effectsSequence.length;
          for (pt = 0; pt < ft; pt += 1)
            ot = this.effectsSequence[pt](ot);
          this.setVValue(ot), this.lock = !1, this.frameId = this.elem.globalData.frameId;
        }
      }
      function Ie(ot, pt, ft) {
        this.propType = "shape", this.comp = ot.comp, this.container = ot, this.elem = ot, this.data = pt, this.k = !1, this.kf = !1, this._mdf = !1;
        var vt = ft === 3 ? pt.pt.k : pt.ks.k;
        this.v = shapePool.clone(vt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = pe, this.effectsSequence = [];
      }
      function Ae(ot) {
        this.effectsSequence.push(ot), this.container.addDynamicProperty(this);
      }
      Ie.prototype.interpolateShape = ne, Ie.prototype.getValue = be, Ie.prototype.setVValue = ge, Ie.prototype.addEffect = Ae;
      function rt(ot, pt, ft) {
        this.propType = "shape", this.comp = ot.comp, this.elem = ot, this.container = ot, this.offsetTime = ot.data.st, this.keyframes = ft === 3 ? pt.pt.k : pt.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
        var vt = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, vt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = L, this.reset = pe, this._caching = {
          lastFrame: L,
          lastIndex: 0
        }, this.effectsSequence = [oe.bind(this)];
      }
      rt.prototype.getValue = be, rt.prototype.interpolateShape = ne, rt.prototype.setVValue = ge, rt.prototype.addEffect = Ae;
      var st = function() {
        var ot = roundCorner;
        function pt(ft, vt) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = vt.d, this.elem = ft, this.comp = ft.comp, this.frameId = -1, this.initDynamicPropertyContainer(ft), this.p = PropertyFactory.getProp(ft, vt.p, 1, 0, this), this.s = PropertyFactory.getProp(ft, vt.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath());
        }
        return pt.prototype = {
          reset: pe,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath());
          },
          convertEllToPath: function() {
            var vt = this.p.v[0], xt = this.p.v[1], Ct = this.s.v[0] / 2, At = this.s.v[1] / 2, kt = this.d !== 3, Vt = this.v;
            Vt.v[0][0] = vt, Vt.v[0][1] = xt - At, Vt.v[1][0] = kt ? vt + Ct : vt - Ct, Vt.v[1][1] = xt, Vt.v[2][0] = vt, Vt.v[2][1] = xt + At, Vt.v[3][0] = kt ? vt - Ct : vt + Ct, Vt.v[3][1] = xt, Vt.i[0][0] = kt ? vt - Ct * ot : vt + Ct * ot, Vt.i[0][1] = xt - At, Vt.i[1][0] = kt ? vt + Ct : vt - Ct, Vt.i[1][1] = xt - At * ot, Vt.i[2][0] = kt ? vt + Ct * ot : vt - Ct * ot, Vt.i[2][1] = xt + At, Vt.i[3][0] = kt ? vt - Ct : vt + Ct, Vt.i[3][1] = xt + At * ot, Vt.o[0][0] = kt ? vt + Ct * ot : vt - Ct * ot, Vt.o[0][1] = xt - At, Vt.o[1][0] = kt ? vt + Ct : vt - Ct, Vt.o[1][1] = xt + At * ot, Vt.o[2][0] = kt ? vt - Ct * ot : vt + Ct * ot, Vt.o[2][1] = xt + At, Vt.o[3][0] = kt ? vt - Ct : vt + Ct, Vt.o[3][1] = xt - At * ot;
          }
        }, extendPrototype([DynamicPropertyContainer], pt), pt;
      }(), dt = function() {
        function ot(pt, ft) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = pt, this.comp = pt.comp, this.data = ft, this.frameId = -1, this.d = ft.d, this.initDynamicPropertyContainer(pt), ft.sy === 1 ? (this.ir = PropertyFactory.getProp(pt, ft.ir, 0, 0, this), this.is = PropertyFactory.getProp(pt, ft.is, 0, 0.01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(pt, ft.pt, 0, 0, this), this.p = PropertyFactory.getProp(pt, ft.p, 1, 0, this), this.r = PropertyFactory.getProp(pt, ft.r, 0, degToRads, this), this.or = PropertyFactory.getProp(pt, ft.or, 0, 0, this), this.os = PropertyFactory.getProp(pt, ft.os, 0, 0.01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath());
        }
        return ot.prototype = {
          reset: pe,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath());
          },
          convertStarToPath: function() {
            var ft = Math.floor(this.pt.v) * 2, vt = Math.PI * 2 / ft, xt = !0, Ct = this.or.v, At = this.ir.v, kt = this.os.v, Vt = this.is.v, ir = 2 * Math.PI * Ct / (ft * 2), er = 2 * Math.PI * At / (ft * 2), Yt, Jt, rr, Qt, wt = -Math.PI / 2;
            wt += this.r.v;
            var Ft = this.data.d === 3 ? -1 : 1;
            for (this.v._length = 0, Yt = 0; Yt < ft; Yt += 1) {
              Jt = xt ? Ct : At, rr = xt ? kt : Vt, Qt = xt ? ir : er;
              var yt = Jt * Math.cos(wt), Et = Jt * Math.sin(wt), Dt = yt === 0 && Et === 0 ? 0 : Et / Math.sqrt(yt * yt + Et * Et), Ot = yt === 0 && Et === 0 ? 0 : -yt / Math.sqrt(yt * yt + Et * Et);
              yt += +this.p.v[0], Et += +this.p.v[1], this.v.setTripleAt(yt, Et, yt - Dt * Qt * rr * Ft, Et - Ot * Qt * rr * Ft, yt + Dt * Qt * rr * Ft, Et + Ot * Qt * rr * Ft, Yt, !0), xt = !xt, wt += vt * Ft;
            }
          },
          convertPolygonToPath: function() {
            var ft = Math.floor(this.pt.v), vt = Math.PI * 2 / ft, xt = this.or.v, Ct = this.os.v, At = 2 * Math.PI * xt / (ft * 4), kt, Vt = -Math.PI * 0.5, ir = this.data.d === 3 ? -1 : 1;
            for (Vt += this.r.v, this.v._length = 0, kt = 0; kt < ft; kt += 1) {
              var er = xt * Math.cos(Vt), Yt = xt * Math.sin(Vt), Jt = er === 0 && Yt === 0 ? 0 : Yt / Math.sqrt(er * er + Yt * Yt), rr = er === 0 && Yt === 0 ? 0 : -er / Math.sqrt(er * er + Yt * Yt);
              er += +this.p.v[0], Yt += +this.p.v[1], this.v.setTripleAt(er, Yt, er - Jt * At * Ct * ir, Yt - rr * At * Ct * ir, er + Jt * At * Ct * ir, Yt + rr * At * Ct * ir, kt, !0), Vt += vt * ir;
            }
            this.paths.length = 0, this.paths[0] = this.v;
          }
        }, extendPrototype([DynamicPropertyContainer], ot), ot;
      }(), ut = function() {
        function ot(pt, ft) {
          this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = pt, this.comp = pt.comp, this.frameId = -1, this.d = ft.d, this.initDynamicPropertyContainer(pt), this.p = PropertyFactory.getProp(pt, ft.p, 1, 0, this), this.s = PropertyFactory.getProp(pt, ft.s, 1, 0, this), this.r = PropertyFactory.getProp(pt, ft.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath());
        }
        return ot.prototype = {
          convertRectToPath: function() {
            var ft = this.p.v[0], vt = this.p.v[1], xt = this.s.v[0] / 2, Ct = this.s.v[1] / 2, At = bmMin(xt, Ct, this.r.v), kt = At * (1 - roundCorner);
            this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(ft + xt, vt - Ct + At, ft + xt, vt - Ct + At, ft + xt, vt - Ct + kt, 0, !0), this.v.setTripleAt(ft + xt, vt + Ct - At, ft + xt, vt + Ct - kt, ft + xt, vt + Ct - At, 1, !0), At !== 0 ? (this.v.setTripleAt(ft + xt - At, vt + Ct, ft + xt - At, vt + Ct, ft + xt - kt, vt + Ct, 2, !0), this.v.setTripleAt(ft - xt + At, vt + Ct, ft - xt + kt, vt + Ct, ft - xt + At, vt + Ct, 3, !0), this.v.setTripleAt(ft - xt, vt + Ct - At, ft - xt, vt + Ct - At, ft - xt, vt + Ct - kt, 4, !0), this.v.setTripleAt(ft - xt, vt - Ct + At, ft - xt, vt - Ct + kt, ft - xt, vt - Ct + At, 5, !0), this.v.setTripleAt(ft - xt + At, vt - Ct, ft - xt + At, vt - Ct, ft - xt + kt, vt - Ct, 6, !0), this.v.setTripleAt(ft + xt - At, vt - Ct, ft + xt - kt, vt - Ct, ft + xt - At, vt - Ct, 7, !0)) : (this.v.setTripleAt(ft - xt, vt + Ct, ft - xt + kt, vt + Ct, ft - xt, vt + Ct, 2), this.v.setTripleAt(ft - xt, vt - Ct, ft - xt, vt - Ct + kt, ft - xt, vt - Ct, 3))) : (this.v.setTripleAt(ft + xt, vt - Ct + At, ft + xt, vt - Ct + kt, ft + xt, vt - Ct + At, 0, !0), At !== 0 ? (this.v.setTripleAt(ft + xt - At, vt - Ct, ft + xt - At, vt - Ct, ft + xt - kt, vt - Ct, 1, !0), this.v.setTripleAt(ft - xt + At, vt - Ct, ft - xt + kt, vt - Ct, ft - xt + At, vt - Ct, 2, !0), this.v.setTripleAt(ft - xt, vt - Ct + At, ft - xt, vt - Ct + At, ft - xt, vt - Ct + kt, 3, !0), this.v.setTripleAt(ft - xt, vt + Ct - At, ft - xt, vt + Ct - kt, ft - xt, vt + Ct - At, 4, !0), this.v.setTripleAt(ft - xt + At, vt + Ct, ft - xt + At, vt + Ct, ft - xt + kt, vt + Ct, 5, !0), this.v.setTripleAt(ft + xt - At, vt + Ct, ft + xt - kt, vt + Ct, ft + xt - At, vt + Ct, 6, !0), this.v.setTripleAt(ft + xt, vt + Ct - At, ft + xt, vt + Ct - At, ft + xt, vt + Ct - kt, 7, !0)) : (this.v.setTripleAt(ft - xt, vt - Ct, ft - xt + kt, vt - Ct, ft - xt, vt - Ct, 1, !0), this.v.setTripleAt(ft - xt, vt + Ct, ft - xt, vt + Ct - kt, ft - xt, vt + Ct, 2, !0), this.v.setTripleAt(ft + xt, vt + Ct, ft + xt - kt, vt + Ct, ft + xt, vt + Ct, 3, !0)));
          },
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath());
          },
          reset: pe
        }, extendPrototype([DynamicPropertyContainer], ot), ot;
      }();
      function ht(ot, pt, ft) {
        var vt;
        if (ft === 3 || ft === 4) {
          var xt = ft === 3 ? pt.pt : pt.ks, Ct = xt.k;
          Ct.length ? vt = new rt(ot, pt, ft) : vt = new Ie(ot, pt, ft);
        } else
          ft === 5 ? vt = new ut(ot, pt) : ft === 6 ? vt = new st(ot, pt) : ft === 7 && (vt = new dt(ot, pt));
        return vt.k && ot.addDynamicProperty(vt), vt;
      }
      function it() {
        return Ie;
      }
      function lt() {
        return rt;
      }
      var St = {};
      return St.getShapeProp = ht, St.getConstructorFunction = it, St.getKeyframedConstructorFunction = lt, St;
    }();
    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */
    var Matrix = /* @__PURE__ */ function() {
      var L = Math.cos, ne = Math.sin, oe = Math.tan, pe = Math.round;
      function me() {
        return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this;
      }
      function ge(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function be(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(1, 0, 0, 0, 0, Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1);
      }
      function Ie(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, 0, Dt, 0, 0, 1, 0, 0, -Dt, 0, Et, 0, 0, 0, 0, 1);
      }
      function Ae(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function rt(yt, Et) {
        return this._t(1, Et, yt, 1, 0, 0);
      }
      function st(yt, Et) {
        return this.shear(oe(yt), oe(Et));
      }
      function dt(yt, Et) {
        var Dt = L(Et), Ot = ne(Et);
        return this._t(Dt, Ot, 0, 0, -Ot, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, oe(yt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Dt, -Ot, 0, 0, Ot, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function ut(yt, Et, Dt) {
        return !Dt && Dt !== 0 && (Dt = 1), yt === 1 && Et === 1 && Dt === 1 ? this : this._t(yt, 0, 0, 0, 0, Et, 0, 0, 0, 0, Dt, 0, 0, 0, 0, 1);
      }
      function ht(yt, Et, Dt, Ot, nr, yr, mr, Tr, Nr, cn, en, Tn, Mn, $r, tn, kr) {
        return this.props[0] = yt, this.props[1] = Et, this.props[2] = Dt, this.props[3] = Ot, this.props[4] = nr, this.props[5] = yr, this.props[6] = mr, this.props[7] = Tr, this.props[8] = Nr, this.props[9] = cn, this.props[10] = en, this.props[11] = Tn, this.props[12] = Mn, this.props[13] = $r, this.props[14] = tn, this.props[15] = kr, this;
      }
      function it(yt, Et, Dt) {
        return Dt = Dt || 0, yt !== 0 || Et !== 0 || Dt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, yt, Et, Dt, 1) : this;
      }
      function lt(yt, Et, Dt, Ot, nr, yr, mr, Tr, Nr, cn, en, Tn, Mn, $r, tn, kr) {
        var dr = this.props;
        if (yt === 1 && Et === 0 && Dt === 0 && Ot === 0 && nr === 0 && yr === 1 && mr === 0 && Tr === 0 && Nr === 0 && cn === 0 && en === 1 && Tn === 0)
          return dr[12] = dr[12] * yt + dr[15] * Mn, dr[13] = dr[13] * yr + dr[15] * $r, dr[14] = dr[14] * en + dr[15] * tn, dr[15] *= kr, this._identityCalculated = !1, this;
        var zn = dr[0], Kn = dr[1], Fn = dr[2], Jn = dr[3], ki = dr[4], Ei = dr[5], Dn = dr[6], Mi = dr[7], Zn = dr[8], ei = dr[9], fi = dr[10], ti = dr[11], wn = dr[12], pi = dr[13], Va = dr[14], Vn = dr[15];
        return dr[0] = zn * yt + Kn * nr + Fn * Nr + Jn * Mn, dr[1] = zn * Et + Kn * yr + Fn * cn + Jn * $r, dr[2] = zn * Dt + Kn * mr + Fn * en + Jn * tn, dr[3] = zn * Ot + Kn * Tr + Fn * Tn + Jn * kr, dr[4] = ki * yt + Ei * nr + Dn * Nr + Mi * Mn, dr[5] = ki * Et + Ei * yr + Dn * cn + Mi * $r, dr[6] = ki * Dt + Ei * mr + Dn * en + Mi * tn, dr[7] = ki * Ot + Ei * Tr + Dn * Tn + Mi * kr, dr[8] = Zn * yt + ei * nr + fi * Nr + ti * Mn, dr[9] = Zn * Et + ei * yr + fi * cn + ti * $r, dr[10] = Zn * Dt + ei * mr + fi * en + ti * tn, dr[11] = Zn * Ot + ei * Tr + fi * Tn + ti * kr, dr[12] = wn * yt + pi * nr + Va * Nr + Vn * Mn, dr[13] = wn * Et + pi * yr + Va * cn + Vn * $r, dr[14] = wn * Dt + pi * mr + Va * en + Vn * tn, dr[15] = wn * Ot + pi * Tr + Va * Tn + Vn * kr, this._identityCalculated = !1, this;
      }
      function St(yt) {
        var Et = yt.props;
        return this.transform(Et[0], Et[1], Et[2], Et[3], Et[4], Et[5], Et[6], Et[7], Et[8], Et[9], Et[10], Et[11], Et[12], Et[13], Et[14], Et[15]);
      }
      function ot() {
        return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity;
      }
      function pt(yt) {
        for (var Et = 0; Et < 16; ) {
          if (yt.props[Et] !== this.props[Et])
            return !1;
          Et += 1;
        }
        return !0;
      }
      function ft(yt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          yt.props[Et] = this.props[Et];
        return yt;
      }
      function vt(yt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          this.props[Et] = yt[Et];
      }
      function xt(yt, Et, Dt) {
        return {
          x: yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12],
          y: yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13],
          z: yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14]
        };
      }
      function Ct(yt, Et, Dt) {
        return yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12];
      }
      function At(yt, Et, Dt) {
        return yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13];
      }
      function kt(yt, Et, Dt) {
        return yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14];
      }
      function Vt() {
        var yt = this.props[0] * this.props[5] - this.props[1] * this.props[4], Et = this.props[5] / yt, Dt = -this.props[1] / yt, Ot = -this.props[4] / yt, nr = this.props[0] / yt, yr = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / yt, mr = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / yt, Tr = new Matrix();
        return Tr.props[0] = Et, Tr.props[1] = Dt, Tr.props[4] = Ot, Tr.props[5] = nr, Tr.props[12] = yr, Tr.props[13] = mr, Tr;
      }
      function ir(yt) {
        var Et = this.getInverseMatrix();
        return Et.applyToPointArray(yt[0], yt[1], yt[2] || 0);
      }
      function er(yt) {
        var Et, Dt = yt.length, Ot = [];
        for (Et = 0; Et < Dt; Et += 1)
          Ot[Et] = ir(yt[Et]);
        return Ot;
      }
      function Yt(yt, Et, Dt) {
        var Ot = createTypedArray("float32", 6);
        if (this.isIdentity())
          Ot[0] = yt[0], Ot[1] = yt[1], Ot[2] = Et[0], Ot[3] = Et[1], Ot[4] = Dt[0], Ot[5] = Dt[1];
        else {
          var nr = this.props[0], yr = this.props[1], mr = this.props[4], Tr = this.props[5], Nr = this.props[12], cn = this.props[13];
          Ot[0] = yt[0] * nr + yt[1] * mr + Nr, Ot[1] = yt[0] * yr + yt[1] * Tr + cn, Ot[2] = Et[0] * nr + Et[1] * mr + Nr, Ot[3] = Et[0] * yr + Et[1] * Tr + cn, Ot[4] = Dt[0] * nr + Dt[1] * mr + Nr, Ot[5] = Dt[0] * yr + Dt[1] * Tr + cn;
        }
        return Ot;
      }
      function Jt(yt, Et, Dt) {
        var Ot;
        return this.isIdentity() ? Ot = [yt, Et, Dt] : Ot = [yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12], yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13], yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14]], Ot;
      }
      function rr(yt, Et) {
        if (this.isIdentity())
          return yt + "," + Et;
        var Dt = this.props;
        return Math.round((yt * Dt[0] + Et * Dt[4] + Dt[12]) * 100) / 100 + "," + Math.round((yt * Dt[1] + Et * Dt[5] + Dt[13]) * 100) / 100;
      }
      function Qt() {
        for (var yt = 0, Et = this.props, Dt = "matrix3d(", Ot = 1e4; yt < 16; )
          Dt += pe(Et[yt] * Ot) / Ot, Dt += yt === 15 ? ")" : ",", yt += 1;
        return Dt;
      }
      function wt(yt) {
        var Et = 1e4;
        return yt < 1e-6 && yt > 0 || yt > -1e-6 && yt < 0 ? pe(yt * Et) / Et : yt;
      }
      function Ft() {
        var yt = this.props, Et = wt(yt[0]), Dt = wt(yt[1]), Ot = wt(yt[4]), nr = wt(yt[5]), yr = wt(yt[12]), mr = wt(yt[13]);
        return "matrix(" + Et + "," + Dt + "," + Ot + "," + nr + "," + yr + "," + mr + ")";
      }
      return function() {
        this.reset = me, this.rotate = ge, this.rotateX = be, this.rotateY = Ie, this.rotateZ = Ae, this.skew = st, this.skewFromAxis = dt, this.shear = rt, this.scale = ut, this.setTransform = ht, this.translate = it, this.transform = lt, this.multiply = St, this.applyToPoint = xt, this.applyToX = Ct, this.applyToY = At, this.applyToZ = kt, this.applyToPointArray = Jt, this.applyToTriplePoints = Yt, this.applyToPointStringified = rr, this.toCSS = Qt, this.to2dCSS = Ft, this.clone = ft, this.cloneFromProps = vt, this.equals = pt, this.inversePoints = er, this.inversePoint = ir, this.getInverseMatrix = Vt, this._t = this.transform, this.isIdentity = ot, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset();
      };
    }();
    function _typeof$3(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(oe) {
        return typeof oe;
      } : _typeof$3 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$3(L);
    }
    var lottie = {};
    function setLocation(L) {
      setLocationHref(L);
    }
    function searchAnimations() {
      animationManager.searchAnimations();
    }
    function setSubframeRendering(L) {
      setSubframeEnabled(L);
    }
    function setPrefix(L) {
      setIdPrefix(L);
    }
    function loadAnimation(L) {
      return animationManager.loadAnimation(L);
    }
    function setQuality(L) {
      if (typeof L == "string")
        switch (L) {
          case "high":
            setDefaultCurveSegments(200);
            break;
          default:
          case "medium":
            setDefaultCurveSegments(50);
            break;
          case "low":
            setDefaultCurveSegments(10);
            break;
        }
      else
        !isNaN(L) && L > 1 && setDefaultCurveSegments(L);
    }
    function inBrowser() {
      return typeof navigator < "u";
    }
    function installPlugin(L, ne) {
      L === "expressions" && setExpressionsPlugin(ne);
    }
    function getFactory(L) {
      switch (L) {
        case "propertyFactory":
          return PropertyFactory;
        case "shapePropertyFactory":
          return ShapePropertyFactory;
        case "matrix":
          return Matrix;
        default:
          return null;
      }
    }
    lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2";
    function checkReady() {
      document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations());
    }
    function getQueryVariable(L) {
      for (var ne = queryString.split("&"), oe = 0; oe < ne.length; oe += 1) {
        var pe = ne[oe].split("=");
        if (decodeURIComponent(pe[0]) == L)
          return decodeURIComponent(pe[1]);
      }
      return null;
    }
    var queryString = "";
    {
      var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || {
        src: ""
      };
      queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer");
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);
    try {
      _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
    } catch (L) {
    }
    var ShapeModifiers = function() {
      var L = {}, ne = {};
      L.registerModifier = oe, L.getModifier = pe;
      function oe(me, ge) {
        ne[me] || (ne[me] = ge);
      }
      function pe(me, ge, be) {
        return new ne[me](ge, be);
      }
      return L;
    }();
    function ShapeModifier() {
    }
    ShapeModifier.prototype.initModifierProperties = function() {
    }, ShapeModifier.prototype.addShapeToModifier = function() {
    }, ShapeModifier.prototype.addShape = function(L) {
      if (!this.closed) {
        L.sh.container.addDynamicProperty(L.sh);
        var ne = {
          shape: L.sh,
          data: L,
          localShapeCollection: shapeCollectionPool.newShapeCollection()
        };
        this.shapes.push(ne), this.addShapeToModifier(ne), this._isAnimated && L.setAsAnimated();
      }
    }, ShapeModifier.prototype.init = function(L, ne) {
      this.shapes = [], this.elem = L, this.initDynamicPropertyContainer(L), this.initModifierProperties(L, ne), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, ShapeModifier.prototype.processKeys = function() {
      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties());
    }, extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier() {
    }
    extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(L, ne) {
      this.s = PropertyFactory.getProp(L, ne.s, 0, 0.01, this), this.e = PropertyFactory.getProp(L, ne.e, 0, 0.01, this), this.o = PropertyFactory.getProp(L, ne.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = ne.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    }, TrimModifier.prototype.addShapeToModifier = function(L) {
      L.pathsData = [];
    }, TrimModifier.prototype.calculateShapeEdges = function(L, ne, oe, pe, me) {
      var ge = [];
      ne <= 1 ? ge.push({
        s: L,
        e: ne
      }) : L >= 1 ? ge.push({
        s: L - 1,
        e: ne - 1
      }) : (ge.push({
        s: L,
        e: 1
      }), ge.push({
        s: 0,
        e: ne - 1
      }));
      var be = [], Ie, Ae = ge.length, rt;
      for (Ie = 0; Ie < Ae; Ie += 1)
        if (rt = ge[Ie], !(rt.e * me < pe || rt.s * me > pe + oe)) {
          var st, dt;
          rt.s * me <= pe ? st = 0 : st = (rt.s * me - pe) / oe, rt.e * me >= pe + oe ? dt = 1 : dt = (rt.e * me - pe) / oe, be.push([st, dt]);
        }
      return be.length || be.push([0, 0]), be;
    }, TrimModifier.prototype.releasePathsData = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        segmentsLengthPool.release(L[ne]);
      return L.length = 0, L;
    }, TrimModifier.prototype.processShapes = function(L) {
      var ne, oe;
      if (this._mdf || L) {
        var pe = this.o.v % 360 / 360;
        if (pe < 0 && (pe += 1), this.s.v > 1 ? ne = 1 + pe : this.s.v < 0 ? ne = 0 + pe : ne = this.s.v + pe, this.e.v > 1 ? oe = 1 + pe : this.e.v < 0 ? oe = 0 + pe : oe = this.e.v + pe, ne > oe) {
          var me = ne;
          ne = oe, oe = me;
        }
        ne = Math.round(ne * 1e4) * 1e-4, oe = Math.round(oe * 1e4) * 1e-4, this.sValue = ne, this.eValue = oe;
      } else
        ne = this.sValue, oe = this.eValue;
      var ge, be, Ie = this.shapes.length, Ae, rt, st, dt, ut, ht = 0;
      if (oe === ne)
        for (be = 0; be < Ie; be += 1)
          this.shapes[be].localShapeCollection.releaseShapes(), this.shapes[be].shape._mdf = !0, this.shapes[be].shape.paths = this.shapes[be].localShapeCollection, this._mdf && (this.shapes[be].pathsData.length = 0);
      else if (oe === 1 && ne === 0 || oe === 0 && ne === 1) {
        if (this._mdf)
          for (be = 0; be < Ie; be += 1)
            this.shapes[be].pathsData.length = 0, this.shapes[be].shape._mdf = !0;
      } else {
        var it = [], lt, St;
        for (be = 0; be < Ie; be += 1)
          if (lt = this.shapes[be], !lt.shape._mdf && !this._mdf && !L && this.m !== 2)
            lt.shape.paths = lt.localShapeCollection;
          else {
            if (ge = lt.shape.paths, rt = ge._length, ut = 0, !lt.shape._mdf && lt.pathsData.length)
              ut = lt.totalShapeLength;
            else {
              for (st = this.releasePathsData(lt.pathsData), Ae = 0; Ae < rt; Ae += 1)
                dt = bez.getSegmentsLength(ge.shapes[Ae]), st.push(dt), ut += dt.totalLength;
              lt.totalShapeLength = ut, lt.pathsData = st;
            }
            ht += ut, lt.shape._mdf = !0;
          }
        var ot = ne, pt = oe, ft = 0, vt;
        for (be = Ie - 1; be >= 0; be -= 1)
          if (lt = this.shapes[be], lt.shape._mdf) {
            for (St = lt.localShapeCollection, St.releaseShapes(), this.m === 2 && Ie > 1 ? (vt = this.calculateShapeEdges(ne, oe, lt.totalShapeLength, ft, ht), ft += lt.totalShapeLength) : vt = [[ot, pt]], rt = vt.length, Ae = 0; Ae < rt; Ae += 1) {
              ot = vt[Ae][0], pt = vt[Ae][1], it.length = 0, pt <= 1 ? it.push({
                s: lt.totalShapeLength * ot,
                e: lt.totalShapeLength * pt
              }) : ot >= 1 ? it.push({
                s: lt.totalShapeLength * (ot - 1),
                e: lt.totalShapeLength * (pt - 1)
              }) : (it.push({
                s: lt.totalShapeLength * ot,
                e: lt.totalShapeLength
              }), it.push({
                s: 0,
                e: lt.totalShapeLength * (pt - 1)
              }));
              var xt = this.addShapes(lt, it[0]);
              if (it[0].s !== it[0].e) {
                if (it.length > 1) {
                  var Ct = lt.shape.paths.shapes[lt.shape.paths._length - 1];
                  if (Ct.c) {
                    var At = xt.pop();
                    this.addPaths(xt, St), xt = this.addShapes(lt, it[1], At);
                  } else
                    this.addPaths(xt, St), xt = this.addShapes(lt, it[1]);
                }
                this.addPaths(xt, St);
              }
            }
            lt.shape.paths = St;
          }
      }
    }, TrimModifier.prototype.addPaths = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        ne.addShape(L[oe]);
    }, TrimModifier.prototype.addSegment = function(L, ne, oe, pe, me, ge, be) {
      me.setXYAt(ne[0], ne[1], "o", ge), me.setXYAt(oe[0], oe[1], "i", ge + 1), be && me.setXYAt(L[0], L[1], "v", ge), me.setXYAt(pe[0], pe[1], "v", ge + 1);
    }, TrimModifier.prototype.addSegmentFromArray = function(L, ne, oe, pe) {
      ne.setXYAt(L[1], L[5], "o", oe), ne.setXYAt(L[2], L[6], "i", oe + 1), pe && ne.setXYAt(L[0], L[4], "v", oe), ne.setXYAt(L[3], L[7], "v", oe + 1);
    }, TrimModifier.prototype.addShapes = function(L, ne, oe) {
      var pe = L.pathsData, me = L.shape.paths.shapes, ge, be = L.shape.paths._length, Ie, Ae, rt = 0, st, dt, ut, ht, it = [], lt, St = !0;
      for (oe ? (dt = oe._length, lt = oe._length) : (oe = shapePool.newElement(), dt = 0, lt = 0), it.push(oe), ge = 0; ge < be; ge += 1) {
        for (ut = pe[ge].lengths, oe.c = me[ge].c, Ae = me[ge].c ? ut.length : ut.length + 1, Ie = 1; Ie < Ae; Ie += 1)
          if (st = ut[Ie - 1], rt + st.addedLength < ne.s)
            rt += st.addedLength, oe.c = !1;
          else if (rt > ne.e) {
            oe.c = !1;
            break;
          } else
            ne.s <= rt && ne.e >= rt + st.addedLength ? (this.addSegment(me[ge].v[Ie - 1], me[ge].o[Ie - 1], me[ge].i[Ie], me[ge].v[Ie], oe, dt, St), St = !1) : (ht = bez.getNewSegment(me[ge].v[Ie - 1], me[ge].v[Ie], me[ge].o[Ie - 1], me[ge].i[Ie], (ne.s - rt) / st.addedLength, (ne.e - rt) / st.addedLength, ut[Ie - 1]), this.addSegmentFromArray(ht, oe, dt, St), St = !1, oe.c = !1), rt += st.addedLength, dt += 1;
        if (me[ge].c && ut.length) {
          if (st = ut[Ie - 1], rt <= ne.e) {
            var ot = ut[Ie - 1].addedLength;
            ne.s <= rt && ne.e >= rt + ot ? (this.addSegment(me[ge].v[Ie - 1], me[ge].o[Ie - 1], me[ge].i[0], me[ge].v[0], oe, dt, St), St = !1) : (ht = bez.getNewSegment(me[ge].v[Ie - 1], me[ge].v[0], me[ge].o[Ie - 1], me[ge].i[0], (ne.s - rt) / ot, (ne.e - rt) / ot, ut[Ie - 1]), this.addSegmentFromArray(ht, oe, dt, St), St = !1, oe.c = !1);
          } else
            oe.c = !1;
          rt += st.addedLength, dt += 1;
        }
        if (oe._length && (oe.setXYAt(oe.v[lt][0], oe.v[lt][1], "i", lt), oe.setXYAt(oe.v[oe._length - 1][0], oe.v[oe._length - 1][1], "o", oe._length - 1)), rt > ne.e)
          break;
        ge < be - 1 && (oe = shapePool.newElement(), St = !0, it.push(oe), dt = 0);
      }
      return it;
    };
    function PuckerAndBloatModifier() {
    }
    extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(L, ne.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length;
    }, PuckerAndBloatModifier.prototype.processPath = function(L, ne) {
      var oe = ne / 100, pe = [0, 0], me = L._length, ge = 0;
      for (ge = 0; ge < me; ge += 1)
        pe[0] += L.v[ge][0], pe[1] += L.v[ge][1];
      pe[0] /= me, pe[1] /= me;
      var be = shapePool.newElement();
      be.c = L.c;
      var Ie, Ae, rt, st, dt, ut;
      for (ge = 0; ge < me; ge += 1)
        Ie = L.v[ge][0] + (pe[0] - L.v[ge][0]) * oe, Ae = L.v[ge][1] + (pe[1] - L.v[ge][1]) * oe, rt = L.o[ge][0] + (pe[0] - L.o[ge][0]) * -oe, st = L.o[ge][1] + (pe[1] - L.o[ge][1]) * -oe, dt = L.i[ge][0] + (pe[0] - L.i[ge][0]) * -oe, ut = L.i[ge][1] + (pe[1] - L.i[ge][1]) * -oe, be.setTripleAt(Ie, Ae, rt, st, dt, ut, ge);
      return be;
    }, PuckerAndBloatModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amount.v;
      if (be !== 0) {
        var Ie, Ae;
        for (oe = 0; oe < pe; oe += 1) {
          if (Ie = this.shapes[oe], Ae = Ie.localShapeCollection, !(!Ie.shape._mdf && !this._mdf && !L))
            for (Ae.releaseShapes(), Ie.shape._mdf = !0, ne = Ie.shape.paths.shapes, ge = Ie.shape.paths._length, me = 0; me < ge; me += 1)
              Ae.addShape(this.processPath(ne[me], be));
          Ie.shape.paths = Ie.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    var TransformPropertyFactory = function() {
      var L = [0, 0];
      function ne(Ae) {
        var rt = this._mdf;
        this.iterateDynamicProperties(), this._mdf = this._mdf || rt, this.a && Ae.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && Ae.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && Ae.skewFromAxis(-this.sk.v, this.sa.v), this.r ? Ae.rotate(-this.r.v) : Ae.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? Ae.translate(this.px.v, this.py.v, -this.pz.v) : Ae.translate(this.px.v, this.py.v, 0) : Ae.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
      function oe(Ae) {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || Ae) {
            var rt;
            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
              var st, dt;
              if (rt = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime)
                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (st = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / rt, 0), dt = this.p.getValueAtTime(this.p.keyframes[0].t / rt, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (st = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / rt, 0), dt = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / rt, 0)) : (st = this.p.pv, dt = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / rt, this.p.offsetTime));
              else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                st = [], dt = [];
                var ut = this.px, ht = this.py;
                ut._caching.lastFrame + ut.offsetTime <= ut.keyframes[0].t ? (st[0] = ut.getValueAtTime((ut.keyframes[0].t + 0.01) / rt, 0), st[1] = ht.getValueAtTime((ht.keyframes[0].t + 0.01) / rt, 0), dt[0] = ut.getValueAtTime(ut.keyframes[0].t / rt, 0), dt[1] = ht.getValueAtTime(ht.keyframes[0].t / rt, 0)) : ut._caching.lastFrame + ut.offsetTime >= ut.keyframes[ut.keyframes.length - 1].t ? (st[0] = ut.getValueAtTime(ut.keyframes[ut.keyframes.length - 1].t / rt, 0), st[1] = ht.getValueAtTime(ht.keyframes[ht.keyframes.length - 1].t / rt, 0), dt[0] = ut.getValueAtTime((ut.keyframes[ut.keyframes.length - 1].t - 0.01) / rt, 0), dt[1] = ht.getValueAtTime((ht.keyframes[ht.keyframes.length - 1].t - 0.01) / rt, 0)) : (st = [ut.pv, ht.pv], dt[0] = ut.getValueAtTime((ut._caching.lastFrame + ut.offsetTime - 0.01) / rt, ut.offsetTime), dt[1] = ht.getValueAtTime((ht._caching.lastFrame + ht.offsetTime - 0.01) / rt, ht.offsetTime));
              } else
                dt = L, st = dt;
              this.v.rotate(-Math.atan2(st[1] - dt[1], st[0] - dt[0]));
            }
            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
          this.frameId = this.elem.globalData.frameId;
        }
      }
      function pe() {
        if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length)
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1;
        else
          return;
        if (!this.s.effectsSequence.length)
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2;
        else
          return;
        if (this.sk)
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
            this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3;
          else
            return;
        this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4);
      }
      function me() {
      }
      function ge(Ae) {
        this._addDynamicProperty(Ae), this.elem.addDynamicProperty(Ae), this._isDirty = !0;
      }
      function be(Ae, rt, st) {
        if (this.elem = Ae, this.frameId = -1, this.propType = "transform", this.data = rt, this.v = new Matrix(), this.pre = new Matrix(), this.appliedTransformations = 0, this.initDynamicPropertyContainer(st || Ae), rt.p && rt.p.s ? (this.px = PropertyFactory.getProp(Ae, rt.p.x, 0, 0, this), this.py = PropertyFactory.getProp(Ae, rt.p.y, 0, 0, this), rt.p.z && (this.pz = PropertyFactory.getProp(Ae, rt.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(Ae, rt.p || {
          k: [0, 0, 0]
        }, 1, 0, this), rt.rx) {
          if (this.rx = PropertyFactory.getProp(Ae, rt.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(Ae, rt.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(Ae, rt.rz, 0, degToRads, this), rt.or.k[0].ti) {
            var dt, ut = rt.or.k.length;
            for (dt = 0; dt < ut; dt += 1)
              rt.or.k[dt].to = null, rt.or.k[dt].ti = null;
          }
          this.or = PropertyFactory.getProp(Ae, rt.or, 1, degToRads, this), this.or.sh = !0;
        } else
          this.r = PropertyFactory.getProp(Ae, rt.r || {
            k: 0
          }, 0, degToRads, this);
        rt.sk && (this.sk = PropertyFactory.getProp(Ae, rt.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(Ae, rt.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(Ae, rt.a || {
          k: [0, 0, 0]
        }, 1, 0, this), this.s = PropertyFactory.getProp(Ae, rt.s || {
          k: [100, 100, 100]
        }, 1, 0.01, this), rt.o ? this.o = PropertyFactory.getProp(Ae, rt.o, 0, 0.01, Ae) : this.o = {
          _mdf: !1,
          v: 1
        }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0);
      }
      be.prototype = {
        applyToMatrix: ne,
        getValue: oe,
        precalculateMatrix: pe,
        autoOrient: me
      }, extendPrototype([DynamicPropertyContainer], be), be.prototype.addDynamicProperty = ge, be.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
      function Ie(Ae, rt, st) {
        return new be(Ae, rt, st);
      }
      return {
        getTransformProperty: Ie
      };
    }();
    function RepeaterModifier() {
    }
    extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.c = PropertyFactory.getProp(L, ne.c, 0, null, this), this.o = PropertyFactory.getProp(L, ne.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(L, ne.tr, this), this.so = PropertyFactory.getProp(L, ne.tr.so, 0, 0.01, this), this.eo = PropertyFactory.getProp(L, ne.tr.eo, 0, 0.01, this), this.data = ne, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix(), this.rMatrix = new Matrix(), this.sMatrix = new Matrix(), this.tMatrix = new Matrix(), this.matrix = new Matrix();
    }, RepeaterModifier.prototype.applyTransforms = function(L, ne, oe, pe, me, ge) {
      var be = ge ? -1 : 1, Ie = pe.s.v[0] + (1 - pe.s.v[0]) * (1 - me), Ae = pe.s.v[1] + (1 - pe.s.v[1]) * (1 - me);
      L.translate(pe.p.v[0] * be * me, pe.p.v[1] * be * me, pe.p.v[2]), ne.translate(-pe.a.v[0], -pe.a.v[1], pe.a.v[2]), ne.rotate(-pe.r.v * be * me), ne.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]), oe.translate(-pe.a.v[0], -pe.a.v[1], pe.a.v[2]), oe.scale(ge ? 1 / Ie : Ie, ge ? 1 / Ae : Ae), oe.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]);
    }, RepeaterModifier.prototype.init = function(L, ne, oe, pe) {
      for (this.elem = L, this.arr = ne, this.pos = oe, this.elemsData = pe, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(L), this.initModifierProperties(L, ne[oe]); oe > 0; )
        oe -= 1, this._elements.unshift(ne[oe]);
      this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, RepeaterModifier.prototype.resetElements = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne]._processed = !1, L[ne].ty === "gr" && this.resetElements(L[ne].it);
    }, RepeaterModifier.prototype.cloneElements = function(L) {
      var ne = JSON.parse(JSON.stringify(L));
      return this.resetElements(ne), ne;
    }, RepeaterModifier.prototype.changeGroupRender = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        L[oe]._render = ne, L[oe].ty === "gr" && this.changeGroupRender(L[oe].it, ne);
    }, RepeaterModifier.prototype.processShapes = function(L) {
      var ne, oe, pe, me, ge, be = !1;
      if (this._mdf || L) {
        var Ie = Math.ceil(this.c.v);
        if (this._groups.length < Ie) {
          for (; this._groups.length < Ie; ) {
            var Ae = {
              it: this.cloneElements(this._elements),
              ty: "gr"
            };
            Ae.it.push({
              a: {
                a: 0,
                ix: 1,
                k: [0, 0]
              },
              nm: "Transform",
              o: {
                a: 0,
                ix: 7,
                k: 100
              },
              p: {
                a: 0,
                ix: 2,
                k: [0, 0]
              },
              r: {
                a: 1,
                ix: 6,
                k: [{
                  s: 0,
                  e: 0,
                  t: 0
                }, {
                  s: 0,
                  e: 0,
                  t: 1
                }]
              },
              s: {
                a: 0,
                ix: 3,
                k: [100, 100]
              },
              sa: {
                a: 0,
                ix: 5,
                k: 0
              },
              sk: {
                a: 0,
                ix: 4,
                k: 0
              },
              ty: "tr"
            }), this.arr.splice(0, 0, Ae), this._groups.splice(0, 0, Ae), this._currentCopies += 1;
          }
          this.elem.reloadShapes(), be = !0;
        }
        ge = 0;
        var rt;
        for (pe = 0; pe <= this._groups.length - 1; pe += 1) {
          if (rt = ge < Ie, this._groups[pe]._render = rt, this.changeGroupRender(this._groups[pe].it, rt), !rt) {
            var st = this.elemsData[pe].it, dt = st[st.length - 1];
            dt.transform.op.v !== 0 ? (dt.transform.op._mdf = !0, dt.transform.op.v = 0) : dt.transform.op._mdf = !1;
          }
          ge += 1;
        }
        this._currentCopies = Ie;
        var ut = this.o.v, ht = ut % 1, it = ut > 0 ? Math.floor(ut) : Math.ceil(ut), lt = this.pMatrix.props, St = this.rMatrix.props, ot = this.sMatrix.props;
        this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
        var pt = 0;
        if (ut > 0) {
          for (; pt < it; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), pt += 1;
          ht && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, ht, !1), pt += ht);
        } else if (ut < 0) {
          for (; pt > it; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), pt -= 1;
          ht && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -ht, !0), pt -= ht);
        }
        pe = this.data.m === 1 ? 0 : this._currentCopies - 1, me = this.data.m === 1 ? 1 : -1, ge = this._currentCopies;
        for (var ft, vt; ge; ) {
          if (ne = this.elemsData[pe].it, oe = ne[ne.length - 1].transform.mProps.v.props, vt = oe.length, ne[ne.length - 1].transform.mProps._mdf = !0, ne[ne.length - 1].transform.op._mdf = !0, ne[ne.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (pe / (this._currentCopies - 1)), pt !== 0) {
            for ((pe !== 0 && me === 1 || pe !== this._currentCopies - 1 && me === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(St[0], St[1], St[2], St[3], St[4], St[5], St[6], St[7], St[8], St[9], St[10], St[11], St[12], St[13], St[14], St[15]), this.matrix.transform(ot[0], ot[1], ot[2], ot[3], ot[4], ot[5], ot[6], ot[7], ot[8], ot[9], ot[10], ot[11], ot[12], ot[13], ot[14], ot[15]), this.matrix.transform(lt[0], lt[1], lt[2], lt[3], lt[4], lt[5], lt[6], lt[7], lt[8], lt[9], lt[10], lt[11], lt[12], lt[13], lt[14], lt[15]), ft = 0; ft < vt; ft += 1)
              oe[ft] = this.matrix.props[ft];
            this.matrix.reset();
          } else
            for (this.matrix.reset(), ft = 0; ft < vt; ft += 1)
              oe[ft] = this.matrix.props[ft];
          pt += 1, ge -= 1, pe += me;
        }
      } else
        for (ge = this._currentCopies, pe = 0, me = 1; ge; )
          ne = this.elemsData[pe].it, oe = ne[ne.length - 1].transform.mProps.v.props, ne[ne.length - 1].transform.mProps._mdf = !1, ne[ne.length - 1].transform.op._mdf = !1, ge -= 1, pe += me;
      return be;
    }, RepeaterModifier.prototype.addShape = function() {
    };
    function RoundCornersModifier() {
    }
    extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(L, ne.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length;
    }, RoundCornersModifier.prototype.processPath = function(L, ne) {
      var oe = shapePool.newElement();
      oe.c = L.c;
      var pe, me = L._length, ge, be, Ie, Ae, rt, st, dt = 0, ut, ht, it, lt, St, ot;
      for (pe = 0; pe < me; pe += 1)
        ge = L.v[pe], Ie = L.o[pe], be = L.i[pe], ge[0] === Ie[0] && ge[1] === Ie[1] && ge[0] === be[0] && ge[1] === be[1] ? (pe === 0 || pe === me - 1) && !L.c ? (oe.setTripleAt(ge[0], ge[1], Ie[0], Ie[1], be[0], be[1], dt), dt += 1) : (pe === 0 ? Ae = L.v[me - 1] : Ae = L.v[pe - 1], rt = Math.sqrt(Math.pow(ge[0] - Ae[0], 2) + Math.pow(ge[1] - Ae[1], 2)), st = rt ? Math.min(rt / 2, ne) / rt : 0, St = ge[0] + (Ae[0] - ge[0]) * st, ut = St, ot = ge[1] - (ge[1] - Ae[1]) * st, ht = ot, it = ut - (ut - ge[0]) * roundCorner, lt = ht - (ht - ge[1]) * roundCorner, oe.setTripleAt(ut, ht, it, lt, St, ot, dt), dt += 1, pe === me - 1 ? Ae = L.v[0] : Ae = L.v[pe + 1], rt = Math.sqrt(Math.pow(ge[0] - Ae[0], 2) + Math.pow(ge[1] - Ae[1], 2)), st = rt ? Math.min(rt / 2, ne) / rt : 0, it = ge[0] + (Ae[0] - ge[0]) * st, ut = it, lt = ge[1] + (Ae[1] - ge[1]) * st, ht = lt, St = ut - (ut - ge[0]) * roundCorner, ot = ht - (ht - ge[1]) * roundCorner, oe.setTripleAt(ut, ht, it, lt, St, ot, dt), dt += 1) : (oe.setTripleAt(L.v[pe][0], L.v[pe][1], L.o[pe][0], L.o[pe][1], L.i[pe][0], L.i[pe][1], dt), dt += 1);
      return oe;
    }, RoundCornersModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.rd.v;
      if (be !== 0) {
        var Ie, Ae;
        for (oe = 0; oe < pe; oe += 1) {
          if (Ie = this.shapes[oe], Ae = Ie.localShapeCollection, !(!Ie.shape._mdf && !this._mdf && !L))
            for (Ae.releaseShapes(), Ie.shape._mdf = !0, ne = Ie.shape.paths.shapes, ge = Ie.shape.paths._length, me = 0; me < ge; me += 1)
              Ae.addShape(this.processPath(ne[me], be));
          Ie.shape.paths = Ie.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function floatEqual(L, ne) {
      return Math.abs(L - ne) * 1e5 <= Math.min(Math.abs(L), Math.abs(ne));
    }
    function floatZero(L) {
      return Math.abs(L) <= 1e-5;
    }
    function lerp(L, ne, oe) {
      return L * (1 - oe) + ne * oe;
    }
    function lerpPoint(L, ne, oe) {
      return [lerp(L[0], ne[0], oe), lerp(L[1], ne[1], oe)];
    }
    function quadRoots(L, ne, oe) {
      if (L === 0)
        return [];
      var pe = ne * ne - 4 * L * oe;
      if (pe < 0)
        return [];
      var me = -ne / (2 * L);
      if (pe === 0)
        return [me];
      var ge = Math.sqrt(pe) / (2 * L);
      return [me - ge, me + ge];
    }
    function polynomialCoefficients(L, ne, oe, pe) {
      return [-L + 3 * ne - 3 * oe + pe, 3 * L - 6 * ne + 3 * oe, -3 * L + 3 * ne, L];
    }
    function singlePoint(L) {
      return new PolynomialBezier(L, L, L, L, !1);
    }
    function PolynomialBezier(L, ne, oe, pe, me) {
      me && pointEqual(L, ne) && (ne = lerpPoint(L, pe, 1 / 3)), me && pointEqual(oe, pe) && (oe = lerpPoint(L, pe, 2 / 3));
      var ge = polynomialCoefficients(L[0], ne[0], oe[0], pe[0]), be = polynomialCoefficients(L[1], ne[1], oe[1], pe[1]);
      this.a = [ge[0], be[0]], this.b = [ge[1], be[1]], this.c = [ge[2], be[2]], this.d = [ge[3], be[3]], this.points = [L, ne, oe, pe];
    }
    PolynomialBezier.prototype.point = function(L) {
      return [((this.a[0] * L + this.b[0]) * L + this.c[0]) * L + this.d[0], ((this.a[1] * L + this.b[1]) * L + this.c[1]) * L + this.d[1]];
    }, PolynomialBezier.prototype.derivative = function(L) {
      return [(3 * L * this.a[0] + 2 * this.b[0]) * L + this.c[0], (3 * L * this.a[1] + 2 * this.b[1]) * L + this.c[1]];
    }, PolynomialBezier.prototype.tangentAngle = function(L) {
      var ne = this.derivative(L);
      return Math.atan2(ne[1], ne[0]);
    }, PolynomialBezier.prototype.normalAngle = function(L) {
      var ne = this.derivative(L);
      return Math.atan2(ne[0], ne[1]);
    }, PolynomialBezier.prototype.inflectionPoints = function() {
      var L = this.a[1] * this.b[0] - this.a[0] * this.b[1];
      if (floatZero(L))
        return [];
      var ne = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / L, oe = ne * ne - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / L;
      if (oe < 0)
        return [];
      var pe = Math.sqrt(oe);
      return floatZero(pe) ? pe > 0 && pe < 1 ? [ne] : [] : [ne - pe, ne + pe].filter(function(me) {
        return me > 0 && me < 1;
      });
    }, PolynomialBezier.prototype.split = function(L) {
      if (L <= 0)
        return [singlePoint(this.points[0]), this];
      if (L >= 1)
        return [this, singlePoint(this.points[this.points.length - 1])];
      var ne = lerpPoint(this.points[0], this.points[1], L), oe = lerpPoint(this.points[1], this.points[2], L), pe = lerpPoint(this.points[2], this.points[3], L), me = lerpPoint(ne, oe, L), ge = lerpPoint(oe, pe, L), be = lerpPoint(me, ge, L);
      return [new PolynomialBezier(this.points[0], ne, me, be, !0), new PolynomialBezier(be, ge, pe, this.points[3], !0)];
    };
    function extrema(L, ne) {
      var oe = L.points[0][ne], pe = L.points[L.points.length - 1][ne];
      if (oe > pe) {
        var me = pe;
        pe = oe, oe = me;
      }
      for (var ge = quadRoots(3 * L.a[ne], 2 * L.b[ne], L.c[ne]), be = 0; be < ge.length; be += 1)
        if (ge[be] > 0 && ge[be] < 1) {
          var Ie = L.point(ge[be])[ne];
          Ie < oe ? oe = Ie : Ie > pe && (pe = Ie);
        }
      return {
        min: oe,
        max: pe
      };
    }
    PolynomialBezier.prototype.bounds = function() {
      return {
        x: extrema(this, 0),
        y: extrema(this, 1)
      };
    }, PolynomialBezier.prototype.boundingBox = function() {
      var L = this.bounds();
      return {
        left: L.x.min,
        right: L.x.max,
        top: L.y.min,
        bottom: L.y.max,
        width: L.x.max - L.x.min,
        height: L.y.max - L.y.min,
        cx: (L.x.max + L.x.min) / 2,
        cy: (L.y.max + L.y.min) / 2
      };
    };
    function intersectData(L, ne, oe) {
      var pe = L.boundingBox();
      return {
        cx: pe.cx,
        cy: pe.cy,
        width: pe.width,
        height: pe.height,
        bez: L,
        t: (ne + oe) / 2,
        t1: ne,
        t2: oe
      };
    }
    function splitData(L) {
      var ne = L.bez.split(0.5);
      return [intersectData(ne[0], L.t1, L.t), intersectData(ne[1], L.t, L.t2)];
    }
    function boxIntersect(L, ne) {
      return Math.abs(L.cx - ne.cx) * 2 < L.width + ne.width && Math.abs(L.cy - ne.cy) * 2 < L.height + ne.height;
    }
    function intersectsImpl(L, ne, oe, pe, me, ge) {
      if (boxIntersect(L, ne)) {
        if (oe >= ge || L.width <= pe && L.height <= pe && ne.width <= pe && ne.height <= pe) {
          me.push([L.t, ne.t]);
          return;
        }
        var be = splitData(L), Ie = splitData(ne);
        intersectsImpl(be[0], Ie[0], oe + 1, pe, me, ge), intersectsImpl(be[0], Ie[1], oe + 1, pe, me, ge), intersectsImpl(be[1], Ie[0], oe + 1, pe, me, ge), intersectsImpl(be[1], Ie[1], oe + 1, pe, me, ge);
      }
    }
    PolynomialBezier.prototype.intersections = function(L, ne, oe) {
      ne === void 0 && (ne = 2), oe === void 0 && (oe = 7);
      var pe = [];
      return intersectsImpl(intersectData(this, 0, 1), intersectData(L, 0, 1), 0, ne, pe, oe), pe;
    }, PolynomialBezier.shapeSegment = function(L, ne) {
      var oe = (ne + 1) % L.length();
      return new PolynomialBezier(L.v[ne], L.o[ne], L.i[oe], L.v[oe], !0);
    }, PolynomialBezier.shapeSegmentInverted = function(L, ne) {
      var oe = (ne + 1) % L.length();
      return new PolynomialBezier(L.v[oe], L.i[oe], L.o[ne], L.v[ne], !0);
    };
    function crossProduct(L, ne) {
      return [L[1] * ne[2] - L[2] * ne[1], L[2] * ne[0] - L[0] * ne[2], L[0] * ne[1] - L[1] * ne[0]];
    }
    function lineIntersection(L, ne, oe, pe) {
      var me = [L[0], L[1], 1], ge = [ne[0], ne[1], 1], be = [oe[0], oe[1], 1], Ie = [pe[0], pe[1], 1], Ae = crossProduct(crossProduct(me, ge), crossProduct(be, Ie));
      return floatZero(Ae[2]) ? null : [Ae[0] / Ae[2], Ae[1] / Ae[2]];
    }
    function polarOffset(L, ne, oe) {
      return [L[0] + Math.cos(ne) * oe, L[1] - Math.sin(ne) * oe];
    }
    function pointDistance(L, ne) {
      return Math.hypot(L[0] - ne[0], L[1] - ne[1]);
    }
    function pointEqual(L, ne) {
      return floatEqual(L[0], ne[0]) && floatEqual(L[1], ne[1]);
    }
    function ZigZagModifier() {
    }
    extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(L, ne.s, 0, null, this), this.frequency = PropertyFactory.getProp(L, ne.r, 0, null, this), this.pointsType = PropertyFactory.getProp(L, ne.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
    };
    function setPoint(L, ne, oe, pe, me, ge, be) {
      var Ie = oe - Math.PI / 2, Ae = oe + Math.PI / 2, rt = ne[0] + Math.cos(oe) * pe * me, st = ne[1] - Math.sin(oe) * pe * me;
      L.setTripleAt(rt, st, rt + Math.cos(Ie) * ge, st - Math.sin(Ie) * ge, rt + Math.cos(Ae) * be, st - Math.sin(Ae) * be, L.length());
    }
    function getPerpendicularVector(L, ne) {
      var oe = [ne[0] - L[0], ne[1] - L[1]], pe = -Math.PI * 0.5, me = [Math.cos(pe) * oe[0] - Math.sin(pe) * oe[1], Math.sin(pe) * oe[0] + Math.cos(pe) * oe[1]];
      return me;
    }
    function getProjectingAngle(L, ne) {
      var oe = ne === 0 ? L.length() - 1 : ne - 1, pe = (ne + 1) % L.length(), me = L.v[oe], ge = L.v[pe], be = getPerpendicularVector(me, ge);
      return Math.atan2(0, 1) - Math.atan2(be[1], be[0]);
    }
    function zigZagCorner(L, ne, oe, pe, me, ge, be) {
      var Ie = getProjectingAngle(ne, oe), Ae = ne.v[oe % ne._length], rt = ne.v[oe === 0 ? ne._length - 1 : oe - 1], st = ne.v[(oe + 1) % ne._length], dt = ge === 2 ? Math.sqrt(Math.pow(Ae[0] - rt[0], 2) + Math.pow(Ae[1] - rt[1], 2)) : 0, ut = ge === 2 ? Math.sqrt(Math.pow(Ae[0] - st[0], 2) + Math.pow(Ae[1] - st[1], 2)) : 0;
      setPoint(L, ne.v[oe % ne._length], Ie, be, pe, ut / ((me + 1) * 2), dt / ((me + 1) * 2));
    }
    function zigZagSegment(L, ne, oe, pe, me, ge) {
      for (var be = 0; be < pe; be += 1) {
        var Ie = (be + 1) / (pe + 1), Ae = me === 2 ? Math.sqrt(Math.pow(ne.points[3][0] - ne.points[0][0], 2) + Math.pow(ne.points[3][1] - ne.points[0][1], 2)) : 0, rt = ne.normalAngle(Ie), st = ne.point(Ie);
        setPoint(L, st, rt, ge, oe, Ae / ((pe + 1) * 2), Ae / ((pe + 1) * 2)), ge = -ge;
      }
      return ge;
    }
    ZigZagModifier.prototype.processPath = function(L, ne, oe, pe) {
      var me = L._length, ge = shapePool.newElement();
      if (ge.c = L.c, L.c || (me -= 1), me === 0)
        return ge;
      var be = -1, Ie = PolynomialBezier.shapeSegment(L, 0);
      zigZagCorner(ge, L, 0, ne, oe, pe, be);
      for (var Ae = 0; Ae < me; Ae += 1)
        be = zigZagSegment(ge, Ie, ne, oe, pe, -be), Ae === me - 1 && !L.c ? Ie = null : Ie = PolynomialBezier.shapeSegment(L, (Ae + 1) % me), zigZagCorner(ge, L, Ae + 1, ne, oe, pe, be);
      return ge;
    }, ZigZagModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amplitude.v, Ie = Math.max(0, Math.round(this.frequency.v)), Ae = this.pointsType.v;
      if (be !== 0) {
        var rt, st;
        for (oe = 0; oe < pe; oe += 1) {
          if (rt = this.shapes[oe], st = rt.localShapeCollection, !(!rt.shape._mdf && !this._mdf && !L))
            for (st.releaseShapes(), rt.shape._mdf = !0, ne = rt.shape.paths.shapes, ge = rt.shape.paths._length, me = 0; me < ge; me += 1)
              st.addShape(this.processPath(ne[me], be, Ie, Ae));
          rt.shape.paths = rt.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function linearOffset(L, ne, oe) {
      var pe = Math.atan2(ne[0] - L[0], ne[1] - L[1]);
      return [polarOffset(L, pe, oe), polarOffset(ne, pe, oe)];
    }
    function offsetSegment(L, ne) {
      var oe, pe, me, ge, be, Ie, Ae;
      Ae = linearOffset(L.points[0], L.points[1], ne), oe = Ae[0], pe = Ae[1], Ae = linearOffset(L.points[1], L.points[2], ne), me = Ae[0], ge = Ae[1], Ae = linearOffset(L.points[2], L.points[3], ne), be = Ae[0], Ie = Ae[1];
      var rt = lineIntersection(oe, pe, me, ge);
      rt === null && (rt = pe);
      var st = lineIntersection(be, Ie, me, ge);
      return st === null && (st = be), new PolynomialBezier(oe, rt, st, Ie);
    }
    function joinLines(L, ne, oe, pe, me) {
      var ge = ne.points[3], be = oe.points[0];
      if (pe === 3 || pointEqual(ge, be))
        return ge;
      if (pe === 2) {
        var Ie = -ne.tangentAngle(1), Ae = -oe.tangentAngle(0) + Math.PI, rt = lineIntersection(ge, polarOffset(ge, Ie + Math.PI / 2, 100), be, polarOffset(be, Ie + Math.PI / 2, 100)), st = rt ? pointDistance(rt, ge) : pointDistance(ge, be) / 2, dt = polarOffset(ge, Ie, 2 * st * roundCorner);
        return L.setXYAt(dt[0], dt[1], "o", L.length() - 1), dt = polarOffset(be, Ae, 2 * st * roundCorner), L.setTripleAt(be[0], be[1], be[0], be[1], dt[0], dt[1], L.length()), be;
      }
      var ut = pointEqual(ge, ne.points[2]) ? ne.points[0] : ne.points[2], ht = pointEqual(be, oe.points[1]) ? oe.points[3] : oe.points[1], it = lineIntersection(ut, ge, be, ht);
      return it && pointDistance(it, ge) < me ? (L.setTripleAt(it[0], it[1], it[0], it[1], it[0], it[1], L.length()), it) : ge;
    }
    function getIntersection(L, ne) {
      var oe = L.intersections(ne);
      return oe.length && floatEqual(oe[0][0], 1) && oe.shift(), oe.length ? oe[0] : null;
    }
    function pruneSegmentIntersection(L, ne) {
      var oe = L.slice(), pe = ne.slice(), me = getIntersection(L[L.length - 1], ne[0]);
      return me && (oe[L.length - 1] = L[L.length - 1].split(me[0])[0], pe[0] = ne[0].split(me[1])[1]), L.length > 1 && ne.length > 1 && (me = getIntersection(L[0], ne[ne.length - 1]), me) ? [[L[0].split(me[0])[0]], [ne[ne.length - 1].split(me[1])[1]]] : [oe, pe];
    }
    function pruneIntersections(L) {
      for (var ne, oe = 1; oe < L.length; oe += 1)
        ne = pruneSegmentIntersection(L[oe - 1], L[oe]), L[oe - 1] = ne[0], L[oe] = ne[1];
      return L.length > 1 && (ne = pruneSegmentIntersection(L[L.length - 1], L[0]), L[L.length - 1] = ne[0], L[0] = ne[1]), L;
    }
    function offsetSegmentSplit(L, ne) {
      var oe = L.inflectionPoints(), pe, me, ge, be;
      if (oe.length === 0)
        return [offsetSegment(L, ne)];
      if (oe.length === 1 || floatEqual(oe[1], 1))
        return ge = L.split(oe[0]), pe = ge[0], me = ge[1], [offsetSegment(pe, ne), offsetSegment(me, ne)];
      ge = L.split(oe[0]), pe = ge[0];
      var Ie = (oe[1] - oe[0]) / (1 - oe[0]);
      return ge = ge[1].split(Ie), be = ge[0], me = ge[1], [offsetSegment(pe, ne), offsetSegment(be, ne), offsetSegment(me, ne)];
    }
    function OffsetPathModifier() {
    }
    extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(L, ne.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(L, ne.ml, 0, null, this), this.lineJoin = ne.lj, this._isAnimated = this.amount.effectsSequence.length !== 0;
    }, OffsetPathModifier.prototype.processPath = function(L, ne, oe, pe) {
      var me = shapePool.newElement();
      me.c = L.c;
      var ge = L.length();
      L.c || (ge -= 1);
      var be, Ie, Ae, rt = [];
      for (be = 0; be < ge; be += 1)
        Ae = PolynomialBezier.shapeSegment(L, be), rt.push(offsetSegmentSplit(Ae, ne));
      if (!L.c)
        for (be = ge - 1; be >= 0; be -= 1)
          Ae = PolynomialBezier.shapeSegmentInverted(L, be), rt.push(offsetSegmentSplit(Ae, ne));
      rt = pruneIntersections(rt);
      var st = null, dt = null;
      for (be = 0; be < rt.length; be += 1) {
        var ut = rt[be];
        for (dt && (st = joinLines(me, dt, ut[0], oe, pe)), dt = ut[ut.length - 1], Ie = 0; Ie < ut.length; Ie += 1)
          Ae = ut[Ie], st && pointEqual(Ae.points[0], st) ? me.setXYAt(Ae.points[1][0], Ae.points[1][1], "o", me.length() - 1) : me.setTripleAt(Ae.points[0][0], Ae.points[0][1], Ae.points[1][0], Ae.points[1][1], Ae.points[0][0], Ae.points[0][1], me.length()), me.setTripleAt(Ae.points[3][0], Ae.points[3][1], Ae.points[3][0], Ae.points[3][1], Ae.points[2][0], Ae.points[2][1], me.length()), st = Ae.points[3];
      }
      return rt.length && joinLines(me, dt, rt[0][0], oe, pe), me;
    }, OffsetPathModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amount.v, Ie = this.miterLimit.v, Ae = this.lineJoin;
      if (be !== 0) {
        var rt, st;
        for (oe = 0; oe < pe; oe += 1) {
          if (rt = this.shapes[oe], st = rt.localShapeCollection, !(!rt.shape._mdf && !this._mdf && !L))
            for (st.releaseShapes(), rt.shape._mdf = !0, ne = rt.shape.paths.shapes, ge = rt.shape.paths._length, me = 0; me < ge; me += 1)
              st.addShape(this.processPath(ne[me], be, Ae, Ie));
          rt.shape.paths = rt.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function getFontProperties(L) {
      for (var ne = L.fStyle ? L.fStyle.split(" ") : [], oe = "normal", pe = "normal", me = ne.length, ge, be = 0; be < me; be += 1)
        switch (ge = ne[be].toLowerCase(), ge) {
          case "italic":
            pe = "italic";
            break;
          case "bold":
            oe = "700";
            break;
          case "black":
            oe = "900";
            break;
          case "medium":
            oe = "500";
            break;
          case "regular":
          case "normal":
            oe = "400";
            break;
          case "light":
          case "thin":
            oe = "200";
            break;
        }
      return {
        style: pe,
        weight: L.fWeight || oe
      };
    }
    var FontManager = function() {
      var L = 5e3, ne = {
        w: 0,
        size: 0,
        shapes: [],
        data: {
          shapes: []
        }
      }, oe = [];
      oe = oe.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
      var pe = 127988, me = 917631, ge = 917601, be = 917626, Ie = 65039, Ae = 8205, rt = 127462, st = 127487, dt = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
      function ut(wt) {
        var Ft = wt.split(","), yt, Et = Ft.length, Dt = [];
        for (yt = 0; yt < Et; yt += 1)
          Ft[yt] !== "sans-serif" && Ft[yt] !== "monospace" && Dt.push(Ft[yt]);
        return Dt.join(",");
      }
      function ht(wt, Ft) {
        var yt = createTag("span");
        yt.setAttribute("aria-hidden", !0), yt.style.fontFamily = Ft;
        var Et = createTag("span");
        Et.innerText = "giItT1WQy@!-/#", yt.style.position = "absolute", yt.style.left = "-10000px", yt.style.top = "-10000px", yt.style.fontSize = "300px", yt.style.fontVariant = "normal", yt.style.fontStyle = "normal", yt.style.fontWeight = "normal", yt.style.letterSpacing = "0", yt.appendChild(Et), document.body.appendChild(yt);
        var Dt = Et.offsetWidth;
        return Et.style.fontFamily = ut(wt) + ", " + Ft, {
          node: Et,
          w: Dt,
          parent: yt
        };
      }
      function it() {
        var wt, Ft = this.fonts.length, yt, Et, Dt = Ft;
        for (wt = 0; wt < Ft; wt += 1)
          this.fonts[wt].loaded ? Dt -= 1 : this.fonts[wt].fOrigin === "n" || this.fonts[wt].origin === 0 ? this.fonts[wt].loaded = !0 : (yt = this.fonts[wt].monoCase.node, Et = this.fonts[wt].monoCase.w, yt.offsetWidth !== Et ? (Dt -= 1, this.fonts[wt].loaded = !0) : (yt = this.fonts[wt].sansCase.node, Et = this.fonts[wt].sansCase.w, yt.offsetWidth !== Et && (Dt -= 1, this.fonts[wt].loaded = !0)), this.fonts[wt].loaded && (this.fonts[wt].sansCase.parent.parentNode.removeChild(this.fonts[wt].sansCase.parent), this.fonts[wt].monoCase.parent.parentNode.removeChild(this.fonts[wt].monoCase.parent)));
        Dt !== 0 && Date.now() - this.initTime < L ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10);
      }
      function lt(wt, Ft) {
        var yt = document.body && Ft ? "svg" : "canvas", Et, Dt = getFontProperties(wt);
        if (yt === "svg") {
          var Ot = createNS("text");
          Ot.style.fontSize = "100px", Ot.setAttribute("font-family", wt.fFamily), Ot.setAttribute("font-style", Dt.style), Ot.setAttribute("font-weight", Dt.weight), Ot.textContent = "1", wt.fClass ? (Ot.style.fontFamily = "inherit", Ot.setAttribute("class", wt.fClass)) : Ot.style.fontFamily = wt.fFamily, Ft.appendChild(Ot), Et = Ot;
        } else {
          var nr = new OffscreenCanvas(500, 500).getContext("2d");
          nr.font = Dt.style + " " + Dt.weight + " 100px " + wt.fFamily, Et = nr;
        }
        function yr(mr) {
          return yt === "svg" ? (Et.textContent = mr, Et.getComputedTextLength()) : Et.measureText(mr).width;
        }
        return {
          measureText: yr
        };
      }
      function St(wt, Ft) {
        if (!wt) {
          this.isLoaded = !0;
          return;
        }
        if (this.chars) {
          this.isLoaded = !0, this.fonts = wt.list;
          return;
        }
        if (!document.body) {
          this.isLoaded = !0, wt.list.forEach(function(en) {
            en.helper = lt(en), en.cache = {};
          }), this.fonts = wt.list;
          return;
        }
        var yt = wt.list, Et, Dt = yt.length, Ot = Dt;
        for (Et = 0; Et < Dt; Et += 1) {
          var nr = !0, yr, mr;
          if (yt[Et].loaded = !1, yt[Et].monoCase = ht(yt[Et].fFamily, "monospace"), yt[Et].sansCase = ht(yt[Et].fFamily, "sans-serif"), !yt[Et].fPath)
            yt[Et].loaded = !0, Ot -= 1;
          else if (yt[Et].fOrigin === "p" || yt[Et].origin === 3) {
            if (yr = document.querySelectorAll('style[f-forigin="p"][f-family="' + yt[Et].fFamily + '"], style[f-origin="3"][f-family="' + yt[Et].fFamily + '"]'), yr.length > 0 && (nr = !1), nr) {
              var Tr = createTag("style");
              Tr.setAttribute("f-forigin", yt[Et].fOrigin), Tr.setAttribute("f-origin", yt[Et].origin), Tr.setAttribute("f-family", yt[Et].fFamily), Tr.type = "text/css", Tr.innerText = "@font-face {font-family: " + yt[Et].fFamily + "; font-style: normal; src: url('" + yt[Et].fPath + "');}", Ft.appendChild(Tr);
            }
          } else if (yt[Et].fOrigin === "g" || yt[Et].origin === 1) {
            for (yr = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), mr = 0; mr < yr.length; mr += 1)
              yr[mr].href.indexOf(yt[Et].fPath) !== -1 && (nr = !1);
            if (nr) {
              var Nr = createTag("link");
              Nr.setAttribute("f-forigin", yt[Et].fOrigin), Nr.setAttribute("f-origin", yt[Et].origin), Nr.type = "text/css", Nr.rel = "stylesheet", Nr.href = yt[Et].fPath, document.body.appendChild(Nr);
            }
          } else if (yt[Et].fOrigin === "t" || yt[Et].origin === 2) {
            for (yr = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), mr = 0; mr < yr.length; mr += 1)
              yt[Et].fPath === yr[mr].src && (nr = !1);
            if (nr) {
              var cn = createTag("link");
              cn.setAttribute("f-forigin", yt[Et].fOrigin), cn.setAttribute("f-origin", yt[Et].origin), cn.setAttribute("rel", "stylesheet"), cn.setAttribute("href", yt[Et].fPath), Ft.appendChild(cn);
            }
          }
          yt[Et].helper = lt(yt[Et], Ft), yt[Et].cache = {}, this.fonts.push(yt[Et]);
        }
        Ot === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100);
      }
      function ot(wt) {
        if (wt) {
          this.chars || (this.chars = []);
          var Ft, yt = wt.length, Et, Dt = this.chars.length, Ot;
          for (Ft = 0; Ft < yt; Ft += 1) {
            for (Et = 0, Ot = !1; Et < Dt; )
              this.chars[Et].style === wt[Ft].style && this.chars[Et].fFamily === wt[Ft].fFamily && this.chars[Et].ch === wt[Ft].ch && (Ot = !0), Et += 1;
            Ot || (this.chars.push(wt[Ft]), Dt += 1);
          }
        }
      }
      function pt(wt, Ft, yt) {
        for (var Et = 0, Dt = this.chars.length; Et < Dt; ) {
          if (this.chars[Et].ch === wt && this.chars[Et].style === Ft && this.chars[Et].fFamily === yt)
            return this.chars[Et];
          Et += 1;
        }
        return (typeof wt == "string" && wt.charCodeAt(0) !== 13 || !wt) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", wt, Ft, yt)), ne;
      }
      function ft(wt, Ft, yt) {
        var Et = this.getFontByName(Ft), Dt = wt;
        if (!Et.cache[Dt]) {
          var Ot = Et.helper;
          if (wt === " ") {
            var nr = Ot.measureText("|" + wt + "|"), yr = Ot.measureText("||");
            Et.cache[Dt] = (nr - yr) / 100;
          } else
            Et.cache[Dt] = Ot.measureText(wt) / 100;
        }
        return Et.cache[Dt] * yt;
      }
      function vt(wt) {
        for (var Ft = 0, yt = this.fonts.length; Ft < yt; ) {
          if (this.fonts[Ft].fName === wt)
            return this.fonts[Ft];
          Ft += 1;
        }
        return this.fonts[0];
      }
      function xt(wt) {
        var Ft = 0, yt = wt.charCodeAt(0);
        if (yt >= 55296 && yt <= 56319) {
          var Et = wt.charCodeAt(1);
          Et >= 56320 && Et <= 57343 && (Ft = (yt - 55296) * 1024 + Et - 56320 + 65536);
        }
        return Ft;
      }
      function Ct(wt, Ft) {
        var yt = wt.toString(16) + Ft.toString(16);
        return dt.indexOf(yt) !== -1;
      }
      function At(wt) {
        return wt === Ae;
      }
      function kt(wt) {
        return wt === Ie;
      }
      function Vt(wt) {
        var Ft = xt(wt);
        return Ft >= rt && Ft <= st;
      }
      function ir(wt) {
        return Vt(wt.substr(0, 2)) && Vt(wt.substr(2, 2));
      }
      function er(wt) {
        return oe.indexOf(wt) !== -1;
      }
      function Yt(wt, Ft) {
        var yt = xt(wt.substr(Ft, 2));
        if (yt !== pe)
          return !1;
        var Et = 0;
        for (Ft += 2; Et < 5; ) {
          if (yt = xt(wt.substr(Ft, 2)), yt < ge || yt > be)
            return !1;
          Et += 1, Ft += 2;
        }
        return xt(wt.substr(Ft, 2)) === me;
      }
      function Jt() {
        this.isLoaded = !0;
      }
      var rr = function() {
        this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      rr.isModifier = Ct, rr.isZeroWidthJoiner = At, rr.isFlagEmoji = ir, rr.isRegionalCode = Vt, rr.isCombinedCharacter = er, rr.isRegionalFlag = Yt, rr.isVariationSelector = kt, rr.BLACK_FLAG_CODE_POINT = pe;
      var Qt = {
        addChars: ot,
        addFonts: St,
        getCharData: pt,
        getFontByName: vt,
        measureText: ft,
        checkLoadedFonts: it,
        setIsLoaded: Jt
      };
      return rr.prototype = Qt, rr;
    }();
    function SlotManager(L) {
      this.animationData = L;
    }
    SlotManager.prototype.getProp = function(L) {
      return this.animationData.slots && this.animationData.slots[L.sid] ? Object.assign(L, this.animationData.slots[L.sid].p) : L;
    };
    function slotFactory(L) {
      return new SlotManager(L);
    }
    function RenderableElement() {
    }
    RenderableElement.prototype = {
      initRenderable: function() {
        this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [];
      },
      addRenderableComponent: function(ne) {
        this.renderableComponents.indexOf(ne) === -1 && this.renderableComponents.push(ne);
      },
      removeRenderableComponent: function(ne) {
        this.renderableComponents.indexOf(ne) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(ne), 1);
      },
      prepareRenderableFrame: function(ne) {
        this.checkLayerLimits(ne);
      },
      checkTransparency: function() {
        this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show());
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function(ne) {
        this.data.ip - this.data.st <= ne && this.data.op - this.data.st > ne ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide());
      },
      renderRenderable: function() {
        var ne, oe = this.renderableComponents.length;
        for (ne = 0; ne < oe; ne += 1)
          this.renderableComponents[ne].renderFrame(this._isFirstFrame);
      },
      sourceRectAtTime: function() {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100
        };
      },
      getLayerSize: function() {
        return this.data.ty === 5 ? {
          w: this.data.textData.width,
          h: this.data.textData.height
        } : {
          w: this.data.width,
          h: this.data.height
        };
      }
    };
    var getBlendMode = /* @__PURE__ */ function() {
      var L = {
        0: "source-over",
        1: "multiply",
        2: "screen",
        3: "overlay",
        4: "darken",
        5: "lighten",
        6: "color-dodge",
        7: "color-burn",
        8: "hard-light",
        9: "soft-light",
        10: "difference",
        11: "exclusion",
        12: "hue",
        13: "saturation",
        14: "color",
        15: "luminosity"
      };
      return function(ne) {
        return L[ne] || "";
      };
    }();
    function SliderEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function AngleEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function ColorEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 1, 0, oe);
    }
    function PointEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 1, 0, oe);
    }
    function LayerIndexEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function MaskIndexEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function CheckboxEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function NoValueEffect() {
      this.p = {};
    }
    function EffectsManager(L, ne) {
      var oe = L.ef || [];
      this.effectElements = [];
      var pe, me = oe.length, ge;
      for (pe = 0; pe < me; pe += 1)
        ge = new GroupEffect(oe[pe], ne), this.effectElements.push(ge);
    }
    function GroupEffect(L, ne) {
      this.init(L, ne);
    }
    extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(L, ne) {
      this.data = L, this.effectElements = [], this.initDynamicPropertyContainer(ne);
      var oe, pe = this.data.ef.length, me, ge = this.data.ef;
      for (oe = 0; oe < pe; oe += 1) {
        switch (me = null, ge[oe].ty) {
          case 0:
            me = new SliderEffect(ge[oe], ne, this);
            break;
          case 1:
            me = new AngleEffect(ge[oe], ne, this);
            break;
          case 2:
            me = new ColorEffect(ge[oe], ne, this);
            break;
          case 3:
            me = new PointEffect(ge[oe], ne, this);
            break;
          case 4:
          case 7:
            me = new CheckboxEffect(ge[oe], ne, this);
            break;
          case 10:
            me = new LayerIndexEffect(ge[oe], ne, this);
            break;
          case 11:
            me = new MaskIndexEffect(ge[oe], ne, this);
            break;
          case 5:
            me = new EffectsManager(ge[oe], ne);
            break;
          default:
            me = new NoValueEffect(ge[oe]);
            break;
        }
        me && this.effectElements.push(me);
      }
    };
    function BaseElement() {
    }
    BaseElement.prototype = {
      checkMasks: function() {
        if (!this.data.hasMask)
          return !1;
        for (var ne = 0, oe = this.data.masksProperties.length; ne < oe; ) {
          if (this.data.masksProperties[ne].mode !== "n" && this.data.masksProperties[ne].cl !== !1)
            return !0;
          ne += 1;
        }
        return !1;
      },
      initExpressions: function() {
        var ne = getExpressionInterfaces();
        if (ne) {
          var oe = ne("layer"), pe = ne("effects"), me = ne("shape"), ge = ne("text"), be = ne("comp");
          this.layerInterface = oe(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
          var Ie = pe.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(Ie), this.data.ty === 0 || this.data.xt ? this.compInterface = be(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = me(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = ge(this), this.layerInterface.text = this.layerInterface.textInterface);
        }
      },
      setBlendMode: function() {
        var ne = getBlendMode(this.data.bm), oe = this.baseElement || this.layerElement;
        oe.style["mix-blend-mode"] = ne;
      },
      initBaseData: function(ne, oe, pe) {
        this.globalData = oe, this.comp = pe, this.data = ne, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function() {
        return this.type;
      },
      sourceRectAtTime: function() {
      }
    };
    function FrameElement() {
    }
    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function() {
        this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function(ne, oe) {
        var pe, me = this.dynamicProperties.length;
        for (pe = 0; pe < me; pe += 1)
          (oe || this._isParent && this.dynamicProperties[pe].propType === "transform") && (this.dynamicProperties[pe].getValue(), this.dynamicProperties[pe]._mdf && (this.globalData._mdf = !0, this._mdf = !0));
      },
      addDynamicProperty: function(ne) {
        this.dynamicProperties.indexOf(ne) === -1 && this.dynamicProperties.push(ne);
      }
    };
    function FootageElement(L, ne, oe) {
      this.initFrame(), this.initRenderable(), this.assetData = ne.getAssetData(L.refId), this.footageData = ne.imageLoader.getAsset(this.assetData), this.initBaseData(L, ne, oe);
    }
    FootageElement.prototype.prepareFrame = function() {
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
      return null;
    }, FootageElement.prototype.renderFrame = function() {
    }, FootageElement.prototype.destroy = function() {
    }, FootageElement.prototype.initExpressions = function() {
      var L = getExpressionInterfaces();
      if (L) {
        var ne = L("footage");
        this.layerInterface = ne(this);
      }
    }, FootageElement.prototype.getFootageData = function() {
      return this.footageData;
    };
    function AudioElement(L, ne, oe) {
      this.initFrame(), this.initRenderable(), this.assetData = ne.getAssetData(L.refId), this.initBaseData(L, ne, oe), this._isPlaying = !1, this._canPlay = !1;
      var pe = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(pe), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      }, this.lv = PropertyFactory.getProp(this, L.au && L.au.lv ? L.au.lv : {
        k: [100]
      }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function(L) {
      if (this.prepareRenderableFrame(L, !0), this.prepareProperties(L, !0), this.tm._placeholder)
        this._currentTime = L / this.data.sr;
      else {
        var ne = this.tm.v;
        this._currentTime = ne;
      }
      this._volume = this.lv.v[0];
      var oe = this._volume * this._volumeMultiplier;
      this._previousVolume !== oe && (this._previousVolume = oe, this.audio.volume(oe));
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
      this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0));
    }, AudioElement.prototype.show = function() {
    }, AudioElement.prototype.hide = function() {
      this.audio.pause(), this._isPlaying = !1;
    }, AudioElement.prototype.pause = function() {
      this.audio.pause(), this._isPlaying = !1, this._canPlay = !1;
    }, AudioElement.prototype.resume = function() {
      this._canPlay = !0;
    }, AudioElement.prototype.setRate = function(L) {
      this.audio.rate(L);
    }, AudioElement.prototype.volume = function(L) {
      this._volumeMultiplier = L, this._previousVolume = L * this._volume, this.audio.volume(this._previousVolume);
    }, AudioElement.prototype.getBaseElement = function() {
      return null;
    }, AudioElement.prototype.destroy = function() {
    }, AudioElement.prototype.sourceRectAtTime = function() {
    }, AudioElement.prototype.initExpressions = function() {
    };
    function BaseRenderer() {
    }
    BaseRenderer.prototype.checkLayers = function(L) {
      var ne, oe = this.layers.length, pe;
      for (this.completeLayers = !0, ne = oe - 1; ne >= 0; ne -= 1)
        this.elements[ne] || (pe = this.layers[ne], pe.ip - pe.st <= L - this.layers[ne].st && pe.op - pe.st > L - this.layers[ne].st && this.buildItem(ne)), this.completeLayers = this.elements[ne] ? this.completeLayers : !1;
      this.checkPendingElements();
    }, BaseRenderer.prototype.createItem = function(L) {
      switch (L.ty) {
        case 2:
          return this.createImage(L);
        case 0:
          return this.createComp(L);
        case 1:
          return this.createSolid(L);
        case 3:
          return this.createNull(L);
        case 4:
          return this.createShape(L);
        case 5:
          return this.createText(L);
        case 6:
          return this.createAudio(L);
        case 13:
          return this.createCamera(L);
        case 15:
          return this.createFootage(L);
        default:
          return this.createNull(L);
      }
    }, BaseRenderer.prototype.createCamera = function() {
      throw new Error("You're using a 3d camera. Try the html renderer.");
    }, BaseRenderer.prototype.createAudio = function(L) {
      return new AudioElement(L, this.globalData, this);
    }, BaseRenderer.prototype.createFootage = function(L) {
      return new FootageElement(L, this.globalData, this);
    }, BaseRenderer.prototype.buildAllItems = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        this.buildItem(L);
      this.checkPendingElements();
    }, BaseRenderer.prototype.includeLayers = function(L) {
      this.completeLayers = !1;
      var ne, oe = L.length, pe, me = this.layers.length;
      for (ne = 0; ne < oe; ne += 1)
        for (pe = 0; pe < me; ) {
          if (this.layers[pe].id === L[ne].id) {
            this.layers[pe] = L[ne];
            break;
          }
          pe += 1;
        }
    }, BaseRenderer.prototype.setProjectInterface = function(L) {
      this.globalData.projectInterface = L;
    }, BaseRenderer.prototype.initItems = function() {
      this.globalData.progressiveLoad || this.buildAllItems();
    }, BaseRenderer.prototype.buildElementParenting = function(L, ne, oe) {
      for (var pe = this.elements, me = this.layers, ge = 0, be = me.length; ge < be; )
        me[ge].ind == ne && (!pe[ge] || pe[ge] === !0 ? (this.buildItem(ge), this.addPendingElement(L)) : (oe.push(pe[ge]), pe[ge].setAsParent(), me[ge].parent !== void 0 ? this.buildElementParenting(L, me[ge].parent, oe) : L.setHierarchy(oe))), ge += 1;
    }, BaseRenderer.prototype.addPendingElement = function(L) {
      this.pendingElements.push(L);
    }, BaseRenderer.prototype.searchExtraCompositions = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        if (L[ne].xt) {
          var pe = this.createComp(L[ne]);
          pe.initExpressions(), this.globalData.projectInterface.registerComposition(pe);
        }
    }, BaseRenderer.prototype.getElementById = function(L) {
      var ne, oe = this.elements.length;
      for (ne = 0; ne < oe; ne += 1)
        if (this.elements[ne].data.ind === L)
          return this.elements[ne];
      return null;
    }, BaseRenderer.prototype.getElementByPath = function(L) {
      var ne = L.shift(), oe;
      if (typeof ne == "number")
        oe = this.elements[ne];
      else {
        var pe, me = this.elements.length;
        for (pe = 0; pe < me; pe += 1)
          if (this.elements[pe].data.nm === ne) {
            oe = this.elements[pe];
            break;
          }
      }
      return L.length === 0 ? oe : oe.getElementByPath(L);
    }, BaseRenderer.prototype.setupGlobalData = function(L, ne) {
      this.globalData.fontManager = new FontManager(), this.globalData.slotManager = slotFactory(L), this.globalData.fontManager.addChars(L.chars), this.globalData.fontManager.addFonts(L.fonts, ne), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = L.fr, this.globalData.nm = L.nm, this.globalData.compSize = {
        w: L.w,
        h: L.h
      };
    };
    var effectTypes = {
      TRANSFORM_EFFECT: "transformEFfect"
    };
    function TransformElement() {
    }
    TransformElement.prototype = {
      initTransform: function() {
        var ne = new Matrix();
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
            o: 0
          },
          _matMdf: !1,
          _localMatMdf: !1,
          _opMdf: !1,
          mat: ne,
          localMat: ne,
          localOpacity: 1
        }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty;
      },
      renderTransform: function() {
        if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
          var ne, oe = this.finalTransform.mat, pe = 0, me = this.hierarchy.length;
          if (!this.finalTransform._matMdf)
            for (; pe < me; ) {
              if (this.hierarchy[pe].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = !0;
                break;
              }
              pe += 1;
            }
          if (this.finalTransform._matMdf)
            for (ne = this.finalTransform.mProp.v.props, oe.cloneFromProps(ne), pe = 0; pe < me; pe += 1)
              oe.multiply(this.hierarchy[pe].finalTransform.mProp.v);
        }
        this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v);
      },
      renderLocalTransform: function() {
        if (this.localTransforms) {
          var ne = 0, oe = this.localTransforms.length;
          if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            for (; ne < oe; )
              this.localTransforms[ne]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[ne]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), ne += 1;
          if (this.finalTransform._localMatMdf) {
            var pe = this.finalTransform.localMat;
            for (this.localTransforms[0].matrix.clone(pe), ne = 1; ne < oe; ne += 1) {
              var me = this.localTransforms[ne].matrix;
              pe.multiply(me);
            }
            pe.multiply(this.finalTransform.mat);
          }
          if (this.finalTransform._opMdf) {
            var ge = this.finalTransform.localOpacity;
            for (ne = 0; ne < oe; ne += 1)
              ge *= this.localTransforms[ne].opacity * 0.01;
            this.finalTransform.localOpacity = ge;
          }
        }
      },
      searchEffectTransforms: function() {
        if (this.renderableEffectsManager) {
          var ne = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          if (ne.length) {
            this.localTransforms = [], this.finalTransform.localMat = new Matrix();
            var oe = 0, pe = ne.length;
            for (oe = 0; oe < pe; oe += 1)
              this.localTransforms.push(ne[oe]);
          }
        }
      },
      globalToLocal: function(ne) {
        var oe = [];
        oe.push(this.finalTransform);
        for (var pe = !0, me = this.comp; pe; )
          me.finalTransform ? (me.data.hasMask && oe.splice(0, 0, me.finalTransform), me = me.comp) : pe = !1;
        var ge, be = oe.length, Ie;
        for (ge = 0; ge < be; ge += 1)
          Ie = oe[ge].mat.applyToPointArray(0, 0, 0), ne = [ne[0] - Ie[0], ne[1] - Ie[1], 0];
        return ne;
      },
      mHelper: new Matrix()
    };
    function MaskElement(L, ne, oe) {
      this.data = L, this.element = ne, this.globalData = oe, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
      var pe = this.globalData.defs, me, ge = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(ge), this.solidPath = "";
      var be, Ie = this.masksProperties, Ae = 0, rt = [], st, dt, ut = createElementID(), ht, it, lt, St, ot = "clipPath", pt = "clip-path";
      for (me = 0; me < ge; me += 1)
        if ((Ie[me].mode !== "a" && Ie[me].mode !== "n" || Ie[me].inv || Ie[me].o.k !== 100 || Ie[me].o.x) && (ot = "mask", pt = "mask"), (Ie[me].mode === "s" || Ie[me].mode === "i") && Ae === 0 ? (ht = createNS("rect"), ht.setAttribute("fill", "#ffffff"), ht.setAttribute("width", this.element.comp.data.w || 0), ht.setAttribute("height", this.element.comp.data.h || 0), rt.push(ht)) : ht = null, be = createNS("path"), Ie[me].mode === "n")
          this.viewData[me] = {
            op: PropertyFactory.getProp(this.element, Ie[me].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, Ie[me], 3),
            elem: be,
            lastPath: ""
          }, pe.appendChild(be);
        else {
          Ae += 1, be.setAttribute("fill", Ie[me].mode === "s" ? "#000000" : "#ffffff"), be.setAttribute("clip-rule", "nonzero");
          var ft;
          if (Ie[me].x.k !== 0 ? (ot = "mask", pt = "mask", St = PropertyFactory.getProp(this.element, Ie[me].x, 0, null, this.element), ft = createElementID(), it = createNS("filter"), it.setAttribute("id", ft), lt = createNS("feMorphology"), lt.setAttribute("operator", "erode"), lt.setAttribute("in", "SourceGraphic"), lt.setAttribute("radius", "0"), it.appendChild(lt), pe.appendChild(it), be.setAttribute("stroke", Ie[me].mode === "s" ? "#000000" : "#ffffff")) : (lt = null, St = null), this.storedData[me] = {
            elem: be,
            x: St,
            expan: lt,
            lastPath: "",
            lastOperator: "",
            filterId: ft,
            lastRadius: 0
          }, Ie[me].mode === "i") {
            dt = rt.length;
            var vt = createNS("g");
            for (st = 0; st < dt; st += 1)
              vt.appendChild(rt[st]);
            var xt = createNS("mask");
            xt.setAttribute("mask-type", "alpha"), xt.setAttribute("id", ut + "_" + Ae), xt.appendChild(be), pe.appendChild(xt), vt.setAttribute("mask", "url(" + getLocationHref() + "#" + ut + "_" + Ae + ")"), rt.length = 0, rt.push(vt);
          } else
            rt.push(be);
          Ie[me].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[me] = {
            elem: be,
            lastPath: "",
            op: PropertyFactory.getProp(this.element, Ie[me].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, Ie[me], 3),
            invRect: ht
          }, this.viewData[me].prop.k || this.drawPath(Ie[me], this.viewData[me].prop.v, this.viewData[me]);
        }
      for (this.maskElement = createNS(ot), ge = rt.length, me = 0; me < ge; me += 1)
        this.maskElement.appendChild(rt[me]);
      Ae > 0 && (this.maskElement.setAttribute("id", ut), this.element.maskedElement.setAttribute(pt, "url(" + getLocationHref() + "#" + ut + ")"), pe.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this);
    }
    MaskElement.prototype.getMaskProperty = function(L) {
      return this.viewData[L].prop;
    }, MaskElement.prototype.renderFrame = function(L) {
      var ne = this.element.finalTransform.mat, oe, pe = this.masksProperties.length;
      for (oe = 0; oe < pe; oe += 1)
        if ((this.viewData[oe].prop._mdf || L) && this.drawPath(this.masksProperties[oe], this.viewData[oe].prop.v, this.viewData[oe]), (this.viewData[oe].op._mdf || L) && this.viewData[oe].elem.setAttribute("fill-opacity", this.viewData[oe].op.v), this.masksProperties[oe].mode !== "n" && (this.viewData[oe].invRect && (this.element.finalTransform.mProp._mdf || L) && this.viewData[oe].invRect.setAttribute("transform", ne.getInverseMatrix().to2dCSS()), this.storedData[oe].x && (this.storedData[oe].x._mdf || L))) {
          var me = this.storedData[oe].expan;
          this.storedData[oe].x.v < 0 ? (this.storedData[oe].lastOperator !== "erode" && (this.storedData[oe].lastOperator = "erode", this.storedData[oe].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[oe].filterId + ")")), me.setAttribute("radius", -this.storedData[oe].x.v)) : (this.storedData[oe].lastOperator !== "dilate" && (this.storedData[oe].lastOperator = "dilate", this.storedData[oe].elem.setAttribute("filter", null)), this.storedData[oe].elem.setAttribute("stroke-width", this.storedData[oe].x.v * 2));
        }
    }, MaskElement.prototype.getMaskelement = function() {
      return this.maskElement;
    }, MaskElement.prototype.createLayerSolidPath = function() {
      var L = "M0,0 ";
      return L += " h" + this.globalData.compSize.w, L += " v" + this.globalData.compSize.h, L += " h-" + this.globalData.compSize.w, L += " v-" + this.globalData.compSize.h + " ", L;
    }, MaskElement.prototype.drawPath = function(L, ne, oe) {
      var pe = " M" + ne.v[0][0] + "," + ne.v[0][1], me, ge;
      for (ge = ne._length, me = 1; me < ge; me += 1)
        pe += " C" + ne.o[me - 1][0] + "," + ne.o[me - 1][1] + " " + ne.i[me][0] + "," + ne.i[me][1] + " " + ne.v[me][0] + "," + ne.v[me][1];
      if (ne.c && ge > 1 && (pe += " C" + ne.o[me - 1][0] + "," + ne.o[me - 1][1] + " " + ne.i[0][0] + "," + ne.i[0][1] + " " + ne.v[0][0] + "," + ne.v[0][1]), oe.lastPath !== pe) {
        var be = "";
        oe.elem && (ne.c && (be = L.inv ? this.solidPath + pe : pe), oe.elem.setAttribute("d", be)), oe.lastPath = pe;
      }
    }, MaskElement.prototype.destroy = function() {
      this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null;
    };
    var filtersFactory = function() {
      var L = {};
      L.createFilter = ne, L.createAlphaToLuminanceFilter = oe;
      function ne(pe, me) {
        var ge = createNS("filter");
        return ge.setAttribute("id", pe), me !== !0 && (ge.setAttribute("filterUnits", "objectBoundingBox"), ge.setAttribute("x", "0%"), ge.setAttribute("y", "0%"), ge.setAttribute("width", "100%"), ge.setAttribute("height", "100%")), ge;
      }
      function oe() {
        var pe = createNS("feColorMatrix");
        return pe.setAttribute("type", "matrix"), pe.setAttribute("color-interpolation-filters", "sRGB"), pe.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), pe;
      }
      return L;
    }(), featureSupport = function() {
      var L = {
        maskType: !0,
        svgLumaHidden: !0,
        offscreenCanvas: typeof OffscreenCanvas < "u"
      };
      return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (L.maskType = !1), /firefox/i.test(navigator.userAgent) && (L.svgLumaHidden = !1), L;
    }(), registeredEffects$1 = {}, idPrefix = "filter_result_";
    function SVGEffects(L) {
      var ne, oe = "SourceGraphic", pe = L.data.ef ? L.data.ef.length : 0, me = createElementID(), ge = filtersFactory.createFilter(me, !0), be = 0;
      this.filters = [];
      var Ie;
      for (ne = 0; ne < pe; ne += 1) {
        Ie = null;
        var Ae = L.data.ef[ne].ty;
        if (registeredEffects$1[Ae]) {
          var rt = registeredEffects$1[Ae].effect;
          Ie = new rt(ge, L.effectsManager.effectElements[ne], L, idPrefix + be, oe), oe = idPrefix + be, registeredEffects$1[Ae].countsAsEffect && (be += 1);
        }
        Ie && this.filters.push(Ie);
      }
      be && (L.globalData.defs.appendChild(ge), L.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + me + ")")), this.filters.length && L.addRenderableComponent(this);
    }
    SVGEffects.prototype.renderFrame = function(L) {
      var ne, oe = this.filters.length;
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].renderFrame(L);
    }, SVGEffects.prototype.getEffects = function(L) {
      var ne, oe = this.filters.length, pe = [];
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].type === L && pe.push(this.filters[ne]);
      return pe;
    };
    function registerEffect$1(L, ne, oe) {
      registeredEffects$1[L] = {
        effect: ne,
        countsAsEffect: oe
      };
    }
    function SVGBaseElement() {
    }
    SVGBaseElement.prototype = {
      initRendererElement: function() {
        this.layerElement = createNS("g");
      },
      createContainerElements: function() {
        this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
        var ne = null;
        if (this.data.td) {
          this.matteMasks = {};
          var oe = createNS("g");
          oe.setAttribute("id", this.layerId), oe.appendChild(this.layerElement), ne = oe, this.globalData.defs.appendChild(oe);
        } else
          this.data.tt ? (this.matteElement.appendChild(this.layerElement), ne = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
        if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) {
          var pe = createNS("clipPath"), me = createNS("path");
          me.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
          var ge = createElementID();
          if (pe.setAttribute("id", ge), pe.appendChild(me), this.globalData.defs.appendChild(pe), this.checkMasks()) {
            var be = createNS("g");
            be.setAttribute("clip-path", "url(" + getLocationHref() + "#" + ge + ")"), be.appendChild(this.layerElement), this.transformedElement = be, ne ? ne.appendChild(this.transformedElement) : this.baseElement = this.transformedElement;
          } else
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + ge + ")");
        }
        this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
      },
      destroyBaseElement: function() {
        this.layerElement = null, this.matteElement = null, this.maskManager.destroy();
      },
      getBaseElement: function() {
        return this.data.hd ? null : this.baseElement;
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms();
      },
      getMatte: function(ne) {
        if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[ne]) {
          var oe = this.layerId + "_" + ne, pe, me, ge, be;
          if (ne === 1 || ne === 3) {
            var Ie = createNS("mask");
            Ie.setAttribute("id", oe), Ie.setAttribute("mask-type", ne === 3 ? "luminance" : "alpha"), ge = createNS("use"), ge.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), Ie.appendChild(ge), this.globalData.defs.appendChild(Ie), !featureSupport.maskType && ne === 1 && (Ie.setAttribute("mask-type", "luminance"), pe = createElementID(), me = filtersFactory.createFilter(pe), this.globalData.defs.appendChild(me), me.appendChild(filtersFactory.createAlphaToLuminanceFilter()), be = createNS("g"), be.appendChild(ge), Ie.appendChild(be), be.setAttribute("filter", "url(" + getLocationHref() + "#" + pe + ")"));
          } else if (ne === 2) {
            var Ae = createNS("mask");
            Ae.setAttribute("id", oe), Ae.setAttribute("mask-type", "alpha");
            var rt = createNS("g");
            Ae.appendChild(rt), pe = createElementID(), me = filtersFactory.createFilter(pe);
            var st = createNS("feComponentTransfer");
            st.setAttribute("in", "SourceGraphic"), me.appendChild(st);
            var dt = createNS("feFuncA");
            dt.setAttribute("type", "table"), dt.setAttribute("tableValues", "1.0 0.0"), st.appendChild(dt), this.globalData.defs.appendChild(me);
            var ut = createNS("rect");
            ut.setAttribute("width", this.comp.data.w), ut.setAttribute("height", this.comp.data.h), ut.setAttribute("x", "0"), ut.setAttribute("y", "0"), ut.setAttribute("fill", "#ffffff"), ut.setAttribute("opacity", "0"), rt.setAttribute("filter", "url(" + getLocationHref() + "#" + pe + ")"), rt.appendChild(ut), ge = createNS("use"), ge.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), rt.appendChild(ge), featureSupport.maskType || (Ae.setAttribute("mask-type", "luminance"), me.appendChild(filtersFactory.createAlphaToLuminanceFilter()), be = createNS("g"), rt.appendChild(ut), be.appendChild(this.layerElement), rt.appendChild(be)), this.globalData.defs.appendChild(Ae);
          }
          this.matteMasks[ne] = oe;
        }
        return this.matteMasks[ne];
      },
      setMatte: function(ne) {
        this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + ne + ")");
      }
    };
    function HierarchyElement() {
    }
    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function() {
        this.hierarchy = [], this._isParent = !1, this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function(ne) {
        this.hierarchy = ne;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function() {
        this._isParent = !0;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function() {
        this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []);
      }
    };
    function RenderableDOMElement() {
    }
    (function() {
      var L = {
        initElement: function(oe, pe, me) {
          this.initFrame(), this.initBaseData(oe, pe, me), this.initTransform(oe, pe, me), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide();
        },
        hide: function() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var oe = this.baseElement || this.layerElement;
            oe.style.display = "none", this.hidden = !0;
          }
        },
        show: function() {
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var oe = this.baseElement || this.layerElement;
              oe.style.display = "block";
            }
            this.hidden = !1, this._isFirstFrame = !0;
          }
        },
        renderFrame: function() {
          this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
        },
        renderInnerContent: function() {
        },
        prepareFrame: function(oe) {
          this._mdf = !1, this.prepareRenderableFrame(oe), this.prepareProperties(oe, this.isInRange), this.checkTransparency();
        },
        destroy: function() {
          this.innerElem = null, this.destroyBaseElement();
        }
      };
      extendPrototype([RenderableElement, createProxyFunction(L)], RenderableDOMElement);
    })();
    function IImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.assetData && this.assetData.sid && (this.assetData = ne.slotManager.getProp(this.assetData)), this.initElement(L, ne, oe), this.sourceRect = {
        top: 0,
        left: 0,
        width: this.assetData.w,
        height: this.assetData.h
      };
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
      var L = this.globalData.getAssetsPath(this.assetData);
      this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", L), this.layerElement.appendChild(this.innerElem);
    }, IImageElement.prototype.sourceRectAtTime = function() {
      return this.sourceRect;
    };
    function ProcessedElement(L, ne) {
      this.elem = L, this.pos = ne;
    }
    function IShapeElement() {
    }
    IShapeElement.prototype = {
      addShapeToModifiers: function(ne) {
        var oe, pe = this.shapeModifiers.length;
        for (oe = 0; oe < pe; oe += 1)
          this.shapeModifiers[oe].addShape(ne);
      },
      isShapeInAnimatedModifiers: function(ne) {
        for (var oe = 0, pe = this.shapeModifiers.length; oe < pe; )
          if (this.shapeModifiers[oe].isAnimatedWithShape(ne))
            return !0;
        return !1;
      },
      renderModifiers: function() {
        if (this.shapeModifiers.length) {
          var ne, oe = this.shapes.length;
          for (ne = 0; ne < oe; ne += 1)
            this.shapes[ne].sh.reset();
          oe = this.shapeModifiers.length;
          var pe;
          for (ne = oe - 1; ne >= 0 && (pe = this.shapeModifiers[ne].processShapes(this._isFirstFrame), !pe); ne -= 1)
            ;
        }
      },
      searchProcessedElement: function(ne) {
        for (var oe = this.processedElements, pe = 0, me = oe.length; pe < me; ) {
          if (oe[pe].elem === ne)
            return oe[pe].pos;
          pe += 1;
        }
        return 0;
      },
      addProcessedElement: function(ne, oe) {
        for (var pe = this.processedElements, me = pe.length; me; )
          if (me -= 1, pe[me].elem === ne) {
            pe[me].pos = oe;
            return;
          }
        pe.push(new ProcessedElement(ne, oe));
      },
      prepareFrame: function(ne) {
        this.prepareRenderableFrame(ne), this.prepareProperties(ne, this.isInRange);
      }
    };
    var lineCapEnum = {
      1: "butt",
      2: "round",
      3: "square"
    }, lineJoinEnum = {
      1: "miter",
      2: "round",
      3: "bevel"
    };
    function SVGShapeData(L, ne, oe) {
      this.caches = [], this.styles = [], this.transformers = L, this.lStr = "", this.sh = oe, this.lvl = ne, this._isAnimated = !!oe.k;
      for (var pe = 0, me = L.length; pe < me; ) {
        if (L[pe].mProps.dynamicProperties.length) {
          this._isAnimated = !0;
          break;
        }
        pe += 1;
      }
    }
    SVGShapeData.prototype.setAsAnimated = function() {
      this._isAnimated = !0;
    };
    function SVGStyleData(L, ne) {
      this.data = L, this.type = L.ty, this.d = "", this.lvl = ne, this._mdf = !1, this.closed = L.hd === !0, this.pElem = createNS("path"), this.msElem = null;
    }
    SVGStyleData.prototype.reset = function() {
      this.d = "", this._mdf = !1;
    };
    function DashProperty(L, ne, oe, pe) {
      this.elem = L, this.frameId = -1, this.dataProps = createSizedArray(ne.length), this.renderer = oe, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", ne.length ? ne.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(pe);
      var me, ge = ne.length || 0, be;
      for (me = 0; me < ge; me += 1)
        be = PropertyFactory.getProp(L, ne[me].v, 0, 0, this), this.k = be.k || this.k, this.dataProps[me] = {
          n: ne[me].n,
          p: be
        };
      this.k || this.getValue(!0), this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function(L) {
      if (!(this.elem.globalData.frameId === this.frameId && !L) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || L, this._mdf)) {
        var ne = 0, oe = this.dataProps.length;
        for (this.renderer === "svg" && (this.dashStr = ""), ne = 0; ne < oe; ne += 1)
          this.dataProps[ne].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[ne].p.v : this.dashArray[ne] = this.dataProps[ne].p.v : this.dashoffset[0] = this.dataProps[ne].p.v;
      }
    }, extendPrototype([DynamicPropertyContainer], DashProperty);
    function SVGStrokeStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.w = PropertyFactory.getProp(L, ne.w, 0, null, this), this.d = new DashProperty(L, ne.d || {}, "svg", this), this.c = PropertyFactory.getProp(L, ne.c, 1, 255, this), this.style = oe, this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.c = PropertyFactory.getProp(L, ne.c, 1, 255, this), this.style = oe;
    }
    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGNoStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.style = oe;
    }
    extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
    function GradientProperty(L, ne, oe) {
      this.data = ne, this.c = createTypedArray("uint8c", ne.p * 4);
      var pe = ne.k.k[0].s ? ne.k.k[0].s.length - ne.p * 4 : ne.k.k.length - ne.p * 4;
      this.o = createTypedArray("float32", pe), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = pe, this.initDynamicPropertyContainer(oe), this.prop = PropertyFactory.getProp(L, ne.k, 1, null, this), this.k = this.prop.k, this.getValue(!0);
    }
    GradientProperty.prototype.comparePoints = function(L, ne) {
      for (var oe = 0, pe = this.o.length / 2, me; oe < pe; ) {
        if (me = Math.abs(L[oe * 4] - L[ne * 4 + oe * 2]), me > 0.01)
          return !1;
        oe += 1;
      }
      return !0;
    }, GradientProperty.prototype.checkCollapsable = function() {
      if (this.o.length / 2 !== this.c.length / 4)
        return !1;
      if (this.data.k.k[0].s)
        for (var L = 0, ne = this.data.k.k.length; L < ne; ) {
          if (!this.comparePoints(this.data.k.k[L].s, this.data.p))
            return !1;
          L += 1;
        }
      else if (!this.comparePoints(this.data.k.k, this.data.p))
        return !1;
      return !0;
    }, GradientProperty.prototype.getValue = function(L) {
      if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || L) {
        var ne, oe = this.data.p * 4, pe, me;
        for (ne = 0; ne < oe; ne += 1)
          pe = ne % 4 === 0 ? 100 : 255, me = Math.round(this.prop.v[ne] * pe), this.c[ne] !== me && (this.c[ne] = me, this._cmdf = !L);
        if (this.o.length)
          for (oe = this.prop.v.length, ne = this.data.p * 4; ne < oe; ne += 1)
            pe = ne % 2 === 0 ? 100 : 1, me = ne % 2 === 0 ? Math.round(this.prop.v[ne] * 100) : this.prop.v[ne], this.o[ne - this.data.p * 4] !== me && (this.o[ne - this.data.p * 4] = me, this._omdf = !L);
        this._mdf = !L;
      }
    }, extendPrototype([DynamicPropertyContainer], GradientProperty);
    function SVGGradientFillStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.initGradientData(L, ne, oe);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function(L, ne, oe) {
      this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.s = PropertyFactory.getProp(L, ne.s, 1, null, this), this.e = PropertyFactory.getProp(L, ne.e, 1, null, this), this.h = PropertyFactory.getProp(L, ne.h || {
        k: 0
      }, 0, 0.01, this), this.a = PropertyFactory.getProp(L, ne.a || {
        k: 0
      }, 0, degToRads, this), this.g = new GradientProperty(L, ne.g, this), this.style = oe, this.stops = [], this.setGradientData(oe.pElem, ne), this.setGradientOpacity(ne, oe), this._isAnimated = !!this._isAnimated;
    }, SVGGradientFillStyleData.prototype.setGradientData = function(L, ne) {
      var oe = createElementID(), pe = createNS(ne.t === 1 ? "linearGradient" : "radialGradient");
      pe.setAttribute("id", oe), pe.setAttribute("spreadMethod", "pad"), pe.setAttribute("gradientUnits", "userSpaceOnUse");
      var me = [], ge, be, Ie;
      for (Ie = ne.g.p * 4, be = 0; be < Ie; be += 4)
        ge = createNS("stop"), pe.appendChild(ge), me.push(ge);
      L.setAttribute(ne.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + oe + ")"), this.gf = pe, this.cst = me;
    }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(L, ne) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var oe, pe, me, ge = createNS("mask"), be = createNS("path");
        ge.appendChild(be);
        var Ie = createElementID(), Ae = createElementID();
        ge.setAttribute("id", Ae);
        var rt = createNS(L.t === 1 ? "linearGradient" : "radialGradient");
        rt.setAttribute("id", Ie), rt.setAttribute("spreadMethod", "pad"), rt.setAttribute("gradientUnits", "userSpaceOnUse"), me = L.g.k.k[0].s ? L.g.k.k[0].s.length : L.g.k.k.length;
        var st = this.stops;
        for (pe = L.g.p * 4; pe < me; pe += 2)
          oe = createNS("stop"), oe.setAttribute("stop-color", "rgb(255,255,255)"), rt.appendChild(oe), st.push(oe);
        be.setAttribute(L.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + Ie + ")"), L.ty === "gs" && (be.setAttribute("stroke-linecap", lineCapEnum[L.lc || 2]), be.setAttribute("stroke-linejoin", lineJoinEnum[L.lj || 2]), L.lj === 1 && be.setAttribute("stroke-miterlimit", L.ml)), this.of = rt, this.ms = ge, this.ost = st, this.maskId = Ae, ne.msElem = be;
      }
    }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(L, ne.w, 0, null, this), this.d = new DashProperty(L, ne.d || {}, "svg", this), this.initGradientData(L, ne, oe), this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
      this.it = [], this.prevViewData = [], this.gr = createNS("g");
    }
    function SVGTransformData(L, ne, oe) {
      this.transform = {
        mProps: L,
        op: ne,
        container: oe
      }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function(ne, oe, pe, me) {
      if (oe === 0)
        return "";
      var ge = ne.o, be = ne.i, Ie = ne.v, Ae, rt = " M" + me.applyToPointStringified(Ie[0][0], Ie[0][1]);
      for (Ae = 1; Ae < oe; Ae += 1)
        rt += " C" + me.applyToPointStringified(ge[Ae - 1][0], ge[Ae - 1][1]) + " " + me.applyToPointStringified(be[Ae][0], be[Ae][1]) + " " + me.applyToPointStringified(Ie[Ae][0], Ie[Ae][1]);
      return pe && oe && (rt += " C" + me.applyToPointStringified(ge[Ae - 1][0], ge[Ae - 1][1]) + " " + me.applyToPointStringified(be[0][0], be[0][1]) + " " + me.applyToPointStringified(Ie[0][0], Ie[0][1]), rt += "z"), rt;
    }, SVGElementsRenderer = function() {
      var L = new Matrix(), ne = new Matrix(), oe = {
        createRenderFunction: pe
      };
      function pe(dt) {
        switch (dt.ty) {
          case "fl":
            return Ie;
          case "gf":
            return rt;
          case "gs":
            return Ae;
          case "st":
            return st;
          case "sh":
          case "el":
          case "rc":
          case "sr":
            return be;
          case "tr":
            return me;
          case "no":
            return ge;
          default:
            return null;
        }
      }
      function me(dt, ut, ht) {
        (ht || ut.transform.op._mdf) && ut.transform.container.setAttribute("opacity", ut.transform.op.v), (ht || ut.transform.mProps._mdf) && ut.transform.container.setAttribute("transform", ut.transform.mProps.v.to2dCSS());
      }
      function ge() {
      }
      function be(dt, ut, ht) {
        var it, lt, St, ot, pt, ft, vt = ut.styles.length, xt = ut.lvl, Ct, At, kt, Vt;
        for (ft = 0; ft < vt; ft += 1) {
          if (ot = ut.sh._mdf || ht, ut.styles[ft].lvl < xt) {
            for (At = ne.reset(), kt = xt - ut.styles[ft].lvl, Vt = ut.transformers.length - 1; !ot && kt > 0; )
              ot = ut.transformers[Vt].mProps._mdf || ot, kt -= 1, Vt -= 1;
            if (ot)
              for (kt = xt - ut.styles[ft].lvl, Vt = ut.transformers.length - 1; kt > 0; )
                At.multiply(ut.transformers[Vt].mProps.v), kt -= 1, Vt -= 1;
          } else
            At = L;
          if (Ct = ut.sh.paths, lt = Ct._length, ot) {
            for (St = "", it = 0; it < lt; it += 1)
              pt = Ct.shapes[it], pt && pt._length && (St += buildShapeString(pt, pt._length, pt.c, At));
            ut.caches[ft] = St;
          } else
            St = ut.caches[ft];
          ut.styles[ft].d += dt.hd === !0 ? "" : St, ut.styles[ft]._mdf = ot || ut.styles[ft]._mdf;
        }
      }
      function Ie(dt, ut, ht) {
        var it = ut.style;
        (ut.c._mdf || ht) && it.pElem.setAttribute("fill", "rgb(" + bmFloor(ut.c.v[0]) + "," + bmFloor(ut.c.v[1]) + "," + bmFloor(ut.c.v[2]) + ")"), (ut.o._mdf || ht) && it.pElem.setAttribute("fill-opacity", ut.o.v);
      }
      function Ae(dt, ut, ht) {
        rt(dt, ut, ht), st(dt, ut, ht);
      }
      function rt(dt, ut, ht) {
        var it = ut.gf, lt = ut.g._hasOpacity, St = ut.s.v, ot = ut.e.v;
        if (ut.o._mdf || ht) {
          var pt = dt.ty === "gf" ? "fill-opacity" : "stroke-opacity";
          ut.style.pElem.setAttribute(pt, ut.o.v);
        }
        if (ut.s._mdf || ht) {
          var ft = dt.t === 1 ? "x1" : "cx", vt = ft === "x1" ? "y1" : "cy";
          it.setAttribute(ft, St[0]), it.setAttribute(vt, St[1]), lt && !ut.g._collapsable && (ut.of.setAttribute(ft, St[0]), ut.of.setAttribute(vt, St[1]));
        }
        var xt, Ct, At, kt;
        if (ut.g._cmdf || ht) {
          xt = ut.cst;
          var Vt = ut.g.c;
          for (At = xt.length, Ct = 0; Ct < At; Ct += 1)
            kt = xt[Ct], kt.setAttribute("offset", Vt[Ct * 4] + "%"), kt.setAttribute("stop-color", "rgb(" + Vt[Ct * 4 + 1] + "," + Vt[Ct * 4 + 2] + "," + Vt[Ct * 4 + 3] + ")");
        }
        if (lt && (ut.g._omdf || ht)) {
          var ir = ut.g.o;
          for (ut.g._collapsable ? xt = ut.cst : xt = ut.ost, At = xt.length, Ct = 0; Ct < At; Ct += 1)
            kt = xt[Ct], ut.g._collapsable || kt.setAttribute("offset", ir[Ct * 2] + "%"), kt.setAttribute("stop-opacity", ir[Ct * 2 + 1]);
        }
        if (dt.t === 1)
          (ut.e._mdf || ht) && (it.setAttribute("x2", ot[0]), it.setAttribute("y2", ot[1]), lt && !ut.g._collapsable && (ut.of.setAttribute("x2", ot[0]), ut.of.setAttribute("y2", ot[1])));
        else {
          var er;
          if ((ut.s._mdf || ut.e._mdf || ht) && (er = Math.sqrt(Math.pow(St[0] - ot[0], 2) + Math.pow(St[1] - ot[1], 2)), it.setAttribute("r", er), lt && !ut.g._collapsable && ut.of.setAttribute("r", er)), ut.e._mdf || ut.h._mdf || ut.a._mdf || ht) {
            er || (er = Math.sqrt(Math.pow(St[0] - ot[0], 2) + Math.pow(St[1] - ot[1], 2)));
            var Yt = Math.atan2(ot[1] - St[1], ot[0] - St[0]), Jt = ut.h.v;
            Jt >= 1 ? Jt = 0.99 : Jt <= -1 && (Jt = -0.99);
            var rr = er * Jt, Qt = Math.cos(Yt + ut.a.v) * rr + St[0], wt = Math.sin(Yt + ut.a.v) * rr + St[1];
            it.setAttribute("fx", Qt), it.setAttribute("fy", wt), lt && !ut.g._collapsable && (ut.of.setAttribute("fx", Qt), ut.of.setAttribute("fy", wt));
          }
        }
      }
      function st(dt, ut, ht) {
        var it = ut.style, lt = ut.d;
        lt && (lt._mdf || ht) && lt.dashStr && (it.pElem.setAttribute("stroke-dasharray", lt.dashStr), it.pElem.setAttribute("stroke-dashoffset", lt.dashoffset[0])), ut.c && (ut.c._mdf || ht) && it.pElem.setAttribute("stroke", "rgb(" + bmFloor(ut.c.v[0]) + "," + bmFloor(ut.c.v[1]) + "," + bmFloor(ut.c.v[2]) + ")"), (ut.o._mdf || ht) && it.pElem.setAttribute("stroke-opacity", ut.o.v), (ut.w._mdf || ht) && (it.pElem.setAttribute("stroke-width", ut.w.v), it.msElem && it.msElem.setAttribute("stroke-width", ut.w.v));
      }
      return oe;
    }();
    function SVGShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(L, ne, oe), this.prevViewData = [];
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {
    }, SVGShapeElement.prototype.identityMatrix = new Matrix(), SVGShapeElement.prototype.buildExpressionInterface = function() {
    }, SVGShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes();
    }, SVGShapeElement.prototype.filterUniqueShapes = function() {
      var L, ne = this.shapes.length, oe, pe, me = this.stylesList.length, ge, be = [], Ie = !1;
      for (pe = 0; pe < me; pe += 1) {
        for (ge = this.stylesList[pe], Ie = !1, be.length = 0, L = 0; L < ne; L += 1)
          oe = this.shapes[L], oe.styles.indexOf(ge) !== -1 && (be.push(oe), Ie = oe._isAnimated || Ie);
        be.length > 1 && Ie && this.setShapesAsAnimated(be);
      }
    }, SVGShapeElement.prototype.setShapesAsAnimated = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne].setAsAnimated();
    }, SVGShapeElement.prototype.createStyleElement = function(L, ne) {
      var oe, pe = new SVGStyleData(L, ne), me = pe.pElem;
      if (L.ty === "st")
        oe = new SVGStrokeStyleData(this, L, pe);
      else if (L.ty === "fl")
        oe = new SVGFillStyleData(this, L, pe);
      else if (L.ty === "gf" || L.ty === "gs") {
        var ge = L.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        oe = new ge(this, L, pe), this.globalData.defs.appendChild(oe.gf), oe.maskId && (this.globalData.defs.appendChild(oe.ms), this.globalData.defs.appendChild(oe.of), me.setAttribute("mask", "url(" + getLocationHref() + "#" + oe.maskId + ")"));
      } else
        L.ty === "no" && (oe = new SVGNoStyleData(this, L, pe));
      return (L.ty === "st" || L.ty === "gs") && (me.setAttribute("stroke-linecap", lineCapEnum[L.lc || 2]), me.setAttribute("stroke-linejoin", lineJoinEnum[L.lj || 2]), me.setAttribute("fill-opacity", "0"), L.lj === 1 && me.setAttribute("stroke-miterlimit", L.ml)), L.r === 2 && me.setAttribute("fill-rule", "evenodd"), L.ln && me.setAttribute("id", L.ln), L.cl && me.setAttribute("class", L.cl), L.bm && (me.style["mix-blend-mode"] = getBlendMode(L.bm)), this.stylesList.push(pe), this.addToAnimatedContents(L, oe), oe;
    }, SVGShapeElement.prototype.createGroupElement = function(L) {
      var ne = new ShapeGroupData();
      return L.ln && ne.gr.setAttribute("id", L.ln), L.cl && ne.gr.setAttribute("class", L.cl), L.bm && (ne.gr.style["mix-blend-mode"] = getBlendMode(L.bm)), ne;
    }, SVGShapeElement.prototype.createTransformElement = function(L, ne) {
      var oe = TransformPropertyFactory.getTransformProperty(this, L, this), pe = new SVGTransformData(oe, oe.o, ne);
      return this.addToAnimatedContents(L, pe), pe;
    }, SVGShapeElement.prototype.createShapeElement = function(L, ne, oe) {
      var pe = 4;
      L.ty === "rc" ? pe = 5 : L.ty === "el" ? pe = 6 : L.ty === "sr" && (pe = 7);
      var me = ShapePropertyFactory.getShapeProp(this, L, pe, this), ge = new SVGShapeData(ne, oe, me);
      return this.shapes.push(ge), this.addShapeToModifiers(ge), this.addToAnimatedContents(L, ge), ge;
    }, SVGShapeElement.prototype.addToAnimatedContents = function(L, ne) {
      for (var oe = 0, pe = this.animatedContents.length; oe < pe; ) {
        if (this.animatedContents[oe].element === ne)
          return;
        oe += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(L),
        element: ne,
        data: L
      });
    }, SVGShapeElement.prototype.setElementStyles = function(L) {
      var ne = L.styles, oe, pe = this.stylesList.length;
      for (oe = 0; oe < pe; oe += 1)
        this.stylesList[oe].closed || ne.push(this.stylesList[oe]);
    }, SVGShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var L, ne = this.itemsData.length;
      for (L = 0; L < ne; L += 1)
        this.prevViewData[L] = this.itemsData[L];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), ne = this.dynamicProperties.length, L = 0; L < ne; L += 1)
        this.dynamicProperties[L].getValue();
      this.renderModifiers();
    }, SVGShapeElement.prototype.searchShapes = function(L, ne, oe, pe, me, ge, be) {
      var Ie = [].concat(ge), Ae, rt = L.length - 1, st, dt, ut = [], ht = [], it, lt, St;
      for (Ae = rt; Ae >= 0; Ae -= 1) {
        if (St = this.searchProcessedElement(L[Ae]), St ? ne[Ae] = oe[St - 1] : L[Ae]._render = be, L[Ae].ty === "fl" || L[Ae].ty === "st" || L[Ae].ty === "gf" || L[Ae].ty === "gs" || L[Ae].ty === "no")
          St ? ne[Ae].style.closed = !1 : ne[Ae] = this.createStyleElement(L[Ae], me), L[Ae]._render && ne[Ae].style.pElem.parentNode !== pe && pe.appendChild(ne[Ae].style.pElem), ut.push(ne[Ae].style);
        else if (L[Ae].ty === "gr") {
          if (!St)
            ne[Ae] = this.createGroupElement(L[Ae]);
          else
            for (dt = ne[Ae].it.length, st = 0; st < dt; st += 1)
              ne[Ae].prevViewData[st] = ne[Ae].it[st];
          this.searchShapes(L[Ae].it, ne[Ae].it, ne[Ae].prevViewData, ne[Ae].gr, me + 1, Ie, be), L[Ae]._render && ne[Ae].gr.parentNode !== pe && pe.appendChild(ne[Ae].gr);
        } else
          L[Ae].ty === "tr" ? (St || (ne[Ae] = this.createTransformElement(L[Ae], pe)), it = ne[Ae].transform, Ie.push(it)) : L[Ae].ty === "sh" || L[Ae].ty === "rc" || L[Ae].ty === "el" || L[Ae].ty === "sr" ? (St || (ne[Ae] = this.createShapeElement(L[Ae], Ie, me)), this.setElementStyles(ne[Ae])) : L[Ae].ty === "tm" || L[Ae].ty === "rd" || L[Ae].ty === "ms" || L[Ae].ty === "pb" || L[Ae].ty === "zz" || L[Ae].ty === "op" ? (St ? (lt = ne[Ae], lt.closed = !1) : (lt = ShapeModifiers.getModifier(L[Ae].ty), lt.init(this, L[Ae]), ne[Ae] = lt, this.shapeModifiers.push(lt)), ht.push(lt)) : L[Ae].ty === "rp" && (St ? (lt = ne[Ae], lt.closed = !0) : (lt = ShapeModifiers.getModifier(L[Ae].ty), ne[Ae] = lt, lt.init(this, L, Ae, ne), this.shapeModifiers.push(lt), be = !1), ht.push(lt));
        this.addProcessedElement(L[Ae], Ae + 1);
      }
      for (rt = ut.length, Ae = 0; Ae < rt; Ae += 1)
        ut[Ae].closed = !0;
      for (rt = ht.length, Ae = 0; Ae < rt; Ae += 1)
        ht[Ae].closed = !0;
    }, SVGShapeElement.prototype.renderInnerContent = function() {
      this.renderModifiers();
      var L, ne = this.stylesList.length;
      for (L = 0; L < ne; L += 1)
        this.stylesList[L].reset();
      for (this.renderShape(), L = 0; L < ne; L += 1)
        (this.stylesList[L]._mdf || this._isFirstFrame) && (this.stylesList[L].msElem && (this.stylesList[L].msElem.setAttribute("d", this.stylesList[L].d), this.stylesList[L].d = "M0 0" + this.stylesList[L].d), this.stylesList[L].pElem.setAttribute("d", this.stylesList[L].d || "M0 0"));
    }, SVGShapeElement.prototype.renderShape = function() {
      var L, ne = this.animatedContents.length, oe;
      for (L = 0; L < ne; L += 1)
        oe = this.animatedContents[L], (this._isFirstFrame || oe.element._isAnimated) && oe.data !== !0 && oe.fn(oe.data, oe.element, this._isFirstFrame);
    }, SVGShapeElement.prototype.destroy = function() {
      this.destroyBaseElement(), this.shapesData = null, this.itemsData = null;
    };
    function LetterProps(L, ne, oe, pe, me, ge) {
      this.o = L, this.sw = ne, this.sc = oe, this.fc = pe, this.m = me, this.p = ge, this._mdf = {
        o: !0,
        sw: !!ne,
        sc: !!oe,
        fc: !!pe,
        m: !0,
        p: !0
      };
    }
    LetterProps.prototype.update = function(L, ne, oe, pe, me, ge) {
      this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
      var be = !1;
      return this.o !== L && (this.o = L, this._mdf.o = !0, be = !0), this.sw !== ne && (this.sw = ne, this._mdf.sw = !0, be = !0), this.sc !== oe && (this.sc = oe, this._mdf.sc = !0, be = !0), this.fc !== pe && (this.fc = pe, this._mdf.fc = !0, be = !0), this.m !== me && (this.m = me, this._mdf.m = !0, be = !0), ge.length && (this.p[0] !== ge[0] || this.p[1] !== ge[1] || this.p[4] !== ge[4] || this.p[5] !== ge[5] || this.p[12] !== ge[12] || this.p[13] !== ge[13]) && (this.p = ge, this._mdf.p = !0, be = !0), be;
    };
    function TextProperty(L, ne) {
      this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, ne.d && ne.d.sid && (ne.d = L.globalData.slotManager.getProp(ne.d)), this.data = ne, this.elem = L, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: "",
        fStyle: "",
        fWeight: "",
        fc: "",
        j: "",
        justifyOffset: "",
        l: [],
        lh: 0,
        lineWidths: [],
        ls: "",
        of: "",
        s: "",
        sc: "",
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: !1,
        strokeColorAnim: !1,
        strokeWidthAnim: !1,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: !1
      }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData);
    }
    TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(L, ne) {
      for (var oe in ne)
        Object.prototype.hasOwnProperty.call(ne, oe) && (L[oe] = ne[oe]);
      return L;
    }, TextProperty.prototype.setCurrentData = function(L) {
      L.__complete || this.completeTextData(L), this.currentData = L, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0;
    }, TextProperty.prototype.searchProperty = function() {
      return this.searchKeyframes();
    }, TextProperty.prototype.searchKeyframes = function() {
      return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf;
    }, TextProperty.prototype.addEffect = function(L) {
      this.effectsSequence.push(L), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.getValue = function(L) {
      if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !L)) {
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var ne = this.currentData, oe = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = !0, this._mdf = !1;
        var pe, me = this.effectsSequence.length, ge = L || this.data.d.k[this.keysIndex].s;
        for (pe = 0; pe < me; pe += 1)
          oe !== this.keysIndex ? ge = this.effectsSequence[pe](ge, ge.t) : ge = this.effectsSequence[pe](this.currentData, ge.t);
        ne !== ge && this.setCurrentData(ge), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }, TextProperty.prototype.getKeyframeValue = function() {
      for (var L = this.data.d.k, ne = this.elem.comp.renderedFrame, oe = 0, pe = L.length; oe <= pe - 1 && !(oe === pe - 1 || L[oe + 1].t > ne); )
        oe += 1;
      return this.keysIndex !== oe && (this.keysIndex = oe), this.data.d.k[this.keysIndex].s;
    }, TextProperty.prototype.buildFinalText = function(L) {
      for (var ne = [], oe = 0, pe = L.length, me, ge, be = !1, Ie = !1, Ae = ""; oe < pe; )
        be = Ie, Ie = !1, me = L.charCodeAt(oe), Ae = L.charAt(oe), FontManager.isCombinedCharacter(me) ? be = !0 : me >= 55296 && me <= 56319 ? FontManager.isRegionalFlag(L, oe) ? Ae = L.substr(oe, 14) : (ge = L.charCodeAt(oe + 1), ge >= 56320 && ge <= 57343 && (FontManager.isModifier(me, ge) ? (Ae = L.substr(oe, 2), be = !0) : FontManager.isFlagEmoji(L.substr(oe, 4)) ? Ae = L.substr(oe, 4) : Ae = L.substr(oe, 2))) : me > 56319 ? (ge = L.charCodeAt(oe + 1), FontManager.isVariationSelector(me) && (be = !0)) : FontManager.isZeroWidthJoiner(me) && (be = !0, Ie = !0), be ? (ne[ne.length - 1] += Ae, be = !1) : ne.push(Ae), oe += Ae.length;
      return ne;
    }, TextProperty.prototype.completeTextData = function(L) {
      L.__complete = !0;
      var ne = this.elem.globalData.fontManager, oe = this.data, pe = [], me, ge, be, Ie = 0, Ae, rt = oe.m.g, st = 0, dt = 0, ut = 0, ht = [], it = 0, lt = 0, St, ot, pt = ne.getFontByName(L.f), ft, vt = 0, xt = getFontProperties(pt);
      L.fWeight = xt.weight, L.fStyle = xt.style, L.finalSize = L.s, L.finalText = this.buildFinalText(L.t), ge = L.finalText.length, L.finalLineHeight = L.lh;
      var Ct = L.tr / 1e3 * L.finalSize, At;
      if (L.sz)
        for (var kt = !0, Vt = L.sz[0], ir = L.sz[1], er, Yt; kt; ) {
          Yt = this.buildFinalText(L.t), er = 0, it = 0, ge = Yt.length, Ct = L.tr / 1e3 * L.finalSize;
          var Jt = -1;
          for (me = 0; me < ge; me += 1)
            At = Yt[me].charCodeAt(0), be = !1, Yt[me] === " " ? Jt = me : (At === 13 || At === 3) && (it = 0, be = !0, er += L.finalLineHeight || L.finalSize * 1.2), ne.chars ? (ft = ne.getCharData(Yt[me], pt.fStyle, pt.fFamily), vt = be ? 0 : ft.w * L.finalSize / 100) : vt = ne.measureText(Yt[me], L.f, L.finalSize), it + vt > Vt && Yt[me] !== " " ? (Jt === -1 ? ge += 1 : me = Jt, er += L.finalLineHeight || L.finalSize * 1.2, Yt.splice(me, Jt === me ? 1 : 0, "\r"), Jt = -1, it = 0) : (it += vt, it += Ct);
          er += pt.ascent * L.finalSize / 100, this.canResize && L.finalSize > this.minimumFontSize && ir < er ? (L.finalSize -= 1, L.finalLineHeight = L.finalSize * L.lh / L.s) : (L.finalText = Yt, ge = L.finalText.length, kt = !1);
        }
      it = -Ct, vt = 0;
      var rr = 0, Qt;
      for (me = 0; me < ge; me += 1)
        if (be = !1, Qt = L.finalText[me], At = Qt.charCodeAt(0), At === 13 || At === 3 ? (rr = 0, ht.push(it), lt = it > lt ? it : lt, it = -2 * Ct, Ae = "", be = !0, ut += 1) : Ae = Qt, ne.chars ? (ft = ne.getCharData(Qt, pt.fStyle, ne.getFontByName(L.f).fFamily), vt = be ? 0 : ft.w * L.finalSize / 100) : vt = ne.measureText(Ae, L.f, L.finalSize), Qt === " " ? rr += vt + Ct : (it += vt + Ct + rr, rr = 0), pe.push({
          l: vt,
          an: vt,
          add: st,
          n: be,
          anIndexes: [],
          val: Ae,
          line: ut,
          animatorJustifyOffset: 0
        }), rt == 2) {
          if (st += vt, Ae === "" || Ae === " " || me === ge - 1) {
            for ((Ae === "" || Ae === " ") && (st -= vt); dt <= me; )
              pe[dt].an = st, pe[dt].ind = Ie, pe[dt].extra = vt, dt += 1;
            Ie += 1, st = 0;
          }
        } else if (rt == 3) {
          if (st += vt, Ae === "" || me === ge - 1) {
            for (Ae === "" && (st -= vt); dt <= me; )
              pe[dt].an = st, pe[dt].ind = Ie, pe[dt].extra = vt, dt += 1;
            st = 0, Ie += 1;
          }
        } else
          pe[Ie].ind = Ie, pe[Ie].extra = 0, Ie += 1;
      if (L.l = pe, lt = it > lt ? it : lt, ht.push(it), L.sz)
        L.boxWidth = L.sz[0], L.justifyOffset = 0;
      else
        switch (L.boxWidth = lt, L.j) {
          case 1:
            L.justifyOffset = -L.boxWidth;
            break;
          case 2:
            L.justifyOffset = -L.boxWidth / 2;
            break;
          default:
            L.justifyOffset = 0;
        }
      L.lineWidths = ht;
      var wt = oe.a, Ft, yt;
      ot = wt.length;
      var Et, Dt, Ot = [];
      for (St = 0; St < ot; St += 1) {
        for (Ft = wt[St], Ft.a.sc && (L.strokeColorAnim = !0), Ft.a.sw && (L.strokeWidthAnim = !0), (Ft.a.fc || Ft.a.fh || Ft.a.fs || Ft.a.fb) && (L.fillColorAnim = !0), Dt = 0, Et = Ft.s.b, me = 0; me < ge; me += 1)
          yt = pe[me], yt.anIndexes[St] = Dt, (Et == 1 && yt.val !== "" || Et == 2 && yt.val !== "" && yt.val !== " " || Et == 3 && (yt.n || yt.val == " " || me == ge - 1) || Et == 4 && (yt.n || me == ge - 1)) && (Ft.s.rn === 1 && Ot.push(Dt), Dt += 1);
        oe.a[St].s.totalChars = Dt;
        var nr = -1, yr;
        if (Ft.s.rn === 1)
          for (me = 0; me < ge; me += 1)
            yt = pe[me], nr != yt.anIndexes[St] && (nr = yt.anIndexes[St], yr = Ot.splice(Math.floor(Math.random() * Ot.length), 1)[0]), yt.anIndexes[St] = yr;
      }
      L.yOffset = L.finalLineHeight || L.finalSize * 1.2, L.ls = L.ls || 0, L.ascent = pt.ascent * L.finalSize / 100;
    }, TextProperty.prototype.updateDocumentData = function(L, ne) {
      ne = ne === void 0 ? this.keysIndex : ne;
      var oe = this.copyData({}, this.data.d.k[ne].s);
      oe = this.copyData(oe, L), this.data.d.k[ne].s = oe, this.recalculate(ne), this.setCurrentData(oe), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.recalculate = function(L) {
      var ne = this.data.d.k[L].s;
      ne.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(ne);
    }, TextProperty.prototype.canResizeFont = function(L) {
      this.canResize = L, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.setMinimumFontSize = function(L) {
      this.minimumFontSize = Math.floor(L) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function() {
      var L = Math.max, ne = Math.min, oe = Math.floor;
      function pe(ge, be) {
        this._currentTextLength = -1, this.k = !1, this.data = be, this.elem = ge, this.comp = ge.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(ge), this.s = PropertyFactory.getProp(ge, be.s || {
          k: 0
        }, 0, 0, this), "e" in be ? this.e = PropertyFactory.getProp(ge, be.e, 0, 0, this) : this.e = {
          v: 100
        }, this.o = PropertyFactory.getProp(ge, be.o || {
          k: 0
        }, 0, 0, this), this.xe = PropertyFactory.getProp(ge, be.xe || {
          k: 0
        }, 0, 0, this), this.ne = PropertyFactory.getProp(ge, be.ne || {
          k: 0
        }, 0, 0, this), this.sm = PropertyFactory.getProp(ge, be.sm || {
          k: 100
        }, 0, 0, this), this.a = PropertyFactory.getProp(ge, be.a, 0, 0.01, this), this.dynamicProperties.length || this.getValue();
      }
      pe.prototype = {
        getMult: function(be) {
          this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
          var Ie = 0, Ae = 0, rt = 1, st = 1;
          this.ne.v > 0 ? Ie = this.ne.v / 100 : Ae = -this.ne.v / 100, this.xe.v > 0 ? rt = 1 - this.xe.v / 100 : st = 1 + this.xe.v / 100;
          var dt = BezierFactory.getBezierEasing(Ie, Ae, rt, st).get, ut = 0, ht = this.finalS, it = this.finalE, lt = this.data.sh;
          if (lt === 2)
            it === ht ? ut = be >= it ? 1 : 0 : ut = L(0, ne(0.5 / (it - ht) + (be - ht) / (it - ht), 1)), ut = dt(ut);
          else if (lt === 3)
            it === ht ? ut = be >= it ? 0 : 1 : ut = 1 - L(0, ne(0.5 / (it - ht) + (be - ht) / (it - ht), 1)), ut = dt(ut);
          else if (lt === 4)
            it === ht ? ut = 0 : (ut = L(0, ne(0.5 / (it - ht) + (be - ht) / (it - ht), 1)), ut < 0.5 ? ut *= 2 : ut = 1 - 2 * (ut - 0.5)), ut = dt(ut);
          else if (lt === 5) {
            if (it === ht)
              ut = 0;
            else {
              var St = it - ht;
              be = ne(L(0, be + 0.5 - ht), it - ht);
              var ot = -St / 2 + be, pt = St / 2;
              ut = Math.sqrt(1 - ot * ot / (pt * pt));
            }
            ut = dt(ut);
          } else
            lt === 6 ? (it === ht ? ut = 0 : (be = ne(L(0, be + 0.5 - ht), it - ht), ut = (1 + Math.cos(Math.PI + Math.PI * 2 * be / (it - ht))) / 2), ut = dt(ut)) : (be >= oe(ht) && (be - ht < 0 ? ut = L(0, ne(ne(it, 1) - (ht - be), 1)) : ut = L(0, ne(it - be, 1))), ut = dt(ut));
          if (this.sm.v !== 100) {
            var ft = this.sm.v * 0.01;
            ft === 0 && (ft = 1e-8);
            var vt = 0.5 - ft * 0.5;
            ut < vt ? ut = 0 : (ut = (ut - vt) / ft, ut > 1 && (ut = 1));
          }
          return ut * this.a.v;
        },
        getValue: function(be) {
          this.iterateDynamicProperties(), this._mdf = be || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, be && this.data.r === 2 && (this.e.v = this._currentTextLength);
          var Ie = this.data.r === 2 ? 1 : 100 / this.data.totalChars, Ae = this.o.v / Ie, rt = this.s.v / Ie + Ae, st = this.e.v / Ie + Ae;
          if (rt > st) {
            var dt = rt;
            rt = st, st = dt;
          }
          this.finalS = rt, this.finalE = st;
        }
      }, extendPrototype([DynamicPropertyContainer], pe);
      function me(ge, be, Ie) {
        return new pe(ge, be);
      }
      return {
        getTextSelectorProp: me
      };
    }();
    function TextAnimatorDataProperty(L, ne, oe) {
      var pe = {
        propType: !1
      }, me = PropertyFactory.getProp, ge = ne.a;
      this.a = {
        r: ge.r ? me(L, ge.r, 0, degToRads, oe) : pe,
        rx: ge.rx ? me(L, ge.rx, 0, degToRads, oe) : pe,
        ry: ge.ry ? me(L, ge.ry, 0, degToRads, oe) : pe,
        sk: ge.sk ? me(L, ge.sk, 0, degToRads, oe) : pe,
        sa: ge.sa ? me(L, ge.sa, 0, degToRads, oe) : pe,
        s: ge.s ? me(L, ge.s, 1, 0.01, oe) : pe,
        a: ge.a ? me(L, ge.a, 1, 0, oe) : pe,
        o: ge.o ? me(L, ge.o, 0, 0.01, oe) : pe,
        p: ge.p ? me(L, ge.p, 1, 0, oe) : pe,
        sw: ge.sw ? me(L, ge.sw, 0, 0, oe) : pe,
        sc: ge.sc ? me(L, ge.sc, 1, 0, oe) : pe,
        fc: ge.fc ? me(L, ge.fc, 1, 0, oe) : pe,
        fh: ge.fh ? me(L, ge.fh, 0, 0, oe) : pe,
        fs: ge.fs ? me(L, ge.fs, 0, 0.01, oe) : pe,
        fb: ge.fb ? me(L, ge.fb, 0, 0.01, oe) : pe,
        t: ge.t ? me(L, ge.t, 0, 0, oe) : pe
      }, this.s = TextSelectorProp.getTextSelectorProp(L, ne.s, oe), this.s.t = ne.s.t;
    }
    function TextAnimatorProperty(L, ne, oe) {
      this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = L, this._renderType = ne, this._elem = oe, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
        alignment: {}
      }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(oe);
    }
    TextAnimatorProperty.prototype.searchProperties = function() {
      var L, ne = this._textData.a.length, oe, pe = PropertyFactory.getProp;
      for (L = 0; L < ne; L += 1)
        oe = this._textData.a[L], this._animatorsData[L] = new TextAnimatorDataProperty(this._elem, oe, this);
      this._textData.p && "m" in this._textData.p ? (this._pathData = {
        a: pe(this._elem, this._textData.p.a, 0, 0, this),
        f: pe(this._elem, this._textData.p.f, 0, 0, this),
        l: pe(this._elem, this._textData.p.l, 0, 0, this),
        r: pe(this._elem, this._textData.p.r, 0, 0, this),
        p: pe(this._elem, this._textData.p.p, 0, 0, this),
        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
      }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = pe(this._elem, this._textData.m.a, 1, 0, this);
    }, TextAnimatorProperty.prototype.getMeasures = function(L, ne) {
      if (this.lettersChangedFlag = ne, !(!this._mdf && !this._isFirstFrame && !ne && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
        this._isFirstFrame = !1;
        var oe = this._moreOptions.alignment.v, pe = this._animatorsData, me = this._textData, ge = this.mHelper, be = this._renderType, Ie = this.renderedLetters.length, Ae, rt, st, dt, ut = L.l, ht, it, lt, St, ot, pt, ft, vt, xt, Ct, At, kt, Vt, ir, er;
        if (this._hasMaskedPath) {
          if (er = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
            var Yt = er.v;
            this._pathData.r.v && (Yt = Yt.reverse()), ht = {
              tLength: 0,
              segments: []
            }, dt = Yt._length - 1;
            var Jt;
            for (kt = 0, st = 0; st < dt; st += 1)
              Jt = bez.buildBezierData(Yt.v[st], Yt.v[st + 1], [Yt.o[st][0] - Yt.v[st][0], Yt.o[st][1] - Yt.v[st][1]], [Yt.i[st + 1][0] - Yt.v[st + 1][0], Yt.i[st + 1][1] - Yt.v[st + 1][1]]), ht.tLength += Jt.segmentLength, ht.segments.push(Jt), kt += Jt.segmentLength;
            st = dt, er.v.c && (Jt = bez.buildBezierData(Yt.v[st], Yt.v[0], [Yt.o[st][0] - Yt.v[st][0], Yt.o[st][1] - Yt.v[st][1]], [Yt.i[0][0] - Yt.v[0][0], Yt.i[0][1] - Yt.v[0][1]]), ht.tLength += Jt.segmentLength, ht.segments.push(Jt), kt += Jt.segmentLength), this._pathData.pi = ht;
          }
          if (ht = this._pathData.pi, it = this._pathData.f.v, ft = 0, pt = 1, St = 0, ot = !0, Ct = ht.segments, it < 0 && er.v.c)
            for (ht.tLength < Math.abs(it) && (it = -Math.abs(it) % ht.tLength), ft = Ct.length - 1, xt = Ct[ft].points, pt = xt.length - 1; it < 0; )
              it += xt[pt].partialLength, pt -= 1, pt < 0 && (ft -= 1, xt = Ct[ft].points, pt = xt.length - 1);
          xt = Ct[ft].points, vt = xt[pt - 1], lt = xt[pt], At = lt.partialLength;
        }
        dt = ut.length, Ae = 0, rt = 0;
        var rr = L.finalSize * 1.2 * 0.714, Qt = !0, wt, Ft, yt, Et, Dt;
        Et = pe.length;
        var Ot, nr = -1, yr, mr, Tr, Nr = it, cn = ft, en = pt, Tn = -1, Mn, $r, tn, kr, dr, zn, Kn, Fn, Jn = "", ki = this.defaultPropsArray, Ei;
        if (L.j === 2 || L.j === 1) {
          var Dn = 0, Mi = 0, Zn = L.j === 2 ? -0.5 : -1, ei = 0, fi = !0;
          for (st = 0; st < dt; st += 1)
            if (ut[st].n) {
              for (Dn && (Dn += Mi); ei < st; )
                ut[ei].animatorJustifyOffset = Dn, ei += 1;
              Dn = 0, fi = !0;
            } else {
              for (yt = 0; yt < Et; yt += 1)
                wt = pe[yt].a, wt.t.propType && (fi && L.j === 2 && (Mi += wt.t.v * Zn), Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? Dn += wt.t.v * Ot[0] * Zn : Dn += wt.t.v * Ot * Zn);
              fi = !1;
            }
          for (Dn && (Dn += Mi); ei < st; )
            ut[ei].animatorJustifyOffset = Dn, ei += 1;
        }
        for (st = 0; st < dt; st += 1) {
          if (ge.reset(), Mn = 1, ut[st].n)
            Ae = 0, rt += L.yOffset, rt += Qt ? 1 : 0, it = Nr, Qt = !1, this._hasMaskedPath && (ft = cn, pt = en, xt = Ct[ft].points, vt = xt[pt - 1], lt = xt[pt], At = lt.partialLength, St = 0), Jn = "", Fn = "", zn = "", Ei = "", ki = this.defaultPropsArray;
          else {
            if (this._hasMaskedPath) {
              if (Tn !== ut[st].line) {
                switch (L.j) {
                  case 1:
                    it += kt - L.lineWidths[ut[st].line];
                    break;
                  case 2:
                    it += (kt - L.lineWidths[ut[st].line]) / 2;
                    break;
                }
                Tn = ut[st].line;
              }
              nr !== ut[st].ind && (ut[nr] && (it += ut[nr].extra), it += ut[st].an / 2, nr = ut[st].ind), it += oe[0] * ut[st].an * 5e-3;
              var ti = 0;
              for (yt = 0; yt < Et; yt += 1)
                wt = pe[yt].a, wt.p.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ti += wt.p.v[0] * Ot[0] : ti += wt.p.v[0] * Ot), wt.a.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ti += wt.a.v[0] * Ot[0] : ti += wt.a.v[0] * Ot);
              for (ot = !0, this._pathData.a.v && (it = ut[0].an * 0.5 + (kt - this._pathData.f.v - ut[0].an * 0.5 - ut[ut.length - 1].an * 0.5) * nr / (dt - 1), it += this._pathData.f.v); ot; )
                St + At >= it + ti || !xt ? (Vt = (it + ti - St) / lt.partialLength, mr = vt.point[0] + (lt.point[0] - vt.point[0]) * Vt, Tr = vt.point[1] + (lt.point[1] - vt.point[1]) * Vt, ge.translate(-oe[0] * ut[st].an * 5e-3, -(oe[1] * rr) * 0.01), ot = !1) : xt && (St += lt.partialLength, pt += 1, pt >= xt.length && (pt = 0, ft += 1, Ct[ft] ? xt = Ct[ft].points : er.v.c ? (pt = 0, ft = 0, xt = Ct[ft].points) : (St -= lt.partialLength, xt = null)), xt && (vt = lt, lt = xt[pt], At = lt.partialLength));
              yr = ut[st].an / 2 - ut[st].add, ge.translate(-yr, 0, 0);
            } else
              yr = ut[st].an / 2 - ut[st].add, ge.translate(-yr, 0, 0), ge.translate(-oe[0] * ut[st].an * 5e-3, -oe[1] * rr * 0.01, 0);
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.t.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), (Ae !== 0 || L.j !== 0) && (this._hasMaskedPath ? Ot.length ? it += wt.t.v * Ot[0] : it += wt.t.v * Ot : Ot.length ? Ae += wt.t.v * Ot[0] : Ae += wt.t.v * Ot));
            for (L.strokeWidthAnim && (tn = L.sw || 0), L.strokeColorAnim && (L.sc ? $r = [L.sc[0], L.sc[1], L.sc[2]] : $r = [0, 0, 0]), L.fillColorAnim && L.fc && (kr = [L.fc[0], L.fc[1], L.fc[2]]), yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.a.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ge.translate(-wt.a.v[0] * Ot[0], -wt.a.v[1] * Ot[1], wt.a.v[2] * Ot[2]) : ge.translate(-wt.a.v[0] * Ot, -wt.a.v[1] * Ot, wt.a.v[2] * Ot));
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.s.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ge.scale(1 + (wt.s.v[0] - 1) * Ot[0], 1 + (wt.s.v[1] - 1) * Ot[1], 1) : ge.scale(1 + (wt.s.v[0] - 1) * Ot, 1 + (wt.s.v[1] - 1) * Ot, 1));
            for (yt = 0; yt < Et; yt += 1) {
              if (wt = pe[yt].a, Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), wt.sk.propType && (Ot.length ? ge.skewFromAxis(-wt.sk.v * Ot[0], wt.sa.v * Ot[1]) : ge.skewFromAxis(-wt.sk.v * Ot, wt.sa.v * Ot)), wt.r.propType && (Ot.length ? ge.rotateZ(-wt.r.v * Ot[2]) : ge.rotateZ(-wt.r.v * Ot)), wt.ry.propType && (Ot.length ? ge.rotateY(wt.ry.v * Ot[1]) : ge.rotateY(wt.ry.v * Ot)), wt.rx.propType && (Ot.length ? ge.rotateX(wt.rx.v * Ot[0]) : ge.rotateX(wt.rx.v * Ot)), wt.o.propType && (Ot.length ? Mn += (wt.o.v * Ot[0] - Mn) * Ot[0] : Mn += (wt.o.v * Ot - Mn) * Ot), L.strokeWidthAnim && wt.sw.propType && (Ot.length ? tn += wt.sw.v * Ot[0] : tn += wt.sw.v * Ot), L.strokeColorAnim && wt.sc.propType)
                for (dr = 0; dr < 3; dr += 1)
                  Ot.length ? $r[dr] += (wt.sc.v[dr] - $r[dr]) * Ot[0] : $r[dr] += (wt.sc.v[dr] - $r[dr]) * Ot;
              if (L.fillColorAnim && L.fc) {
                if (wt.fc.propType)
                  for (dr = 0; dr < 3; dr += 1)
                    Ot.length ? kr[dr] += (wt.fc.v[dr] - kr[dr]) * Ot[0] : kr[dr] += (wt.fc.v[dr] - kr[dr]) * Ot;
                wt.fh.propType && (Ot.length ? kr = addHueToRGB(kr, wt.fh.v * Ot[0]) : kr = addHueToRGB(kr, wt.fh.v * Ot)), wt.fs.propType && (Ot.length ? kr = addSaturationToRGB(kr, wt.fs.v * Ot[0]) : kr = addSaturationToRGB(kr, wt.fs.v * Ot)), wt.fb.propType && (Ot.length ? kr = addBrightnessToRGB(kr, wt.fb.v * Ot[0]) : kr = addBrightnessToRGB(kr, wt.fb.v * Ot));
              }
            }
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.p.propType && (Ft = pe[yt].s, Ot = Ft.getMult(ut[st].anIndexes[yt], me.a[yt].s.totalChars), this._hasMaskedPath ? Ot.length ? ge.translate(0, wt.p.v[1] * Ot[0], -wt.p.v[2] * Ot[1]) : ge.translate(0, wt.p.v[1] * Ot, -wt.p.v[2] * Ot) : Ot.length ? ge.translate(wt.p.v[0] * Ot[0], wt.p.v[1] * Ot[1], -wt.p.v[2] * Ot[2]) : ge.translate(wt.p.v[0] * Ot, wt.p.v[1] * Ot, -wt.p.v[2] * Ot));
            if (L.strokeWidthAnim && (zn = tn < 0 ? 0 : tn), L.strokeColorAnim && (Kn = "rgb(" + Math.round($r[0] * 255) + "," + Math.round($r[1] * 255) + "," + Math.round($r[2] * 255) + ")"), L.fillColorAnim && L.fc && (Fn = "rgb(" + Math.round(kr[0] * 255) + "," + Math.round(kr[1] * 255) + "," + Math.round(kr[2] * 255) + ")"), this._hasMaskedPath) {
              if (ge.translate(0, -L.ls), ge.translate(0, oe[1] * rr * 0.01 + rt, 0), this._pathData.p.v) {
                ir = (lt.point[1] - vt.point[1]) / (lt.point[0] - vt.point[0]);
                var wn = Math.atan(ir) * 180 / Math.PI;
                lt.point[0] < vt.point[0] && (wn += 180), ge.rotate(-wn * Math.PI / 180);
              }
              ge.translate(mr, Tr, 0), it -= oe[0] * ut[st].an * 5e-3, ut[st + 1] && nr !== ut[st + 1].ind && (it += ut[st].an / 2, it += L.tr * 1e-3 * L.finalSize);
            } else {
              switch (ge.translate(Ae, rt, 0), L.ps && ge.translate(L.ps[0], L.ps[1] + L.ascent, 0), L.j) {
                case 1:
                  ge.translate(ut[st].animatorJustifyOffset + L.justifyOffset + (L.boxWidth - L.lineWidths[ut[st].line]), 0, 0);
                  break;
                case 2:
                  ge.translate(ut[st].animatorJustifyOffset + L.justifyOffset + (L.boxWidth - L.lineWidths[ut[st].line]) / 2, 0, 0);
                  break;
              }
              ge.translate(0, -L.ls), ge.translate(yr, 0, 0), ge.translate(oe[0] * ut[st].an * 5e-3, oe[1] * rr * 0.01, 0), Ae += ut[st].l + L.tr * 1e-3 * L.finalSize;
            }
            be === "html" ? Jn = ge.toCSS() : be === "svg" ? Jn = ge.to2dCSS() : ki = [ge.props[0], ge.props[1], ge.props[2], ge.props[3], ge.props[4], ge.props[5], ge.props[6], ge.props[7], ge.props[8], ge.props[9], ge.props[10], ge.props[11], ge.props[12], ge.props[13], ge.props[14], ge.props[15]], Ei = Mn;
          }
          Ie <= st ? (Dt = new LetterProps(Ei, zn, Kn, Fn, Jn, ki), this.renderedLetters.push(Dt), Ie += 1, this.lettersChangedFlag = !0) : (Dt = this.renderedLetters[st], this.lettersChangedFlag = Dt.update(Ei, zn, Kn, Fn, Jn, ki) || this.lettersChangedFlag);
        }
      }
    }, TextAnimatorProperty.prototype.getValue = function() {
      this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties());
    }, TextAnimatorProperty.prototype.mHelper = new Matrix(), TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function ITextElement() {
    }
    ITextElement.prototype.initElement = function(L, ne, oe) {
      this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(L, ne, oe), this.textProperty = new TextProperty(this, L.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(L.t, this.renderType, this), this.initTransform(L, ne, oe), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties);
    }, ITextElement.prototype.prepareFrame = function(L) {
      this._mdf = !1, this.prepareRenderableFrame(L), this.prepareProperties(L, this.isInRange);
    }, ITextElement.prototype.createPathShape = function(L, ne) {
      var oe, pe = ne.length, me, ge = "";
      for (oe = 0; oe < pe; oe += 1)
        ne[oe].ty === "sh" && (me = ne[oe].ks.k, ge += buildShapeString(me, me.i.length, !0, L));
      return ge;
    }, ITextElement.prototype.updateDocumentData = function(L, ne) {
      this.textProperty.updateDocumentData(L, ne);
    }, ITextElement.prototype.canResizeFont = function(L) {
      this.textProperty.canResizeFont(L);
    }, ITextElement.prototype.setMinimumFontSize = function(L) {
      this.textProperty.setMinimumFontSize(L);
    }, ITextElement.prototype.applyTextPropertiesToMatrix = function(L, ne, oe, pe, me) {
      switch (L.ps && ne.translate(L.ps[0], L.ps[1] + L.ascent, 0), ne.translate(0, -L.ls, 0), L.j) {
        case 1:
          ne.translate(L.justifyOffset + (L.boxWidth - L.lineWidths[oe]), 0, 0);
          break;
        case 2:
          ne.translate(L.justifyOffset + (L.boxWidth - L.lineWidths[oe]) / 2, 0, 0);
          break;
      }
      ne.translate(pe, me, 0);
    }, ITextElement.prototype.buildColor = function(L) {
      return "rgb(" + Math.round(L[0] * 255) + "," + Math.round(L[1] * 255) + "," + Math.round(L[2] * 255) + ")";
    }, ITextElement.prototype.emptyProp = new LetterProps(), ITextElement.prototype.destroy = function() {
    }, ITextElement.prototype.validateText = function() {
      (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1);
    };
    var emptyShapeData = {
      shapes: []
    };
    function SVGTextLottieElement(L, ne, oe) {
      this.textSpans = [], this.renderType = "svg", this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
      this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"));
    }, SVGTextLottieElement.prototype.buildTextContents = function(L) {
      for (var ne = 0, oe = L.length, pe = [], me = ""; ne < oe; )
        L[ne] === "\r" || L[ne] === "" ? (pe.push(me), me = "") : me += L[ne], ne += 1;
      return pe.push(me), pe;
    }, SVGTextLottieElement.prototype.buildShapeData = function(L, ne) {
      if (L.shapes && L.shapes.length) {
        var oe = L.shapes[0];
        if (oe.it) {
          var pe = oe.it[oe.it.length - 1];
          pe.s && (pe.s.k[0] = ne, pe.s.k[1] = ne);
        }
      }
      return L;
    }, SVGTextLottieElement.prototype.buildNewText = function() {
      this.addDynamicProperty(this);
      var L, ne, oe = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(oe ? oe.l.length : 0), oe.fc ? this.layerElement.setAttribute("fill", this.buildColor(oe.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), oe.sc && (this.layerElement.setAttribute("stroke", this.buildColor(oe.sc)), this.layerElement.setAttribute("stroke-width", oe.sw)), this.layerElement.setAttribute("font-size", oe.finalSize);
      var pe = this.globalData.fontManager.getFontByName(oe.f);
      if (pe.fClass)
        this.layerElement.setAttribute("class", pe.fClass);
      else {
        this.layerElement.setAttribute("font-family", pe.fFamily);
        var me = oe.fWeight, ge = oe.fStyle;
        this.layerElement.setAttribute("font-style", ge), this.layerElement.setAttribute("font-weight", me);
      }
      this.layerElement.setAttribute("aria-label", oe.t);
      var be = oe.l || [], Ie = !!this.globalData.fontManager.chars;
      ne = be.length;
      var Ae, rt = this.mHelper, st = "", dt = this.data.singleShape, ut = 0, ht = 0, it = !0, lt = oe.tr * 1e-3 * oe.finalSize;
      if (dt && !Ie && !oe.sz) {
        var St = this.textContainer, ot = "start";
        switch (oe.j) {
          case 1:
            ot = "end";
            break;
          case 2:
            ot = "middle";
            break;
          default:
            ot = "start";
            break;
        }
        St.setAttribute("text-anchor", ot), St.setAttribute("letter-spacing", lt);
        var pt = this.buildTextContents(oe.finalText);
        for (ne = pt.length, ht = oe.ps ? oe.ps[1] + oe.ascent : 0, L = 0; L < ne; L += 1)
          Ae = this.textSpans[L].span || createNS("tspan"), Ae.textContent = pt[L], Ae.setAttribute("x", 0), Ae.setAttribute("y", ht), Ae.style.display = "inherit", St.appendChild(Ae), this.textSpans[L] || (this.textSpans[L] = {
            span: null,
            glyph: null
          }), this.textSpans[L].span = Ae, ht += oe.finalLineHeight;
        this.layerElement.appendChild(St);
      } else {
        var ft = this.textSpans.length, vt;
        for (L = 0; L < ne; L += 1) {
          if (this.textSpans[L] || (this.textSpans[L] = {
            span: null,
            childSpan: null,
            glyph: null
          }), !Ie || !dt || L === 0) {
            if (Ae = ft > L ? this.textSpans[L].span : createNS(Ie ? "g" : "text"), ft <= L) {
              if (Ae.setAttribute("stroke-linecap", "butt"), Ae.setAttribute("stroke-linejoin", "round"), Ae.setAttribute("stroke-miterlimit", "4"), this.textSpans[L].span = Ae, Ie) {
                var xt = createNS("g");
                Ae.appendChild(xt), this.textSpans[L].childSpan = xt;
              }
              this.textSpans[L].span = Ae, this.layerElement.appendChild(Ae);
            }
            Ae.style.display = "inherit";
          }
          if (rt.reset(), dt && (be[L].n && (ut = -lt, ht += oe.yOffset, ht += it ? 1 : 0, it = !1), this.applyTextPropertiesToMatrix(oe, rt, be[L].line, ut, ht), ut += be[L].l || 0, ut += lt), Ie) {
            vt = this.globalData.fontManager.getCharData(oe.finalText[L], pe.fStyle, this.globalData.fontManager.getFontByName(oe.f).fFamily);
            var Ct;
            if (vt.t === 1)
              Ct = new SVGCompElement(vt.data, this.globalData, this);
            else {
              var At = emptyShapeData;
              vt.data && vt.data.shapes && (At = this.buildShapeData(vt.data, oe.finalSize)), Ct = new SVGShapeElement(At, this.globalData, this);
            }
            if (this.textSpans[L].glyph) {
              var kt = this.textSpans[L].glyph;
              this.textSpans[L].childSpan.removeChild(kt.layerElement), kt.destroy();
            }
            this.textSpans[L].glyph = Ct, Ct._debug = !0, Ct.prepareFrame(0), Ct.renderFrame(), this.textSpans[L].childSpan.appendChild(Ct.layerElement), vt.t === 1 && this.textSpans[L].childSpan.setAttribute("transform", "scale(" + oe.finalSize / 100 + "," + oe.finalSize / 100 + ")");
          } else
            dt && Ae.setAttribute("transform", "translate(" + rt.props[12] + "," + rt.props[13] + ")"), Ae.textContent = be[L].val, Ae.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        }
        dt && Ae && Ae.setAttribute("d", st);
      }
      for (; L < this.textSpans.length; )
        this.textSpans[L].span.style.display = "none", L += 1;
      this._sizeChanged = !0;
    }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
      if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
        this._sizeChanged = !1;
        var L = this.layerElement.getBBox();
        this.bbox = {
          top: L.y,
          left: L.x,
          width: L.width,
          height: L.height
        };
      }
      return this.bbox;
    }, SVGTextLottieElement.prototype.getValue = function() {
      var L, ne = this.textSpans.length, oe;
      for (this.renderedFrame = this.comp.renderedFrame, L = 0; L < ne; L += 1)
        oe = this.textSpans[L].glyph, oe && (oe.prepareFrame(this.comp.renderedFrame - this.data.st), oe._mdf && (this._mdf = !0));
    }, SVGTextLottieElement.prototype.renderInnerContent = function() {
      if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
        this._sizeChanged = !0;
        var L, ne, oe = this.textAnimator.renderedLetters, pe = this.textProperty.currentData.l;
        ne = pe.length;
        var me, ge, be;
        for (L = 0; L < ne; L += 1)
          pe[L].n || (me = oe[L], ge = this.textSpans[L].span, be = this.textSpans[L].glyph, be && be.renderFrame(), me._mdf.m && ge.setAttribute("transform", me.m), me._mdf.o && ge.setAttribute("opacity", me.o), me._mdf.sw && ge.setAttribute("stroke-width", me.sw), me._mdf.sc && ge.setAttribute("stroke", me.sc), me._mdf.fc && ge.setAttribute("fill", me.fc));
      }
    };
    function ISolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
      var L = createNS("rect");
      L.setAttribute("width", this.data.sw), L.setAttribute("height", this.data.sh), L.setAttribute("fill", this.data.sc), this.layerElement.appendChild(L);
    };
    function NullElement(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initFrame(), this.initTransform(L, ne, oe), this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function(L) {
      this.prepareProperties(L, !0);
    }, NullElement.prototype.renderFrame = function() {
    }, NullElement.prototype.getBaseElement = function() {
      return null;
    }, NullElement.prototype.destroy = function() {
    }, NullElement.prototype.sourceRectAtTime = function() {
    }, NullElement.prototype.hide = function() {
    }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
    function SVGRendererBase() {
    }
    extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function(L) {
      return new NullElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createShape = function(L) {
      return new SVGShapeElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createText = function(L) {
      return new SVGTextLottieElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createImage = function(L) {
      return new IImageElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createSolid = function(L) {
      return new ISolidElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.configAnimation = function(L) {
      this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + L.w + " " + L.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", L.w), this.svgElement.setAttribute("height", L.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
      var ne = this.globalData.defs;
      this.setupGlobalData(L, ne), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = L;
      var oe = createNS("clipPath"), pe = createNS("rect");
      pe.setAttribute("width", L.w), pe.setAttribute("height", L.h), pe.setAttribute("x", 0), pe.setAttribute("y", 0);
      var me = createElementID();
      oe.setAttribute("id", me), oe.appendChild(pe), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + me + ")"), ne.appendChild(oe), this.layers = L.layers, this.elements = createSizedArray(L.layers.length);
    }, SVGRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, SVGRendererBase.prototype.updateContainerSize = function() {
    }, SVGRendererBase.prototype.findIndexByInd = function(L) {
      var ne = 0, oe = this.layers.length;
      for (ne = 0; ne < oe; ne += 1)
        if (this.layers[ne].ind === L)
          return ne;
      return -1;
    }, SVGRendererBase.prototype.buildItem = function(L) {
      var ne = this.elements;
      if (!(ne[L] || this.layers[L].ty === 99)) {
        ne[L] = !0;
        var oe = this.createItem(this.layers[L]);
        if (ne[L] = oe, getExpressionsPlugin() && (this.layers[L].ty === 0 && this.globalData.projectInterface.registerComposition(oe), oe.initExpressions()), this.appendElementInPos(oe, L), this.layers[L].tt) {
          var pe = "tp" in this.layers[L] ? this.findIndexByInd(this.layers[L].tp) : L - 1;
          if (pe === -1)
            return;
          if (!this.elements[pe] || this.elements[pe] === !0)
            this.buildItem(pe), this.addPendingElement(oe);
          else {
            var me = ne[pe], ge = me.getMatte(this.layers[L].tt);
            oe.setMatte(ge);
          }
        }
      }
    }, SVGRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        if (L.checkParenting(), L.data.tt)
          for (var ne = 0, oe = this.elements.length; ne < oe; ) {
            if (this.elements[ne] === L) {
              var pe = "tp" in L.data ? this.findIndexByInd(L.data.tp) : ne - 1, me = this.elements[pe], ge = me.getMatte(this.layers[ne].tt);
              L.setMatte(ge);
              break;
            }
            ne += 1;
          }
      }
    }, SVGRendererBase.prototype.renderFrame = function(L) {
      if (!(this.renderedFrame === L || this.destroyed)) {
        L === null ? L = this.renderedFrame : this.renderedFrame = L, this.globalData.frameNum = L, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = L, this.globalData._mdf = !1;
        var ne, oe = this.layers.length;
        for (this.completeLayers || this.checkLayers(L), ne = oe - 1; ne >= 0; ne -= 1)
          (this.completeLayers || this.elements[ne]) && this.elements[ne].prepareFrame(L - this.layers[ne].st);
        if (this.globalData._mdf)
          for (ne = 0; ne < oe; ne += 1)
            (this.completeLayers || this.elements[ne]) && this.elements[ne].renderFrame();
      }
    }, SVGRendererBase.prototype.appendElementInPos = function(L, ne) {
      var oe = L.getBaseElement();
      if (oe) {
        for (var pe = 0, me; pe < ne; )
          this.elements[pe] && this.elements[pe] !== !0 && this.elements[pe].getBaseElement() && (me = this.elements[pe].getBaseElement()), pe += 1;
        me ? this.layerElement.insertBefore(oe, me) : this.layerElement.appendChild(oe);
      }
    }, SVGRendererBase.prototype.hide = function() {
      this.layerElement.style.display = "none";
    }, SVGRendererBase.prototype.show = function() {
      this.layerElement.style.display = "block";
    };
    function ICompElement() {
    }
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initTransform(L, ne, oe), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !ne.progressiveLoad) && this.buildAllItems(), this.hide();
    }, ICompElement.prototype.prepareFrame = function(L) {
      if (this._mdf = !1, this.prepareRenderableFrame(L), this.prepareProperties(L, this.isInRange), !(!this.isInRange && !this.data.xt)) {
        if (this.tm._placeholder)
          this.renderedFrame = L / this.data.sr;
        else {
          var ne = this.tm.v;
          ne === this.data.op && (ne = this.data.op - 1), this.renderedFrame = ne;
        }
        var oe, pe = this.elements.length;
        for (this.completeLayers || this.checkLayers(this.renderedFrame), oe = pe - 1; oe >= 0; oe -= 1)
          (this.completeLayers || this.elements[oe]) && (this.elements[oe].prepareFrame(this.renderedFrame - this.layers[oe].st), this.elements[oe]._mdf && (this._mdf = !0));
      }
    }, ICompElement.prototype.renderInnerContent = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        (this.completeLayers || this.elements[L]) && this.elements[L].renderFrame();
    }, ICompElement.prototype.setElements = function(L) {
      this.elements = L;
    }, ICompElement.prototype.getElements = function() {
      return this.elements;
    }, ICompElement.prototype.destroyElements = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy();
    }, ICompElement.prototype.destroy = function() {
      this.destroyElements(), this.destroyBaseElement();
    };
    function SVGCompElement(L, ne, oe) {
      this.layers = L.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function(L) {
      return new SVGCompElement(L, this.globalData, this);
    };
    function SVGRenderer(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
      var oe = "";
      if (ne && ne.title) {
        var pe = createNS("title"), me = createElementID();
        pe.setAttribute("id", me), pe.textContent = ne.title, this.svgElement.appendChild(pe), oe += me;
      }
      if (ne && ne.description) {
        var ge = createNS("desc"), be = createElementID();
        ge.setAttribute("id", be), ge.textContent = ne.description, this.svgElement.appendChild(ge), oe += " " + be;
      }
      oe && this.svgElement.setAttribute("aria-labelledby", oe);
      var Ie = createNS("defs");
      this.svgElement.appendChild(Ie);
      var Ae = createNS("g");
      this.svgElement.appendChild(Ae), this.layerElement = Ae, this.renderConfig = {
        preserveAspectRatio: ne && ne.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: ne && ne.contentVisibility || "visible",
        progressiveLoad: ne && ne.progressiveLoad || !1,
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        viewBoxOnly: ne && ne.viewBoxOnly || !1,
        viewBoxSize: ne && ne.viewBoxSize || !1,
        className: ne && ne.className || "",
        id: ne && ne.id || "",
        focusable: ne && ne.focusable,
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "100%",
          height: ne && ne.filterSize && ne.filterSize.height || "100%",
          x: ne && ne.filterSize && ne.filterSize.x || "0%",
          y: ne && ne.filterSize && ne.filterSize.y || "0%"
        },
        width: ne && ne.width,
        height: ne && ne.height,
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        defs: Ie,
        renderConfig: this.renderConfig
      }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg";
    }
    extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function(L) {
      return new SVGCompElement(L, this.globalData, this);
    };
    function ShapeTransformManager() {
      this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
      addTransformSequence: function(ne) {
        var oe, pe = ne.length, me = "_";
        for (oe = 0; oe < pe; oe += 1)
          me += ne[oe].transform.key + "_";
        var ge = this.sequences[me];
        return ge || (ge = {
          transforms: [].concat(ne),
          finalTransform: new Matrix(),
          _mdf: !1
        }, this.sequences[me] = ge, this.sequenceList.push(ge)), ge;
      },
      processSequence: function(ne, oe) {
        for (var pe = 0, me = ne.transforms.length, ge = oe; pe < me && !oe; ) {
          if (ne.transforms[pe].transform.mProps._mdf) {
            ge = !0;
            break;
          }
          pe += 1;
        }
        if (ge)
          for (ne.finalTransform.reset(), pe = me - 1; pe >= 0; pe -= 1)
            ne.finalTransform.multiply(ne.transforms[pe].transform.mProps.v);
        ne._mdf = ge;
      },
      processSequences: function(ne) {
        var oe, pe = this.sequenceList.length;
        for (oe = 0; oe < pe; oe += 1)
          this.processSequence(this.sequenceList[oe], ne);
      },
      getNewKey: function() {
        return this.transform_key_count += 1, "_" + this.transform_key_count;
      }
    };
    var lumaLoader = function() {
      var ne = "__lottie_element_luma_buffer", oe = null, pe = null, me = null;
      function ge() {
        var Ae = createNS("svg"), rt = createNS("filter"), st = createNS("feColorMatrix");
        return rt.setAttribute("id", ne), st.setAttribute("type", "matrix"), st.setAttribute("color-interpolation-filters", "sRGB"), st.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), rt.appendChild(st), Ae.appendChild(rt), Ae.setAttribute("id", ne + "_svg"), featureSupport.svgLumaHidden && (Ae.style.display = "none"), Ae;
      }
      function be() {
        oe || (me = ge(), document.body.appendChild(me), oe = createTag("canvas"), pe = oe.getContext("2d"), pe.filter = "url(#" + ne + ")", pe.fillStyle = "rgba(0,0,0,0)", pe.fillRect(0, 0, 1, 1));
      }
      function Ie(Ae) {
        return oe || be(), oe.width = Ae.width, oe.height = Ae.height, pe.filter = "url(#" + ne + ")", oe;
      }
      return {
        load: be,
        get: Ie
      };
    };
    function createCanvas(L, ne) {
      if (featureSupport.offscreenCanvas)
        return new OffscreenCanvas(L, ne);
      var oe = createTag("canvas");
      return oe.width = L, oe.height = ne, oe;
    }
    var assetLoader = function() {
      return {
        loadLumaCanvas: lumaLoader.load,
        getLumaCanvas: lumaLoader.get,
        createCanvas
      };
    }(), registeredEffects = {};
    function CVEffects(L) {
      var ne, oe = L.data.ef ? L.data.ef.length : 0;
      this.filters = [];
      var pe;
      for (ne = 0; ne < oe; ne += 1) {
        pe = null;
        var me = L.data.ef[ne].ty;
        if (registeredEffects[me]) {
          var ge = registeredEffects[me].effect;
          pe = new ge(L.effectsManager.effectElements[ne], L);
        }
        pe && this.filters.push(pe);
      }
      this.filters.length && L.addRenderableComponent(this);
    }
    CVEffects.prototype.renderFrame = function(L) {
      var ne, oe = this.filters.length;
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].renderFrame(L);
    }, CVEffects.prototype.getEffects = function(L) {
      var ne, oe = this.filters.length, pe = [];
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].type === L && pe.push(this.filters[ne]);
      return pe;
    };
    function registerEffect(L, ne) {
      registeredEffects[L] = {
        effect: ne
      };
    }
    function CVMaskElement(L, ne) {
      this.data = L, this.element = ne, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
      var oe, pe = this.masksProperties.length, me = !1;
      for (oe = 0; oe < pe; oe += 1)
        this.masksProperties[oe].mode !== "n" && (me = !0), this.viewData[oe] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[oe], 3);
      this.hasMasks = me, me && this.element.addRenderableComponent(this);
    }
    CVMaskElement.prototype.renderFrame = function() {
      if (this.hasMasks) {
        var L = this.element.finalTransform.mat, ne = this.element.canvasContext, oe, pe = this.masksProperties.length, me, ge, be;
        for (ne.beginPath(), oe = 0; oe < pe; oe += 1)
          if (this.masksProperties[oe].mode !== "n") {
            this.masksProperties[oe].inv && (ne.moveTo(0, 0), ne.lineTo(this.element.globalData.compSize.w, 0), ne.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), ne.lineTo(0, this.element.globalData.compSize.h), ne.lineTo(0, 0)), be = this.viewData[oe].v, me = L.applyToPointArray(be.v[0][0], be.v[0][1], 0), ne.moveTo(me[0], me[1]);
            var Ie, Ae = be._length;
            for (Ie = 1; Ie < Ae; Ie += 1)
              ge = L.applyToTriplePoints(be.o[Ie - 1], be.i[Ie], be.v[Ie]), ne.bezierCurveTo(ge[0], ge[1], ge[2], ge[3], ge[4], ge[5]);
            ge = L.applyToTriplePoints(be.o[Ie - 1], be.i[0], be.v[0]), ne.bezierCurveTo(ge[0], ge[1], ge[2], ge[3], ge[4], ge[5]);
          }
        this.element.globalData.renderer.save(!0), ne.clip();
      }
    }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
      this.element = null;
    };
    function CVBaseElement() {
    }
    var operationsMap = {
      1: "source-in",
      2: "source-out",
      3: "source-in",
      4: "source-out"
    };
    CVBaseElement.prototype = {
      createElements: function() {
      },
      initRendererElement: function() {
      },
      createContainerElements: function() {
        if (this.data.tt >= 1) {
          this.buffers = [];
          var ne = this.globalData.canvasContext, oe = assetLoader.createCanvas(ne.canvas.width, ne.canvas.height);
          this.buffers.push(oe);
          var pe = assetLoader.createCanvas(ne.canvas.width, ne.canvas.height);
          this.buffers.push(pe), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas();
        }
        this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms();
      },
      createContent: function() {
      },
      setBlendMode: function() {
        var ne = this.globalData;
        if (ne.blendMode !== this.data.bm) {
          ne.blendMode = this.data.bm;
          var oe = getBlendMode(this.data.bm);
          ne.canvasContext.globalCompositeOperation = oe;
        }
      },
      createRenderableComponents: function() {
        this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
      },
      hideElement: function() {
        !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0);
      },
      showElement: function() {
        this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0);
      },
      clearCanvas: function(ne) {
        ne.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
      },
      prepareLayer: function() {
        if (this.data.tt >= 1) {
          var ne = this.buffers[0], oe = ne.getContext("2d");
          this.clearCanvas(oe), oe.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
        }
      },
      exitLayer: function() {
        if (this.data.tt >= 1) {
          var ne = this.buffers[1], oe = ne.getContext("2d");
          this.clearCanvas(oe), oe.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
          var pe = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
          if (pe.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
            var me = assetLoader.getLumaCanvas(this.canvasContext.canvas), ge = me.getContext("2d");
            ge.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(me, 0, 0);
          }
          this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(ne, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over";
        }
      },
      renderFrame: function(ne) {
        if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !ne)) {
          this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
          var oe = this.data.ty === 0;
          this.prepareLayer(), this.globalData.renderer.save(oe), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(oe), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1);
        }
      },
      destroy: function() {
        this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy();
      },
      mHelper: new Matrix()
    }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(L, ne, oe, pe) {
      this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
      var me = 4;
      ne.ty === "rc" ? me = 5 : ne.ty === "el" ? me = 6 : ne.ty === "sr" && (me = 7), this.sh = ShapePropertyFactory.getShapeProp(L, ne, me, L);
      var ge, be = oe.length, Ie;
      for (ge = 0; ge < be; ge += 1)
        oe[ge].closed || (Ie = {
          transforms: pe.addTransformSequence(oe[ge].transforms),
          trNodes: []
        }, this.styledShapes.push(Ie), oe[ge].elements.push(Ie));
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager(), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
      opacity: 1,
      _opMdf: !1
    }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []);
    }, CVShapeElement.prototype.createStyleElement = function(L, ne) {
      var oe = {
        data: L,
        type: L.ty,
        preTransforms: this.transformsManager.addTransformSequence(ne),
        transforms: [],
        elements: [],
        closed: L.hd === !0
      }, pe = {};
      if (L.ty === "fl" || L.ty === "st" ? (pe.c = PropertyFactory.getProp(this, L.c, 1, 255, this), pe.c.k || (oe.co = "rgb(" + bmFloor(pe.c.v[0]) + "," + bmFloor(pe.c.v[1]) + "," + bmFloor(pe.c.v[2]) + ")")) : (L.ty === "gf" || L.ty === "gs") && (pe.s = PropertyFactory.getProp(this, L.s, 1, null, this), pe.e = PropertyFactory.getProp(this, L.e, 1, null, this), pe.h = PropertyFactory.getProp(this, L.h || {
        k: 0
      }, 0, 0.01, this), pe.a = PropertyFactory.getProp(this, L.a || {
        k: 0
      }, 0, degToRads, this), pe.g = new GradientProperty(this, L.g, this)), pe.o = PropertyFactory.getProp(this, L.o, 0, 0.01, this), L.ty === "st" || L.ty === "gs") {
        if (oe.lc = lineCapEnum[L.lc || 2], oe.lj = lineJoinEnum[L.lj || 2], L.lj == 1 && (oe.ml = L.ml), pe.w = PropertyFactory.getProp(this, L.w, 0, null, this), pe.w.k || (oe.wi = pe.w.v), L.d) {
          var me = new DashProperty(this, L.d, "canvas", this);
          pe.d = me, pe.d.k || (oe.da = pe.d.dashArray, oe.do = pe.d.dashoffset[0]);
        }
      } else
        oe.r = L.r === 2 ? "evenodd" : "nonzero";
      return this.stylesList.push(oe), pe.style = oe, pe;
    }, CVShapeElement.prototype.createGroupElement = function() {
      var L = {
        it: [],
        prevViewData: []
      };
      return L;
    }, CVShapeElement.prototype.createTransformElement = function(L) {
      var ne = {
        transform: {
          opacity: 1,
          _opMdf: !1,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, L.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, L, this)
        }
      };
      return ne;
    }, CVShapeElement.prototype.createShapeElement = function(L) {
      var ne = new CVShapeData(this, L, this.stylesList, this.transformsManager);
      return this.shapes.push(ne), this.addShapeToModifiers(ne), ne;
    }, CVShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var L, ne = this.itemsData.length;
      for (L = 0; L < ne; L += 1)
        this.prevViewData[L] = this.itemsData[L];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), ne = this.dynamicProperties.length, L = 0; L < ne; L += 1)
        this.dynamicProperties[L].getValue();
      this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame);
    }, CVShapeElement.prototype.addTransformToStyleList = function(L) {
      var ne, oe = this.stylesList.length;
      for (ne = 0; ne < oe; ne += 1)
        this.stylesList[ne].closed || this.stylesList[ne].transforms.push(L);
    }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
      var L, ne = this.stylesList.length;
      for (L = 0; L < ne; L += 1)
        this.stylesList[L].closed || this.stylesList[L].transforms.pop();
    }, CVShapeElement.prototype.closeStyles = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne].closed = !0;
    }, CVShapeElement.prototype.searchShapes = function(L, ne, oe, pe, me) {
      var ge, be = L.length - 1, Ie, Ae, rt = [], st = [], dt, ut, ht, it = [].concat(me);
      for (ge = be; ge >= 0; ge -= 1) {
        if (dt = this.searchProcessedElement(L[ge]), dt ? ne[ge] = oe[dt - 1] : L[ge]._shouldRender = pe, L[ge].ty === "fl" || L[ge].ty === "st" || L[ge].ty === "gf" || L[ge].ty === "gs")
          dt ? ne[ge].style.closed = !1 : ne[ge] = this.createStyleElement(L[ge], it), rt.push(ne[ge].style);
        else if (L[ge].ty === "gr") {
          if (!dt)
            ne[ge] = this.createGroupElement(L[ge]);
          else
            for (Ae = ne[ge].it.length, Ie = 0; Ie < Ae; Ie += 1)
              ne[ge].prevViewData[Ie] = ne[ge].it[Ie];
          this.searchShapes(L[ge].it, ne[ge].it, ne[ge].prevViewData, pe, it);
        } else
          L[ge].ty === "tr" ? (dt || (ht = this.createTransformElement(L[ge]), ne[ge] = ht), it.push(ne[ge]), this.addTransformToStyleList(ne[ge])) : L[ge].ty === "sh" || L[ge].ty === "rc" || L[ge].ty === "el" || L[ge].ty === "sr" ? dt || (ne[ge] = this.createShapeElement(L[ge])) : L[ge].ty === "tm" || L[ge].ty === "rd" || L[ge].ty === "pb" || L[ge].ty === "zz" || L[ge].ty === "op" ? (dt ? (ut = ne[ge], ut.closed = !1) : (ut = ShapeModifiers.getModifier(L[ge].ty), ut.init(this, L[ge]), ne[ge] = ut, this.shapeModifiers.push(ut)), st.push(ut)) : L[ge].ty === "rp" && (dt ? (ut = ne[ge], ut.closed = !0) : (ut = ShapeModifiers.getModifier(L[ge].ty), ne[ge] = ut, ut.init(this, L, ge, ne), this.shapeModifiers.push(ut), pe = !1), st.push(ut));
        this.addProcessedElement(L[ge], ge + 1);
      }
      for (this.removeTransformFromStyleList(), this.closeStyles(rt), be = st.length, ge = 0; ge < be; ge += 1)
        st[ge].closed = !0;
    }, CVShapeElement.prototype.renderInnerContent = function() {
      this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0);
    }, CVShapeElement.prototype.renderShapeTransform = function(L, ne) {
      (L._opMdf || ne.op._mdf || this._isFirstFrame) && (ne.opacity = L.opacity, ne.opacity *= ne.op.v, ne._opMdf = !0);
    }, CVShapeElement.prototype.drawLayer = function() {
      var L, ne = this.stylesList.length, oe, pe, me, ge, be, Ie, Ae = this.globalData.renderer, rt = this.globalData.canvasContext, st, dt;
      for (L = 0; L < ne; L += 1)
        if (dt = this.stylesList[L], st = dt.type, !((st === "st" || st === "gs") && dt.wi === 0 || !dt.data._shouldRender || dt.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          for (Ae.save(), be = dt.elements, st === "st" || st === "gs" ? (Ae.ctxStrokeStyle(st === "st" ? dt.co : dt.grd), Ae.ctxLineWidth(dt.wi), Ae.ctxLineCap(dt.lc), Ae.ctxLineJoin(dt.lj), Ae.ctxMiterLimit(dt.ml || 0)) : Ae.ctxFillStyle(st === "fl" ? dt.co : dt.grd), Ae.ctxOpacity(dt.coOp), st !== "st" && st !== "gs" && rt.beginPath(), Ae.ctxTransform(dt.preTransforms.finalTransform.props), pe = be.length, oe = 0; oe < pe; oe += 1) {
            for ((st === "st" || st === "gs") && (rt.beginPath(), dt.da && (rt.setLineDash(dt.da), rt.lineDashOffset = dt.do)), Ie = be[oe].trNodes, ge = Ie.length, me = 0; me < ge; me += 1)
              Ie[me].t === "m" ? rt.moveTo(Ie[me].p[0], Ie[me].p[1]) : Ie[me].t === "c" ? rt.bezierCurveTo(Ie[me].pts[0], Ie[me].pts[1], Ie[me].pts[2], Ie[me].pts[3], Ie[me].pts[4], Ie[me].pts[5]) : rt.closePath();
            (st === "st" || st === "gs") && (Ae.ctxStroke(), dt.da && rt.setLineDash(this.dashResetter));
          }
          st !== "st" && st !== "gs" && this.globalData.renderer.ctxFill(dt.r), Ae.restore();
        }
    }, CVShapeElement.prototype.renderShape = function(L, ne, oe, pe) {
      var me, ge = ne.length - 1, be;
      for (be = L, me = ge; me >= 0; me -= 1)
        ne[me].ty === "tr" ? (be = oe[me].transform, this.renderShapeTransform(L, be)) : ne[me].ty === "sh" || ne[me].ty === "el" || ne[me].ty === "rc" || ne[me].ty === "sr" ? this.renderPath(ne[me], oe[me]) : ne[me].ty === "fl" ? this.renderFill(ne[me], oe[me], be) : ne[me].ty === "st" ? this.renderStroke(ne[me], oe[me], be) : ne[me].ty === "gf" || ne[me].ty === "gs" ? this.renderGradientFill(ne[me], oe[me], be) : ne[me].ty === "gr" ? this.renderShape(be, ne[me].it, oe[me].it) : ne[me].ty;
      pe && this.drawLayer();
    }, CVShapeElement.prototype.renderStyledShape = function(L, ne) {
      if (this._isFirstFrame || ne._mdf || L.transforms._mdf) {
        var oe = L.trNodes, pe = ne.paths, me, ge, be, Ie = pe._length;
        oe.length = 0;
        var Ae = L.transforms.finalTransform;
        for (be = 0; be < Ie; be += 1) {
          var rt = pe.shapes[be];
          if (rt && rt.v) {
            for (ge = rt._length, me = 1; me < ge; me += 1)
              me === 1 && oe.push({
                t: "m",
                p: Ae.applyToPointArray(rt.v[0][0], rt.v[0][1], 0)
              }), oe.push({
                t: "c",
                pts: Ae.applyToTriplePoints(rt.o[me - 1], rt.i[me], rt.v[me])
              });
            ge === 1 && oe.push({
              t: "m",
              p: Ae.applyToPointArray(rt.v[0][0], rt.v[0][1], 0)
            }), rt.c && ge && (oe.push({
              t: "c",
              pts: Ae.applyToTriplePoints(rt.o[me - 1], rt.i[0], rt.v[0])
            }), oe.push({
              t: "z"
            }));
          }
        }
        L.trNodes = oe;
      }
    }, CVShapeElement.prototype.renderPath = function(L, ne) {
      if (L.hd !== !0 && L._shouldRender) {
        var oe, pe = ne.styledShapes.length;
        for (oe = 0; oe < pe; oe += 1)
          this.renderStyledShape(ne.styledShapes[oe], ne.sh);
      }
    }, CVShapeElement.prototype.renderFill = function(L, ne, oe) {
      var pe = ne.style;
      (ne.c._mdf || this._isFirstFrame) && (pe.co = "rgb(" + bmFloor(ne.c.v[0]) + "," + bmFloor(ne.c.v[1]) + "," + bmFloor(ne.c.v[2]) + ")"), (ne.o._mdf || oe._opMdf || this._isFirstFrame) && (pe.coOp = ne.o.v * oe.opacity);
    }, CVShapeElement.prototype.renderGradientFill = function(L, ne, oe) {
      var pe = ne.style, me;
      if (!pe.grd || ne.g._mdf || ne.s._mdf || ne.e._mdf || L.t !== 1 && (ne.h._mdf || ne.a._mdf)) {
        var ge = this.globalData.canvasContext, be = ne.s.v, Ie = ne.e.v;
        if (L.t === 1)
          me = ge.createLinearGradient(be[0], be[1], Ie[0], Ie[1]);
        else {
          var Ae = Math.sqrt(Math.pow(be[0] - Ie[0], 2) + Math.pow(be[1] - Ie[1], 2)), rt = Math.atan2(Ie[1] - be[1], Ie[0] - be[0]), st = ne.h.v;
          st >= 1 ? st = 0.99 : st <= -1 && (st = -0.99);
          var dt = Ae * st, ut = Math.cos(rt + ne.a.v) * dt + be[0], ht = Math.sin(rt + ne.a.v) * dt + be[1];
          me = ge.createRadialGradient(ut, ht, 0, be[0], be[1], Ae);
        }
        var it, lt = L.g.p, St = ne.g.c, ot = 1;
        for (it = 0; it < lt; it += 1)
          ne.g._hasOpacity && ne.g._collapsable && (ot = ne.g.o[it * 2 + 1]), me.addColorStop(St[it * 4] / 100, "rgba(" + St[it * 4 + 1] + "," + St[it * 4 + 2] + "," + St[it * 4 + 3] + "," + ot + ")");
        pe.grd = me;
      }
      pe.coOp = ne.o.v * oe.opacity;
    }, CVShapeElement.prototype.renderStroke = function(L, ne, oe) {
      var pe = ne.style, me = ne.d;
      me && (me._mdf || this._isFirstFrame) && (pe.da = me.dashArray, pe.do = me.dashoffset[0]), (ne.c._mdf || this._isFirstFrame) && (pe.co = "rgb(" + bmFloor(ne.c.v[0]) + "," + bmFloor(ne.c.v[1]) + "," + bmFloor(ne.c.v[2]) + ")"), (ne.o._mdf || oe._opMdf || this._isFirstFrame) && (pe.coOp = ne.o.v * oe.opacity), (ne.w._mdf || this._isFirstFrame) && (pe.wi = ne.w.v);
    }, CVShapeElement.prototype.destroy = function() {
      this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0;
    };
    function CVTextElement(L, ne, oe) {
      this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
        fill: "rgba(0,0,0,0)",
        stroke: "rgba(0,0,0,0)",
        sWidth: 0,
        fValue: ""
      }, this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
      var L = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(L.l ? L.l.length : 0);
      var ne = !1;
      L.fc ? (ne = !0, this.values.fill = this.buildColor(L.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = ne;
      var oe = !1;
      L.sc && (oe = !0, this.values.stroke = this.buildColor(L.sc), this.values.sWidth = L.sw);
      var pe = this.globalData.fontManager.getFontByName(L.f), me, ge, be = L.l, Ie = this.mHelper;
      this.stroke = oe, this.values.fValue = L.finalSize + "px " + this.globalData.fontManager.getFontByName(L.f).fFamily, ge = L.finalText.length;
      var Ae, rt, st, dt, ut, ht, it, lt, St, ot, pt = this.data.singleShape, ft = L.tr * 1e-3 * L.finalSize, vt = 0, xt = 0, Ct = !0, At = 0;
      for (me = 0; me < ge; me += 1) {
        Ae = this.globalData.fontManager.getCharData(L.finalText[me], pe.fStyle, this.globalData.fontManager.getFontByName(L.f).fFamily), rt = Ae && Ae.data || {}, Ie.reset(), pt && be[me].n && (vt = -ft, xt += L.yOffset, xt += Ct ? 1 : 0, Ct = !1), ut = rt.shapes ? rt.shapes[0].it : [], it = ut.length, Ie.scale(L.finalSize / 100, L.finalSize / 100), pt && this.applyTextPropertiesToMatrix(L, Ie, be[me].line, vt, xt), St = createSizedArray(it - 1);
        var kt = 0;
        for (ht = 0; ht < it; ht += 1)
          if (ut[ht].ty === "sh") {
            for (dt = ut[ht].ks.k.i.length, lt = ut[ht].ks.k, ot = [], st = 1; st < dt; st += 1)
              st === 1 && ot.push(Ie.applyToX(lt.v[0][0], lt.v[0][1], 0), Ie.applyToY(lt.v[0][0], lt.v[0][1], 0)), ot.push(Ie.applyToX(lt.o[st - 1][0], lt.o[st - 1][1], 0), Ie.applyToY(lt.o[st - 1][0], lt.o[st - 1][1], 0), Ie.applyToX(lt.i[st][0], lt.i[st][1], 0), Ie.applyToY(lt.i[st][0], lt.i[st][1], 0), Ie.applyToX(lt.v[st][0], lt.v[st][1], 0), Ie.applyToY(lt.v[st][0], lt.v[st][1], 0));
            ot.push(Ie.applyToX(lt.o[st - 1][0], lt.o[st - 1][1], 0), Ie.applyToY(lt.o[st - 1][0], lt.o[st - 1][1], 0), Ie.applyToX(lt.i[0][0], lt.i[0][1], 0), Ie.applyToY(lt.i[0][0], lt.i[0][1], 0), Ie.applyToX(lt.v[0][0], lt.v[0][1], 0), Ie.applyToY(lt.v[0][0], lt.v[0][1], 0)), St[kt] = ot, kt += 1;
          }
        pt && (vt += be[me].l, vt += ft), this.textSpans[At] ? this.textSpans[At].elem = St : this.textSpans[At] = {
          elem: St
        }, At += 1;
      }
    }, CVTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var L = this.canvasContext;
      L.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      var ne, oe, pe, me, ge, be, Ie = this.textAnimator.renderedLetters, Ae = this.textProperty.currentData.l;
      oe = Ae.length;
      var rt, st = null, dt = null, ut = null, ht, it, lt = this.globalData.renderer;
      for (ne = 0; ne < oe; ne += 1)
        if (!Ae[ne].n) {
          if (rt = Ie[ne], rt && (lt.save(), lt.ctxTransform(rt.p), lt.ctxOpacity(rt.o)), this.fill) {
            for (rt && rt.fc ? st !== rt.fc && (lt.ctxFillStyle(rt.fc), st = rt.fc) : st !== this.values.fill && (st = this.values.fill, lt.ctxFillStyle(this.values.fill)), ht = this.textSpans[ne].elem, me = ht.length, this.globalData.canvasContext.beginPath(), pe = 0; pe < me; pe += 1)
              for (it = ht[pe], be = it.length, this.globalData.canvasContext.moveTo(it[0], it[1]), ge = 2; ge < be; ge += 6)
                this.globalData.canvasContext.bezierCurveTo(it[ge], it[ge + 1], it[ge + 2], it[ge + 3], it[ge + 4], it[ge + 5]);
            this.globalData.canvasContext.closePath(), lt.ctxFill();
          }
          if (this.stroke) {
            for (rt && rt.sw ? ut !== rt.sw && (ut = rt.sw, lt.ctxLineWidth(rt.sw)) : ut !== this.values.sWidth && (ut = this.values.sWidth, lt.ctxLineWidth(this.values.sWidth)), rt && rt.sc ? dt !== rt.sc && (dt = rt.sc, lt.ctxStrokeStyle(rt.sc)) : dt !== this.values.stroke && (dt = this.values.stroke, lt.ctxStrokeStyle(this.values.stroke)), ht = this.textSpans[ne].elem, me = ht.length, this.globalData.canvasContext.beginPath(), pe = 0; pe < me; pe += 1)
              for (it = ht[pe], be = it.length, this.globalData.canvasContext.moveTo(it[0], it[1]), ge = 2; ge < be; ge += 6)
                this.globalData.canvasContext.bezierCurveTo(it[ge], it[ge + 1], it[ge + 2], it[ge + 3], it[ge + 4], it[ge + 5]);
            this.globalData.canvasContext.closePath(), lt.ctxStroke();
          }
          rt && this.globalData.renderer.restore();
        }
    };
    function CVImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.img = ne.imageLoader.getAsset(this.assetData), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var L = createTag("canvas");
        L.width = this.assetData.w, L.height = this.assetData.h;
        var ne = L.getContext("2d"), oe = this.img.width, pe = this.img.height, me = oe / pe, ge = this.assetData.w / this.assetData.h, be, Ie, Ae = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        me > ge && Ae === "xMidYMid slice" || me < ge && Ae !== "xMidYMid slice" ? (Ie = pe, be = Ie * ge) : (be = oe, Ie = be / ge), ne.drawImage(this.img, (oe - be) / 2, (pe - Ie) / 2, be, Ie, 0, 0, this.assetData.w, this.assetData.h), this.img = L;
      }
    }, CVImageElement.prototype.renderInnerContent = function() {
      this.canvasContext.drawImage(this.img, 0, 0);
    }, CVImageElement.prototype.destroy = function() {
      this.img = null;
    };
    function CVSolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
      this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
    };
    function CanvasRendererBase() {
    }
    extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function(L) {
      return new CVShapeElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createText = function(L) {
      return new CVTextElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createImage = function(L) {
      return new CVImageElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createSolid = function(L) {
      return new CVSolidElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function(L) {
      L[0] === 1 && L[1] === 0 && L[4] === 0 && L[5] === 1 && L[12] === 0 && L[13] === 0 || this.canvasContext.transform(L[0], L[1], L[4], L[5], L[12], L[13]);
    }, CanvasRendererBase.prototype.ctxOpacity = function(L) {
      this.canvasContext.globalAlpha *= L < 0 ? 0 : L;
    }, CanvasRendererBase.prototype.ctxFillStyle = function(L) {
      this.canvasContext.fillStyle = L;
    }, CanvasRendererBase.prototype.ctxStrokeStyle = function(L) {
      this.canvasContext.strokeStyle = L;
    }, CanvasRendererBase.prototype.ctxLineWidth = function(L) {
      this.canvasContext.lineWidth = L;
    }, CanvasRendererBase.prototype.ctxLineCap = function(L) {
      this.canvasContext.lineCap = L;
    }, CanvasRendererBase.prototype.ctxLineJoin = function(L) {
      this.canvasContext.lineJoin = L;
    }, CanvasRendererBase.prototype.ctxMiterLimit = function(L) {
      this.canvasContext.miterLimit = L;
    }, CanvasRendererBase.prototype.ctxFill = function(L) {
      this.canvasContext.fill(L);
    }, CanvasRendererBase.prototype.ctxFillRect = function(L, ne, oe, pe) {
      this.canvasContext.fillRect(L, ne, oe, pe);
    }, CanvasRendererBase.prototype.ctxStroke = function() {
      this.canvasContext.stroke();
    }, CanvasRendererBase.prototype.reset = function() {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    }, CanvasRendererBase.prototype.save = function() {
      this.canvasContext.save();
    }, CanvasRendererBase.prototype.restore = function(L) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      L && (this.globalData.blendMode = "source-over"), this.contextData.restore(L);
    }, CanvasRendererBase.prototype.configAnimation = function(L) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag("canvas");
        var ne = this.animationItem.container.style;
        ne.width = "100%", ne.height = "100%";
        var oe = "0px 0px 0px";
        ne.transformOrigin = oe, ne.mozTransformOrigin = oe, ne.webkitTransformOrigin = oe, ne["-webkit-transform"] = oe, ne.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id);
      } else
        this.canvasContext = this.renderConfig.context;
      this.contextData.setContext(this.canvasContext), this.data = L, this.layers = L.layers, this.transformCanvas = {
        w: L.w,
        h: L.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0
      }, this.setupGlobalData(L, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(L.layers.length), this.updateContainerSize();
    }, CanvasRendererBase.prototype.updateContainerSize = function(L, ne) {
      this.reset();
      var oe, pe;
      L ? (oe = L, pe = ne, this.canvasContext.canvas.width = oe, this.canvasContext.canvas.height = pe) : (this.animationItem.wrapper && this.animationItem.container ? (oe = this.animationItem.wrapper.offsetWidth, pe = this.animationItem.wrapper.offsetHeight) : (oe = this.canvasContext.canvas.width, pe = this.canvasContext.canvas.height), this.canvasContext.canvas.width = oe * this.renderConfig.dpr, this.canvasContext.canvas.height = pe * this.renderConfig.dpr);
      var me, ge;
      if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
        var be = this.renderConfig.preserveAspectRatio.split(" "), Ie = be[1] || "meet", Ae = be[0] || "xMidYMid", rt = Ae.substr(0, 4), st = Ae.substr(4);
        me = oe / pe, ge = this.transformCanvas.w / this.transformCanvas.h, ge > me && Ie === "meet" || ge < me && Ie === "slice" ? (this.transformCanvas.sx = oe / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = oe / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = pe / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = pe / (this.transformCanvas.h / this.renderConfig.dpr)), rt === "xMid" && (ge < me && Ie === "meet" || ge > me && Ie === "slice") ? this.transformCanvas.tx = (oe - this.transformCanvas.w * (pe / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : rt === "xMax" && (ge < me && Ie === "meet" || ge > me && Ie === "slice") ? this.transformCanvas.tx = (oe - this.transformCanvas.w * (pe / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, st === "YMid" && (ge > me && Ie === "meet" || ge < me && Ie === "slice") ? this.transformCanvas.ty = (pe - this.transformCanvas.h * (oe / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : st === "YMax" && (ge > me && Ie === "meet" || ge < me && Ie === "slice") ? this.transformCanvas.ty = (pe - this.transformCanvas.h * (oe / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0;
      } else
        this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = oe / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = pe / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0);
    }, CanvasRendererBase.prototype.destroy = function() {
      this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = ne - 1; L >= 0; L -= 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0;
    }, CanvasRendererBase.prototype.renderFrame = function(L, ne) {
      if (!(this.renderedFrame === L && this.renderConfig.clearCanvas === !0 && !ne || this.destroyed || L === -1)) {
        this.renderedFrame = L, this.globalData.frameNum = L - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || ne, this.globalData.projectInterface.currentFrame = L;
        var oe, pe = this.layers.length;
        for (this.completeLayers || this.checkLayers(L), oe = pe - 1; oe >= 0; oe -= 1)
          (this.completeLayers || this.elements[oe]) && this.elements[oe].prepareFrame(L - this.layers[oe].st);
        if (this.globalData._mdf) {
          for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), oe = pe - 1; oe >= 0; oe -= 1)
            (this.completeLayers || this.elements[oe]) && this.elements[oe].renderFrame();
          this.renderConfig.clearCanvas !== !0 && this.restore();
        }
      }
    }, CanvasRendererBase.prototype.buildItem = function(L) {
      var ne = this.elements;
      if (!(ne[L] || this.layers[L].ty === 99)) {
        var oe = this.createItem(this.layers[L], this, this.globalData);
        ne[L] = oe, oe.initExpressions();
      }
    }, CanvasRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        L.checkParenting();
      }
    }, CanvasRendererBase.prototype.hide = function() {
      this.animationItem.container.style.display = "none";
    }, CanvasRendererBase.prototype.show = function() {
      this.animationItem.container.style.display = "block";
    };
    function CanvasContext() {
      this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random();
    }
    function CVContextData() {
      this.stack = [], this.cArrPos = 0, this.cTr = new Matrix();
      var L, ne = 15;
      for (L = 0; L < ne; L += 1) {
        var oe = new CanvasContext();
        this.stack[L] = oe;
      }
      this._length = ne, this.nativeContext = null, this.transformMat = new Matrix(), this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "";
    }
    CVContextData.prototype.duplicate = function() {
      var L = this._length * 2, ne = 0;
      for (ne = this._length; ne < L; ne += 1)
        this.stack[ne] = new CanvasContext();
      this._length = L;
    }, CVContextData.prototype.reset = function() {
      this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1;
    }, CVContextData.prototype.restore = function(L) {
      this.cArrPos -= 1;
      var ne = this.stack[this.cArrPos], oe = ne.transform, pe, me = this.cTr.props;
      for (pe = 0; pe < 16; pe += 1)
        me[pe] = oe[pe];
      if (L) {
        this.nativeContext.restore();
        var ge = this.stack[this.cArrPos + 1];
        this.appliedFillStyle = ge.fillStyle, this.appliedStrokeStyle = ge.strokeStyle, this.appliedLineWidth = ge.lineWidth, this.appliedLineCap = ge.lineCap, this.appliedLineJoin = ge.lineJoin, this.appliedMiterLimit = ge.miterLimit;
      }
      this.nativeContext.setTransform(oe[0], oe[1], oe[4], oe[5], oe[12], oe[13]), (L || ne.opacity !== -1 && this.currentOpacity !== ne.opacity) && (this.nativeContext.globalAlpha = ne.opacity, this.currentOpacity = ne.opacity), this.currentFillStyle = ne.fillStyle, this.currentStrokeStyle = ne.strokeStyle, this.currentLineWidth = ne.lineWidth, this.currentLineCap = ne.lineCap, this.currentLineJoin = ne.lineJoin, this.currentMiterLimit = ne.miterLimit;
    }, CVContextData.prototype.save = function(L) {
      L && this.nativeContext.save();
      var ne = this.cTr.props;
      this._length <= this.cArrPos && this.duplicate();
      var oe = this.stack[this.cArrPos], pe;
      for (pe = 0; pe < 16; pe += 1)
        oe.transform[pe] = ne[pe];
      this.cArrPos += 1;
      var me = this.stack[this.cArrPos];
      me.opacity = oe.opacity, me.fillStyle = oe.fillStyle, me.strokeStyle = oe.strokeStyle, me.lineWidth = oe.lineWidth, me.lineCap = oe.lineCap, me.lineJoin = oe.lineJoin, me.miterLimit = oe.miterLimit;
    }, CVContextData.prototype.setOpacity = function(L) {
      this.stack[this.cArrPos].opacity = L;
    }, CVContextData.prototype.setContext = function(L) {
      this.nativeContext = L;
    }, CVContextData.prototype.fillStyle = function(L) {
      this.stack[this.cArrPos].fillStyle !== L && (this.currentFillStyle = L, this.stack[this.cArrPos].fillStyle = L);
    }, CVContextData.prototype.strokeStyle = function(L) {
      this.stack[this.cArrPos].strokeStyle !== L && (this.currentStrokeStyle = L, this.stack[this.cArrPos].strokeStyle = L);
    }, CVContextData.prototype.lineWidth = function(L) {
      this.stack[this.cArrPos].lineWidth !== L && (this.currentLineWidth = L, this.stack[this.cArrPos].lineWidth = L);
    }, CVContextData.prototype.lineCap = function(L) {
      this.stack[this.cArrPos].lineCap !== L && (this.currentLineCap = L, this.stack[this.cArrPos].lineCap = L);
    }, CVContextData.prototype.lineJoin = function(L) {
      this.stack[this.cArrPos].lineJoin !== L && (this.currentLineJoin = L, this.stack[this.cArrPos].lineJoin = L);
    }, CVContextData.prototype.miterLimit = function(L) {
      this.stack[this.cArrPos].miterLimit !== L && (this.currentMiterLimit = L, this.stack[this.cArrPos].miterLimit = L);
    }, CVContextData.prototype.transform = function(L) {
      this.transformMat.cloneFromProps(L);
      var ne = this.cTr;
      this.transformMat.multiply(ne), ne.cloneFromProps(this.transformMat.props);
      var oe = ne.props;
      this.nativeContext.setTransform(oe[0], oe[1], oe[4], oe[5], oe[12], oe[13]);
    }, CVContextData.prototype.opacity = function(L) {
      var ne = this.stack[this.cArrPos].opacity;
      ne *= L < 0 ? 0 : L, this.stack[this.cArrPos].opacity !== ne && (this.currentOpacity !== L && (this.nativeContext.globalAlpha = L, this.currentOpacity = L), this.stack[this.cArrPos].opacity = ne);
    }, CVContextData.prototype.fill = function(L) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(L);
    }, CVContextData.prototype.fillRect = function(L, ne, oe, pe) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(L, ne, oe, pe);
    }, CVContextData.prototype.stroke = function() {
      this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke();
    };
    function CVCompElement(L, ne, oe) {
      this.completeLayers = !1, this.layers = L.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
      var L = this.canvasContext;
      L.beginPath(), L.moveTo(0, 0), L.lineTo(this.data.w, 0), L.lineTo(this.data.w, this.data.h), L.lineTo(0, this.data.h), L.lineTo(0, 0), L.clip();
      var ne, oe = this.layers.length;
      for (ne = oe - 1; ne >= 0; ne -= 1)
        (this.completeLayers || this.elements[ne]) && this.elements[ne].renderFrame();
    }, CVCompElement.prototype.destroy = function() {
      var L, ne = this.layers.length;
      for (L = ne - 1; L >= 0; L -= 1)
        this.elements[L] && this.elements[L].destroy();
      this.layers = null, this.elements = null;
    }, CVCompElement.prototype.createComp = function(L) {
      return new CVCompElement(L, this.globalData, this);
    };
    function CanvasRenderer(L, ne) {
      this.animationItem = L, this.renderConfig = {
        clearCanvas: ne && ne.clearCanvas !== void 0 ? ne.clearCanvas : !0,
        context: ne && ne.context || null,
        progressiveLoad: ne && ne.progressiveLoad || !1,
        preserveAspectRatio: ne && ne.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: ne && ne.contentVisibility || "visible",
        className: ne && ne.className || "",
        id: ne && ne.id || "",
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.renderConfig.dpr = ne && ne.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = ne && ne.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
        frameNum: -1,
        _mdf: !1,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1
      }, this.contextData = new CVContextData(), this.elements = [], this.pendingElements = [], this.transformMat = new Matrix(), this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData));
    }
    extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function(L) {
      return new CVCompElement(L, this.globalData, this);
    };
    function HBaseElement() {
    }
    HBaseElement.prototype = {
      checkBlendMode: function() {
      },
      initRendererElement: function() {
        this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement);
      },
      createContainerElements: function() {
        this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        var ne = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var oe = this.finalTransform.mat.toCSS();
          ne.transform = oe, ne.webkitTransform = oe;
        }
        this.finalTransform._opMdf && (ne.opacity = this.finalTransform.mProp.o.v);
      },
      renderFrame: function() {
        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
      },
      destroy: function() {
        this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null);
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function() {
      },
      setMatte: function() {
      }
    }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
      var L;
      this.data.hasMask ? (L = createNS("rect"), L.setAttribute("width", this.data.sw), L.setAttribute("height", this.data.sh), L.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (L = createTag("div"), L.style.width = this.data.sw + "px", L.style.height = this.data.sh + "px", L.style.backgroundColor = this.data.sc), this.layerElement.appendChild(L);
    };
    function HShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(L, ne, oe), this.prevViewData = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
      var L;
      if (this.baseElement.style.fontSize = 0, this.data.hasMask)
        this.layerElement.appendChild(this.shapesContainer), L = this.svgElement;
      else {
        L = createNS("svg");
        var ne = this.comp.data ? this.comp.data : this.globalData.compSize;
        L.setAttribute("width", ne.w), L.setAttribute("height", ne.h), L.appendChild(this.shapesContainer), this.layerElement.appendChild(L);
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = L;
    }, HShapeElement.prototype.getTransformedPoint = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        ne = L[oe].mProps.v.applyToPointArray(ne[0], ne[1], 0);
      return ne;
    }, HShapeElement.prototype.calculateShapeBoundingBox = function(L, ne) {
      var oe = L.sh.v, pe = L.transformers, me, ge = oe._length, be, Ie, Ae, rt;
      if (!(ge <= 1)) {
        for (me = 0; me < ge - 1; me += 1)
          be = this.getTransformedPoint(pe, oe.v[me]), Ie = this.getTransformedPoint(pe, oe.o[me]), Ae = this.getTransformedPoint(pe, oe.i[me + 1]), rt = this.getTransformedPoint(pe, oe.v[me + 1]), this.checkBounds(be, Ie, Ae, rt, ne);
        oe.c && (be = this.getTransformedPoint(pe, oe.v[me]), Ie = this.getTransformedPoint(pe, oe.o[me]), Ae = this.getTransformedPoint(pe, oe.i[0]), rt = this.getTransformedPoint(pe, oe.v[0]), this.checkBounds(be, Ie, Ae, rt, ne));
      }
    }, HShapeElement.prototype.checkBounds = function(L, ne, oe, pe, me) {
      this.getBoundsOfCurve(L, ne, oe, pe);
      var ge = this.shapeBoundingBox;
      me.x = bmMin(ge.left, me.x), me.xMax = bmMax(ge.right, me.xMax), me.y = bmMin(ge.top, me.y), me.yMax = bmMax(ge.bottom, me.yMax);
    }, HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0
    }, HShapeElement.prototype.getBoundsOfCurve = function(L, ne, oe, pe) {
      for (var me = [[L[0], pe[0]], [L[1], pe[1]]], ge, be, Ie, Ae, rt, st, dt, ut = 0; ut < 2; ++ut)
        be = 6 * L[ut] - 12 * ne[ut] + 6 * oe[ut], ge = -3 * L[ut] + 9 * ne[ut] - 9 * oe[ut] + 3 * pe[ut], Ie = 3 * ne[ut] - 3 * L[ut], be |= 0, ge |= 0, Ie |= 0, ge === 0 && be === 0 || (ge === 0 ? (Ae = -Ie / be, Ae > 0 && Ae < 1 && me[ut].push(this.calculateF(Ae, L, ne, oe, pe, ut))) : (rt = be * be - 4 * Ie * ge, rt >= 0 && (st = (-be + bmSqrt(rt)) / (2 * ge), st > 0 && st < 1 && me[ut].push(this.calculateF(st, L, ne, oe, pe, ut)), dt = (-be - bmSqrt(rt)) / (2 * ge), dt > 0 && dt < 1 && me[ut].push(this.calculateF(dt, L, ne, oe, pe, ut)))));
      this.shapeBoundingBox.left = bmMin.apply(null, me[0]), this.shapeBoundingBox.top = bmMin.apply(null, me[1]), this.shapeBoundingBox.right = bmMax.apply(null, me[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, me[1]);
    }, HShapeElement.prototype.calculateF = function(L, ne, oe, pe, me, ge) {
      return bmPow(1 - L, 3) * ne[ge] + 3 * bmPow(1 - L, 2) * L * oe[ge] + 3 * (1 - L) * bmPow(L, 2) * pe[ge] + bmPow(L, 3) * me[ge];
    }, HShapeElement.prototype.calculateBoundingBox = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        L[oe] && L[oe].sh ? this.calculateShapeBoundingBox(L[oe], ne) : L[oe] && L[oe].it ? this.calculateBoundingBox(L[oe].it, ne) : L[oe] && L[oe].style && L[oe].w && this.expandStrokeBoundingBox(L[oe].w, ne);
    }, HShapeElement.prototype.expandStrokeBoundingBox = function(L, ne) {
      var oe = 0;
      if (L.keyframes) {
        for (var pe = 0; pe < L.keyframes.length; pe += 1) {
          var me = L.keyframes[pe].s;
          me > oe && (oe = me);
        }
        oe *= L.mult;
      } else
        oe = L.v * L.mult;
      ne.x -= oe, ne.xMax += oe, ne.y -= oe, ne.yMax += oe;
    }, HShapeElement.prototype.currentBoxContains = function(L) {
      return this.currentBBox.x <= L.x && this.currentBBox.y <= L.y && this.currentBBox.width + this.currentBBox.x >= L.x + L.width && this.currentBBox.height + this.currentBBox.y >= L.y + L.height;
    }, HShapeElement.prototype.renderInnerContent = function() {
      if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
        var L = this.tempBoundingBox, ne = 999999;
        if (L.x = ne, L.xMax = -ne, L.y = ne, L.yMax = -ne, this.calculateBoundingBox(this.itemsData, L), L.width = L.xMax < L.x ? 0 : L.xMax - L.x, L.height = L.yMax < L.y ? 0 : L.yMax - L.y, this.currentBoxContains(L))
          return;
        var oe = !1;
        if (this.currentBBox.w !== L.width && (this.currentBBox.w = L.width, this.shapeCont.setAttribute("width", L.width), oe = !0), this.currentBBox.h !== L.height && (this.currentBBox.h = L.height, this.shapeCont.setAttribute("height", L.height), oe = !0), oe || this.currentBBox.x !== L.x || this.currentBBox.y !== L.y) {
          this.currentBBox.w = L.width, this.currentBBox.h = L.height, this.currentBBox.x = L.x, this.currentBBox.y = L.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
          var pe = this.shapeCont.style, me = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
          pe.transform = me, pe.webkitTransform = me;
        }
      }
    };
    function HTextElement(L, ne, oe) {
      this.textSpans = [], this.textPaths = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      }, this.renderType = "svg", this.isMasked = !1, this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
      if (this.isMasked = this.checkMasks(), this.isMasked) {
        this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
        var L = createNS("g");
        this.maskedElement.appendChild(L), this.innerElem = L;
      } else
        this.renderType = "html", this.innerElem = this.layerElement;
      this.checkParenting();
    }, HTextElement.prototype.buildNewText = function() {
      var L = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(L.l ? L.l.length : 0);
      var ne = this.innerElem.style, oe = L.fc ? this.buildColor(L.fc) : "rgba(0,0,0,0)";
      ne.fill = oe, ne.color = oe, L.sc && (ne.stroke = this.buildColor(L.sc), ne.strokeWidth = L.sw + "px");
      var pe = this.globalData.fontManager.getFontByName(L.f);
      if (!this.globalData.fontManager.chars)
        if (ne.fontSize = L.finalSize + "px", ne.lineHeight = L.finalSize + "px", pe.fClass)
          this.innerElem.className = pe.fClass;
        else {
          ne.fontFamily = pe.fFamily;
          var me = L.fWeight, ge = L.fStyle;
          ne.fontStyle = ge, ne.fontWeight = me;
        }
      var be, Ie, Ae = L.l;
      Ie = Ae.length;
      var rt, st, dt, ut = this.mHelper, ht, it = "", lt = 0;
      for (be = 0; be < Ie; be += 1) {
        if (this.globalData.fontManager.chars ? (this.textPaths[lt] ? rt = this.textPaths[lt] : (rt = createNS("path"), rt.setAttribute("stroke-linecap", lineCapEnum[1]), rt.setAttribute("stroke-linejoin", lineJoinEnum[2]), rt.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[lt] ? (st = this.textSpans[lt], dt = st.children[0]) : (st = createTag("div"), st.style.lineHeight = 0, dt = createNS("svg"), dt.appendChild(rt), styleDiv(st)))) : this.isMasked ? rt = this.textPaths[lt] ? this.textPaths[lt] : createNS("text") : this.textSpans[lt] ? (st = this.textSpans[lt], rt = this.textPaths[lt]) : (st = createTag("span"), styleDiv(st), rt = createTag("span"), styleDiv(rt), st.appendChild(rt)), this.globalData.fontManager.chars) {
          var St = this.globalData.fontManager.getCharData(L.finalText[be], pe.fStyle, this.globalData.fontManager.getFontByName(L.f).fFamily), ot;
          if (St ? ot = St.data : ot = null, ut.reset(), ot && ot.shapes && ot.shapes.length && (ht = ot.shapes[0].it, ut.scale(L.finalSize / 100, L.finalSize / 100), it = this.createPathShape(ut, ht), rt.setAttribute("d", it)), this.isMasked)
            this.innerElem.appendChild(rt);
          else {
            if (this.innerElem.appendChild(st), ot && ot.shapes) {
              document.body.appendChild(dt);
              var pt = dt.getBBox();
              dt.setAttribute("width", pt.width + 2), dt.setAttribute("height", pt.height + 2), dt.setAttribute("viewBox", pt.x - 1 + " " + (pt.y - 1) + " " + (pt.width + 2) + " " + (pt.height + 2));
              var ft = dt.style, vt = "translate(" + (pt.x - 1) + "px," + (pt.y - 1) + "px)";
              ft.transform = vt, ft.webkitTransform = vt, Ae[be].yOffset = pt.y - 1;
            } else
              dt.setAttribute("width", 1), dt.setAttribute("height", 1);
            st.appendChild(dt);
          }
        } else if (rt.textContent = Ae[be].val, rt.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked)
          this.innerElem.appendChild(rt);
        else {
          this.innerElem.appendChild(st);
          var xt = rt.style, Ct = "translate3d(0," + -L.finalSize / 1.2 + "px,0)";
          xt.transform = Ct, xt.webkitTransform = Ct;
        }
        this.isMasked ? this.textSpans[lt] = rt : this.textSpans[lt] = st, this.textSpans[lt].style.display = "block", this.textPaths[lt] = rt, lt += 1;
      }
      for (; lt < this.textSpans.length; )
        this.textSpans[lt].style.display = "none", lt += 1;
    }, HTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var L;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag)
          return;
        if (this.isMasked && this.finalTransform._matMdf) {
          this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), L = this.svgElement.style;
          var ne = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
          L.transform = ne, L.webkitTransform = ne;
        }
      }
      if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
        var oe, pe, me = 0, ge = this.textAnimator.renderedLetters, be = this.textProperty.currentData.l;
        pe = be.length;
        var Ie, Ae, rt;
        for (oe = 0; oe < pe; oe += 1)
          be[oe].n ? me += 1 : (Ae = this.textSpans[oe], rt = this.textPaths[oe], Ie = ge[me], me += 1, Ie._mdf.m && (this.isMasked ? Ae.setAttribute("transform", Ie.m) : (Ae.style.webkitTransform = Ie.m, Ae.style.transform = Ie.m)), Ae.style.opacity = Ie.o, Ie.sw && Ie._mdf.sw && rt.setAttribute("stroke-width", Ie.sw), Ie.sc && Ie._mdf.sc && rt.setAttribute("stroke", Ie.sc), Ie.fc && Ie._mdf.fc && (rt.setAttribute("fill", Ie.fc), rt.style.color = Ie.fc));
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var st = this.innerElem.getBBox();
          this.currentBBox.w !== st.width && (this.currentBBox.w = st.width, this.svgElement.setAttribute("width", st.width)), this.currentBBox.h !== st.height && (this.currentBBox.h = st.height, this.svgElement.setAttribute("height", st.height));
          var dt = 1;
          if (this.currentBBox.w !== st.width + dt * 2 || this.currentBBox.h !== st.height + dt * 2 || this.currentBBox.x !== st.x - dt || this.currentBBox.y !== st.y - dt) {
            this.currentBBox.w = st.width + dt * 2, this.currentBBox.h = st.height + dt * 2, this.currentBBox.x = st.x - dt, this.currentBBox.y = st.y - dt, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), L = this.svgElement.style;
            var ut = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            L.transform = ut, L.webkitTransform = ut;
          }
        }
      }
    };
    function HCameraElement(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initHierarchy();
      var pe = PropertyFactory.getProp;
      if (this.pe = pe(this, L.pe, 0, 0, this), L.ks.p.s ? (this.px = pe(this, L.ks.p.x, 1, 0, this), this.py = pe(this, L.ks.p.y, 1, 0, this), this.pz = pe(this, L.ks.p.z, 1, 0, this)) : this.p = pe(this, L.ks.p, 1, 0, this), L.ks.a && (this.a = pe(this, L.ks.a, 1, 0, this)), L.ks.or.k.length && L.ks.or.k[0].to) {
        var me, ge = L.ks.or.k.length;
        for (me = 0; me < ge; me += 1)
          L.ks.or.k[me].to = null, L.ks.or.k[me].ti = null;
      }
      this.or = pe(this, L.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = pe(this, L.ks.rx, 0, degToRads, this), this.ry = pe(this, L.ks.ry, 0, degToRads, this), this.rz = pe(this, L.ks.rz, 0, degToRads, this), this.mat = new Matrix(), this._prevMat = new Matrix(), this._isFirstFrame = !0, this.finalTransform = {
        mProp: this
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
      var L, ne = this.comp.threeDElements.length, oe, pe, me;
      for (L = 0; L < ne; L += 1)
        if (oe = this.comp.threeDElements[L], oe.type === "3d") {
          pe = oe.perspectiveElem.style, me = oe.container.style;
          var ge = this.pe.v + "px", be = "0px 0px 0px", Ie = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          pe.perspective = ge, pe.webkitPerspective = ge, me.transformOrigin = be, me.mozTransformOrigin = be, me.webkitTransformOrigin = be, pe.transform = Ie, pe.webkitTransform = Ie;
        }
    }, HCameraElement.prototype.createElements = function() {
    }, HCameraElement.prototype.hide = function() {
    }, HCameraElement.prototype.renderFrame = function() {
      var L = this._isFirstFrame, ne, oe;
      if (this.hierarchy)
        for (oe = this.hierarchy.length, ne = 0; ne < oe; ne += 1)
          L = this.hierarchy[ne].finalTransform.mProp._mdf || L;
      if (L || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
        if (this.mat.reset(), this.hierarchy)
          for (oe = this.hierarchy.length - 1, ne = oe; ne >= 0; ne -= 1) {
            var pe = this.hierarchy[ne].finalTransform.mProp;
            this.mat.translate(-pe.p.v[0], -pe.p.v[1], pe.p.v[2]), this.mat.rotateX(-pe.or.v[0]).rotateY(-pe.or.v[1]).rotateZ(pe.or.v[2]), this.mat.rotateX(-pe.rx.v).rotateY(-pe.ry.v).rotateZ(pe.rz.v), this.mat.scale(1 / pe.s.v[0], 1 / pe.s.v[1], 1 / pe.s.v[2]), this.mat.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]);
          }
        if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
          var me;
          this.p ? me = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : me = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          var ge = Math.sqrt(Math.pow(me[0], 2) + Math.pow(me[1], 2) + Math.pow(me[2], 2)), be = [me[0] / ge, me[1] / ge, me[2] / ge], Ie = Math.sqrt(be[2] * be[2] + be[0] * be[0]), Ae = Math.atan2(be[1], Ie), rt = Math.atan2(be[0], -be[2]);
          this.mat.rotateY(rt).rotateX(-Ae);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
        var st = !this._prevMat.equals(this.mat);
        if ((st || this.pe._mdf) && this.comp.threeDElements) {
          oe = this.comp.threeDElements.length;
          var dt, ut, ht;
          for (ne = 0; ne < oe; ne += 1)
            if (dt = this.comp.threeDElements[ne], dt.type === "3d") {
              if (st) {
                var it = this.mat.toCSS();
                ht = dt.container.style, ht.transform = it, ht.webkitTransform = it;
              }
              this.pe._mdf && (ut = dt.perspectiveElem.style, ut.perspective = this.pe.v + "px", ut.webkitPerspective = this.pe.v + "px");
            }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = !1;
    }, HCameraElement.prototype.prepareFrame = function(L) {
      this.prepareProperties(L, !0);
    }, HCameraElement.prototype.destroy = function() {
    }, HCameraElement.prototype.getBaseElement = function() {
      return null;
    };
    function HImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
      var L = this.globalData.getAssetsPath(this.assetData), ne = new Image();
      this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", L), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(ne), ne.crossOrigin = "anonymous", ne.src = L, this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
    };
    function HybridRendererBase(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: ne && ne.className || "",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "400%",
          height: ne && ne.filterSize && ne.filterSize.height || "400%",
          x: ne && ne.filterSize && ne.filterSize.x || "-100%",
          y: ne && ne.filterSize && ne.filterSize.y || "-100%"
        }
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        L.checkParenting();
      }
    }, HybridRendererBase.prototype.appendElementInPos = function(L, ne) {
      var oe = L.getBaseElement();
      if (oe) {
        var pe = this.layers[ne];
        if (!pe.ddd || !this.supports3d)
          if (this.threeDElements)
            this.addTo3dContainer(oe, ne);
          else {
            for (var me = 0, ge, be, Ie; me < ne; )
              this.elements[me] && this.elements[me] !== !0 && this.elements[me].getBaseElement && (be = this.elements[me], Ie = this.layers[me].ddd ? this.getThreeDContainerByPos(me) : be.getBaseElement(), ge = Ie || ge), me += 1;
            ge ? (!pe.ddd || !this.supports3d) && this.layerElement.insertBefore(oe, ge) : (!pe.ddd || !this.supports3d) && this.layerElement.appendChild(oe);
          }
        else
          this.addTo3dContainer(oe, ne);
      }
    }, HybridRendererBase.prototype.createShape = function(L) {
      return this.supports3d ? new HShapeElement(L, this.globalData, this) : new SVGShapeElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createText = function(L) {
      return this.supports3d ? new HTextElement(L, this.globalData, this) : new SVGTextLottieElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createCamera = function(L) {
      return this.camera = new HCameraElement(L, this.globalData, this), this.camera;
    }, HybridRendererBase.prototype.createImage = function(L) {
      return this.supports3d ? new HImageElement(L, this.globalData, this) : new IImageElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createSolid = function(L) {
      return this.supports3d ? new HSolidElement(L, this.globalData, this) : new ISolidElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function(L) {
      for (var ne = 0, oe = this.threeDElements.length; ne < oe; ) {
        if (this.threeDElements[ne].startPos <= L && this.threeDElements[ne].endPos >= L)
          return this.threeDElements[ne].perspectiveElem;
        ne += 1;
      }
      return null;
    }, HybridRendererBase.prototype.createThreeDContainer = function(L, ne) {
      var oe = createTag("div"), pe, me;
      styleDiv(oe);
      var ge = createTag("div");
      if (styleDiv(ge), ne === "3d") {
        pe = oe.style, pe.width = this.globalData.compSize.w + "px", pe.height = this.globalData.compSize.h + "px";
        var be = "50% 50%";
        pe.webkitTransformOrigin = be, pe.mozTransformOrigin = be, pe.transformOrigin = be, me = ge.style;
        var Ie = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
        me.transform = Ie, me.webkitTransform = Ie;
      }
      oe.appendChild(ge);
      var Ae = {
        container: ge,
        perspectiveElem: oe,
        startPos: L,
        endPos: L,
        type: ne
      };
      return this.threeDElements.push(Ae), Ae;
    }, HybridRendererBase.prototype.build3dContainers = function() {
      var L, ne = this.layers.length, oe, pe = "";
      for (L = 0; L < ne; L += 1)
        this.layers[L].ddd && this.layers[L].ty !== 3 ? (pe !== "3d" && (pe = "3d", oe = this.createThreeDContainer(L, "3d")), oe.endPos = Math.max(oe.endPos, L)) : (pe !== "2d" && (pe = "2d", oe = this.createThreeDContainer(L, "2d")), oe.endPos = Math.max(oe.endPos, L));
      for (ne = this.threeDElements.length, L = ne - 1; L >= 0; L -= 1)
        this.resizerElem.appendChild(this.threeDElements[L].perspectiveElem);
    }, HybridRendererBase.prototype.addTo3dContainer = function(L, ne) {
      for (var oe = 0, pe = this.threeDElements.length; oe < pe; ) {
        if (ne <= this.threeDElements[oe].endPos) {
          for (var me = this.threeDElements[oe].startPos, ge; me < ne; )
            this.elements[me] && this.elements[me].getBaseElement && (ge = this.elements[me].getBaseElement()), me += 1;
          ge ? this.threeDElements[oe].container.insertBefore(L, ge) : this.threeDElements[oe].container.appendChild(L);
          break;
        }
        oe += 1;
      }
    }, HybridRendererBase.prototype.configAnimation = function(L) {
      var ne = createTag("div"), oe = this.animationItem.wrapper, pe = ne.style;
      pe.width = L.w + "px", pe.height = L.h + "px", this.resizerElem = ne, styleDiv(ne), pe.transformStyle = "flat", pe.mozTransformStyle = "flat", pe.webkitTransformStyle = "flat", this.renderConfig.className && ne.setAttribute("class", this.renderConfig.className), oe.appendChild(ne), pe.overflow = "hidden";
      var me = createNS("svg");
      me.setAttribute("width", "1"), me.setAttribute("height", "1"), styleDiv(me), this.resizerElem.appendChild(me);
      var ge = createNS("defs");
      me.appendChild(ge), this.data = L, this.setupGlobalData(L, me), this.globalData.defs = ge, this.layers = L.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize();
    }, HybridRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, HybridRendererBase.prototype.updateContainerSize = function() {
      var L = this.animationItem.wrapper.offsetWidth, ne = this.animationItem.wrapper.offsetHeight, oe = L / ne, pe = this.globalData.compSize.w / this.globalData.compSize.h, me, ge, be, Ie;
      pe > oe ? (me = L / this.globalData.compSize.w, ge = L / this.globalData.compSize.w, be = 0, Ie = (ne - this.globalData.compSize.h * (L / this.globalData.compSize.w)) / 2) : (me = ne / this.globalData.compSize.h, ge = ne / this.globalData.compSize.h, be = (L - this.globalData.compSize.w * (ne / this.globalData.compSize.h)) / 2, Ie = 0);
      var Ae = this.resizerElem.style;
      Ae.webkitTransform = "matrix3d(" + me + ",0,0,0,0," + ge + ",0,0,0,0,1,0," + be + "," + Ie + ",0,1)", Ae.transform = Ae.webkitTransform;
    }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function() {
      this.resizerElem.style.display = "none";
    }, HybridRendererBase.prototype.show = function() {
      this.resizerElem.style.display = "block";
    }, HybridRendererBase.prototype.initItems = function() {
      if (this.buildAllItems(), this.camera)
        this.camera.setup();
      else {
        var L = this.globalData.compSize.w, ne = this.globalData.compSize.h, oe, pe = this.threeDElements.length;
        for (oe = 0; oe < pe; oe += 1) {
          var me = this.threeDElements[oe].perspectiveElem.style;
          me.webkitPerspective = Math.sqrt(Math.pow(L, 2) + Math.pow(ne, 2)) + "px", me.perspective = me.webkitPerspective;
        }
      }
    }, HybridRendererBase.prototype.searchExtraCompositions = function(L) {
      var ne, oe = L.length, pe = createTag("div");
      for (ne = 0; ne < oe; ne += 1)
        if (L[ne].xt) {
          var me = this.createComp(L[ne], pe, this.globalData.comp, null);
          me.initExpressions(), this.globalData.projectInterface.registerComposition(me);
        }
    };
    function HCompElement(L, ne, oe) {
      this.layers = L.layers, this.supports3d = !L.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
      this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement;
    }, HCompElement.prototype.addTo3dContainer = function(L, ne) {
      for (var oe = 0, pe; oe < ne; )
        this.elements[oe] && this.elements[oe].getBaseElement && (pe = this.elements[oe].getBaseElement()), oe += 1;
      pe ? this.layerElement.insertBefore(L, pe) : this.layerElement.appendChild(L);
    }, HCompElement.prototype.createComp = function(L) {
      return this.supports3d ? new HCompElement(L, this.globalData, this) : new SVGCompElement(L, this.globalData, this);
    };
    function HybridRenderer(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: ne && ne.className || "",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "400%",
          height: ne && ne.filterSize && ne.filterSize.height || "400%",
          x: ne && ne.filterSize && ne.filterSize.x || "-100%",
          y: ne && ne.filterSize && ne.filterSize.y || "-100%"
        },
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function(L) {
      return this.supports3d ? new HCompElement(L, this.globalData, this) : new SVGCompElement(L, this.globalData, this);
    };
    var CompExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        function ne(oe) {
          for (var pe = 0, me = L.layers.length; pe < me; ) {
            if (L.layers[pe].nm === oe || L.layers[pe].ind === oe)
              return L.elements[pe].layerInterface;
            pe += 1;
          }
          return null;
        }
        return Object.defineProperty(ne, "_name", {
          value: L.data.nm
        }), ne.layer = ne, ne.pixelAspect = 1, ne.height = L.data.h || L.globalData.compSize.h, ne.width = L.data.w || L.globalData.compSize.w, ne.pixelAspect = 1, ne.frameDuration = 1 / L.globalData.frameRate, ne.displayStartTime = 0, ne.numLayers = L.layers.length, ne;
      };
    }();
    function _typeof$2(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(oe) {
        return typeof oe;
      } : _typeof$2 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$2(L);
    }
    function seedRandom(L, ne) {
      var oe = this, pe = 256, me = 6, ge = 52, be = "random", Ie = ne.pow(pe, me), Ae = ne.pow(2, ge), rt = Ae * 2, st = pe - 1, dt;
      function ut(ft, vt, xt) {
        var Ct = [];
        vt = vt === !0 ? {
          entropy: !0
        } : vt || {};
        var At = St(lt(vt.entropy ? [ft, pt(L)] : ft === null ? ot() : ft, 3), Ct), kt = new ht(Ct), Vt = function() {
          for (var er = kt.g(me), Yt = Ie, Jt = 0; er < Ae; )
            er = (er + Jt) * pe, Yt *= pe, Jt = kt.g(1);
          for (; er >= rt; )
            er /= 2, Yt /= 2, Jt >>>= 1;
          return (er + Jt) / Yt;
        };
        return Vt.int32 = function() {
          return kt.g(4) | 0;
        }, Vt.quick = function() {
          return kt.g(4) / 4294967296;
        }, Vt.double = Vt, St(pt(kt.S), L), (vt.pass || xt || function(ir, er, Yt, Jt) {
          return Jt && (Jt.S && it(Jt, kt), ir.state = function() {
            return it(kt, {});
          }), Yt ? (ne[be] = ir, er) : ir;
        })(Vt, At, "global" in vt ? vt.global : this == ne, vt.state);
      }
      ne["seed" + be] = ut;
      function ht(ft) {
        var vt, xt = ft.length, Ct = this, At = 0, kt = Ct.i = Ct.j = 0, Vt = Ct.S = [];
        for (xt || (ft = [xt++]); At < pe; )
          Vt[At] = At++;
        for (At = 0; At < pe; At++)
          Vt[At] = Vt[kt = st & kt + ft[At % xt] + (vt = Vt[At])], Vt[kt] = vt;
        Ct.g = function(ir) {
          for (var er, Yt = 0, Jt = Ct.i, rr = Ct.j, Qt = Ct.S; ir--; )
            er = Qt[Jt = st & Jt + 1], Yt = Yt * pe + Qt[st & (Qt[Jt] = Qt[rr = st & rr + er]) + (Qt[rr] = er)];
          return Ct.i = Jt, Ct.j = rr, Yt;
        };
      }
      function it(ft, vt) {
        return vt.i = ft.i, vt.j = ft.j, vt.S = ft.S.slice(), vt;
      }
      function lt(ft, vt) {
        var xt = [], Ct = _typeof$2(ft), At;
        if (vt && Ct == "object")
          for (At in ft)
            try {
              xt.push(lt(ft[At], vt - 1));
            } catch {
            }
        return xt.length ? xt : Ct == "string" ? ft : ft + "\0";
      }
      function St(ft, vt) {
        for (var xt = ft + "", Ct, At = 0; At < xt.length; )
          vt[st & At] = st & (Ct ^= vt[st & At] * 19) + xt.charCodeAt(At++);
        return pt(vt);
      }
      function ot() {
        try {
          var ft = new Uint8Array(pe);
          return (oe.crypto || oe.msCrypto).getRandomValues(ft), pt(ft);
        } catch {
          var vt = oe.navigator, xt = vt && vt.plugins;
          return [+/* @__PURE__ */ new Date(), oe, xt, oe.screen, pt(L)];
        }
      }
      function pt(ft) {
        return String.fromCharCode.apply(0, ft);
      }
      St(ne.random(), L);
    }
    function initialize$2(L) {
      seedRandom([], L);
    }
    var propTypes = {
      SHAPE: "shape"
    };
    function _typeof$1(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(oe) {
        return typeof oe;
      } : _typeof$1 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$1(L);
    }
    var ExpressionManager = function() {
      var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {};
      initialize$2(BMMath);
      function resetFrame() {
        _lottieGlobal = {};
      }
      function $bm_isInstanceOfArray(L) {
        return L.constructor === Array || L.constructor === Float32Array;
      }
      function isNumerable(L, ne) {
        return L === "number" || ne instanceof Number || L === "boolean" || L === "string";
      }
      function $bm_neg(L) {
        var ne = _typeof$1(L);
        if (ne === "number" || L instanceof Number || ne === "boolean")
          return -L;
        if ($bm_isInstanceOfArray(L)) {
          var oe, pe = L.length, me = [];
          for (oe = 0; oe < pe; oe += 1)
            me[oe] = -L[oe];
          return me;
        }
        return L.propType ? L.v : -L;
      }
      var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
      function sum(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne);
        if (isNumerable(oe, L) && isNumerable(pe, ne) || oe === "string" || pe === "string")
          return L + ne;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne))
          return L = L.slice(0), L[0] += ne, L;
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne))
          return ne = ne.slice(0), ne[0] = L + ne[0], ne;
        if ($bm_isInstanceOfArray(L) && $bm_isInstanceOfArray(ne)) {
          for (var me = 0, ge = L.length, be = ne.length, Ie = []; me < ge || me < be; )
            (typeof L[me] == "number" || L[me] instanceof Number) && (typeof ne[me] == "number" || ne[me] instanceof Number) ? Ie[me] = L[me] + ne[me] : Ie[me] = ne[me] === void 0 ? L[me] : L[me] || ne[me], me += 1;
          return Ie;
        }
        return 0;
      }
      var add = sum;
      function sub(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne);
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return oe === "string" && (L = parseInt(L, 10)), pe === "string" && (ne = parseInt(ne, 10)), L - ne;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne))
          return L = L.slice(0), L[0] -= ne, L;
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne))
          return ne = ne.slice(0), ne[0] = L - ne[0], ne;
        if ($bm_isInstanceOfArray(L) && $bm_isInstanceOfArray(ne)) {
          for (var me = 0, ge = L.length, be = ne.length, Ie = []; me < ge || me < be; )
            (typeof L[me] == "number" || L[me] instanceof Number) && (typeof ne[me] == "number" || ne[me] instanceof Number) ? Ie[me] = L[me] - ne[me] : Ie[me] = ne[me] === void 0 ? L[me] : L[me] || ne[me], me += 1;
          return Ie;
        }
        return 0;
      }
      function mul(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne), me;
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return L * ne;
        var ge, be;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne)) {
          for (be = L.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L[ge] * ne;
          return me;
        }
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne)) {
          for (be = ne.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L * ne[ge];
          return me;
        }
        return 0;
      }
      function div(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne), me;
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return L / ne;
        var ge, be;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne)) {
          for (be = L.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L[ge] / ne;
          return me;
        }
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne)) {
          for (be = ne.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L / ne[ge];
          return me;
        }
        return 0;
      }
      function mod(L, ne) {
        return typeof L == "string" && (L = parseInt(L, 10)), typeof ne == "string" && (ne = parseInt(ne, 10)), L % ne;
      }
      var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod;
      function clamp(L, ne, oe) {
        if (ne > oe) {
          var pe = oe;
          oe = ne, ne = pe;
        }
        return Math.min(Math.max(L, ne), oe);
      }
      function radiansToDegrees(L) {
        return L / degToRads;
      }
      var radians_to_degrees = radiansToDegrees;
      function degreesToRadians(L) {
        return L * degToRads;
      }
      var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0];
      function length(L, ne) {
        if (typeof L == "number" || L instanceof Number)
          return ne = ne || 0, Math.abs(L - ne);
        ne || (ne = helperLengthArray);
        var oe, pe = Math.min(L.length, ne.length), me = 0;
        for (oe = 0; oe < pe; oe += 1)
          me += Math.pow(ne[oe] - L[oe], 2);
        return Math.sqrt(me);
      }
      function normalize(L) {
        return div(L, length(L));
      }
      function rgbToHsl(L) {
        var ne = L[0], oe = L[1], pe = L[2], me = Math.max(ne, oe, pe), ge = Math.min(ne, oe, pe), be, Ie, Ae = (me + ge) / 2;
        if (me === ge)
          be = 0, Ie = 0;
        else {
          var rt = me - ge;
          switch (Ie = Ae > 0.5 ? rt / (2 - me - ge) : rt / (me + ge), me) {
            case ne:
              be = (oe - pe) / rt + (oe < pe ? 6 : 0);
              break;
            case oe:
              be = (pe - ne) / rt + 2;
              break;
            case pe:
              be = (ne - oe) / rt + 4;
              break;
          }
          be /= 6;
        }
        return [be, Ie, Ae, L[3]];
      }
      function hue2rgb(L, ne, oe) {
        return oe < 0 && (oe += 1), oe > 1 && (oe -= 1), oe < 1 / 6 ? L + (ne - L) * 6 * oe : oe < 1 / 2 ? ne : oe < 2 / 3 ? L + (ne - L) * (2 / 3 - oe) * 6 : L;
      }
      function hslToRgb(L) {
        var ne = L[0], oe = L[1], pe = L[2], me, ge, be;
        if (oe === 0)
          me = pe, be = pe, ge = pe;
        else {
          var Ie = pe < 0.5 ? pe * (1 + oe) : pe + oe - pe * oe, Ae = 2 * pe - Ie;
          me = hue2rgb(Ae, Ie, ne + 1 / 3), ge = hue2rgb(Ae, Ie, ne), be = hue2rgb(Ae, Ie, ne - 1 / 3);
        }
        return [me, ge, be, L[3]];
      }
      function linear(L, ne, oe, pe, me) {
        if ((pe === void 0 || me === void 0) && (pe = ne, me = oe, ne = 0, oe = 1), oe < ne) {
          var ge = oe;
          oe = ne, ne = ge;
        }
        if (L <= ne)
          return pe;
        if (L >= oe)
          return me;
        var be = oe === ne ? 0 : (L - ne) / (oe - ne);
        if (!pe.length)
          return pe + (me - pe) * be;
        var Ie, Ae = pe.length, rt = createTypedArray("float32", Ae);
        for (Ie = 0; Ie < Ae; Ie += 1)
          rt[Ie] = pe[Ie] + (me[Ie] - pe[Ie]) * be;
        return rt;
      }
      function random(L, ne) {
        if (ne === void 0 && (L === void 0 ? (L = 0, ne = 1) : (ne = L, L = void 0)), ne.length) {
          var oe, pe = ne.length;
          L || (L = createTypedArray("float32", pe));
          var me = createTypedArray("float32", pe), ge = BMMath.random();
          for (oe = 0; oe < pe; oe += 1)
            me[oe] = L[oe] + ge * (ne[oe] - L[oe]);
          return me;
        }
        L === void 0 && (L = 0);
        var be = BMMath.random();
        return L + be * (ne - L);
      }
      function createPath(L, ne, oe, pe) {
        var me, ge = L.length, be = shapePool.newElement();
        be.setPathData(!!pe, ge);
        var Ie = [0, 0], Ae, rt;
        for (me = 0; me < ge; me += 1)
          Ae = ne && ne[me] ? ne[me] : Ie, rt = oe && oe[me] ? oe[me] : Ie, be.setTripleAt(L[me][0], L[me][1], rt[0] + L[me][0], rt[1] + L[me][1], Ae[0] + L[me][0], Ae[1] + L[me][1], me, !0);
        return be;
      }
      function initiateExpression(elem, data, property) {
        function noOp(L) {
          return L;
        }
        if (!elem.globalData.renderConfig.runExpressions)
          return noOp;
        var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
          get: function() {
            return thisProperty.v;
          }
        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
        var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function L(ne, oe) {
          var pe, me, ge = this.pv.length ? this.pv.length : 1, be = createTypedArray("float32", ge);
          ne = 5;
          var Ie = Math.floor(time * ne);
          for (pe = 0, me = 0; pe < Ie; ) {
            for (me = 0; me < ge; me += 1)
              be[me] += -oe + oe * 2 * BMMath.random();
            pe += 1;
          }
          var Ae = time * ne, rt = Ae - Math.floor(Ae), st = createTypedArray("float32", ge);
          if (ge > 1) {
            for (me = 0; me < ge; me += 1)
              st[me] = this.pv[me] + be[me] + (-oe + oe * 2 * BMMath.random()) * rt;
            return st;
          }
          return this.pv + be[0] + (-oe + oe * 2 * BMMath.random()) * rt;
        }).bind(this);
        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
        function loopInDuration(L, ne) {
          return loopIn(L, ne, !0);
        }
        function loopOutDuration(L, ne) {
          return loopOut(L, ne, !0);
        }
        this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
        function lookAt(L, ne) {
          var oe = [ne[0] - L[0], ne[1] - L[1], ne[2] - L[2]], pe = Math.atan2(oe[0], Math.sqrt(oe[1] * oe[1] + oe[2] * oe[2])) / degToRads, me = -Math.atan2(oe[1], oe[2]) / degToRads;
          return [me, pe, 0];
        }
        function easeOut(L, ne, oe, pe, me) {
          return applyEase(easeOutBez, L, ne, oe, pe, me);
        }
        function easeIn(L, ne, oe, pe, me) {
          return applyEase(easeInBez, L, ne, oe, pe, me);
        }
        function ease(L, ne, oe, pe, me) {
          return applyEase(easeInOutBez, L, ne, oe, pe, me);
        }
        function applyEase(L, ne, oe, pe, me, ge) {
          me === void 0 ? (me = oe, ge = pe) : ne = (ne - oe) / (pe - oe), ne > 1 ? ne = 1 : ne < 0 && (ne = 0);
          var be = L(ne);
          if ($bm_isInstanceOfArray(me)) {
            var Ie, Ae = me.length, rt = createTypedArray("float32", Ae);
            for (Ie = 0; Ie < Ae; Ie += 1)
              rt[Ie] = (ge[Ie] - me[Ie]) * be + me[Ie];
            return rt;
          }
          return (ge - me) * be + me;
        }
        function nearestKey(L) {
          var ne, oe = data.k.length, pe, me;
          if (!data.k.length || typeof data.k[0] == "number")
            pe = 0, me = 0;
          else if (pe = -1, L *= elem.comp.globalData.frameRate, L < data.k[0].t)
            pe = 1, me = data.k[0].t;
          else {
            for (ne = 0; ne < oe - 1; ne += 1)
              if (L === data.k[ne].t) {
                pe = ne + 1, me = data.k[ne].t;
                break;
              } else if (L > data.k[ne].t && L < data.k[ne + 1].t) {
                L - data.k[ne].t > data.k[ne + 1].t - L ? (pe = ne + 2, me = data.k[ne + 1].t) : (pe = ne + 1, me = data.k[ne].t);
                break;
              }
            pe === -1 && (pe = ne + 1, me = data.k[ne].t);
          }
          var ge = {};
          return ge.index = pe, ge.time = me / elem.comp.globalData.frameRate, ge;
        }
        function key(L) {
          var ne, oe, pe;
          if (!data.k.length || typeof data.k[0] == "number")
            throw new Error("The property has no keyframe at index " + L);
          L -= 1, ne = {
            time: data.k[L].t / elem.comp.globalData.frameRate,
            value: []
          };
          var me = Object.prototype.hasOwnProperty.call(data.k[L], "s") ? data.k[L].s : data.k[L - 1].e;
          for (pe = me.length, oe = 0; oe < pe; oe += 1)
            ne[oe] = me[oe], ne.value[oe] = me[oe];
          return ne;
        }
        function framesToTime(L, ne) {
          return ne || (ne = elem.comp.globalData.frameRate), L / ne;
        }
        function timeToFrames(L, ne) {
          return !L && L !== 0 && (L = time), ne || (ne = elem.comp.globalData.frameRate), L * ne;
        }
        function seedRandom(L) {
          BMMath.seedrandom(randSeed + L);
        }
        function sourceRectAtTime() {
          return elem.sourceRectAtTime();
        }
        function substring(L, ne) {
          return typeof value == "string" ? ne === void 0 ? value.substring(L) : value.substring(L, ne) : "";
        }
        function substr(L, ne) {
          return typeof value == "string" ? ne === void 0 ? value.substr(L) : value.substr(L, ne) : "";
        }
        function posterizeTime(L) {
          time = L === 0 ? 0 : Math.floor(time * L) / L, value = valueAtTime(time);
        }
        var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
        function executeExpression(L) {
          return value = L, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt);
        }
        return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression;
      }
      return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob;
    }(), Expressions = function() {
      var L = {};
      L.initExpressions = ne, L.resetFrame = ExpressionManager.resetFrame;
      function ne(oe) {
        var pe = 0, me = [];
        function ge() {
          pe += 1;
        }
        function be() {
          pe -= 1, pe === 0 && Ae();
        }
        function Ie(rt) {
          me.indexOf(rt) === -1 && me.push(rt);
        }
        function Ae() {
          var rt, st = me.length;
          for (rt = 0; rt < st; rt += 1)
            me[rt].release();
          me.length = 0;
        }
        oe.renderer.compInterface = CompExpressionInterface(oe.renderer), oe.renderer.globalData.projectInterface.registerComposition(oe.renderer), oe.renderer.globalData.pushExpression = ge, oe.renderer.globalData.popExpression = be, oe.renderer.globalData.registerExpressionProperty = Ie;
      }
      return L;
    }(), MaskManagerInterface = function() {
      function L(oe, pe) {
        this._mask = oe, this._data = pe;
      }
      Object.defineProperty(L.prototype, "maskPath", {
        get: function() {
          return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop;
        }
      }), Object.defineProperty(L.prototype, "maskOpacity", {
        get: function() {
          return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100;
        }
      });
      var ne = function(pe) {
        var me = createSizedArray(pe.viewData.length), ge, be = pe.viewData.length;
        for (ge = 0; ge < be; ge += 1)
          me[ge] = new L(pe.viewData[ge], pe.masksProperties[ge]);
        var Ie = function(rt) {
          for (ge = 0; ge < be; ) {
            if (pe.masksProperties[ge].nm === rt)
              return me[ge];
            ge += 1;
          }
          return null;
        };
        return Ie;
      };
      return ne;
    }(), ExpressionPropertyInterface = /* @__PURE__ */ function() {
      var L = {
        pv: 0,
        v: 0,
        mult: 1
      }, ne = {
        pv: [0, 0, 0],
        v: [0, 0, 0],
        mult: 1
      };
      function oe(be, Ie, Ae) {
        Object.defineProperty(be, "velocity", {
          get: function() {
            return Ie.getVelocityAtTime(Ie.comp.currentFrame);
          }
        }), be.numKeys = Ie.keyframes ? Ie.keyframes.length : 0, be.key = function(rt) {
          if (!be.numKeys)
            return 0;
          var st = "";
          "s" in Ie.keyframes[rt - 1] ? st = Ie.keyframes[rt - 1].s : "e" in Ie.keyframes[rt - 2] ? st = Ie.keyframes[rt - 2].e : st = Ie.keyframes[rt - 2].s;
          var dt = Ae === "unidimensional" ? new Number(st) : Object.assign({}, st);
          return dt.time = Ie.keyframes[rt - 1].t / Ie.elem.comp.globalData.frameRate, dt.value = Ae === "unidimensional" ? st[0] : st, dt;
        }, be.valueAtTime = Ie.getValueAtTime, be.speedAtTime = Ie.getSpeedAtTime, be.velocityAtTime = Ie.getVelocityAtTime, be.propertyGroup = Ie.propertyGroup;
      }
      function pe(be) {
        (!be || !("pv" in be)) && (be = L);
        var Ie = 1 / be.mult, Ae = be.pv * Ie, rt = new Number(Ae);
        return rt.value = Ae, oe(rt, be, "unidimensional"), function() {
          return be.k && be.getValue(), Ae = be.v * Ie, rt.value !== Ae && (rt = new Number(Ae), rt.value = Ae, oe(rt, be, "unidimensional")), rt;
        };
      }
      function me(be) {
        (!be || !("pv" in be)) && (be = ne);
        var Ie = 1 / be.mult, Ae = be.data && be.data.l || be.pv.length, rt = createTypedArray("float32", Ae), st = createTypedArray("float32", Ae);
        return rt.value = st, oe(rt, be, "multidimensional"), function() {
          be.k && be.getValue();
          for (var dt = 0; dt < Ae; dt += 1)
            st[dt] = be.v[dt] * Ie, rt[dt] = st[dt];
          return rt;
        };
      }
      function ge() {
        return L;
      }
      return function(be) {
        return be ? be.propType === "unidimensional" ? pe(be) : me(be) : ge;
      };
    }(), TransformExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        function ne(be) {
          switch (be) {
            case "scale":
            case "Scale":
            case "ADBE Scale":
            case 6:
              return ne.scale;
            case "rotation":
            case "Rotation":
            case "ADBE Rotation":
            case "ADBE Rotate Z":
            case 10:
              return ne.rotation;
            case "ADBE Rotate X":
              return ne.xRotation;
            case "ADBE Rotate Y":
              return ne.yRotation;
            case "position":
            case "Position":
            case "ADBE Position":
            case 2:
              return ne.position;
            case "ADBE Position_0":
              return ne.xPosition;
            case "ADBE Position_1":
              return ne.yPosition;
            case "ADBE Position_2":
              return ne.zPosition;
            case "anchorPoint":
            case "AnchorPoint":
            case "Anchor Point":
            case "ADBE AnchorPoint":
            case 1:
              return ne.anchorPoint;
            case "opacity":
            case "Opacity":
            case 11:
              return ne.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(ne, "rotation", {
          get: ExpressionPropertyInterface(L.r || L.rz)
        }), Object.defineProperty(ne, "zRotation", {
          get: ExpressionPropertyInterface(L.rz || L.r)
        }), Object.defineProperty(ne, "xRotation", {
          get: ExpressionPropertyInterface(L.rx)
        }), Object.defineProperty(ne, "yRotation", {
          get: ExpressionPropertyInterface(L.ry)
        }), Object.defineProperty(ne, "scale", {
          get: ExpressionPropertyInterface(L.s)
        });
        var oe, pe, me, ge;
        return L.p ? ge = ExpressionPropertyInterface(L.p) : (oe = ExpressionPropertyInterface(L.px), pe = ExpressionPropertyInterface(L.py), L.pz && (me = ExpressionPropertyInterface(L.pz))), Object.defineProperty(ne, "position", {
          get: function() {
            return L.p ? ge() : [oe(), pe(), me ? me() : 0];
          }
        }), Object.defineProperty(ne, "xPosition", {
          get: ExpressionPropertyInterface(L.px)
        }), Object.defineProperty(ne, "yPosition", {
          get: ExpressionPropertyInterface(L.py)
        }), Object.defineProperty(ne, "zPosition", {
          get: ExpressionPropertyInterface(L.pz)
        }), Object.defineProperty(ne, "anchorPoint", {
          get: ExpressionPropertyInterface(L.a)
        }), Object.defineProperty(ne, "opacity", {
          get: ExpressionPropertyInterface(L.o)
        }), Object.defineProperty(ne, "skew", {
          get: ExpressionPropertyInterface(L.sk)
        }), Object.defineProperty(ne, "skewAxis", {
          get: ExpressionPropertyInterface(L.sa)
        }), Object.defineProperty(ne, "orientation", {
          get: ExpressionPropertyInterface(L.or)
        }), ne;
      };
    }(), LayerExpressionInterface = /* @__PURE__ */ function() {
      function L(rt) {
        var st = new Matrix();
        if (rt !== void 0) {
          var dt = this._elem.finalTransform.mProp.getValueAtTime(rt);
          dt.clone(st);
        } else {
          var ut = this._elem.finalTransform.mProp;
          ut.applyToMatrix(st);
        }
        return st;
      }
      function ne(rt, st) {
        var dt = this.getMatrix(st);
        return dt.props[12] = 0, dt.props[13] = 0, dt.props[14] = 0, this.applyPoint(dt, rt);
      }
      function oe(rt, st) {
        var dt = this.getMatrix(st);
        return this.applyPoint(dt, rt);
      }
      function pe(rt, st) {
        var dt = this.getMatrix(st);
        return dt.props[12] = 0, dt.props[13] = 0, dt.props[14] = 0, this.invertPoint(dt, rt);
      }
      function me(rt, st) {
        var dt = this.getMatrix(st);
        return this.invertPoint(dt, rt);
      }
      function ge(rt, st) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, ut = this._elem.hierarchy.length;
          for (dt = 0; dt < ut; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(rt);
        }
        return rt.applyToPointArray(st[0], st[1], st[2] || 0);
      }
      function be(rt, st) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, ut = this._elem.hierarchy.length;
          for (dt = 0; dt < ut; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(rt);
        }
        return rt.inversePoint(st);
      }
      function Ie(rt) {
        var st = new Matrix();
        if (st.reset(), this._elem.finalTransform.mProp.applyToMatrix(st), this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, ut = this._elem.hierarchy.length;
          for (dt = 0; dt < ut; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(st);
          return st.inversePoint(rt);
        }
        return st.inversePoint(rt);
      }
      function Ae() {
        return [1, 1, 1, 1];
      }
      return function(rt) {
        var st;
        function dt(lt) {
          ht.mask = new MaskManagerInterface(lt, rt);
        }
        function ut(lt) {
          ht.effect = lt;
        }
        function ht(lt) {
          switch (lt) {
            case "ADBE Root Vectors Group":
            case "Contents":
            case 2:
              return ht.shapeInterface;
            case 1:
            case 6:
            case "Transform":
            case "transform":
            case "ADBE Transform Group":
              return st;
            case 4:
            case "ADBE Effect Parade":
            case "effects":
            case "Effects":
              return ht.effect;
            case "ADBE Text Properties":
              return ht.textInterface;
            default:
              return null;
          }
        }
        ht.getMatrix = L, ht.invertPoint = be, ht.applyPoint = ge, ht.toWorld = oe, ht.toWorldVec = ne, ht.fromWorld = me, ht.fromWorldVec = pe, ht.toComp = oe, ht.fromComp = Ie, ht.sampleImage = Ae, ht.sourceRectAtTime = rt.sourceRectAtTime.bind(rt), ht._elem = rt, st = TransformExpressionInterface(rt.finalTransform.mProp);
        var it = getDescriptor(st, "anchorPoint");
        return Object.defineProperties(ht, {
          hasParent: {
            get: function() {
              return rt.hierarchy.length;
            }
          },
          parent: {
            get: function() {
              return rt.hierarchy[0].layerInterface;
            }
          },
          rotation: getDescriptor(st, "rotation"),
          scale: getDescriptor(st, "scale"),
          position: getDescriptor(st, "position"),
          opacity: getDescriptor(st, "opacity"),
          anchorPoint: it,
          anchor_point: it,
          transform: {
            get: function() {
              return st;
            }
          },
          active: {
            get: function() {
              return rt.isInRange;
            }
          }
        }), ht.startTime = rt.data.st, ht.index = rt.data.ind, ht.source = rt.data.refId, ht.height = rt.data.ty === 0 ? rt.data.h : 100, ht.width = rt.data.ty === 0 ? rt.data.w : 100, ht.inPoint = rt.data.ip / rt.comp.globalData.frameRate, ht.outPoint = rt.data.op / rt.comp.globalData.frameRate, ht._name = rt.data.nm, ht.registerMaskInterface = dt, ht.registerEffectsInterface = ut, ht;
      };
    }(), propertyGroupFactory = /* @__PURE__ */ function() {
      return function(L, ne) {
        return function(oe) {
          return oe = oe === void 0 ? 1 : oe, oe <= 0 ? L : ne(oe - 1);
        };
      };
    }(), PropertyInterface = /* @__PURE__ */ function() {
      return function(L, ne) {
        var oe = {
          _name: L
        };
        function pe(me) {
          return me = me === void 0 ? 1 : me, me <= 0 ? oe : ne(me - 1);
        }
        return pe;
      };
    }(), EffectsExpressionInterface = /* @__PURE__ */ function() {
      var L = {
        createEffectsInterface: ne
      };
      function ne(me, ge) {
        if (me.effectsManager) {
          var be = [], Ie = me.data.ef, Ae, rt = me.effectsManager.effectElements.length;
          for (Ae = 0; Ae < rt; Ae += 1)
            be.push(oe(Ie[Ae], me.effectsManager.effectElements[Ae], ge, me));
          var st = me.data.ef || [], dt = function(ht) {
            for (Ae = 0, rt = st.length; Ae < rt; ) {
              if (ht === st[Ae].nm || ht === st[Ae].mn || ht === st[Ae].ix)
                return be[Ae];
              Ae += 1;
            }
            return null;
          };
          return Object.defineProperty(dt, "numProperties", {
            get: function() {
              return st.length;
            }
          }), dt;
        }
        return null;
      }
      function oe(me, ge, be, Ie) {
        function Ae(ht) {
          for (var it = me.ef, lt = 0, St = it.length; lt < St; ) {
            if (ht === it[lt].nm || ht === it[lt].mn || ht === it[lt].ix)
              return it[lt].ty === 5 ? st[lt] : st[lt]();
            lt += 1;
          }
          throw new Error();
        }
        var rt = propertyGroupFactory(Ae, be), st = [], dt, ut = me.ef.length;
        for (dt = 0; dt < ut; dt += 1)
          me.ef[dt].ty === 5 ? st.push(oe(me.ef[dt], ge.effectElements[dt], ge.effectElements[dt].propertyGroup, Ie)) : st.push(pe(ge.effectElements[dt], me.ef[dt].ty, Ie, rt));
        return me.mn === "ADBE Color Control" && Object.defineProperty(Ae, "color", {
          get: function() {
            return st[0]();
          }
        }), Object.defineProperties(Ae, {
          numProperties: {
            get: function() {
              return me.np;
            }
          },
          _name: {
            value: me.nm
          },
          propertyGroup: {
            value: rt
          }
        }), Ae.enabled = me.en !== 0, Ae.active = Ae.enabled, Ae;
      }
      function pe(me, ge, be, Ie) {
        var Ae = ExpressionPropertyInterface(me.p);
        function rt() {
          return ge === 10 ? be.comp.compInterface(me.p.v) : Ae();
        }
        return me.p.setGroupProperty && me.p.setGroupProperty(PropertyInterface("", Ie)), rt;
      }
      return L;
    }(), ShapePathInterface = /* @__PURE__ */ function() {
      return function(ne, oe, pe) {
        var me = oe.sh;
        function ge(Ie) {
          return Ie === "Shape" || Ie === "shape" || Ie === "Path" || Ie === "path" || Ie === "ADBE Vector Shape" || Ie === 2 ? ge.path : null;
        }
        var be = propertyGroupFactory(ge, pe);
        return me.setGroupProperty(PropertyInterface("Path", be)), Object.defineProperties(ge, {
          path: {
            get: function() {
              return me.k && me.getValue(), me;
            }
          },
          shape: {
            get: function() {
              return me.k && me.getValue(), me;
            }
          },
          _name: {
            value: ne.nm
          },
          ix: {
            value: ne.ix
          },
          propertyIndex: {
            value: ne.ix
          },
          mn: {
            value: ne.mn
          },
          propertyGroup: {
            value: pe
          }
        }), ge;
      };
    }(), ShapeExpressionInterface = /* @__PURE__ */ function() {
      function L(it, lt, St) {
        var ot = [], pt, ft = it ? it.length : 0;
        for (pt = 0; pt < ft; pt += 1)
          it[pt].ty === "gr" ? ot.push(oe(it[pt], lt[pt], St)) : it[pt].ty === "fl" ? ot.push(pe(it[pt], lt[pt], St)) : it[pt].ty === "st" ? ot.push(be(it[pt], lt[pt], St)) : it[pt].ty === "tm" ? ot.push(Ie(it[pt], lt[pt], St)) : it[pt].ty === "tr" || (it[pt].ty === "el" ? ot.push(rt(it[pt], lt[pt], St)) : it[pt].ty === "sr" ? ot.push(st(it[pt], lt[pt], St)) : it[pt].ty === "sh" ? ot.push(ShapePathInterface(it[pt], lt[pt], St)) : it[pt].ty === "rc" ? ot.push(dt(it[pt], lt[pt], St)) : it[pt].ty === "rd" ? ot.push(ut(it[pt], lt[pt], St)) : it[pt].ty === "rp" ? ot.push(ht(it[pt], lt[pt], St)) : it[pt].ty === "gf" ? ot.push(me(it[pt], lt[pt], St)) : ot.push(ge(it[pt], lt[pt])));
        return ot;
      }
      function ne(it, lt, St) {
        var ot, pt = function(xt) {
          for (var Ct = 0, At = ot.length; Ct < At; ) {
            if (ot[Ct]._name === xt || ot[Ct].mn === xt || ot[Ct].propertyIndex === xt || ot[Ct].ix === xt || ot[Ct].ind === xt)
              return ot[Ct];
            Ct += 1;
          }
          return typeof xt == "number" ? ot[xt - 1] : null;
        };
        pt.propertyGroup = propertyGroupFactory(pt, St), ot = L(it.it, lt.it, pt.propertyGroup), pt.numProperties = ot.length;
        var ft = Ae(it.it[it.it.length - 1], lt.it[lt.it.length - 1], pt.propertyGroup);
        return pt.transform = ft, pt.propertyIndex = it.cix, pt._name = it.nm, pt;
      }
      function oe(it, lt, St) {
        var ot = function(xt) {
          switch (xt) {
            case "ADBE Vectors Group":
            case "Contents":
            case 2:
              return ot.content;
            default:
              return ot.transform;
          }
        };
        ot.propertyGroup = propertyGroupFactory(ot, St);
        var pt = ne(it, lt, ot.propertyGroup), ft = Ae(it.it[it.it.length - 1], lt.it[lt.it.length - 1], ot.propertyGroup);
        return ot.content = pt, ot.transform = ft, Object.defineProperty(ot, "_name", {
          get: function() {
            return it.nm;
          }
        }), ot.numProperties = it.np, ot.propertyIndex = it.ix, ot.nm = it.nm, ot.mn = it.mn, ot;
      }
      function pe(it, lt, St) {
        function ot(pt) {
          return pt === "Color" || pt === "color" ? ot.color : pt === "Opacity" || pt === "opacity" ? ot.opacity : null;
        }
        return Object.defineProperties(ot, {
          color: {
            get: ExpressionPropertyInterface(lt.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(lt.o)
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), lt.c.setGroupProperty(PropertyInterface("Color", St)), lt.o.setGroupProperty(PropertyInterface("Opacity", St)), ot;
      }
      function me(it, lt, St) {
        function ot(pt) {
          return pt === "Start Point" || pt === "start point" ? ot.startPoint : pt === "End Point" || pt === "end point" ? ot.endPoint : pt === "Opacity" || pt === "opacity" ? ot.opacity : null;
        }
        return Object.defineProperties(ot, {
          startPoint: {
            get: ExpressionPropertyInterface(lt.s)
          },
          endPoint: {
            get: ExpressionPropertyInterface(lt.e)
          },
          opacity: {
            get: ExpressionPropertyInterface(lt.o)
          },
          type: {
            get: function() {
              return "a";
            }
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), lt.s.setGroupProperty(PropertyInterface("Start Point", St)), lt.e.setGroupProperty(PropertyInterface("End Point", St)), lt.o.setGroupProperty(PropertyInterface("Opacity", St)), ot;
      }
      function ge() {
        function it() {
          return null;
        }
        return it;
      }
      function be(it, lt, St) {
        var ot = propertyGroupFactory(At, St), pt = propertyGroupFactory(Ct, ot);
        function ft(kt) {
          Object.defineProperty(Ct, it.d[kt].nm, {
            get: ExpressionPropertyInterface(lt.d.dataProps[kt].p)
          });
        }
        var vt, xt = it.d ? it.d.length : 0, Ct = {};
        for (vt = 0; vt < xt; vt += 1)
          ft(vt), lt.d.dataProps[vt].p.setGroupProperty(pt);
        function At(kt) {
          return kt === "Color" || kt === "color" ? At.color : kt === "Opacity" || kt === "opacity" ? At.opacity : kt === "Stroke Width" || kt === "stroke width" ? At.strokeWidth : null;
        }
        return Object.defineProperties(At, {
          color: {
            get: ExpressionPropertyInterface(lt.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(lt.o)
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(lt.w)
          },
          dash: {
            get: function() {
              return Ct;
            }
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), lt.c.setGroupProperty(PropertyInterface("Color", ot)), lt.o.setGroupProperty(PropertyInterface("Opacity", ot)), lt.w.setGroupProperty(PropertyInterface("Stroke Width", ot)), At;
      }
      function Ie(it, lt, St) {
        function ot(ft) {
          return ft === it.e.ix || ft === "End" || ft === "end" ? ot.end : ft === it.s.ix ? ot.start : ft === it.o.ix ? ot.offset : null;
        }
        var pt = propertyGroupFactory(ot, St);
        return ot.propertyIndex = it.ix, lt.s.setGroupProperty(PropertyInterface("Start", pt)), lt.e.setGroupProperty(PropertyInterface("End", pt)), lt.o.setGroupProperty(PropertyInterface("Offset", pt)), ot.propertyIndex = it.ix, ot.propertyGroup = St, Object.defineProperties(ot, {
          start: {
            get: ExpressionPropertyInterface(lt.s)
          },
          end: {
            get: ExpressionPropertyInterface(lt.e)
          },
          offset: {
            get: ExpressionPropertyInterface(lt.o)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function Ae(it, lt, St) {
        function ot(ft) {
          return it.a.ix === ft || ft === "Anchor Point" ? ot.anchorPoint : it.o.ix === ft || ft === "Opacity" ? ot.opacity : it.p.ix === ft || ft === "Position" ? ot.position : it.r.ix === ft || ft === "Rotation" || ft === "ADBE Vector Rotation" ? ot.rotation : it.s.ix === ft || ft === "Scale" ? ot.scale : it.sk && it.sk.ix === ft || ft === "Skew" ? ot.skew : it.sa && it.sa.ix === ft || ft === "Skew Axis" ? ot.skewAxis : null;
        }
        var pt = propertyGroupFactory(ot, St);
        return lt.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", pt)), lt.transform.mProps.p.setGroupProperty(PropertyInterface("Position", pt)), lt.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", pt)), lt.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", pt)), lt.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", pt)), lt.transform.mProps.sk && (lt.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", pt)), lt.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", pt))), lt.transform.op.setGroupProperty(PropertyInterface("Opacity", pt)), Object.defineProperties(ot, {
          opacity: {
            get: ExpressionPropertyInterface(lt.transform.mProps.o)
          },
          position: {
            get: ExpressionPropertyInterface(lt.transform.mProps.p)
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(lt.transform.mProps.a)
          },
          scale: {
            get: ExpressionPropertyInterface(lt.transform.mProps.s)
          },
          rotation: {
            get: ExpressionPropertyInterface(lt.transform.mProps.r)
          },
          skew: {
            get: ExpressionPropertyInterface(lt.transform.mProps.sk)
          },
          skewAxis: {
            get: ExpressionPropertyInterface(lt.transform.mProps.sa)
          },
          _name: {
            value: it.nm
          }
        }), ot.ty = "tr", ot.mn = it.mn, ot.propertyGroup = St, ot;
      }
      function rt(it, lt, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.s.ix === vt ? ot.size : null;
        }
        var pt = propertyGroupFactory(ot, St);
        ot.propertyIndex = it.ix;
        var ft = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
        return ft.s.setGroupProperty(PropertyInterface("Size", pt)), ft.p.setGroupProperty(PropertyInterface("Position", pt)), Object.defineProperties(ot, {
          size: {
            get: ExpressionPropertyInterface(ft.s)
          },
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function st(it, lt, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.r.ix === vt ? ot.rotation : it.pt.ix === vt ? ot.points : it.or.ix === vt || vt === "ADBE Vector Star Outer Radius" ? ot.outerRadius : it.os.ix === vt ? ot.outerRoundness : it.ir && (it.ir.ix === vt || vt === "ADBE Vector Star Inner Radius") ? ot.innerRadius : it.is && it.is.ix === vt ? ot.innerRoundness : null;
        }
        var pt = propertyGroupFactory(ot, St), ft = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
        return ot.propertyIndex = it.ix, ft.or.setGroupProperty(PropertyInterface("Outer Radius", pt)), ft.os.setGroupProperty(PropertyInterface("Outer Roundness", pt)), ft.pt.setGroupProperty(PropertyInterface("Points", pt)), ft.p.setGroupProperty(PropertyInterface("Position", pt)), ft.r.setGroupProperty(PropertyInterface("Rotation", pt)), it.ir && (ft.ir.setGroupProperty(PropertyInterface("Inner Radius", pt)), ft.is.setGroupProperty(PropertyInterface("Inner Roundness", pt))), Object.defineProperties(ot, {
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          rotation: {
            get: ExpressionPropertyInterface(ft.r)
          },
          points: {
            get: ExpressionPropertyInterface(ft.pt)
          },
          outerRadius: {
            get: ExpressionPropertyInterface(ft.or)
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(ft.os)
          },
          innerRadius: {
            get: ExpressionPropertyInterface(ft.ir)
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(ft.is)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function dt(it, lt, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.r.ix === vt ? ot.roundness : it.s.ix === vt || vt === "Size" || vt === "ADBE Vector Rect Size" ? ot.size : null;
        }
        var pt = propertyGroupFactory(ot, St), ft = lt.sh.ty === "tm" ? lt.sh.prop : lt.sh;
        return ot.propertyIndex = it.ix, ft.p.setGroupProperty(PropertyInterface("Position", pt)), ft.s.setGroupProperty(PropertyInterface("Size", pt)), ft.r.setGroupProperty(PropertyInterface("Rotation", pt)), Object.defineProperties(ot, {
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          roundness: {
            get: ExpressionPropertyInterface(ft.r)
          },
          size: {
            get: ExpressionPropertyInterface(ft.s)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function ut(it, lt, St) {
        function ot(vt) {
          return it.r.ix === vt || vt === "Round Corners 1" ? ot.radius : null;
        }
        var pt = propertyGroupFactory(ot, St), ft = lt;
        return ot.propertyIndex = it.ix, ft.rd.setGroupProperty(PropertyInterface("Radius", pt)), Object.defineProperties(ot, {
          radius: {
            get: ExpressionPropertyInterface(ft.rd)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function ht(it, lt, St) {
        function ot(vt) {
          return it.c.ix === vt || vt === "Copies" ? ot.copies : it.o.ix === vt || vt === "Offset" ? ot.offset : null;
        }
        var pt = propertyGroupFactory(ot, St), ft = lt;
        return ot.propertyIndex = it.ix, ft.c.setGroupProperty(PropertyInterface("Copies", pt)), ft.o.setGroupProperty(PropertyInterface("Offset", pt)), Object.defineProperties(ot, {
          copies: {
            get: ExpressionPropertyInterface(ft.c)
          },
          offset: {
            get: ExpressionPropertyInterface(ft.o)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      return function(it, lt, St) {
        var ot;
        function pt(vt) {
          if (typeof vt == "number")
            return vt = vt === void 0 ? 1 : vt, vt === 0 ? St : ot[vt - 1];
          for (var xt = 0, Ct = ot.length; xt < Ct; ) {
            if (ot[xt]._name === vt)
              return ot[xt];
            xt += 1;
          }
          return null;
        }
        function ft() {
          return St;
        }
        return pt.propertyGroup = propertyGroupFactory(pt, ft), ot = L(it, lt, pt.propertyGroup), pt.numProperties = ot.length, pt._name = "Contents", pt;
      };
    }(), TextExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        var ne;
        function oe(pe) {
          switch (pe) {
            case "ADBE Text Document":
              return oe.sourceText;
            default:
              return null;
          }
        }
        return Object.defineProperty(oe, "sourceText", {
          get: function() {
            L.textProperty.getValue();
            var me = L.textProperty.currentData.t;
            return (!ne || me !== ne.value) && (ne = new String(me), ne.value = me || new String(me), Object.defineProperty(ne, "style", {
              get: function() {
                return {
                  fillColor: L.textProperty.currentData.fc
                };
              }
            })), ne;
          }
        }), oe;
      };
    }();
    function _typeof(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(oe) {
        return typeof oe;
      } : _typeof = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof(L);
    }
    var FootageInterface = /* @__PURE__ */ function() {
      var L = function(pe) {
        var me = "", ge = pe.getFootageData();
        function be() {
          return me = "", ge = pe.getFootageData(), Ie;
        }
        function Ie(Ae) {
          if (ge[Ae])
            return me = Ae, ge = ge[Ae], _typeof(ge) === "object" ? Ie : ge;
          var rt = Ae.indexOf(me);
          if (rt !== -1) {
            var st = parseInt(Ae.substr(rt + me.length), 10);
            return ge = ge[st], _typeof(ge) === "object" ? Ie : ge;
          }
          return "";
        }
        return be;
      }, ne = function(pe) {
        function me(ge) {
          return ge === "Outline" ? me.outlineInterface() : null;
        }
        return me._name = "Outline", me.outlineInterface = L(pe), me;
      };
      return function(oe) {
        function pe(me) {
          return me === "Data" ? pe.dataInterface : null;
        }
        return pe._name = "Data", pe.dataInterface = ne(oe), pe;
      };
    }(), interfaces = {
      layer: LayerExpressionInterface,
      effects: EffectsExpressionInterface,
      comp: CompExpressionInterface,
      shape: ShapeExpressionInterface,
      text: TextExpressionInterface,
      footage: FootageInterface
    };
    function getInterface(L) {
      return interfaces[L] || null;
    }
    var expressionHelpers = /* @__PURE__ */ function() {
      function L(be, Ie, Ae) {
        Ie.x && (Ae.k = !0, Ae.x = !0, Ae.initiateExpression = ExpressionManager.initiateExpression, Ae.effectsSequence.push(Ae.initiateExpression(be, Ie, Ae).bind(Ae)));
      }
      function ne(be) {
        return be *= this.elem.globalData.frameRate, be -= this.offsetTime, be !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < be ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(be, this._cachingAtTime), this._cachingAtTime.lastFrame = be), this._cachingAtTime.value;
      }
      function oe(be) {
        var Ie = -0.01, Ae = this.getValueAtTime(be), rt = this.getValueAtTime(be + Ie), st = 0;
        if (Ae.length) {
          var dt;
          for (dt = 0; dt < Ae.length; dt += 1)
            st += Math.pow(rt[dt] - Ae[dt], 2);
          st = Math.sqrt(st) * 100;
        } else
          st = 0;
        return st;
      }
      function pe(be) {
        if (this.vel !== void 0)
          return this.vel;
        var Ie = -1e-3, Ae = this.getValueAtTime(be), rt = this.getValueAtTime(be + Ie), st;
        if (Ae.length) {
          st = createTypedArray("float32", Ae.length);
          var dt;
          for (dt = 0; dt < Ae.length; dt += 1)
            st[dt] = (rt[dt] - Ae[dt]) / Ie;
        } else
          st = (rt - Ae) / Ie;
        return st;
      }
      function me() {
        return this.pv;
      }
      function ge(be) {
        this.propertyGroup = be;
      }
      return {
        searchExpressions: L,
        getSpeedAtTime: oe,
        getVelocityAtTime: pe,
        getValueAtTime: ne,
        getStaticValueAtTime: me,
        setGroupProperty: ge
      };
    }();
    function addPropertyDecorator() {
      function L(ut, ht, it) {
        if (!this.k || !this.keyframes)
          return this.pv;
        ut = ut ? ut.toLowerCase() : "";
        var lt = this.comp.renderedFrame, St = this.keyframes, ot = St[St.length - 1].t;
        if (lt <= ot)
          return this.pv;
        var pt, ft;
        it ? (ht ? pt = Math.abs(ot - this.elem.comp.globalData.frameRate * ht) : pt = Math.max(0, ot - this.elem.data.ip), ft = ot - pt) : ((!ht || ht > St.length - 1) && (ht = St.length - 1), ft = St[St.length - 1 - ht].t, pt = ot - ft);
        var vt, xt, Ct;
        if (ut === "pingpong") {
          var At = Math.floor((lt - ft) / pt);
          if (At % 2 !== 0)
            return this.getValueAtTime((pt - (lt - ft) % pt + ft) / this.comp.globalData.frameRate, 0);
        } else if (ut === "offset") {
          var kt = this.getValueAtTime(ft / this.comp.globalData.frameRate, 0), Vt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), ir = this.getValueAtTime(((lt - ft) % pt + ft) / this.comp.globalData.frameRate, 0), er = Math.floor((lt - ft) / pt);
          if (this.pv.length) {
            for (Ct = new Array(kt.length), xt = Ct.length, vt = 0; vt < xt; vt += 1)
              Ct[vt] = (Vt[vt] - kt[vt]) * er + ir[vt];
            return Ct;
          }
          return (Vt - kt) * er + ir;
        } else if (ut === "continue") {
          var Yt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Jt = this.getValueAtTime((ot - 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (Ct = new Array(Yt.length), xt = Ct.length, vt = 0; vt < xt; vt += 1)
              Ct[vt] = Yt[vt] + (Yt[vt] - Jt[vt]) * ((lt - ot) / this.comp.globalData.frameRate) / 5e-4;
            return Ct;
          }
          return Yt + (Yt - Jt) * ((lt - ot) / 1e-3);
        }
        return this.getValueAtTime(((lt - ft) % pt + ft) / this.comp.globalData.frameRate, 0);
      }
      function ne(ut, ht, it) {
        if (!this.k)
          return this.pv;
        ut = ut ? ut.toLowerCase() : "";
        var lt = this.comp.renderedFrame, St = this.keyframes, ot = St[0].t;
        if (lt >= ot)
          return this.pv;
        var pt, ft;
        it ? (ht ? pt = Math.abs(this.elem.comp.globalData.frameRate * ht) : pt = Math.max(0, this.elem.data.op - ot), ft = ot + pt) : ((!ht || ht > St.length - 1) && (ht = St.length - 1), ft = St[ht].t, pt = ft - ot);
        var vt, xt, Ct;
        if (ut === "pingpong") {
          var At = Math.floor((ot - lt) / pt);
          if (At % 2 === 0)
            return this.getValueAtTime(((ot - lt) % pt + ot) / this.comp.globalData.frameRate, 0);
        } else if (ut === "offset") {
          var kt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Vt = this.getValueAtTime(ft / this.comp.globalData.frameRate, 0), ir = this.getValueAtTime((pt - (ot - lt) % pt + ot) / this.comp.globalData.frameRate, 0), er = Math.floor((ot - lt) / pt) + 1;
          if (this.pv.length) {
            for (Ct = new Array(kt.length), xt = Ct.length, vt = 0; vt < xt; vt += 1)
              Ct[vt] = ir[vt] - (Vt[vt] - kt[vt]) * er;
            return Ct;
          }
          return ir - (Vt - kt) * er;
        } else if (ut === "continue") {
          var Yt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Jt = this.getValueAtTime((ot + 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (Ct = new Array(Yt.length), xt = Ct.length, vt = 0; vt < xt; vt += 1)
              Ct[vt] = Yt[vt] + (Yt[vt] - Jt[vt]) * (ot - lt) / 1e-3;
            return Ct;
          }
          return Yt + (Yt - Jt) * (ot - lt) / 1e-3;
        }
        return this.getValueAtTime((pt - ((ot - lt) % pt + ot)) / this.comp.globalData.frameRate, 0);
      }
      function oe(ut, ht) {
        if (!this.k)
          return this.pv;
        if (ut = (ut || 0.4) * 0.5, ht = Math.floor(ht || 5), ht <= 1)
          return this.pv;
        var it = this.comp.renderedFrame / this.comp.globalData.frameRate, lt = it - ut, St = it + ut, ot = ht > 1 ? (St - lt) / (ht - 1) : 1, pt = 0, ft = 0, vt;
        this.pv.length ? vt = createTypedArray("float32", this.pv.length) : vt = 0;
        for (var xt; pt < ht; ) {
          if (xt = this.getValueAtTime(lt + pt * ot), this.pv.length)
            for (ft = 0; ft < this.pv.length; ft += 1)
              vt[ft] += xt[ft];
          else
            vt += xt;
          pt += 1;
        }
        if (this.pv.length)
          for (ft = 0; ft < this.pv.length; ft += 1)
            vt[ft] /= ht;
        else
          vt /= ht;
        return vt;
      }
      function pe(ut) {
        this._transformCachingAtTime || (this._transformCachingAtTime = {
          v: new Matrix()
        });
        var ht = this._transformCachingAtTime.v;
        if (ht.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
          var it = this.a.getValueAtTime(ut);
          ht.translate(-it[0] * this.a.mult, -it[1] * this.a.mult, it[2] * this.a.mult);
        }
        if (this.appliedTransformations < 2) {
          var lt = this.s.getValueAtTime(ut);
          ht.scale(lt[0] * this.s.mult, lt[1] * this.s.mult, lt[2] * this.s.mult);
        }
        if (this.sk && this.appliedTransformations < 3) {
          var St = this.sk.getValueAtTime(ut), ot = this.sa.getValueAtTime(ut);
          ht.skewFromAxis(-St * this.sk.mult, ot * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var pt = this.r.getValueAtTime(ut);
          ht.rotate(-pt * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var ft = this.rz.getValueAtTime(ut), vt = this.ry.getValueAtTime(ut), xt = this.rx.getValueAtTime(ut), Ct = this.or.getValueAtTime(ut);
          ht.rotateZ(-ft * this.rz.mult).rotateY(vt * this.ry.mult).rotateX(xt * this.rx.mult).rotateZ(-Ct[2] * this.or.mult).rotateY(Ct[1] * this.or.mult).rotateX(Ct[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var At = this.px.getValueAtTime(ut), kt = this.py.getValueAtTime(ut);
          if (this.data.p.z) {
            var Vt = this.pz.getValueAtTime(ut);
            ht.translate(At * this.px.mult, kt * this.py.mult, -Vt * this.pz.mult);
          } else
            ht.translate(At * this.px.mult, kt * this.py.mult, 0);
        } else {
          var ir = this.p.getValueAtTime(ut);
          ht.translate(ir[0] * this.p.mult, ir[1] * this.p.mult, -ir[2] * this.p.mult);
        }
        return ht;
      }
      function me() {
        return this.v.clone(new Matrix());
      }
      var ge = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function(ut, ht, it) {
        var lt = ge(ut, ht, it);
        return lt.dynamicProperties.length ? lt.getValueAtTime = pe.bind(lt) : lt.getValueAtTime = me.bind(lt), lt.setGroupProperty = expressionHelpers.setGroupProperty, lt;
      };
      var be = PropertyFactory.getProp;
      PropertyFactory.getProp = function(ut, ht, it, lt, St) {
        var ot = be(ut, ht, it, lt, St);
        ot.kf ? ot.getValueAtTime = expressionHelpers.getValueAtTime.bind(ot) : ot.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(ot), ot.setGroupProperty = expressionHelpers.setGroupProperty, ot.loopOut = L, ot.loopIn = ne, ot.smooth = oe, ot.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(ot), ot.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ot), ot.numKeys = ht.a === 1 ? ht.k.length : 0, ot.propertyIndex = ht.ix;
        var pt = 0;
        return it !== 0 && (pt = createTypedArray("float32", ht.a === 1 ? ht.k[0].s.length : ht.k.length)), ot._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: pt
        }, expressionHelpers.searchExpressions(ut, ht, ot), ot.k && St.addDynamicProperty(ot), ot;
      };
      function Ie(ut) {
        return this._cachingAtTime || (this._cachingAtTime = {
          shapeValue: shapePool.clone(this.pv),
          lastIndex: 0,
          lastTime: initialDefaultFrame
        }), ut *= this.elem.globalData.frameRate, ut -= this.offsetTime, ut !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < ut ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = ut, this.interpolateShape(ut, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue;
      }
      var Ae = ShapePropertyFactory.getConstructorFunction(), rt = ShapePropertyFactory.getKeyframedConstructorFunction();
      function st() {
      }
      st.prototype = {
        vertices: function(ht, it) {
          this.k && this.getValue();
          var lt = this.v;
          it !== void 0 && (lt = this.getValueAtTime(it, 0));
          var St, ot = lt._length, pt = lt[ht], ft = lt.v, vt = createSizedArray(ot);
          for (St = 0; St < ot; St += 1)
            ht === "i" || ht === "o" ? vt[St] = [pt[St][0] - ft[St][0], pt[St][1] - ft[St][1]] : vt[St] = [pt[St][0], pt[St][1]];
          return vt;
        },
        points: function(ht) {
          return this.vertices("v", ht);
        },
        inTangents: function(ht) {
          return this.vertices("i", ht);
        },
        outTangents: function(ht) {
          return this.vertices("o", ht);
        },
        isClosed: function() {
          return this.v.c;
        },
        pointOnPath: function(ht, it) {
          var lt = this.v;
          it !== void 0 && (lt = this.getValueAtTime(it, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(lt));
          for (var St = this._segmentsLength, ot = St.lengths, pt = St.totalLength * ht, ft = 0, vt = ot.length, xt = 0, Ct; ft < vt; ) {
            if (xt + ot[ft].addedLength > pt) {
              var At = ft, kt = lt.c && ft === vt - 1 ? 0 : ft + 1, Vt = (pt - xt) / ot[ft].addedLength;
              Ct = bez.getPointInSegment(lt.v[At], lt.v[kt], lt.o[At], lt.i[kt], Vt, ot[ft]);
              break;
            } else
              xt += ot[ft].addedLength;
            ft += 1;
          }
          return Ct || (Ct = lt.c ? [lt.v[0][0], lt.v[0][1]] : [lt.v[lt._length - 1][0], lt.v[lt._length - 1][1]]), Ct;
        },
        vectorOnPath: function(ht, it, lt) {
          ht == 1 ? ht = this.v.c : ht == 0 && (ht = 0.999);
          var St = this.pointOnPath(ht, it), ot = this.pointOnPath(ht + 1e-3, it), pt = ot[0] - St[0], ft = ot[1] - St[1], vt = Math.sqrt(Math.pow(pt, 2) + Math.pow(ft, 2));
          if (vt === 0)
            return [0, 0];
          var xt = lt === "tangent" ? [pt / vt, ft / vt] : [-ft / vt, pt / vt];
          return xt;
        },
        tangentOnPath: function(ht, it) {
          return this.vectorOnPath(ht, it, "tangent");
        },
        normalOnPath: function(ht, it) {
          return this.vectorOnPath(ht, it, "normal");
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime
      }, extendPrototype([st], Ae), extendPrototype([st], rt), rt.prototype.getValueAtTime = Ie, rt.prototype.initiateExpression = ExpressionManager.initiateExpression;
      var dt = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function(ut, ht, it, lt, St) {
        var ot = dt(ut, ht, it, lt, St);
        return ot.propertyIndex = ht.ix, ot.lock = !1, it === 3 ? expressionHelpers.searchExpressions(ut, ht.pt, ot) : it === 4 && expressionHelpers.searchExpressions(ut, ht.ks, ot), ot.k && ut.addDynamicProperty(ot), ot;
      };
    }
    function initialize$1() {
      addPropertyDecorator();
    }
    function addDecorator() {
      function L() {
        return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null;
      }
      TextProperty.prototype.getExpressionValue = function(ne, oe) {
        var pe = this.calculateExpression(oe);
        if (ne.t !== pe) {
          var me = {};
          return this.copyData(me, ne), me.t = pe.toString(), me.__complete = !1, me;
        }
        return ne;
      }, TextProperty.prototype.searchProperty = function() {
        var ne = this.searchKeyframes(), oe = this.searchExpressions();
        return this.kf = ne || oe, this.kf;
      }, TextProperty.prototype.searchExpressions = L;
    }
    function initialize() {
      addDecorator();
    }
    function SVGComposableEffect() {
    }
    SVGComposableEffect.prototype = {
      createMergeNode: function L(ne, oe) {
        var pe = createNS("feMerge");
        pe.setAttribute("result", ne);
        var me, ge;
        for (ge = 0; ge < oe.length; ge += 1)
          me = createNS("feMergeNode"), me.setAttribute("in", oe[ge]), pe.appendChild(me), pe.appendChild(me);
        return pe;
      }
    };
    var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
    function SVGTintFilter(L, ne, oe, pe, me) {
      this.filterManager = ne;
      var ge = createNS("feColorMatrix");
      ge.setAttribute("type", "matrix"), ge.setAttribute("color-interpolation-filters", "linearRGB"), ge.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = ge, ge.setAttribute("result", pe + "_tint_1"), L.appendChild(ge), ge = createNS("feColorMatrix"), ge.setAttribute("type", "matrix"), ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), ge.setAttribute("result", pe + "_tint_2"), L.appendChild(ge), this.matrixFilter = ge;
      var be = this.createMergeNode(pe, [me, pe + "_tint_1", pe + "_tint_2"]);
      L.appendChild(be);
    }
    extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[0].p.v, oe = this.filterManager.effectElements[1].p.v, pe = this.filterManager.effectElements[2].p.v / 100;
        this.linearFilter.setAttribute("values", linearFilterValue + " " + pe + " 0"), this.matrixFilter.setAttribute("values", oe[0] - ne[0] + " 0 0 0 " + ne[0] + " " + (oe[1] - ne[1]) + " 0 0 0 " + ne[1] + " " + (oe[2] - ne[2]) + " 0 0 0 " + ne[2] + " 0 0 0 1 0");
      }
    };
    function SVGFillFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = createNS("feColorMatrix");
      me.setAttribute("type", "matrix"), me.setAttribute("color-interpolation-filters", "sRGB"), me.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), me.setAttribute("result", pe), L.appendChild(me), this.matrixFilter = me;
    }
    SVGFillFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[2].p.v, oe = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute("values", "0 0 0 0 " + ne[0] + " 0 0 0 0 " + ne[1] + " 0 0 0 0 " + ne[2] + " 0 0 0 " + oe + " 0");
      }
    };
    function SVGStrokeEffect(L, ne, oe) {
      this.initialized = !1, this.filterManager = ne, this.elem = oe, this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function() {
      var L = this.elem.layerElement.children || this.elem.layerElement.childNodes, ne, oe, pe, me;
      for (this.filterManager.effectElements[1].p.v === 1 ? (me = this.elem.maskManager.masksProperties.length, pe = 0) : (pe = this.filterManager.effectElements[0].p.v - 1, me = pe + 1), oe = createNS("g"), oe.setAttribute("fill", "none"), oe.setAttribute("stroke-linecap", "round"), oe.setAttribute("stroke-dashoffset", 1), pe; pe < me; pe += 1)
        ne = createNS("path"), oe.appendChild(ne), this.paths.push({
          p: ne,
          m: pe
        });
      if (this.filterManager.effectElements[10].p.v === 3) {
        var ge = createNS("mask"), be = createElementID();
        ge.setAttribute("id", be), ge.setAttribute("mask-type", "alpha"), ge.appendChild(oe), this.elem.globalData.defs.appendChild(ge);
        var Ie = createNS("g");
        for (Ie.setAttribute("mask", "url(" + getLocationHref() + "#" + be + ")"); L[0]; )
          Ie.appendChild(L[0]);
        this.elem.layerElement.appendChild(Ie), this.masker = ge, oe.setAttribute("stroke", "#fff");
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2)
          for (L = this.elem.layerElement.children || this.elem.layerElement.childNodes; L.length; )
            this.elem.layerElement.removeChild(L[0]);
        this.elem.layerElement.appendChild(oe), this.elem.layerElement.removeAttribute("mask"), oe.setAttribute("stroke", "#fff");
      }
      this.initialized = !0, this.pathMasker = oe;
    }, SVGStrokeEffect.prototype.renderFrame = function(L) {
      this.initialized || this.initialize();
      var ne, oe = this.paths.length, pe, me;
      for (ne = 0; ne < oe; ne += 1)
        if (this.paths[ne].m !== -1 && (pe = this.elem.maskManager.viewData[this.paths[ne].m], me = this.paths[ne].p, (L || this.filterManager._mdf || pe.prop._mdf) && me.setAttribute("d", pe.lastPath), L || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || pe.prop._mdf)) {
          var ge;
          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
            var be = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, Ie = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, Ae = me.getTotalLength();
            ge = "0 0 0 " + Ae * be + " ";
            var rt = Ae * (Ie - be), st = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01, dt = Math.floor(rt / st), ut;
            for (ut = 0; ut < dt; ut += 1)
              ge += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
            ge += "0 " + Ae * 10 + " 0 0";
          } else
            ge = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          me.setAttribute("stroke-dasharray", ge);
        }
      if ((L || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (L || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (L || this.filterManager.effectElements[3].p._mdf)) {
        var ht = this.filterManager.effectElements[3].p.v;
        this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(ht[0] * 255) + "," + bmFloor(ht[1] * 255) + "," + bmFloor(ht[2] * 255) + ")");
      }
    };
    function SVGTritoneFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = createNS("feColorMatrix");
      me.setAttribute("type", "matrix"), me.setAttribute("color-interpolation-filters", "linearRGB"), me.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), L.appendChild(me);
      var ge = createNS("feComponentTransfer");
      ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("result", pe), this.matrixFilter = ge;
      var be = createNS("feFuncR");
      be.setAttribute("type", "table"), ge.appendChild(be), this.feFuncR = be;
      var Ie = createNS("feFuncG");
      Ie.setAttribute("type", "table"), ge.appendChild(Ie), this.feFuncG = Ie;
      var Ae = createNS("feFuncB");
      Ae.setAttribute("type", "table"), ge.appendChild(Ae), this.feFuncB = Ae, L.appendChild(ge);
    }
    SVGTritoneFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[0].p.v, oe = this.filterManager.effectElements[1].p.v, pe = this.filterManager.effectElements[2].p.v, me = pe[0] + " " + oe[0] + " " + ne[0], ge = pe[1] + " " + oe[1] + " " + ne[1], be = pe[2] + " " + oe[2] + " " + ne[2];
        this.feFuncR.setAttribute("tableValues", me), this.feFuncG.setAttribute("tableValues", ge), this.feFuncB.setAttribute("tableValues", be);
      }
    };
    function SVGProLevelsFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = this.filterManager.effectElements, ge = createNS("feComponentTransfer");
      (me[10].p.k || me[10].p.v !== 0 || me[11].p.k || me[11].p.v !== 1 || me[12].p.k || me[12].p.v !== 1 || me[13].p.k || me[13].p.v !== 0 || me[14].p.k || me[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", ge)), (me[17].p.k || me[17].p.v !== 0 || me[18].p.k || me[18].p.v !== 1 || me[19].p.k || me[19].p.v !== 1 || me[20].p.k || me[20].p.v !== 0 || me[21].p.k || me[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", ge)), (me[24].p.k || me[24].p.v !== 0 || me[25].p.k || me[25].p.v !== 1 || me[26].p.k || me[26].p.v !== 1 || me[27].p.k || me[27].p.v !== 0 || me[28].p.k || me[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", ge)), (me[31].p.k || me[31].p.v !== 0 || me[32].p.k || me[32].p.v !== 1 || me[33].p.k || me[33].p.v !== 1 || me[34].p.k || me[34].p.v !== 0 || me[35].p.k || me[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", ge)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (ge.setAttribute("color-interpolation-filters", "sRGB"), L.appendChild(ge)), (me[3].p.k || me[3].p.v !== 0 || me[4].p.k || me[4].p.v !== 1 || me[5].p.k || me[5].p.v !== 1 || me[6].p.k || me[6].p.v !== 0 || me[7].p.k || me[7].p.v !== 1) && (ge = createNS("feComponentTransfer"), ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("result", pe), L.appendChild(ge), this.feFuncRComposed = this.createFeFunc("feFuncR", ge), this.feFuncGComposed = this.createFeFunc("feFuncG", ge), this.feFuncBComposed = this.createFeFunc("feFuncB", ge));
    }
    SVGProLevelsFilter.prototype.createFeFunc = function(L, ne) {
      var oe = createNS(L);
      return oe.setAttribute("type", "table"), ne.appendChild(oe), oe;
    }, SVGProLevelsFilter.prototype.getTableValue = function(L, ne, oe, pe, me) {
      for (var ge = 0, be = 256, Ie, Ae = Math.min(L, ne), rt = Math.max(L, ne), st = Array.call(null, {
        length: be
      }), dt, ut = 0, ht = me - pe, it = ne - L; ge <= 256; )
        Ie = ge / 256, Ie <= Ae ? dt = it < 0 ? me : pe : Ie >= rt ? dt = it < 0 ? pe : me : dt = pe + ht * Math.pow((Ie - L) / it, 1 / oe), st[ut] = dt, ut += 1, ge += 256 / (be - 1);
      return st.join(" ");
    }, SVGProLevelsFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne, oe = this.filterManager.effectElements;
        this.feFuncRComposed && (L || oe[3].p._mdf || oe[4].p._mdf || oe[5].p._mdf || oe[6].p._mdf || oe[7].p._mdf) && (ne = this.getTableValue(oe[3].p.v, oe[4].p.v, oe[5].p.v, oe[6].p.v, oe[7].p.v), this.feFuncRComposed.setAttribute("tableValues", ne), this.feFuncGComposed.setAttribute("tableValues", ne), this.feFuncBComposed.setAttribute("tableValues", ne)), this.feFuncR && (L || oe[10].p._mdf || oe[11].p._mdf || oe[12].p._mdf || oe[13].p._mdf || oe[14].p._mdf) && (ne = this.getTableValue(oe[10].p.v, oe[11].p.v, oe[12].p.v, oe[13].p.v, oe[14].p.v), this.feFuncR.setAttribute("tableValues", ne)), this.feFuncG && (L || oe[17].p._mdf || oe[18].p._mdf || oe[19].p._mdf || oe[20].p._mdf || oe[21].p._mdf) && (ne = this.getTableValue(oe[17].p.v, oe[18].p.v, oe[19].p.v, oe[20].p.v, oe[21].p.v), this.feFuncG.setAttribute("tableValues", ne)), this.feFuncB && (L || oe[24].p._mdf || oe[25].p._mdf || oe[26].p._mdf || oe[27].p._mdf || oe[28].p._mdf) && (ne = this.getTableValue(oe[24].p.v, oe[25].p.v, oe[26].p.v, oe[27].p.v, oe[28].p.v), this.feFuncB.setAttribute("tableValues", ne)), this.feFuncA && (L || oe[31].p._mdf || oe[32].p._mdf || oe[33].p._mdf || oe[34].p._mdf || oe[35].p._mdf) && (ne = this.getTableValue(oe[31].p.v, oe[32].p.v, oe[33].p.v, oe[34].p.v, oe[35].p.v), this.feFuncA.setAttribute("tableValues", ne));
      }
    };
    function SVGDropShadowEffect(L, ne, oe, pe, me) {
      var ge = ne.container.globalData.renderConfig.filterSize, be = ne.data.fs || ge;
      L.setAttribute("x", be.x || ge.x), L.setAttribute("y", be.y || ge.y), L.setAttribute("width", be.width || ge.width), L.setAttribute("height", be.height || ge.height), this.filterManager = ne;
      var Ie = createNS("feGaussianBlur");
      Ie.setAttribute("in", "SourceAlpha"), Ie.setAttribute("result", pe + "_drop_shadow_1"), Ie.setAttribute("stdDeviation", "0"), this.feGaussianBlur = Ie, L.appendChild(Ie);
      var Ae = createNS("feOffset");
      Ae.setAttribute("dx", "25"), Ae.setAttribute("dy", "0"), Ae.setAttribute("in", pe + "_drop_shadow_1"), Ae.setAttribute("result", pe + "_drop_shadow_2"), this.feOffset = Ae, L.appendChild(Ae);
      var rt = createNS("feFlood");
      rt.setAttribute("flood-color", "#00ff00"), rt.setAttribute("flood-opacity", "1"), rt.setAttribute("result", pe + "_drop_shadow_3"), this.feFlood = rt, L.appendChild(rt);
      var st = createNS("feComposite");
      st.setAttribute("in", pe + "_drop_shadow_3"), st.setAttribute("in2", pe + "_drop_shadow_2"), st.setAttribute("operator", "in"), st.setAttribute("result", pe + "_drop_shadow_4"), L.appendChild(st);
      var dt = this.createMergeNode(pe, [pe + "_drop_shadow_4", me]);
      L.appendChild(dt);
    }
    extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        if ((L || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), L || this.filterManager.effectElements[0].p._mdf) {
          var ne = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(ne[0] * 255), Math.round(ne[1] * 255), Math.round(ne[2] * 255)));
        }
        if ((L || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), L || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var oe = this.filterManager.effectElements[3].p.v, pe = (this.filterManager.effectElements[2].p.v - 90) * degToRads, me = oe * Math.cos(pe), ge = oe * Math.sin(pe);
          this.feOffset.setAttribute("dx", me), this.feOffset.setAttribute("dy", ge);
        }
      }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(L, ne, oe) {
      this.initialized = !1, this.filterManager = ne, this.filterElem = L, this.elem = oe, oe.matteElement = createNS("g"), oe.matteElement.appendChild(oe.layerElement), oe.matteElement.appendChild(oe.transformedElement), oe.baseElement = oe.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function(L) {
      for (var ne = 0, oe = _svgMatteSymbols.length; ne < oe; ) {
        if (_svgMatteSymbols[ne] === L)
          return _svgMatteSymbols[ne];
        ne += 1;
      }
      return null;
    }, SVGMatte3Effect.prototype.replaceInParent = function(L, ne) {
      var oe = L.layerElement.parentNode;
      if (oe) {
        for (var pe = oe.children, me = 0, ge = pe.length; me < ge && pe[me] !== L.layerElement; )
          me += 1;
        var be;
        me <= ge - 2 && (be = pe[me + 1]);
        var Ie = createNS("use");
        Ie.setAttribute("href", "#" + ne), be ? oe.insertBefore(Ie, be) : oe.appendChild(Ie);
      }
    }, SVGMatte3Effect.prototype.setElementAsMask = function(L, ne) {
      if (!this.findSymbol(ne)) {
        var oe = createElementID(), pe = createNS("mask");
        pe.setAttribute("id", ne.layerId), pe.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(ne);
        var me = L.globalData.defs;
        me.appendChild(pe);
        var ge = createNS("symbol");
        ge.setAttribute("id", oe), this.replaceInParent(ne, oe), ge.appendChild(ne.layerElement), me.appendChild(ge);
        var be = createNS("use");
        be.setAttribute("href", "#" + oe), pe.appendChild(be), ne.data.hd = !1, ne.show();
      }
      L.setMatte(ne.layerId);
    }, SVGMatte3Effect.prototype.initialize = function() {
      for (var L = this.filterManager.effectElements[0].p.v, ne = this.elem.comp.elements, oe = 0, pe = ne.length; oe < pe; )
        ne[oe] && ne[oe].data.ind === L && this.setElementAsMask(this.elem, ne[oe]), oe += 1;
      this.initialized = !0;
    }, SVGMatte3Effect.prototype.renderFrame = function() {
      this.initialized || this.initialize();
    };
    function SVGGaussianBlurEffect(L, ne, oe, pe) {
      L.setAttribute("x", "-100%"), L.setAttribute("y", "-100%"), L.setAttribute("width", "300%"), L.setAttribute("height", "300%"), this.filterManager = ne;
      var me = createNS("feGaussianBlur");
      me.setAttribute("result", pe), L.appendChild(me), this.feGaussianBlur = me;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = 0.3, oe = this.filterManager.effectElements[0].p.v * ne, pe = this.filterManager.effectElements[1].p.v, me = pe == 3 ? 0 : oe, ge = pe == 2 ? 0 : oe;
        this.feGaussianBlur.setAttribute("stdDeviation", me + " " + ge);
        var be = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
        this.feGaussianBlur.setAttribute("edgeMode", be);
      }
    };
    function TransformEffect() {
    }
    TransformEffect.prototype.init = function(L) {
      this.effectsManager = L, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix(), this.opacity = -1, this._mdf = !1, this._opMdf = !1;
    }, TransformEffect.prototype.renderFrame = function(L) {
      if (this._opMdf = !1, this._mdf = !1, L || this.effectsManager._mdf) {
        var ne = this.effectsManager.effectElements, oe = ne[0].p.v, pe = ne[1].p.v, me = ne[2].p.v === 1, ge = ne[3].p.v, be = me ? ge : ne[4].p.v, Ie = ne[5].p.v, Ae = ne[6].p.v, rt = ne[7].p.v;
        this.matrix.reset(), this.matrix.translate(-oe[0], -oe[1], oe[2]), this.matrix.scale(be * 0.01, ge * 0.01, 1), this.matrix.rotate(-rt * degToRads), this.matrix.skewFromAxis(-Ie * degToRads, (Ae + 90) * degToRads), this.matrix.translate(pe[0], pe[1], 0), this._mdf = !0, this.opacity !== ne[8].p.v && (this.opacity = ne[8].p.v, this._opMdf = !0);
      }
    };
    function SVGTransformEffect(L, ne) {
      this.init(ne);
    }
    extendPrototype([TransformEffect], SVGTransformEffect);
    function CVTransformEffect(L) {
      this.init(L);
    }
    return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie;
  });
})(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = /* @__PURE__ */ getDefaultExportFromCjs(lottieExports), LottieComponent = ({ animationData: L, height: ne, width: oe, loop: pe, autoplay: me }) => {
  const ge = useRef(null);
  let be = null;
  return useEffect(() => (be = lottie.loadAnimation({
    container: ge.current,
    // the dom element that will contain the animation
    renderer: "svg",
    loop: pe,
    autoplay: me,
    animationData: L
    // the animation data
  }), () => {
    be && (be.destroy(), be = null);
  }), [L, pe, me]), /* @__PURE__ */ React__default.createElement("div", { ref: ge, style: { height: ne, width: oe, background: "transparent" } });
}, v$3 = "5.7.4", fr = 30, ip = 0, op = 150, w$3 = 500, h$3 = 500, nm = "animation lock", ddd = 0, assets = [], layers = [
  {
    ddd: 0,
    ind: 1,
    ty: 4,
    nm: "Shape Layer 2",
    sr: 1,
    ks: {
      o: {
        a: 0,
        k: 100,
        ix: 11
      },
      r: {
        a: 0,
        k: 26,
        ix: 10
      },
      p: {
        a: 0,
        k: [
          245.00000000000003,
          250.99999999999997,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          1.163,
          -1444.186,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 0,
        k: [
          -94,
          94,
          100
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            d: 1,
            ty: "el",
            s: {
              a: 0,
              k: [
                257.836,
                257.836
              ],
              ix: 2
            },
            p: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 3
            },
            nm: "Ellipse Path 1",
            mn: "ADBE Vector Shape - Ellipse",
            hd: !1
          },
          {
            ty: "st",
            c: {
              a: 0,
              k: [
                0.9882352941176471,
                0.7254901960784313,
                0.00392156862745098,
                1
              ],
              ix: 3
            },
            o: {
              a: 0,
              k: 100,
              ix: 4
            },
            w: {
              a: 0,
              k: 17,
              ix: 5
            },
            lc: 2,
            lj: 1,
            ml: 4,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                -0.082,
                -1449.082
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Ellipse 1",
        np: 3,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      },
      {
        ty: "tm",
        s: {
          a: 1,
          k: [
            {
              i: {
                x: [
                  0.403
                ],
                y: [
                  1
                ]
              },
              o: {
                x: [
                  0.559
                ],
                y: [
                  0
                ]
              },
              t: 45,
              s: [
                100
              ]
            },
            {
              t: 61,
              s: [
                0
              ]
            }
          ],
          ix: 1
        },
        e: {
          a: 1,
          k: [
            {
              i: {
                x: [
                  3e-3
                ],
                y: [
                  1
                ]
              },
              o: {
                x: [
                  0.333
                ],
                y: [
                  0
                ]
              },
              t: 54,
              s: [
                100
              ]
            },
            {
              t: 63,
              s: [
                0
              ]
            }
          ],
          ix: 2
        },
        o: {
          a: 0,
          k: 0,
          ix: 3
        },
        m: 1,
        ix: 2,
        nm: "Trim Paths 1",
        mn: "ADBE Vector Filter - Trim",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  },
  {
    ddd: 0,
    ind: 2,
    ty: 4,
    nm: "Artwork 26 Outlines",
    sr: 1,
    ks: {
      o: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.833
              ],
              y: [
                0.833
              ]
            },
            o: {
              x: [
                0.167
              ],
              y: [
                0.167
              ]
            },
            t: 64,
            s: [
              0
            ]
          },
          {
            t: 71.5,
            s: [
              100
            ]
          }
        ],
        ix: 11
      },
      r: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.667
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 69,
            s: [
              -12
            ]
          },
          {
            i: {
              x: [
                0.667
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 75.857,
            s: [
              6
            ]
          },
          {
            t: 81,
            s: [
              0
            ]
          }
        ],
        ix: 10
      },
      p: {
        a: 0,
        k: [
          246,
          293,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          45.5,
          118.235,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.667,
                0.667,
                0.667
              ],
              y: [
                1,
                1,
                1
              ]
            },
            o: {
              x: [
                0.333,
                0.333,
                0.333
              ],
              y: [
                0,
                0,
                0
              ]
            },
            t: 64,
            s: [
              28.000000000000004,
              28.000000000000004,
              100
            ]
          },
          {
            i: {
              x: [
                0.667,
                0.667,
                0.667
              ],
              y: [
                1,
                1,
                1
              ]
            },
            o: {
              x: [
                0.333,
                0.333,
                0.333
              ],
              y: [
                0,
                0,
                0
              ]
            },
            t: 71.5,
            s: [
              104,
              104,
              100
            ]
          },
          {
            i: {
              x: [
                0.667,
                0.667,
                0.667
              ],
              y: [
                1,
                1,
                1
              ]
            },
            o: {
              x: [
                0.333,
                0.333,
                0.333
              ],
              y: [
                0,
                0,
                0
              ]
            },
            t: 77.833,
            s: [
              83,
              83,
              100
            ]
          },
          {
            t: 81,
            s: [
              94,
              94,
              100
            ]
          }
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    0.464,
                    0
                  ],
                  [
                    0.65,
                    2.47
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -15.463,
                    4.073
                  ],
                  [
                    -4.072,
                    -15.463
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    2.94,
                    -0.774
                  ],
                  [
                    0.774,
                    2.94
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    9.593,
                    -2.526
                  ],
                  [
                    -2.526,
                    -9.593
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    2.94,
                    -0.774
                  ]
                ],
                o: [
                  [
                    -2.439,
                    0
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -4.072,
                    -15.463
                  ],
                  [
                    15.463,
                    -4.072
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0.775,
                    2.94
                  ],
                  [
                    -2.937,
                    0.774
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -2.527,
                    -9.593
                  ],
                  [
                    -9.593,
                    2.527
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0.775,
                    2.939
                  ],
                  [
                    -0.469,
                    0.124
                  ]
                ],
                v: [
                  [
                    -19.195,
                    26.948
                  ],
                  [
                    -24.514,
                    22.844
                  ],
                  [
                    -28.046,
                    9.441
                  ],
                  [
                    -7.387,
                    -25.988
                  ],
                  [
                    28.042,
                    -5.331
                  ],
                  [
                    31.342,
                    7.204
                  ],
                  [
                    27.421,
                    13.929
                  ],
                  [
                    20.698,
                    10.008
                  ],
                  [
                    17.396,
                    -2.527
                  ],
                  [
                    -4.583,
                    -15.344
                  ],
                  [
                    -17.4,
                    6.637
                  ],
                  [
                    -13.869,
                    20.041
                  ],
                  [
                    -17.79,
                    26.765
                  ]
                ],
                c: !0
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "fl",
            c: {
              a: 0,
              k: [
                0.3803921568627451,
                0.3803921568627451,
                0.3803921568627451,
                1
              ],
              ix: 4
            },
            o: {
              a: 0,
              k: 100,
              ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                21.036,
                52.852
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                -19.082,
                25.904
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.833
                    ],
                    y: [
                      0.833
                    ]
                  },
                  o: {
                    x: [
                      0.167
                    ],
                    y: [
                      0.167
                    ]
                  },
                  t: 70,
                  s: [
                    -34
                  ]
                },
                {
                  i: {
                    x: [
                      0.833
                    ],
                    y: [
                      0.833
                    ]
                  },
                  o: {
                    x: [
                      0.167
                    ],
                    y: [
                      0.167
                    ]
                  },
                  t: 76,
                  s: [
                    23
                  ]
                },
                {
                  t: 83,
                  s: [
                    13
                  ]
                }
              ],
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Group 1",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      },
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    5.956,
                    0
                  ],
                  [
                    0,
                    5.954
                  ],
                  [
                    -5.953,
                    0
                  ],
                  [
                    0,
                    -5.955
                  ]
                ],
                o: [
                  [
                    -5.953,
                    0
                  ],
                  [
                    0,
                    -5.955
                  ],
                  [
                    5.956,
                    0
                  ],
                  [
                    0,
                    5.954
                  ]
                ],
                v: [
                  [
                    0,
                    12.369
                  ],
                  [
                    -10.781,
                    1.587
                  ],
                  [
                    0,
                    -9.194
                  ],
                  [
                    10.781,
                    1.587
                  ]
                ],
                c: !0
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ind: 1,
            ty: "sh",
            ix: 2,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    8.217,
                    0
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    -8.216
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -8.217,
                    0
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    8.217
                  ],
                  [
                    0,
                    0
                  ]
                ],
                o: [
                  [
                    0,
                    0
                  ],
                  [
                    -8.217,
                    0
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    8.217
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    8.217,
                    0
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    -8.216
                  ]
                ],
                v: [
                  [
                    30.402,
                    -34.757
                  ],
                  [
                    -30.402,
                    -34.757
                  ],
                  [
                    -45.343,
                    -19.817
                  ],
                  [
                    -45.343,
                    19.817
                  ],
                  [
                    -30.402,
                    34.758
                  ],
                  [
                    30.402,
                    34.758
                  ],
                  [
                    45.343,
                    19.817
                  ],
                  [
                    45.343,
                    -19.817
                  ]
                ],
                c: !0
              },
              ix: 2
            },
            nm: "Path 2",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "mm",
            mm: 1,
            nm: "Merge Paths 1",
            mn: "ADBE Vector Filter - Merge",
            hd: !1
          },
          {
            ty: "fl",
            c: {
              a: 0,
              k: [
                0.9882352941176471,
                0.7254901960784313,
                0.00392156862745098,
                1
              ],
              ix: 4
            },
            o: {
              a: 0,
              k: 100,
              ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                45.343,
                84.252
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Group 2",
        np: 6,
        cix: 2,
        bm: 0,
        ix: 2,
        mn: "ADBE Vector Group",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  },
  {
    ddd: 0,
    ind: 3,
    ty: 4,
    nm: "Shape Layer 6",
    sr: 1,
    ks: {
      o: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.833
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 81,
            s: [
              100
            ]
          },
          {
            t: 84,
            s: [
              0
            ]
          }
        ],
        ix: 11
      },
      r: {
        a: 0,
        k: 31,
        ix: 10
      },
      p: {
        a: 0,
        k: [
          306,
          229.99999999999997,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          164,
          -1393,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 0,
        k: [
          100,
          100,
          100
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                o: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                v: [
                  [
                    163.5,
                    -1393
                  ],
                  [
                    181.5,
                    -1411.5
                  ]
                ],
                c: !1
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "tm",
            s: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.667
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.333
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 79,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 1
            },
            e: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.126
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.512
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 74,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 2
            },
            o: {
              a: 0,
              k: 0,
              ix: 3
            },
            m: 1,
            ix: 2,
            nm: "Trim Paths 1",
            mn: "ADBE Vector Filter - Trim",
            hd: !1
          },
          {
            ty: "st",
            c: {
              a: 0,
              k: [
                0.788235294117647,
                0.6196078431372549,
                0.45098039215686275,
                1
              ],
              ix: 3
            },
            o: {
              a: 0,
              k: 100,
              ix: 4
            },
            w: {
              a: 0,
              k: 6,
              ix: 5
            },
            lc: 2,
            lj: 1,
            ml: 4,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Shape 1",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  },
  {
    ddd: 0,
    ind: 4,
    ty: 4,
    nm: "Shape Layer 5",
    sr: 1,
    ks: {
      o: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.833
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 81,
            s: [
              100
            ]
          },
          {
            t: 84,
            s: [
              0
            ]
          }
        ],
        ix: 11
      },
      r: {
        a: 0,
        k: 68,
        ix: 10
      },
      p: {
        a: 0,
        k: [
          302,
          248.25,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          164,
          -1393,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 0,
        k: [
          100,
          100,
          100
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                o: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                v: [
                  [
                    163.5,
                    -1393
                  ],
                  [
                    181.5,
                    -1411.5
                  ]
                ],
                c: !1
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "tm",
            s: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.667
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.333
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 79,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 1
            },
            e: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.126
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.512
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 74,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 2
            },
            o: {
              a: 0,
              k: 0,
              ix: 3
            },
            m: 1,
            ix: 2,
            nm: "Trim Paths 1",
            mn: "ADBE Vector Filter - Trim",
            hd: !1
          },
          {
            ty: "st",
            c: {
              a: 0,
              k: [
                0.788235294117647,
                0.6196078431372549,
                0.45098039215686275,
                1
              ],
              ix: 3
            },
            o: {
              a: 0,
              k: 100,
              ix: 4
            },
            w: {
              a: 0,
              k: 6,
              ix: 5
            },
            lc: 2,
            lj: 1,
            ml: 4,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Shape 1",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  },
  {
    ddd: 0,
    ind: 5,
    ty: 4,
    nm: "Shape Layer 4",
    sr: 1,
    ks: {
      o: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.833
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 81,
            s: [
              100
            ]
          },
          {
            t: 84,
            s: [
              0
            ]
          }
        ],
        ix: 11
      },
      r: {
        a: 0,
        k: -1,
        ix: 10
      },
      p: {
        a: 0,
        k: [
          292.5,
          215.75000000000003,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          164,
          -1393,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 0,
        k: [
          100,
          100,
          100
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                o: [
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    0
                  ]
                ],
                v: [
                  [
                    163.5,
                    -1393
                  ],
                  [
                    181.5,
                    -1411.5
                  ]
                ],
                c: !1
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "tm",
            s: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.667
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.333
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 79,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 1
            },
            e: {
              a: 1,
              k: [
                {
                  i: {
                    x: [
                      0.126
                    ],
                    y: [
                      1
                    ]
                  },
                  o: {
                    x: [
                      0.512
                    ],
                    y: [
                      0
                    ]
                  },
                  t: 74,
                  s: [
                    0
                  ]
                },
                {
                  t: 84,
                  s: [
                    100
                  ]
                }
              ],
              ix: 2
            },
            o: {
              a: 0,
              k: 0,
              ix: 3
            },
            m: 1,
            ix: 2,
            nm: "Trim Paths 1",
            mn: "ADBE Vector Filter - Trim",
            hd: !1
          },
          {
            ty: "st",
            c: {
              a: 0,
              k: [
                0.788235294117647,
                0.6196078431372549,
                0.45098039215686275,
                1
              ],
              ix: 3
            },
            o: {
              a: 0,
              k: 100,
              ix: 4
            },
            w: {
              a: 0,
              k: 6,
              ix: 5
            },
            lc: 2,
            lj: 1,
            ml: 4,
            bm: 0,
            nm: "Stroke 1",
            mn: "ADBE Vector Graphic - Stroke",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Shape 1",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  },
  {
    ddd: 0,
    ind: 6,
    ty: 4,
    nm: "Artwork 25 Outlines",
    sr: 1,
    ks: {
      o: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.667
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 60,
            s: [
              0
            ]
          },
          {
            t: 62,
            s: [
              100
            ]
          }
        ],
        ix: 11
      },
      r: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.274
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 64.137,
            s: [
              -48
            ]
          },
          {
            i: {
              x: [
                0.282
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.333
              ],
              y: [
                0
              ]
            },
            t: 71,
            s: [
              12
            ]
          },
          {
            i: {
              x: [
                0.833
              ],
              y: [
                1
              ]
            },
            o: {
              x: [
                0.167
              ],
              y: [
                0
              ]
            },
            t: 78,
            s: [
              0
            ]
          },
          {
            t: 83,
            s: [
              0
            ]
          }
        ],
        ix: 10
      },
      p: {
        a: 0,
        k: [
          307,
          143,
          0
        ],
        ix: 2,
        l: 2
      },
      a: {
        a: 0,
        k: [
          144.64,
          7.435,
          0
        ],
        ix: 1,
        l: 2
      },
      s: {
        a: 1,
        k: [
          {
            i: {
              x: [
                0.667,
                0.667,
                0.667
              ],
              y: [
                1,
                1,
                1
              ]
            },
            o: {
              x: [
                0.333,
                0.333,
                0.333
              ],
              y: [
                0,
                0,
                0
              ]
            },
            t: 60,
            s: [
              3,
              3,
              100
            ]
          },
          {
            i: {
              x: [
                0.667,
                0.667,
                0.667
              ],
              y: [
                1,
                1,
                1
              ]
            },
            o: {
              x: [
                0.333,
                0.333,
                0.333
              ],
              y: [
                0,
                0,
                0
              ]
            },
            t: 69.454,
            s: [
              107,
              107,
              100
            ]
          },
          {
            t: 84,
            s: [
              107,
              107,
              100
            ]
          }
        ],
        ix: 6,
        l: 2
      }
    },
    ao: 0,
    shapes: [
      {
        ty: "gr",
        it: [
          {
            ind: 0,
            ty: "sh",
            ix: 1,
            ks: {
              a: 0,
              k: {
                i: [
                  [
                    2.629,
                    0.788
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    1.165,
                    -0.35
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    -2.743
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -9.502,
                    -12.127
                  ],
                  [
                    -12.544,
                    -9.08
                  ],
                  [
                    -0.873,
                    -0.39
                  ],
                  [
                    -0.865,
                    0
                  ],
                  [
                    -0.807,
                    0.363
                  ],
                  [
                    -21.074,
                    15.254
                  ],
                  [
                    -7.257,
                    9.261
                  ],
                  [
                    0,
                    11.902
                  ],
                  [
                    0,
                    0
                  ]
                ],
                o: [
                  [
                    0,
                    0
                  ],
                  [
                    -1.165,
                    -0.35
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    -2.626,
                    0.788
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    11.902
                  ],
                  [
                    7.257,
                    9.261
                  ],
                  [
                    21.072,
                    15.254
                  ],
                  [
                    0.807,
                    0.362
                  ],
                  [
                    0.866,
                    0
                  ],
                  [
                    0.872,
                    -0.39
                  ],
                  [
                    12.543,
                    -9.08
                  ],
                  [
                    9.502,
                    -12.126
                  ],
                  [
                    0,
                    0
                  ],
                  [
                    0,
                    -2.743
                  ]
                ],
                v: [
                  [
                    84.967,
                    -80.815
                  ],
                  [
                    1.786,
                    -105.77
                  ],
                  [
                    -1.785,
                    -105.77
                  ],
                  [
                    -84.969,
                    -80.815
                  ],
                  [
                    -89.395,
                    -74.865
                  ],
                  [
                    -89.395,
                    16.636
                  ],
                  [
                    -75.075,
                    52.847
                  ],
                  [
                    -45.234,
                    80.488
                  ],
                  [
                    -2.538,
                    105.489
                  ],
                  [
                    0,
                    106.032
                  ],
                  [
                    2.539,
                    105.489
                  ],
                  [
                    45.235,
                    80.488
                  ],
                  [
                    75.075,
                    52.847
                  ],
                  [
                    89.395,
                    16.636
                  ],
                  [
                    89.395,
                    -74.865
                  ]
                ],
                c: !0
              },
              ix: 2
            },
            nm: "Path 1",
            mn: "ADBE Vector Shape - Group",
            hd: !1
          },
          {
            ty: "fl",
            c: {
              a: 0,
              k: [
                0.9882352941176471,
                0.9215686274509803,
                0.7333333333333333,
                1
              ],
              ix: 4
            },
            o: {
              a: 0,
              k: 100,
              ix: 5
            },
            r: 1,
            bm: 0,
            nm: "Fill 1",
            mn: "ADBE Vector Graphic - Fill",
            hd: !1
          },
          {
            ty: "tr",
            p: {
              a: 0,
              k: [
                89.395,
                106.032
              ],
              ix: 2
            },
            a: {
              a: 0,
              k: [
                0,
                0
              ],
              ix: 1
            },
            s: {
              a: 0,
              k: [
                100,
                100
              ],
              ix: 3
            },
            r: {
              a: 0,
              k: 0,
              ix: 6
            },
            o: {
              a: 0,
              k: 100,
              ix: 7
            },
            sk: {
              a: 0,
              k: 0,
              ix: 4
            },
            sa: {
              a: 0,
              k: 0,
              ix: 5
            },
            nm: "Transform"
          }
        ],
        nm: "Group 1",
        np: 4,
        cix: 2,
        bm: 0,
        ix: 1,
        mn: "ADBE Vector Group",
        hd: !1
      }
    ],
    ip: -9,
    op: 291,
    st: -9,
    bm: 0
  }
], markers = [], Lock = {
  v: v$3,
  fr,
  ip,
  op,
  w: w$3,
  h: h$3,
  nm,
  ddd,
  assets,
  layers,
  markers
}, NoAccess = () => /* @__PURE__ */ React__default.createElement("div", { className: "h-screen w-screen flex justify-center text-center items-start pt-32" }, /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement(
  LottieComponent,
  {
    animationData: Lock,
    loop: !1,
    autoplay: !0,
    height: 400,
    width: 400
  }
), /* @__PURE__ */ React__default.createElement("span", { className: "text-5xl" }, "403"), /* @__PURE__ */ React__default.createElement("div", { className: "text-3xl pt-2" }, "Permission Denied"), /* @__PURE__ */ React__default.createElement("div", { className: "text-3xl " }, "You have no access to this page"))), MainNavbar = ({ NotificationPanel: L, ThreeBarsSVG: ne, systemName: oe, threeBarsOnClick: pe, notificationCondition: me }) => /* @__PURE__ */ React__default.createElement("header", { className: "w-full flex flex-1 flex-col  md:ml-20 fixed top-0 z-50 shadow-md" }, /* @__PURE__ */ React__default.createElement("div", { className: "relative z-10 flex h-16 flex-shrink-0 w-full border-b border-gray-200 bg-white shadow-sm " }, /* @__PURE__ */ React__default.createElement(
  "button",
  {
    type: "button",
    className: "border-r border-gray-200 px-4 text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500 md:hidden",
    onClick: pe
  },
  /* @__PURE__ */ React__default.createElement("span", { className: "sr-only" }, "Open sidebar"),
  typeof ne == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-6 w-6", src: ne }) : ne
), /* @__PURE__ */ React__default.createElement("div", { className: "flex justify-between items-center lg:gap-x-16 px-4 sm:px-6 w-11/12" }, /* @__PURE__ */ React__default.createElement("div", { className: " text-sm font-bold leading-7 text-gray-700 sm:truncate sm:text-lg sm:tracking-tight mr-2" }, /* @__PURE__ */ React__default.createElement("span", { className: "text-goldd" }, "GOLD "), "TIGER", " ", oe), /* @__PURE__ */ React__default.createElement("div", { className: me }, typeof L == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-6 w-6", src: L }) : L)))), AccordionContext = createContext({
  accordionRef: null,
  items: {},
  setItems: (L) => {
  },
  transition: null,
  alwaysOpen: !1
}), Accordion = ({ children: L, as: ne = "div", className: oe = "", transition: pe = void 0, alwaysOpen: me = !1 }) => {
  const ge = useRef(null), [be, Ie] = useState({}), Ae = useMemo(() => ne || "div", [ne]), rt = useMemo(() => ({
    accordionRef: ge,
    items: be,
    setItems: Ie,
    transition: pe,
    alwaysOpen: me
  }), [me, be, pe]);
  return React__default.createElement(
    AccordionContext.Provider,
    { value: rt },
    React__default.createElement(Ae, { className: oe }, L)
  );
}, AccordionItemContext = createContext({
  accordionRef: null,
  active: !1,
  items: {},
  hash: "",
  transition: null,
  alwaysOpen: !1,
  toggle: () => {
  },
  isActive: !1
}), AccordionItem = ({ children: L, isActive: ne = !1 }) => {
  const { accordionRef: oe, items: pe, setItems: me, transition: ge, alwaysOpen: be } = useContext(AccordionContext), [Ie, Ae] = useState(!1), rt = useMemo(() => Math.random().toString(36).substring(2, 9), []);
  useEffect(() => {
    rt in pe || me({ ...pe, [rt]: Ae });
  }, [pe]);
  const st = useMemo(() => ({
    accordionRef: oe,
    active: Ie,
    toggle: () => Ae(!Ie),
    items: pe,
    hash: rt,
    transition: ge,
    alwaysOpen: be,
    isActive: ne
  }), [oe, Ie, be, rt, ne, pe, ge]);
  return React__default.createElement(AccordionItemContext.Provider, { value: st }, typeof L == "function" ? L({ open: Ie }) : L);
}, AccordionHeader = ({ children: L, as: ne = "button", className: oe = "", href: pe = "", onClick: me }) => {
  const { hash: ge, toggle: be, items: Ie, alwaysOpen: Ae, isActive: rt } = useContext(AccordionItemContext), st = useRef(null), dt = useMemo(() => ne || "button", [ne]);
  return useEffect(() => {
    if (rt && st && st.current) {
      be();
      const ut = st.current;
      ut.setAttribute("aria-expanded", "true");
      const ht = document.querySelector(`#${ut.getAttribute("aria-controls")}`);
      ht && (ht.style.maxHeight = "none");
    }
  }, []), useEffect(() => {
    const ut = (it) => {
      let lt = it.getAttribute("aria-expanded");
      it.setAttribute("aria-expanded", lt === "false" ? "true" : "false");
    }, ht = (it) => {
      if (it) {
        const lt = () => {
          it.style.maxHeight !== "0px" && (it.style.maxHeight = "none"), it.removeEventListener("transitionend", lt);
        };
        it.addEventListener("transitionend", lt), it.style.maxHeight === "0px" ? it.style.maxHeight = it.scrollHeight + "px" : (it.style.maxHeight = it.scrollHeight + "px", it.style.maxHeight = it.scrollHeight + "px", it.style.maxHeight = "0px");
      }
    };
    if (st && st.current) {
      const it = st == null ? void 0 : st.current, lt = (St) => {
        var pt;
        if (dt === "a" && St.preventDefault(), be(), !Ae) {
          const ft = (pt = it.parentNode) == null ? void 0 : pt.querySelectorAll(`:scope > ${dt}[aria-expanded='true']`);
          ft && ft.forEach((vt) => {
            if (vt && vt !== it) {
              const xt = vt.id.split("-")[1];
              Ie[xt](!1), ut(vt);
              const Ct = document.querySelector(`#${vt.getAttribute("aria-controls")}`);
              Ct && ht(Ct);
            }
          });
        }
        ut(it);
        const ot = document.querySelector(`#${it.getAttribute("aria-controls")}`);
        ht(ot), me && me(St);
      };
      return it && it.addEventListener("click", lt), () => {
        it && it.removeEventListener("click", lt);
      };
    }
    return () => {
    };
  }, [dt, Ae, Ie, me, be]), dt === "a" ? React__default.createElement("a", { ref: st, id: `button-${ge}`, href: pe, "aria-expanded": "false", className: oe, "aria-controls": `content-${ge}` }, L) : React__default.createElement(dt, { ref: st, id: `button-${ge}`, "aria-expanded": "false", className: oe, "aria-controls": `content-${ge}` }, L);
}, AccordionBody = ({ children: L, as: ne = "div", className: oe = "" }) => {
  const { hash: pe, transition: me } = useContext(AccordionItemContext), ge = useMemo(() => ne || "div", [ne]), be = useMemo(() => {
    const Ie = {
      duration: "300ms",
      timingFunction: "cubic-bezier(0, 0, 0.2, 1)"
    };
    return me && "duration" in me && me.duration && (Ie.duration = me.duration), me && "timingFunction" in me && me.timingFunction && (Ie.timingFunction = me.timingFunction), Ie;
  }, [me]);
  return React__default.createElement(ge, { id: `content-${pe}`, "aria-labelledby": `button-${pe}`, className: oe, style: {
    maxHeight: "0px",
    transitionProperty: "max-height",
    overflow: "hidden",
    transitionDuration: be.duration,
    transitionTimingFunction: be.timingFunction
  } }, L);
};
var reactDom = { exports: {} }, reactDom_development = {}, scheduler = { exports: {} }, scheduler_development = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_development;
function requireScheduler_development() {
  return hasRequiredScheduler_development || (hasRequiredScheduler_development = 1, function(L) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ne = !1, oe = !1, pe = 5;
      function me(vr, Dr) {
        var Jr = vr.length;
        vr.push(Dr), Ie(vr, Dr, Jr);
      }
      function ge(vr) {
        return vr.length === 0 ? null : vr[0];
      }
      function be(vr) {
        if (vr.length === 0)
          return null;
        var Dr = vr[0], Jr = vr.pop();
        return Jr !== Dr && (vr[0] = Jr, Ae(vr, Jr, 0)), Dr;
      }
      function Ie(vr, Dr, Jr) {
        for (var mn = Jr; mn > 0; ) {
          var kn = mn - 1 >>> 1, bi = vr[kn];
          if (rt(bi, Dr) > 0)
            vr[kn] = Dr, vr[mn] = bi, mn = kn;
          else
            return;
        }
      }
      function Ae(vr, Dr, Jr) {
        for (var mn = Jr, kn = vr.length, bi = kn >>> 1; mn < bi; ) {
          var ri = (mn + 1) * 2 - 1, ba = vr[ri], vn = ri + 1, Ba = vr[vn];
          if (rt(ba, Dr) < 0)
            vn < kn && rt(Ba, ba) < 0 ? (vr[mn] = Ba, vr[vn] = Dr, mn = vn) : (vr[mn] = ba, vr[ri] = Dr, mn = ri);
          else if (vn < kn && rt(Ba, Dr) < 0)
            vr[mn] = Ba, vr[vn] = Dr, mn = vn;
          else
            return;
        }
      }
      function rt(vr, Dr) {
        var Jr = vr.sortIndex - Dr.sortIndex;
        return Jr !== 0 ? Jr : vr.id - Dr.id;
      }
      var st = 1, dt = 2, ut = 3, ht = 4, it = 5;
      function lt(vr, Dr) {
      }
      var St = typeof performance == "object" && typeof performance.now == "function";
      if (St) {
        var ot = performance;
        L.unstable_now = function() {
          return ot.now();
        };
      } else {
        var pt = Date, ft = pt.now();
        L.unstable_now = function() {
          return pt.now() - ft;
        };
      }
      var vt = 1073741823, xt = -1, Ct = 250, At = 5e3, kt = 1e4, Vt = vt, ir = [], er = [], Yt = 1, Jt = null, rr = ut, Qt = !1, wt = !1, Ft = !1, yt = typeof setTimeout == "function" ? setTimeout : null, Et = typeof clearTimeout == "function" ? clearTimeout : null, Dt = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ot(vr) {
        for (var Dr = ge(er); Dr !== null; ) {
          if (Dr.callback === null)
            be(er);
          else if (Dr.startTime <= vr)
            be(er), Dr.sortIndex = Dr.expirationTime, me(ir, Dr);
          else
            return;
          Dr = ge(er);
        }
      }
      function nr(vr) {
        if (Ft = !1, Ot(vr), !wt)
          if (ge(ir) !== null)
            wt = !0, ti(yr);
          else {
            var Dr = ge(er);
            Dr !== null && wn(nr, Dr.startTime - vr);
          }
      }
      function yr(vr, Dr) {
        wt = !1, Ft && (Ft = !1, pi()), Qt = !0;
        var Jr = rr;
        try {
          var mn;
          if (!oe)
            return mr(vr, Dr);
        } finally {
          Jt = null, rr = Jr, Qt = !1;
        }
      }
      function mr(vr, Dr) {
        var Jr = Dr;
        for (Ot(Jr), Jt = ge(ir); Jt !== null && !ne && !(Jt.expirationTime > Jr && (!vr || ki())); ) {
          var mn = Jt.callback;
          if (typeof mn == "function") {
            Jt.callback = null, rr = Jt.priorityLevel;
            var kn = Jt.expirationTime <= Jr, bi = mn(kn);
            Jr = L.unstable_now(), typeof bi == "function" ? Jt.callback = bi : Jt === ge(ir) && be(ir), Ot(Jr);
          } else
            be(ir);
          Jt = ge(ir);
        }
        if (Jt !== null)
          return !0;
        var ri = ge(er);
        return ri !== null && wn(nr, ri.startTime - Jr), !1;
      }
      function Tr(vr, Dr) {
        switch (vr) {
          case st:
          case dt:
          case ut:
          case ht:
          case it:
            break;
          default:
            vr = ut;
        }
        var Jr = rr;
        rr = vr;
        try {
          return Dr();
        } finally {
          rr = Jr;
        }
      }
      function Nr(vr) {
        var Dr;
        switch (rr) {
          case st:
          case dt:
          case ut:
            Dr = ut;
            break;
          default:
            Dr = rr;
            break;
        }
        var Jr = rr;
        rr = Dr;
        try {
          return vr();
        } finally {
          rr = Jr;
        }
      }
      function cn(vr) {
        var Dr = rr;
        return function() {
          var Jr = rr;
          rr = Dr;
          try {
            return vr.apply(this, arguments);
          } finally {
            rr = Jr;
          }
        };
      }
      function en(vr, Dr, Jr) {
        var mn = L.unstable_now(), kn;
        if (typeof Jr == "object" && Jr !== null) {
          var bi = Jr.delay;
          typeof bi == "number" && bi > 0 ? kn = mn + bi : kn = mn;
        } else
          kn = mn;
        var ri;
        switch (vr) {
          case st:
            ri = xt;
            break;
          case dt:
            ri = Ct;
            break;
          case it:
            ri = Vt;
            break;
          case ht:
            ri = kt;
            break;
          case ut:
          default:
            ri = At;
            break;
        }
        var ba = kn + ri, vn = {
          id: Yt++,
          callback: Dr,
          priorityLevel: vr,
          startTime: kn,
          expirationTime: ba,
          sortIndex: -1
        };
        return kn > mn ? (vn.sortIndex = kn, me(er, vn), ge(ir) === null && vn === ge(er) && (Ft ? pi() : Ft = !0, wn(nr, kn - mn))) : (vn.sortIndex = ba, me(ir, vn), !wt && !Qt && (wt = !0, ti(yr))), vn;
      }
      function Tn() {
      }
      function Mn() {
        !wt && !Qt && (wt = !0, ti(yr));
      }
      function $r() {
        return ge(ir);
      }
      function tn(vr) {
        vr.callback = null;
      }
      function kr() {
        return rr;
      }
      var dr = !1, zn = null, Kn = -1, Fn = pe, Jn = -1;
      function ki() {
        var vr = L.unstable_now() - Jn;
        return !(vr < Fn);
      }
      function Ei() {
      }
      function Dn(vr) {
        if (vr < 0 || vr > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        vr > 0 ? Fn = Math.floor(1e3 / vr) : Fn = pe;
      }
      var Mi = function() {
        if (zn !== null) {
          var vr = L.unstable_now();
          Jn = vr;
          var Dr = !0, Jr = !0;
          try {
            Jr = zn(Dr, vr);
          } finally {
            Jr ? Zn() : (dr = !1, zn = null);
          }
        } else
          dr = !1;
      }, Zn;
      if (typeof Dt == "function")
        Zn = function() {
          Dt(Mi);
        };
      else if (typeof MessageChannel < "u") {
        var ei = new MessageChannel(), fi = ei.port2;
        ei.port1.onmessage = Mi, Zn = function() {
          fi.postMessage(null);
        };
      } else
        Zn = function() {
          yt(Mi, 0);
        };
      function ti(vr) {
        zn = vr, dr || (dr = !0, Zn());
      }
      function wn(vr, Dr) {
        Kn = yt(function() {
          vr(L.unstable_now());
        }, Dr);
      }
      function pi() {
        Et(Kn), Kn = -1;
      }
      var Va = Ei, Vn = null;
      L.unstable_IdlePriority = it, L.unstable_ImmediatePriority = st, L.unstable_LowPriority = ht, L.unstable_NormalPriority = ut, L.unstable_Profiling = Vn, L.unstable_UserBlockingPriority = dt, L.unstable_cancelCallback = tn, L.unstable_continueExecution = Mn, L.unstable_forceFrameRate = Dn, L.unstable_getCurrentPriorityLevel = kr, L.unstable_getFirstCallbackNode = $r, L.unstable_next = Nr, L.unstable_pauseExecution = Tn, L.unstable_requestPaint = Va, L.unstable_runWithPriority = Tr, L.unstable_scheduleCallback = en, L.unstable_shouldYield = ki, L.unstable_wrapCallback = cn, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(scheduler_development)), scheduler_development;
}
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function(L) {
    function ne(yt, Et) {
      var Dt = yt.length;
      yt.push(Et);
      e:
        for (; 0 < Dt; ) {
          var Ot = Dt - 1 >>> 1, nr = yt[Ot];
          if (0 < me(nr, Et))
            yt[Ot] = Et, yt[Dt] = nr, Dt = Ot;
          else
            break e;
        }
    }
    function oe(yt) {
      return yt.length === 0 ? null : yt[0];
    }
    function pe(yt) {
      if (yt.length === 0)
        return null;
      var Et = yt[0], Dt = yt.pop();
      if (Dt !== Et) {
        yt[0] = Dt;
        e:
          for (var Ot = 0, nr = yt.length, yr = nr >>> 1; Ot < yr; ) {
            var mr = 2 * (Ot + 1) - 1, Tr = yt[mr], Nr = mr + 1, cn = yt[Nr];
            if (0 > me(Tr, Dt))
              Nr < nr && 0 > me(cn, Tr) ? (yt[Ot] = cn, yt[Nr] = Dt, Ot = Nr) : (yt[Ot] = Tr, yt[mr] = Dt, Ot = mr);
            else if (Nr < nr && 0 > me(cn, Dt))
              yt[Ot] = cn, yt[Nr] = Dt, Ot = Nr;
            else
              break e;
          }
      }
      return Et;
    }
    function me(yt, Et) {
      var Dt = yt.sortIndex - Et.sortIndex;
      return Dt !== 0 ? Dt : yt.id - Et.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var ge = performance;
      L.unstable_now = function() {
        return ge.now();
      };
    } else {
      var be = Date, Ie = be.now();
      L.unstable_now = function() {
        return be.now() - Ie;
      };
    }
    var Ae = [], rt = [], st = 1, dt = null, ut = 3, ht = !1, it = !1, lt = !1, St = typeof setTimeout == "function" ? setTimeout : null, ot = typeof clearTimeout == "function" ? clearTimeout : null, pt = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function ft(yt) {
      for (var Et = oe(rt); Et !== null; ) {
        if (Et.callback === null)
          pe(rt);
        else if (Et.startTime <= yt)
          pe(rt), Et.sortIndex = Et.expirationTime, ne(Ae, Et);
        else
          break;
        Et = oe(rt);
      }
    }
    function vt(yt) {
      if (lt = !1, ft(yt), !it)
        if (oe(Ae) !== null)
          it = !0, wt(xt);
        else {
          var Et = oe(rt);
          Et !== null && Ft(vt, Et.startTime - yt);
        }
    }
    function xt(yt, Et) {
      it = !1, lt && (lt = !1, ot(kt), kt = -1), ht = !0;
      var Dt = ut;
      try {
        for (ft(Et), dt = oe(Ae); dt !== null && (!(dt.expirationTime > Et) || yt && !er()); ) {
          var Ot = dt.callback;
          if (typeof Ot == "function") {
            dt.callback = null, ut = dt.priorityLevel;
            var nr = Ot(dt.expirationTime <= Et);
            Et = L.unstable_now(), typeof nr == "function" ? dt.callback = nr : dt === oe(Ae) && pe(Ae), ft(Et);
          } else
            pe(Ae);
          dt = oe(Ae);
        }
        if (dt !== null)
          var yr = !0;
        else {
          var mr = oe(rt);
          mr !== null && Ft(vt, mr.startTime - Et), yr = !1;
        }
        return yr;
      } finally {
        dt = null, ut = Dt, ht = !1;
      }
    }
    var Ct = !1, At = null, kt = -1, Vt = 5, ir = -1;
    function er() {
      return !(L.unstable_now() - ir < Vt);
    }
    function Yt() {
      if (At !== null) {
        var yt = L.unstable_now();
        ir = yt;
        var Et = !0;
        try {
          Et = At(!0, yt);
        } finally {
          Et ? Jt() : (Ct = !1, At = null);
        }
      } else
        Ct = !1;
    }
    var Jt;
    if (typeof pt == "function")
      Jt = function() {
        pt(Yt);
      };
    else if (typeof MessageChannel < "u") {
      var rr = new MessageChannel(), Qt = rr.port2;
      rr.port1.onmessage = Yt, Jt = function() {
        Qt.postMessage(null);
      };
    } else
      Jt = function() {
        St(Yt, 0);
      };
    function wt(yt) {
      At = yt, Ct || (Ct = !0, Jt());
    }
    function Ft(yt, Et) {
      kt = St(function() {
        yt(L.unstable_now());
      }, Et);
    }
    L.unstable_IdlePriority = 5, L.unstable_ImmediatePriority = 1, L.unstable_LowPriority = 4, L.unstable_NormalPriority = 3, L.unstable_Profiling = null, L.unstable_UserBlockingPriority = 2, L.unstable_cancelCallback = function(yt) {
      yt.callback = null;
    }, L.unstable_continueExecution = function() {
      it || ht || (it = !0, wt(xt));
    }, L.unstable_forceFrameRate = function(yt) {
      0 > yt || 125 < yt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Vt = 0 < yt ? Math.floor(1e3 / yt) : 5;
    }, L.unstable_getCurrentPriorityLevel = function() {
      return ut;
    }, L.unstable_getFirstCallbackNode = function() {
      return oe(Ae);
    }, L.unstable_next = function(yt) {
      switch (ut) {
        case 1:
        case 2:
        case 3:
          var Et = 3;
          break;
        default:
          Et = ut;
      }
      var Dt = ut;
      ut = Et;
      try {
        return yt();
      } finally {
        ut = Dt;
      }
    }, L.unstable_pauseExecution = function() {
    }, L.unstable_requestPaint = function() {
    }, L.unstable_runWithPriority = function(yt, Et) {
      switch (yt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          yt = 3;
      }
      var Dt = ut;
      ut = yt;
      try {
        return Et();
      } finally {
        ut = Dt;
      }
    }, L.unstable_scheduleCallback = function(yt, Et, Dt) {
      var Ot = L.unstable_now();
      switch (typeof Dt == "object" && Dt !== null ? (Dt = Dt.delay, Dt = typeof Dt == "number" && 0 < Dt ? Ot + Dt : Ot) : Dt = Ot, yt) {
        case 1:
          var nr = -1;
          break;
        case 2:
          nr = 250;
          break;
        case 5:
          nr = 1073741823;
          break;
        case 4:
          nr = 1e4;
          break;
        default:
          nr = 5e3;
      }
      return nr = Dt + nr, yt = { id: st++, callback: Et, priorityLevel: yt, startTime: Dt, expirationTime: nr, sortIndex: -1 }, Dt > Ot ? (yt.sortIndex = Dt, ne(rt, yt), oe(Ae) === null && yt === oe(rt) && (lt ? (ot(kt), kt = -1) : lt = !0, Ft(vt, Dt - Ot))) : (yt.sortIndex = nr, ne(Ae, yt), it || ht || (it = !0, wt(xt))), yt;
    }, L.unstable_shouldYield = er, L.unstable_wrapCallback = function(yt) {
      var Et = ut;
      return function() {
        var Dt = ut;
        ut = Et;
        try {
          return yt.apply(this, arguments);
        } finally {
          ut = Dt;
        }
      };
    };
  }(scheduler_production_min)), scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  return hasRequiredScheduler || (hasRequiredScheduler = 1, process.env.NODE_ENV === "production" ? scheduler.exports = requireScheduler_production_min() : scheduler.exports = requireScheduler_development()), scheduler.exports;
}
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_development;
function requireReactDom_development() {
  return hasRequiredReactDom_development || (hasRequiredReactDom_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var L = React__default, ne = requireScheduler(), oe = L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, pe = !1;
    function me(re) {
      pe = re;
    }
    function ge(re) {
      if (!pe) {
        for (var ie = arguments.length, he = new Array(ie > 1 ? ie - 1 : 0), ve = 1; ve < ie; ve++)
          he[ve - 1] = arguments[ve];
        Ie("warn", re, he);
      }
    }
    function be(re) {
      if (!pe) {
        for (var ie = arguments.length, he = new Array(ie > 1 ? ie - 1 : 0), ve = 1; ve < ie; ve++)
          he[ve - 1] = arguments[ve];
        Ie("error", re, he);
      }
    }
    function Ie(re, ie, he) {
      {
        var ve = oe.ReactDebugCurrentFrame, Ce = ve.getStackAddendum();
        Ce !== "" && (ie += "%s", he = he.concat([Ce]));
        var ke = he.map(function(at) {
          return String(at);
        });
        ke.unshift("Warning: " + ie), Function.prototype.apply.call(console[re], console, ke);
      }
    }
    var Ae = 0, rt = 1, st = 2, dt = 3, ut = 4, ht = 5, it = 6, lt = 7, St = 8, ot = 9, pt = 10, ft = 11, vt = 12, xt = 13, Ct = 14, At = 15, kt = 16, Vt = 17, ir = 18, er = 19, Yt = 21, Jt = 22, rr = 23, Qt = 24, wt = 25, Ft = !0, yt = !1, Et = !1, Dt = !1, Ot = !1, nr = !0, yr = !1, mr = !1, Tr = !0, Nr = !0, cn = !0, en = /* @__PURE__ */ new Set(), Tn = {}, Mn = {};
    function $r(re, ie) {
      tn(re, ie), tn(re + "Capture", ie);
    }
    function tn(re, ie) {
      Tn[re] && be("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", re), Tn[re] = ie;
      {
        var he = re.toLowerCase();
        Mn[he] = re, re === "onDoubleClick" && (Mn.ondblclick = re);
      }
      for (var ve = 0; ve < ie.length; ve++)
        en.add(ie[ve]);
    }
    var kr = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", dr = Object.prototype.hasOwnProperty;
    function zn(re) {
      {
        var ie = typeof Symbol == "function" && Symbol.toStringTag, he = ie && re[Symbol.toStringTag] || re.constructor.name || "Object";
        return he;
      }
    }
    function Kn(re) {
      try {
        return Fn(re), !1;
      } catch {
        return !0;
      }
    }
    function Fn(re) {
      return "" + re;
    }
    function Jn(re, ie) {
      if (Kn(re))
        return be("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, zn(re)), Fn(re);
    }
    function ki(re) {
      if (Kn(re))
        return be("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", zn(re)), Fn(re);
    }
    function Ei(re, ie) {
      if (Kn(re))
        return be("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, zn(re)), Fn(re);
    }
    function Dn(re, ie) {
      if (Kn(re))
        return be("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, zn(re)), Fn(re);
    }
    function Mi(re) {
      if (Kn(re))
        return be("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", zn(re)), Fn(re);
    }
    function Zn(re) {
      if (Kn(re))
        return be("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", zn(re)), Fn(re);
    }
    var ei = 0, fi = 1, ti = 2, wn = 3, pi = 4, Va = 5, Vn = 6, vr = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Dr = vr + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Jr = new RegExp("^[" + vr + "][" + Dr + "]*$"), mn = {}, kn = {};
    function bi(re) {
      return dr.call(kn, re) ? !0 : dr.call(mn, re) ? !1 : Jr.test(re) ? (kn[re] = !0, !0) : (mn[re] = !0, be("Invalid attribute name: `%s`", re), !1);
    }
    function ri(re, ie, he) {
      return ie !== null ? ie.type === ei : he ? !1 : re.length > 2 && (re[0] === "o" || re[0] === "O") && (re[1] === "n" || re[1] === "N");
    }
    function ba(re, ie, he, ve) {
      if (he !== null && he.type === ei)
        return !1;
      switch (typeof ie) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (ve)
            return !1;
          if (he !== null)
            return !he.acceptsBooleans;
          var Ce = re.toLowerCase().slice(0, 5);
          return Ce !== "data-" && Ce !== "aria-";
        }
        default:
          return !1;
      }
    }
    function vn(re, ie, he, ve) {
      if (ie === null || typeof ie > "u" || ba(re, ie, he, ve))
        return !0;
      if (ve)
        return !1;
      if (he !== null)
        switch (he.type) {
          case wn:
            return !ie;
          case pi:
            return ie === !1;
          case Va:
            return isNaN(ie);
          case Vn:
            return isNaN(ie) || ie < 1;
        }
      return !1;
    }
    function Ba(re) {
      return Bn.hasOwnProperty(re) ? Bn[re] : null;
    }
    function ni(re, ie, he, ve, Ce, ke, at) {
      this.acceptsBooleans = ie === ti || ie === wn || ie === pi, this.attributeName = ve, this.attributeNamespace = Ce, this.mustUseProperty = he, this.propertyName = re, this.type = ie, this.sanitizeURL = ke, this.removeEmptyString = at;
    }
    var Bn = {}, su = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    su.forEach(function(re) {
      Bn[re] = new ni(
        re,
        ei,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(re) {
      var ie = re[0], he = re[1];
      Bn[ie] = new ni(
        ie,
        fi,
        !1,
        // mustUseProperty
        he,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(re) {
      Bn[re] = new ni(
        re,
        ti,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(re) {
      Bn[re] = new ni(
        re,
        ti,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(re) {
      Bn[re] = new ni(
        re,
        wn,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Bn[re] = new ni(
        re,
        wn,
        !0,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Bn[re] = new ni(
        re,
        pi,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Bn[re] = new ni(
        re,
        Vn,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(re) {
      Bn[re] = new ni(
        re,
        Va,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Lo = /[\-\:]([a-z])/g, Ms = function(re) {
      return re[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Lo, Ms);
      Bn[ie] = new ni(
        ie,
        fi,
        !1,
        // mustUseProperty
        re,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Lo, Ms);
      Bn[ie] = new ni(
        ie,
        fi,
        !1,
        // mustUseProperty
        re,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Lo, Ms);
      Bn[ie] = new ni(
        ie,
        fi,
        !1,
        // mustUseProperty
        re,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(re) {
      Bn[re] = new ni(
        re,
        fi,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var lu = "xlinkHref";
    Bn[lu] = new ni(
      "xlinkHref",
      fi,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(re) {
      Bn[re] = new ni(
        re,
        fi,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var uu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, $o = !1;
    function df(re) {
      !$o && uu.test(re) && ($o = !0, be("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(re)));
    }
    function hl(re, ie, he, ve) {
      if (ve.mustUseProperty) {
        var Ce = ve.propertyName;
        return re[Ce];
      } else {
        Jn(he, ie), ve.sanitizeURL && df("" + he);
        var ke = ve.attributeName, at = null;
        if (ve.type === pi) {
          if (re.hasAttribute(ke)) {
            var mt = re.getAttribute(ke);
            return mt === "" ? !0 : vn(ie, he, ve, !1) ? mt : mt === "" + he ? he : mt;
          }
        } else if (re.hasAttribute(ke)) {
          if (vn(ie, he, ve, !1))
            return re.getAttribute(ke);
          if (ve.type === wn)
            return he;
          at = re.getAttribute(ke);
        }
        return vn(ie, he, ve, !1) ? at === null ? he : at : at === "" + he ? he : at;
      }
    }
    function fu(re, ie, he, ve) {
      {
        if (!bi(ie))
          return;
        if (!re.hasAttribute(ie))
          return he === void 0 ? void 0 : null;
        var Ce = re.getAttribute(ie);
        return Jn(he, ie), Ce === "" + he ? he : Ce;
      }
    }
    function ts(re, ie, he, ve) {
      var Ce = Ba(ie);
      if (!ri(ie, Ce, ve)) {
        if (vn(ie, he, Ce, ve) && (he = null), ve || Ce === null) {
          if (bi(ie)) {
            var ke = ie;
            he === null ? re.removeAttribute(ke) : (Jn(he, ie), re.setAttribute(ke, "" + he));
          }
          return;
        }
        var at = Ce.mustUseProperty;
        if (at) {
          var mt = Ce.propertyName;
          if (he === null) {
            var gt = Ce.type;
            re[mt] = gt === wn ? !1 : "";
          } else
            re[mt] = he;
          return;
        }
        var Tt = Ce.attributeName, Pt = Ce.attributeNamespace;
        if (he === null)
          re.removeAttribute(Tt);
        else {
          var Nt = Ce.type, $t;
          Nt === wn || Nt === pi && he === !0 ? $t = "" : (Jn(he, Tt), $t = "" + he, Ce.sanitizeURL && df($t.toString())), Pt ? re.setAttributeNS(Pt, Tt, $t) : re.setAttribute(Tt, $t);
        }
      }
    }
    var Fs = Symbol.for("react.element"), xa = Symbol.for("react.portal"), Ha = Symbol.for("react.fragment"), Ca = Symbol.for("react.strict_mode"), pl = Symbol.for("react.profiler"), hf = Symbol.for("react.provider"), pf = Symbol.for("react.context"), Ds = Symbol.for("react.forward_ref"), ro = Symbol.for("react.suspense"), sa = Symbol.for("react.suspense_list"), Os = Symbol.for("react.memo"), Hi = Symbol.for("react.lazy"), Sc = Symbol.for("react.scope"), Ec = Symbol.for("react.debug_trace_mode"), mf = Symbol.for("react.offscreen"), Io = Symbol.for("react.legacy_hidden"), ch = Symbol.for("react.cache"), dh = Symbol.for("react.tracing_marker"), Hn = Symbol.iterator, hh = "@@iterator";
    function wo(re) {
      if (re === null || typeof re != "object")
        return null;
      var ie = Hn && re[Hn] || re[hh];
      return typeof ie == "function" ? ie : null;
    }
    var Kr = Object.assign, No = 0, bc, no, ml, Ua, xc, Ta, Cc;
    function Tc() {
    }
    Tc.__reactDisabledLog = !0;
    function cu() {
      {
        if (No === 0) {
          bc = console.log, no = console.info, ml = console.warn, Ua = console.error, xc = console.group, Ta = console.groupCollapsed, Cc = console.groupEnd;
          var re = {
            configurable: !0,
            enumerable: !0,
            value: Tc,
            writable: !0
          };
          Object.defineProperties(console, {
            info: re,
            log: re,
            warn: re,
            error: re,
            group: re,
            groupCollapsed: re,
            groupEnd: re
          });
        }
        No++;
      }
    }
    function du() {
      {
        if (No--, No === 0) {
          var re = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Kr({}, re, {
              value: bc
            }),
            info: Kr({}, re, {
              value: no
            }),
            warn: Kr({}, re, {
              value: ml
            }),
            error: Kr({}, re, {
              value: Ua
            }),
            group: Kr({}, re, {
              value: xc
            }),
            groupCollapsed: Kr({}, re, {
              value: Ta
            }),
            groupEnd: Kr({}, re, {
              value: Cc
            })
          });
        }
        No < 0 && be("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var io = oe.ReactCurrentDispatcher, zo;
    function wa(re, ie, he) {
      {
        if (zo === void 0)
          try {
            throw Error();
          } catch (Ce) {
            var ve = Ce.stack.trim().match(/\n( *(at )?)/);
            zo = ve && ve[1] || "";
          }
        return `
` + zo + re;
      }
    }
    var vf = !1, hu;
    {
      var yf = typeof WeakMap == "function" ? WeakMap : Map;
      hu = new yf();
    }
    function pu(re, ie) {
      if (!re || vf)
        return "";
      {
        var he = hu.get(re);
        if (he !== void 0)
          return he;
      }
      var ve;
      vf = !0;
      var Ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ke;
      ke = io.current, io.current = null, cu();
      try {
        if (ie) {
          var at = function() {
            throw Error();
          };
          if (Object.defineProperty(at.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(at, []);
            } catch (Wt) {
              ve = Wt;
            }
            Reflect.construct(re, [], at);
          } else {
            try {
              at.call();
            } catch (Wt) {
              ve = Wt;
            }
            re.call(at.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Wt) {
            ve = Wt;
          }
          re();
        }
      } catch (Wt) {
        if (Wt && ve && typeof Wt.stack == "string") {
          for (var mt = Wt.stack.split(`
`), gt = ve.stack.split(`
`), Tt = mt.length - 1, Pt = gt.length - 1; Tt >= 1 && Pt >= 0 && mt[Tt] !== gt[Pt]; )
            Pt--;
          for (; Tt >= 1 && Pt >= 0; Tt--, Pt--)
            if (mt[Tt] !== gt[Pt]) {
              if (Tt !== 1 || Pt !== 1)
                do
                  if (Tt--, Pt--, Pt < 0 || mt[Tt] !== gt[Pt]) {
                    var Nt = `
` + mt[Tt].replace(" at new ", " at ");
                    return re.displayName && Nt.includes("<anonymous>") && (Nt = Nt.replace("<anonymous>", re.displayName)), typeof re == "function" && hu.set(re, Nt), Nt;
                  }
                while (Tt >= 1 && Pt >= 0);
              break;
            }
        }
      } finally {
        vf = !1, io.current = ke, du(), Error.prepareStackTrace = Ce;
      }
      var $t = re ? re.displayName || re.name : "", Gt = $t ? wa($t) : "";
      return typeof re == "function" && hu.set(re, Gt), Gt;
    }
    function mu(re, ie, he) {
      return pu(re, !0);
    }
    function rs(re, ie, he) {
      return pu(re, !1);
    }
    function ph(re) {
      var ie = re.prototype;
      return !!(ie && ie.isReactComponent);
    }
    function Ls(re, ie, he) {
      if (re == null)
        return "";
      if (typeof re == "function")
        return pu(re, ph(re));
      if (typeof re == "string")
        return wa(re);
      switch (re) {
        case ro:
          return wa("Suspense");
        case sa:
          return wa("SuspenseList");
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case Ds:
            return rs(re.render);
          case Os:
            return Ls(re.type, ie, he);
          case Hi: {
            var ve = re, Ce = ve._payload, ke = ve._init;
            try {
              return Ls(ke(Ce), ie, he);
            } catch {
            }
          }
        }
      return "";
    }
    function un(re) {
      switch (re._debugOwner && re._debugOwner.type, re._debugSource, re.tag) {
        case ht:
          return wa(re.type);
        case kt:
          return wa("Lazy");
        case xt:
          return wa("Suspense");
        case er:
          return wa("SuspenseList");
        case Ae:
        case st:
        case At:
          return rs(re.type);
        case ft:
          return rs(re.type.render);
        case rt:
          return mu(re.type);
        default:
          return "";
      }
    }
    function Vo(re) {
      try {
        var ie = "", he = re;
        do
          ie += un(he), he = he.return;
        while (he);
        return ie;
      } catch (ve) {
        return `
Error generating stack: ` + ve.message + `
` + ve.stack;
      }
    }
    function wc(re, ie, he) {
      var ve = re.displayName;
      if (ve)
        return ve;
      var Ce = ie.displayName || ie.name || "";
      return Ce !== "" ? he + "(" + Ce + ")" : he;
    }
    function vu(re) {
      return re.displayName || "Context";
    }
    function an(re) {
      if (re == null)
        return null;
      if (typeof re.tag == "number" && be("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof re == "function")
        return re.displayName || re.name || null;
      if (typeof re == "string")
        return re;
      switch (re) {
        case Ha:
          return "Fragment";
        case xa:
          return "Portal";
        case pl:
          return "Profiler";
        case Ca:
          return "StrictMode";
        case ro:
          return "Suspense";
        case sa:
          return "SuspenseList";
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case pf:
            var ie = re;
            return vu(ie) + ".Consumer";
          case hf:
            var he = re;
            return vu(he._context) + ".Provider";
          case Ds:
            return wc(re, re.render, "ForwardRef");
          case Os:
            var ve = re.displayName || null;
            return ve !== null ? ve : an(re.type) || "Memo";
          case Hi: {
            var Ce = re, ke = Ce._payload, at = Ce._init;
            try {
              return an(at(ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function _c(re, ie, he) {
      var ve = ie.displayName || ie.name || "";
      return re.displayName || (ve !== "" ? he + "(" + ve + ")" : he);
    }
    function gf(re) {
      return re.displayName || "Context";
    }
    function Wr(re) {
      var ie = re.tag, he = re.type;
      switch (ie) {
        case Qt:
          return "Cache";
        case ot:
          var ve = he;
          return gf(ve) + ".Consumer";
        case pt:
          var Ce = he;
          return gf(Ce._context) + ".Provider";
        case ir:
          return "DehydratedFragment";
        case ft:
          return _c(he, he.render, "ForwardRef");
        case lt:
          return "Fragment";
        case ht:
          return he;
        case ut:
          return "Portal";
        case dt:
          return "Root";
        case it:
          return "Text";
        case kt:
          return an(he);
        case St:
          return he === Ca ? "StrictMode" : "Mode";
        case Jt:
          return "Offscreen";
        case vt:
          return "Profiler";
        case Yt:
          return "Scope";
        case xt:
          return "Suspense";
        case er:
          return "SuspenseList";
        case wt:
          return "TracingMarker";
        case rt:
        case Ae:
        case Vt:
        case st:
        case Ct:
        case At:
          if (typeof he == "function")
            return he.displayName || he.name || null;
          if (typeof he == "string")
            return he;
          break;
      }
      return null;
    }
    var vl = oe.ReactDebugCurrentFrame, ii = null, mi = !1;
    function la() {
      {
        if (ii === null)
          return null;
        var re = ii._debugOwner;
        if (re !== null && typeof re < "u")
          return Wr(re);
      }
      return null;
    }
    function yl() {
      return ii === null ? "" : Vo(ii);
    }
    function Un() {
      vl.getCurrentStack = null, ii = null, mi = !1;
    }
    function yn(re) {
      vl.getCurrentStack = re === null ? null : yl, ii = re, mi = !1;
    }
    function Sf() {
      return ii;
    }
    function ja(re) {
      mi = re;
    }
    function xi(re) {
      return "" + re;
    }
    function _o(re) {
      switch (typeof re) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return re;
        case "object":
          return Zn(re), re;
        default:
          return "";
      }
    }
    var Ef = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function ao(re, ie) {
      Ef[ie.type] || ie.onChange || ie.onInput || ie.readOnly || ie.disabled || ie.value == null || be("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), ie.onChange || ie.readOnly || ie.disabled || ie.checked == null || be("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function yu(re) {
      var ie = re.type, he = re.nodeName;
      return he && he.toLowerCase() === "input" && (ie === "checkbox" || ie === "radio");
    }
    function Ac(re) {
      return re._valueTracker;
    }
    function gl(re) {
      re._valueTracker = null;
    }
    function Sl(re) {
      var ie = "";
      return re && (yu(re) ? ie = re.checked ? "true" : "false" : ie = re.value), ie;
    }
    function Rt(re) {
      var ie = yu(re) ? "checked" : "value", he = Object.getOwnPropertyDescriptor(re.constructor.prototype, ie);
      Zn(re[ie]);
      var ve = "" + re[ie];
      if (!(re.hasOwnProperty(ie) || typeof he > "u" || typeof he.get != "function" || typeof he.set != "function")) {
        var Ce = he.get, ke = he.set;
        Object.defineProperty(re, ie, {
          configurable: !0,
          get: function() {
            return Ce.call(this);
          },
          set: function(mt) {
            Zn(mt), ve = "" + mt, ke.call(this, mt);
          }
        }), Object.defineProperty(re, ie, {
          enumerable: he.enumerable
        });
        var at = {
          getValue: function() {
            return ve;
          },
          setValue: function(mt) {
            Zn(mt), ve = "" + mt;
          },
          stopTracking: function() {
            gl(re), delete re[ie];
          }
        };
        return at;
      }
    }
    function zt(re) {
      Ac(re) || (re._valueTracker = Rt(re));
    }
    function ar(re) {
      if (!re)
        return !1;
      var ie = Ac(re);
      if (!ie)
        return !0;
      var he = ie.getValue(), ve = Sl(re);
      return ve !== he ? (ie.setValue(ve), !0) : !1;
    }
    function Sr(re) {
      if (re = re || (typeof document < "u" ? document : void 0), typeof re > "u")
        return null;
      try {
        return re.activeElement || re.body;
      } catch {
        return re.body;
      }
    }
    var gn = !1, Gr = !1, _n = !1, ai = !1;
    function An(re) {
      var ie = re.type === "checkbox" || re.type === "radio";
      return ie ? re.checked != null : re.value != null;
    }
    function bn(re, ie) {
      var he = re, ve = ie.checked, Ce = Kr({}, ie, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: ve ?? he._wrapperState.initialChecked
      });
      return Ce;
    }
    function Ci(re, ie) {
      ao("input", ie), ie.checked !== void 0 && ie.defaultChecked !== void 0 && !Gr && (be("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", la() || "A component", ie.type), Gr = !0), ie.value !== void 0 && ie.defaultValue !== void 0 && !gn && (be("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", la() || "A component", ie.type), gn = !0);
      var he = re, ve = ie.defaultValue == null ? "" : ie.defaultValue;
      he._wrapperState = {
        initialChecked: ie.checked != null ? ie.checked : ie.defaultChecked,
        initialValue: _o(ie.value != null ? ie.value : ve),
        controlled: An(ie)
      };
    }
    function ua(re, ie) {
      var he = re, ve = ie.checked;
      ve != null && ts(he, "checked", ve, !1);
    }
    function Wn(re, ie) {
      var he = re;
      {
        var ve = An(ie);
        !he._wrapperState.controlled && ve && !ai && (be("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ai = !0), he._wrapperState.controlled && !ve && !_n && (be("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), _n = !0);
      }
      ua(re, ie);
      var Ce = _o(ie.value), ke = ie.type;
      if (Ce != null)
        ke === "number" ? (Ce === 0 && he.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        he.value != Ce) && (he.value = xi(Ce)) : he.value !== xi(Ce) && (he.value = xi(Ce));
      else if (ke === "submit" || ke === "reset") {
        he.removeAttribute("value");
        return;
      }
      ie.hasOwnProperty("value") ? Di(he, ie.type, Ce) : ie.hasOwnProperty("defaultValue") && Di(he, ie.type, _o(ie.defaultValue)), ie.checked == null && ie.defaultChecked != null && (he.defaultChecked = !!ie.defaultChecked);
    }
    function Fi(re, ie, he) {
      var ve = re;
      if (ie.hasOwnProperty("value") || ie.hasOwnProperty("defaultValue")) {
        var Ce = ie.type, ke = Ce === "submit" || Ce === "reset";
        if (ke && (ie.value === void 0 || ie.value === null))
          return;
        var at = xi(ve._wrapperState.initialValue);
        he || at !== ve.value && (ve.value = at), ve.defaultValue = at;
      }
      var mt = ve.name;
      mt !== "" && (ve.name = ""), ve.defaultChecked = !ve.defaultChecked, ve.defaultChecked = !!ve._wrapperState.initialChecked, mt !== "" && (ve.name = mt);
    }
    function fa(re, ie) {
      var he = re;
      Wn(he, ie), oi(he, ie);
    }
    function oi(re, ie) {
      var he = ie.name;
      if (ie.type === "radio" && he != null) {
        for (var ve = re; ve.parentNode; )
          ve = ve.parentNode;
        Jn(he, "name");
        for (var Ce = ve.querySelectorAll("input[name=" + JSON.stringify("" + he) + '][type="radio"]'), ke = 0; ke < Ce.length; ke++) {
          var at = Ce[ke];
          if (!(at === re || at.form !== re.form)) {
            var mt = Zv(at);
            if (!mt)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            ar(at), Wn(at, mt);
          }
        }
      }
    }
    function Di(re, ie, he) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (ie !== "number" || Sr(re.ownerDocument) !== re) && (he == null ? re.defaultValue = xi(re._wrapperState.initialValue) : re.defaultValue !== xi(he) && (re.defaultValue = xi(he)));
    }
    var oo = !1, ns = !1, El = !1;
    function is(re, ie) {
      ie.value == null && (typeof ie.children == "object" && ie.children !== null ? L.Children.forEach(ie.children, function(he) {
        he != null && (typeof he == "string" || typeof he == "number" || ns || (ns = !0, be("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : ie.dangerouslySetInnerHTML != null && (El || (El = !0, be("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), ie.selected != null && !oo && (be("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), oo = !0);
    }
    function mh(re, ie) {
      ie.value != null && re.setAttribute("value", xi(_o(ie.value)));
    }
    var bf = Array.isArray;
    function Oi(re) {
      return bf(re);
    }
    var Pc;
    Pc = !1;
    function wm() {
      var re = la();
      return re ? `

Check the render method of \`` + re + "`." : "";
    }
    var _m = ["value", "defaultValue"];
    function hg(re) {
      {
        ao("select", re);
        for (var ie = 0; ie < _m.length; ie++) {
          var he = _m[ie];
          if (re[he] != null) {
            var ve = Oi(re[he]);
            re.multiple && !ve ? be("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", he, wm()) : !re.multiple && ve && be("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", he, wm());
          }
        }
      }
    }
    function $s(re, ie, he, ve) {
      var Ce = re.options;
      if (ie) {
        for (var ke = he, at = {}, mt = 0; mt < ke.length; mt++)
          at["$" + ke[mt]] = !0;
        for (var gt = 0; gt < Ce.length; gt++) {
          var Tt = at.hasOwnProperty("$" + Ce[gt].value);
          Ce[gt].selected !== Tt && (Ce[gt].selected = Tt), Tt && ve && (Ce[gt].defaultSelected = !0);
        }
      } else {
        for (var Pt = xi(_o(he)), Nt = null, $t = 0; $t < Ce.length; $t++) {
          if (Ce[$t].value === Pt) {
            Ce[$t].selected = !0, ve && (Ce[$t].defaultSelected = !0);
            return;
          }
          Nt === null && !Ce[$t].disabled && (Nt = Ce[$t]);
        }
        Nt !== null && (Nt.selected = !0);
      }
    }
    function vh(re, ie) {
      return Kr({}, ie, {
        value: void 0
      });
    }
    function Am(re, ie) {
      var he = re;
      hg(ie), he._wrapperState = {
        wasMultiple: !!ie.multiple
      }, ie.value !== void 0 && ie.defaultValue !== void 0 && !Pc && (be("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Pc = !0);
    }
    function pg(re, ie) {
      var he = re;
      he.multiple = !!ie.multiple;
      var ve = ie.value;
      ve != null ? $s(he, !!ie.multiple, ve, !1) : ie.defaultValue != null && $s(he, !!ie.multiple, ie.defaultValue, !0);
    }
    function mg(re, ie) {
      var he = re, ve = he._wrapperState.wasMultiple;
      he._wrapperState.wasMultiple = !!ie.multiple;
      var Ce = ie.value;
      Ce != null ? $s(he, !!ie.multiple, Ce, !1) : ve !== !!ie.multiple && (ie.defaultValue != null ? $s(he, !!ie.multiple, ie.defaultValue, !0) : $s(he, !!ie.multiple, ie.multiple ? [] : "", !1));
    }
    function vg(re, ie) {
      var he = re, ve = ie.value;
      ve != null && $s(he, !!ie.multiple, ve, !1);
    }
    var yh = !1;
    function gh(re, ie) {
      var he = re;
      if (ie.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var ve = Kr({}, ie, {
        value: void 0,
        defaultValue: void 0,
        children: xi(he._wrapperState.initialValue)
      });
      return ve;
    }
    function Pm(re, ie) {
      var he = re;
      ao("textarea", ie), ie.value !== void 0 && ie.defaultValue !== void 0 && !yh && (be("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", la() || "A component"), yh = !0);
      var ve = ie.value;
      if (ve == null) {
        var Ce = ie.children, ke = ie.defaultValue;
        if (Ce != null) {
          be("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (ke != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Oi(Ce)) {
              if (Ce.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              Ce = Ce[0];
            }
            ke = Ce;
          }
        }
        ke == null && (ke = ""), ve = ke;
      }
      he._wrapperState = {
        initialValue: _o(ve)
      };
    }
    function Rm(re, ie) {
      var he = re, ve = _o(ie.value), Ce = _o(ie.defaultValue);
      if (ve != null) {
        var ke = xi(ve);
        ke !== he.value && (he.value = ke), ie.defaultValue == null && he.defaultValue !== ke && (he.defaultValue = ke);
      }
      Ce != null && (he.defaultValue = xi(Ce));
    }
    function km(re, ie) {
      var he = re, ve = he.textContent;
      ve === he._wrapperState.initialValue && ve !== "" && ve !== null && (he.value = ve);
    }
    function Sh(re, ie) {
      Rm(re, ie);
    }
    var as = "http://www.w3.org/1999/xhtml", yg = "http://www.w3.org/1998/Math/MathML", Eh = "http://www.w3.org/2000/svg";
    function Rc(re) {
      switch (re) {
        case "svg":
          return Eh;
        case "math":
          return yg;
        default:
          return as;
      }
    }
    function bh(re, ie) {
      return re == null || re === as ? Rc(ie) : re === Eh && ie === "foreignObject" ? as : re;
    }
    var gg = function(re) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ie, he, ve, Ce) {
        MSApp.execUnsafeLocalFunction(function() {
          return re(ie, he, ve, Ce);
        });
      } : re;
    }, kc, Mm = gg(function(re, ie) {
      if (re.namespaceURI === Eh && !("innerHTML" in re)) {
        kc = kc || document.createElement("div"), kc.innerHTML = "<svg>" + ie.valueOf().toString() + "</svg>";
        for (var he = kc.firstChild; re.firstChild; )
          re.removeChild(re.firstChild);
        for (; he.firstChild; )
          re.appendChild(he.firstChild);
        return;
      }
      re.innerHTML = ie;
    }), _a = 1, os = 3, vi = 8, Ao = 9, bl = 11, Mc = function(re, ie) {
      if (ie) {
        var he = re.firstChild;
        if (he && he === re.lastChild && he.nodeType === os) {
          he.nodeValue = ie;
          return;
        }
      }
      re.textContent = ie;
    }, Fm = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, gu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Dm(re, ie) {
      return re + ie.charAt(0).toUpperCase() + ie.substring(1);
    }
    var Om = ["Webkit", "ms", "Moz", "O"];
    Object.keys(gu).forEach(function(re) {
      Om.forEach(function(ie) {
        gu[Dm(ie, re)] = gu[re];
      });
    });
    function Fc(re, ie, he) {
      var ve = ie == null || typeof ie == "boolean" || ie === "";
      return ve ? "" : !he && typeof ie == "number" && ie !== 0 && !(gu.hasOwnProperty(re) && gu[re]) ? ie + "px" : (Dn(ie, re), ("" + ie).trim());
    }
    var Su = /([A-Z])/g, Sg = /^ms-/;
    function Eg(re) {
      return re.replace(Su, "-$1").toLowerCase().replace(Sg, "-ms-");
    }
    var Lm = function() {
    };
    {
      var $m = /^(?:webkit|moz|o)[A-Z]/, Im = /^-ms-/, xf = /-(.)/g, Eu = /;\s*$/, bu = {}, xu = {}, Nm = !1, xh = !1, Ch = function(re) {
        return re.replace(xf, function(ie, he) {
          return he.toUpperCase();
        });
      }, Th = function(re) {
        bu.hasOwnProperty(re) && bu[re] || (bu[re] = !0, be(
          "Unsupported style property %s. Did you mean %s?",
          re,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ch(re.replace(Im, "ms-"))
        ));
      }, zm = function(re) {
        bu.hasOwnProperty(re) && bu[re] || (bu[re] = !0, be("Unsupported vendor-prefixed style property %s. Did you mean %s?", re, re.charAt(0).toUpperCase() + re.slice(1)));
      }, Vm = function(re, ie) {
        xu.hasOwnProperty(ie) && xu[ie] || (xu[ie] = !0, be(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, re, ie.replace(Eu, "")));
      }, Bm = function(re, ie) {
        Nm || (Nm = !0, be("`NaN` is an invalid value for the `%s` css style property.", re));
      }, bg = function(re, ie) {
        xh || (xh = !0, be("`Infinity` is an invalid value for the `%s` css style property.", re));
      };
      Lm = function(re, ie) {
        re.indexOf("-") > -1 ? Th(re) : $m.test(re) ? zm(re) : Eu.test(ie) && Vm(re, ie), typeof ie == "number" && (isNaN(ie) ? Bm(re, ie) : isFinite(ie) || bg(re, ie));
      };
    }
    var xg = Lm;
    function Cg(re) {
      {
        var ie = "", he = "";
        for (var ve in re)
          if (re.hasOwnProperty(ve)) {
            var Ce = re[ve];
            if (Ce != null) {
              var ke = ve.indexOf("--") === 0;
              ie += he + (ke ? ve : Eg(ve)) + ":", ie += Fc(ve, Ce, ke), he = ";";
            }
          }
        return ie || null;
      }
    }
    function Hm(re, ie) {
      var he = re.style;
      for (var ve in ie)
        if (ie.hasOwnProperty(ve)) {
          var Ce = ve.indexOf("--") === 0;
          Ce || xg(ve, ie[ve]);
          var ke = Fc(ve, ie[ve], Ce);
          ve === "float" && (ve = "cssFloat"), Ce ? he.setProperty(ve, ke) : he[ve] = ke;
        }
    }
    function Tg(re) {
      return re == null || typeof re == "boolean" || re === "";
    }
    function so(re) {
      var ie = {};
      for (var he in re)
        for (var ve = Fm[he] || [he], Ce = 0; Ce < ve.length; Ce++)
          ie[ve[Ce]] = he;
      return ie;
    }
    function Cf(re, ie) {
      {
        if (!ie)
          return;
        var he = so(re), ve = so(ie), Ce = {};
        for (var ke in he) {
          var at = he[ke], mt = ve[ke];
          if (mt && at !== mt) {
            var gt = at + "," + mt;
            if (Ce[gt])
              continue;
            Ce[gt] = !0, be("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Tg(re[at]) ? "Removing" : "Updating", at, mt);
          }
        }
      }
    }
    var Um = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, jm = Kr({
      menuitem: !0
    }, Um), Gm = "__html";
    function Dc(re, ie) {
      if (ie) {
        if (jm[re] && (ie.children != null || ie.dangerouslySetInnerHTML != null))
          throw new Error(re + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (ie.dangerouslySetInnerHTML != null) {
          if (ie.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof ie.dangerouslySetInnerHTML != "object" || !(Gm in ie.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!ie.suppressContentEditableWarning && ie.contentEditable && ie.children != null && be("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), ie.style != null && typeof ie.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ss(re, ie) {
      if (re.indexOf("-") === -1)
        return typeof ie.is == "string";
      switch (re) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Oc = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Wm = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Po = {}, wh = new RegExp("^(aria)-[" + Dr + "]*$"), Tf = new RegExp("^(aria)[A-Z][" + Dr + "]*$");
    function _h(re, ie) {
      {
        if (dr.call(Po, ie) && Po[ie])
          return !0;
        if (Tf.test(ie)) {
          var he = "aria-" + ie.slice(4).toLowerCase(), ve = Wm.hasOwnProperty(he) ? he : null;
          if (ve == null)
            return be("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", ie), Po[ie] = !0, !0;
          if (ie !== ve)
            return be("Invalid ARIA attribute `%s`. Did you mean `%s`?", ie, ve), Po[ie] = !0, !0;
        }
        if (wh.test(ie)) {
          var Ce = ie.toLowerCase(), ke = Wm.hasOwnProperty(Ce) ? Ce : null;
          if (ke == null)
            return Po[ie] = !0, !1;
          if (ie !== ke)
            return be("Unknown ARIA attribute `%s`. Did you mean `%s`?", ie, ke), Po[ie] = !0, !0;
        }
      }
      return !0;
    }
    function qm(re, ie) {
      {
        var he = [];
        for (var ve in ie) {
          var Ce = _h(re, ve);
          Ce || he.push(ve);
        }
        var ke = he.map(function(at) {
          return "`" + at + "`";
        }).join(", ");
        he.length === 1 ? be("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ke, re) : he.length > 1 && be("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ke, re);
      }
    }
    function Lc(re, ie) {
      ss(re, ie) || qm(re, ie);
    }
    var xl = !1;
    function Ah(re, ie) {
      {
        if (re !== "input" && re !== "textarea" && re !== "select")
          return;
        ie != null && ie.value === null && !xl && (xl = !0, re === "select" && ie.multiple ? be("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", re) : be("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", re));
      }
    }
    var Ph = function() {
    };
    {
      var Li = {}, Rh = /^on./, Ym = /^on[^A-Z]/, Qm = new RegExp("^(aria)-[" + Dr + "]*$"), Xm = new RegExp("^(aria)[A-Z][" + Dr + "]*$");
      Ph = function(re, ie, he, ve) {
        if (dr.call(Li, ie) && Li[ie])
          return !0;
        var Ce = ie.toLowerCase();
        if (Ce === "onfocusin" || Ce === "onfocusout")
          return be("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Li[ie] = !0, !0;
        if (ve != null) {
          var ke = ve.registrationNameDependencies, at = ve.possibleRegistrationNames;
          if (ke.hasOwnProperty(ie))
            return !0;
          var mt = at.hasOwnProperty(Ce) ? at[Ce] : null;
          if (mt != null)
            return be("Invalid event handler property `%s`. Did you mean `%s`?", ie, mt), Li[ie] = !0, !0;
          if (Rh.test(ie))
            return be("Unknown event handler property `%s`. It will be ignored.", ie), Li[ie] = !0, !0;
        } else if (Rh.test(ie))
          return Ym.test(ie) && be("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", ie), Li[ie] = !0, !0;
        if (Qm.test(ie) || Xm.test(ie))
          return !0;
        if (Ce === "innerhtml")
          return be("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Li[ie] = !0, !0;
        if (Ce === "aria")
          return be("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Li[ie] = !0, !0;
        if (Ce === "is" && he !== null && he !== void 0 && typeof he != "string")
          return be("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof he), Li[ie] = !0, !0;
        if (typeof he == "number" && isNaN(he))
          return be("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", ie), Li[ie] = !0, !0;
        var gt = Ba(ie), Tt = gt !== null && gt.type === ei;
        if (Oc.hasOwnProperty(Ce)) {
          var Pt = Oc[Ce];
          if (Pt !== ie)
            return be("Invalid DOM property `%s`. Did you mean `%s`?", ie, Pt), Li[ie] = !0, !0;
        } else if (!Tt && ie !== Ce)
          return be("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", ie, Ce), Li[ie] = !0, !0;
        return typeof he == "boolean" && ba(ie, he, gt, !1) ? (he ? be('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', he, ie, ie, he, ie) : be('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', he, ie, ie, he, ie, ie, ie), Li[ie] = !0, !0) : Tt ? !0 : ba(ie, he, gt, !1) ? (Li[ie] = !0, !1) : ((he === "false" || he === "true") && gt !== null && gt.type === wn && (be("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", he, ie, he === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', ie, he), Li[ie] = !0), !0);
      };
    }
    var Km = function(re, ie, he) {
      {
        var ve = [];
        for (var Ce in ie) {
          var ke = Ph(re, Ce, ie[Ce], he);
          ke || ve.push(Ce);
        }
        var at = ve.map(function(mt) {
          return "`" + mt + "`";
        }).join(", ");
        ve.length === 1 ? be("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", at, re) : ve.length > 1 && be("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", at, re);
      }
    };
    function Jm(re, ie, he) {
      ss(re, ie) || Km(re, ie, he);
    }
    var ls = 1, wf = 2, Cl = 4, wg = ls | wf | Cl, _f = null;
    function Af(re) {
      _f !== null && be("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), _f = re;
    }
    function _g() {
      _f === null && be("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), _f = null;
    }
    function Zm(re) {
      return re === _f;
    }
    function $c(re) {
      var ie = re.target || re.srcElement || window;
      return ie.correspondingUseElement && (ie = ie.correspondingUseElement), ie.nodeType === os ? ie.parentNode : ie;
    }
    var Pn = null, Is = null, us = null;
    function Cu(re) {
      var ie = Qu(re);
      if (ie) {
        if (typeof Pn != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var he = ie.stateNode;
        if (he) {
          var ve = Zv(he);
          Pn(ie.stateNode, ie.type, ve);
        }
      }
    }
    function ev(re) {
      Pn = re;
    }
    function Ic(re) {
      Is ? us ? us.push(re) : us = [re] : Is = re;
    }
    function Pf() {
      return Is !== null || us !== null;
    }
    function Rf() {
      if (Is) {
        var re = Is, ie = us;
        if (Is = null, us = null, Cu(re), ie)
          for (var he = 0; he < ie.length; he++)
            Cu(ie[he]);
      }
    }
    var Tl = function(re, ie) {
      return re(ie);
    }, kh = function() {
    }, Mh = !1;
    function Ag() {
      var re = Pf();
      re && (kh(), Rf());
    }
    function Fh(re, ie, he) {
      if (Mh)
        return re(ie, he);
      Mh = !0;
      try {
        return Tl(re, ie, he);
      } finally {
        Mh = !1, Ag();
      }
    }
    function Nc(re, ie, he) {
      Tl = re, kh = he;
    }
    function zc(re) {
      return re === "button" || re === "input" || re === "select" || re === "textarea";
    }
    function Dh(re, ie, he) {
      switch (re) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(he.disabled && zc(ie));
        default:
          return !1;
      }
    }
    function wl(re, ie) {
      var he = re.stateNode;
      if (he === null)
        return null;
      var ve = Zv(he);
      if (ve === null)
        return null;
      var Ce = ve[ie];
      if (Dh(ie, re.type, ve))
        return null;
      if (Ce && typeof Ce != "function")
        throw new Error("Expected `" + ie + "` listener to be a function, instead got a value of `" + typeof Ce + "` type.");
      return Ce;
    }
    var kf = !1;
    if (kr)
      try {
        var _l = {};
        Object.defineProperty(_l, "passive", {
          get: function() {
            kf = !0;
          }
        }), window.addEventListener("test", _l, _l), window.removeEventListener("test", _l, _l);
      } catch {
        kf = !1;
      }
    function tv(re, ie, he, ve, Ce, ke, at, mt, gt) {
      var Tt = Array.prototype.slice.call(arguments, 3);
      try {
        ie.apply(he, Tt);
      } catch (Pt) {
        this.onError(Pt);
      }
    }
    var Oh = tv;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Lh = document.createElement("react");
      Oh = function(ie, he, ve, Ce, ke, at, mt, gt, Tt) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Pt = document.createEvent("Event"), Nt = !1, $t = !0, Gt = window.event, Wt = Object.getOwnPropertyDescriptor(window, "event");
        function Xt() {
          Lh.removeEventListener(Kt, Ir, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Gt);
        }
        var xr = Array.prototype.slice.call(arguments, 3);
        function Ir() {
          Nt = !0, Xt(), he.apply(ve, xr), $t = !1;
        }
        var Fr, ln = !1, nn = !1;
        function Ht(Ut) {
          if (Fr = Ut.error, ln = !0, Fr === null && Ut.colno === 0 && Ut.lineno === 0 && (nn = !0), Ut.defaultPrevented && Fr != null && typeof Fr == "object")
            try {
              Fr._suppressLogging = !0;
            } catch {
            }
        }
        var Kt = "react-" + (ie || "invokeguardedcallback");
        if (window.addEventListener("error", Ht), Lh.addEventListener(Kt, Ir, !1), Pt.initEvent(Kt, !1, !1), Lh.dispatchEvent(Pt), Wt && Object.defineProperty(window, "event", Wt), Nt && $t && (ln ? nn && (Fr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Fr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Fr)), window.removeEventListener("error", Ht), !Nt)
          return Xt(), tv.apply(this, arguments);
      };
    }
    var Pg = Oh, Ns = !1, Ro = null, Mf = !1, zs = null, Bo = {
      onError: function(re) {
        Ns = !0, Ro = re;
      }
    };
    function Al(re, ie, he, ve, Ce, ke, at, mt, gt) {
      Ns = !1, Ro = null, Pg.apply(Bo, arguments);
    }
    function fs(re, ie, he, ve, Ce, ke, at, mt, gt) {
      if (Al.apply(this, arguments), Ns) {
        var Tt = Ih();
        Mf || (Mf = !0, zs = Tt);
      }
    }
    function $h() {
      if (Mf) {
        var re = zs;
        throw Mf = !1, zs = null, re;
      }
    }
    function Rg() {
      return Ns;
    }
    function Ih() {
      if (Ns) {
        var re = Ro;
        return Ns = !1, Ro = null, re;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function lo(re) {
      return re._reactInternals;
    }
    function Ff(re) {
      return re._reactInternals !== void 0;
    }
    function Tu(re, ie) {
      re._reactInternals = ie;
    }
    var Lr = (
      /*                      */
      0
    ), Vs = (
      /*                */
      1
    ), On = (
      /*                    */
      2
    ), Qr = (
      /*                       */
      4
    ), pn = (
      /*                */
      16
    ), Sn = (
      /*                 */
      32
    ), Ho = (
      /*                     */
      64
    ), Ur = (
      /*                   */
      128
    ), si = (
      /*            */
      256
    ), Aa = (
      /*                          */
      512
    ), uo = (
      /*                     */
      1024
    ), jn = (
      /*                      */
      2048
    ), fo = (
      /*                    */
      4096
    ), Bs = (
      /*                   */
      8192
    ), Df = (
      /*             */
      16384
    ), Vc = jn | Qr | Ho | Aa | uo | Df, rv = (
      /*               */
      32767
    ), Ga = (
      /*                   */
      32768
    ), $i = (
      /*                */
      65536
    ), Of = (
      /* */
      131072
    ), Nh = (
      /*                       */
      1048576
    ), zh = (
      /*                    */
      2097152
    ), Pa = (
      /*                 */
      4194304
    ), Hs = (
      /*                */
      8388608
    ), Ra = (
      /*               */
      16777216
    ), Pl = (
      /*              */
      33554432
    ), wu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Qr | uo | 0
    ), ka = On | Qr | pn | Sn | Aa | fo | Bs, ea = Qr | Ho | Aa | Bs, co = jn | pn, Ui = Pa | Hs | zh, cs = oe.ReactCurrentOwner;
    function Wa(re) {
      var ie = re, he = re;
      if (re.alternate)
        for (; ie.return; )
          ie = ie.return;
      else {
        var ve = ie;
        do
          ie = ve, (ie.flags & (On | fo)) !== Lr && (he = ie.return), ve = ie.return;
        while (ve);
      }
      return ie.tag === dt ? he : null;
    }
    function Vh(re) {
      if (re.tag === xt) {
        var ie = re.memoizedState;
        if (ie === null) {
          var he = re.alternate;
          he !== null && (ie = he.memoizedState);
        }
        if (ie !== null)
          return ie.dehydrated;
      }
      return null;
    }
    function Bc(re) {
      return re.tag === dt ? re.stateNode.containerInfo : null;
    }
    function Bh(re) {
      return Wa(re) === re;
    }
    function qa(re) {
      {
        var ie = cs.current;
        if (ie !== null && ie.tag === rt) {
          var he = ie, ve = he.stateNode;
          ve._warnedAboutRefsInRender || be("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Wr(he) || "A component"), ve._warnedAboutRefsInRender = !0;
        }
      }
      var Ce = lo(re);
      return Ce ? Wa(Ce) === Ce : !1;
    }
    function Ma(re) {
      if (Wa(re) !== re)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ln(re) {
      var ie = re.alternate;
      if (!ie) {
        var he = Wa(re);
        if (he === null)
          throw new Error("Unable to find node on an unmounted component.");
        return he !== re ? null : re;
      }
      for (var ve = re, Ce = ie; ; ) {
        var ke = ve.return;
        if (ke === null)
          break;
        var at = ke.alternate;
        if (at === null) {
          var mt = ke.return;
          if (mt !== null) {
            ve = Ce = mt;
            continue;
          }
          break;
        }
        if (ke.child === at.child) {
          for (var gt = ke.child; gt; ) {
            if (gt === ve)
              return Ma(ke), re;
            if (gt === Ce)
              return Ma(ke), ie;
            gt = gt.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (ve.return !== Ce.return)
          ve = ke, Ce = at;
        else {
          for (var Tt = !1, Pt = ke.child; Pt; ) {
            if (Pt === ve) {
              Tt = !0, ve = ke, Ce = at;
              break;
            }
            if (Pt === Ce) {
              Tt = !0, Ce = ke, ve = at;
              break;
            }
            Pt = Pt.sibling;
          }
          if (!Tt) {
            for (Pt = at.child; Pt; ) {
              if (Pt === ve) {
                Tt = !0, ve = at, Ce = ke;
                break;
              }
              if (Pt === Ce) {
                Tt = !0, Ce = at, ve = ke;
                break;
              }
              Pt = Pt.sibling;
            }
            if (!Tt)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (ve.alternate !== Ce)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (ve.tag !== dt)
        throw new Error("Unable to find node on an unmounted component.");
      return ve.stateNode.current === ve ? re : ie;
    }
    function ho(re) {
      var ie = Ln(re);
      return ie !== null ? Hh(ie) : null;
    }
    function Hh(re) {
      if (re.tag === ht || re.tag === it)
        return re;
      for (var ie = re.child; ie !== null; ) {
        var he = Hh(ie);
        if (he !== null)
          return he;
        ie = ie.sibling;
      }
      return null;
    }
    function nv(re) {
      var ie = Ln(re);
      return ie !== null ? Hc(ie) : null;
    }
    function Hc(re) {
      if (re.tag === ht || re.tag === it)
        return re;
      for (var ie = re.child; ie !== null; ) {
        if (ie.tag !== ut) {
          var he = Hc(ie);
          if (he !== null)
            return he;
        }
        ie = ie.sibling;
      }
      return null;
    }
    var Uc = ne.unstable_scheduleCallback, iv = ne.unstable_cancelCallback, jc = ne.unstable_shouldYield, av = ne.unstable_requestPaint, qn = ne.unstable_now, Uh = ne.unstable_getCurrentPriorityLevel, Gc = ne.unstable_ImmediatePriority, Ya = ne.unstable_UserBlockingPriority, Uo = ne.unstable_NormalPriority, Wc = ne.unstable_LowPriority, Us = ne.unstable_IdlePriority, jh = ne.unstable_yieldValue, Gh = ne.unstable_setDisableYieldValue, js = null, Ii = null, hr = null, ci = !1, ji = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Wh(re) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var ie = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (ie.isDisabled)
        return !0;
      if (!ie.supportsFiber)
        return be("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Tr && (re = Kr({}, re, {
          getLaneLabelMap: Ws,
          injectProfilingHooks: hs
        })), js = ie.inject(re), Ii = ie;
      } catch (he) {
        be("React instrumentation encountered an error: %s.", he);
      }
      return !!ie.checkDCE;
    }
    function ov(re, ie) {
      if (Ii && typeof Ii.onScheduleFiberRoot == "function")
        try {
          Ii.onScheduleFiberRoot(js, re, ie);
        } catch (he) {
          ci || (ci = !0, be("React instrumentation encountered an error: %s", he));
        }
    }
    function ds(re, ie) {
      if (Ii && typeof Ii.onCommitFiberRoot == "function")
        try {
          var he = (re.current.flags & Ur) === Ur;
          if (Nr) {
            var ve;
            switch (ie) {
              case ta:
                ve = Gc;
                break;
              case Gi:
                ve = Ya;
                break;
              case ms:
                ve = Uo;
                break;
              case Uf:
                ve = Us;
                break;
              default:
                ve = Uo;
                break;
            }
            Ii.onCommitFiberRoot(js, re, ve, he);
          }
        } catch (Ce) {
          ci || (ci = !0, be("React instrumentation encountered an error: %s", Ce));
        }
    }
    function Gs(re) {
      if (Ii && typeof Ii.onPostCommitFiberRoot == "function")
        try {
          Ii.onPostCommitFiberRoot(js, re);
        } catch (ie) {
          ci || (ci = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function qh(re) {
      if (Ii && typeof Ii.onCommitFiberUnmount == "function")
        try {
          Ii.onCommitFiberUnmount(js, re);
        } catch (ie) {
          ci || (ci = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function Ti(re) {
      if (typeof jh == "function" && (Gh(re), me(re)), Ii && typeof Ii.setStrictMode == "function")
        try {
          Ii.setStrictMode(js, re);
        } catch (ie) {
          ci || (ci = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function hs(re) {
      hr = re;
    }
    function Ws() {
      {
        for (var re = /* @__PURE__ */ new Map(), ie = 1, he = 0; he < $n; he++) {
          var ve = kg(ie);
          re.set(ie, ve), ie *= 2;
        }
        return re;
      }
    }
    function qc(re) {
      hr !== null && typeof hr.markCommitStarted == "function" && hr.markCommitStarted(re);
    }
    function Yh() {
      hr !== null && typeof hr.markCommitStopped == "function" && hr.markCommitStopped();
    }
    function qs(re) {
      hr !== null && typeof hr.markComponentRenderStarted == "function" && hr.markComponentRenderStarted(re);
    }
    function Rl() {
      hr !== null && typeof hr.markComponentRenderStopped == "function" && hr.markComponentRenderStopped();
    }
    function sv(re) {
      hr !== null && typeof hr.markComponentPassiveEffectMountStarted == "function" && hr.markComponentPassiveEffectMountStarted(re);
    }
    function Qh() {
      hr !== null && typeof hr.markComponentPassiveEffectMountStopped == "function" && hr.markComponentPassiveEffectMountStopped();
    }
    function Yc(re) {
      hr !== null && typeof hr.markComponentPassiveEffectUnmountStarted == "function" && hr.markComponentPassiveEffectUnmountStarted(re);
    }
    function lv() {
      hr !== null && typeof hr.markComponentPassiveEffectUnmountStopped == "function" && hr.markComponentPassiveEffectUnmountStopped();
    }
    function uv(re) {
      hr !== null && typeof hr.markComponentLayoutEffectMountStarted == "function" && hr.markComponentLayoutEffectMountStarted(re);
    }
    function fv() {
      hr !== null && typeof hr.markComponentLayoutEffectMountStopped == "function" && hr.markComponentLayoutEffectMountStopped();
    }
    function Qc(re) {
      hr !== null && typeof hr.markComponentLayoutEffectUnmountStarted == "function" && hr.markComponentLayoutEffectUnmountStarted(re);
    }
    function _u() {
      hr !== null && typeof hr.markComponentLayoutEffectUnmountStopped == "function" && hr.markComponentLayoutEffectUnmountStopped();
    }
    function Xc(re, ie, he) {
      hr !== null && typeof hr.markComponentErrored == "function" && hr.markComponentErrored(re, ie, he);
    }
    function cv(re, ie, he) {
      hr !== null && typeof hr.markComponentSuspended == "function" && hr.markComponentSuspended(re, ie, he);
    }
    function dv(re) {
      hr !== null && typeof hr.markLayoutEffectsStarted == "function" && hr.markLayoutEffectsStarted(re);
    }
    function Au() {
      hr !== null && typeof hr.markLayoutEffectsStopped == "function" && hr.markLayoutEffectsStopped();
    }
    function hv(re) {
      hr !== null && typeof hr.markPassiveEffectsStarted == "function" && hr.markPassiveEffectsStarted(re);
    }
    function Lf() {
      hr !== null && typeof hr.markPassiveEffectsStopped == "function" && hr.markPassiveEffectsStopped();
    }
    function ko(re) {
      hr !== null && typeof hr.markRenderStarted == "function" && hr.markRenderStarted(re);
    }
    function $f() {
      hr !== null && typeof hr.markRenderYielded == "function" && hr.markRenderYielded();
    }
    function Pu() {
      hr !== null && typeof hr.markRenderStopped == "function" && hr.markRenderStopped();
    }
    function kl(re) {
      hr !== null && typeof hr.markRenderScheduled == "function" && hr.markRenderScheduled(re);
    }
    function Xh(re, ie) {
      hr !== null && typeof hr.markForceUpdateScheduled == "function" && hr.markForceUpdateScheduled(re, ie);
    }
    function Ys(re, ie) {
      hr !== null && typeof hr.markStateUpdateScheduled == "function" && hr.markStateUpdateScheduled(re, ie);
    }
    var zr = (
      /*                         */
      0
    ), Zr = (
      /*                 */
      1
    ), Vr = (
      /*                    */
      2
    ), Yn = (
      /*               */
      8
    ), po = (
      /*              */
      16
    ), Kc = Math.clz32 ? Math.clz32 : Ml, Jc = Math.log, Kh = Math.LN2;
    function Ml(re) {
      var ie = re >>> 0;
      return ie === 0 ? 32 : 31 - (Jc(ie) / Kh | 0) | 0;
    }
    var $n = 31, Zt = (
      /*                        */
      0
    ), on = (
      /*                          */
      0
    ), Br = (
      /*                        */
      1
    ), jo = (
      /*    */
      2
    ), Qa = (
      /*             */
      4
    ), Fl = (
      /*            */
      8
    ), In = (
      /*                     */
      16
    ), Dl = (
      /*                */
      32
    ), Qs = (
      /*                       */
      4194240
    ), Ol = (
      /*                        */
      64
    ), mo = (
      /*                        */
      128
    ), Fa = (
      /*                        */
      256
    ), Ll = (
      /*                        */
      512
    ), If = (
      /*                        */
      1024
    ), Nf = (
      /*                        */
      2048
    ), Zc = (
      /*                        */
      4096
    ), ed = (
      /*                        */
      8192
    ), td = (
      /*                        */
      16384
    ), rd = (
      /*                       */
      32768
    ), nd = (
      /*                       */
      65536
    ), id = (
      /*                       */
      131072
    ), ad = (
      /*                       */
      262144
    ), od = (
      /*                       */
      524288
    ), $l = (
      /*                       */
      1048576
    ), sd = (
      /*                       */
      2097152
    ), Il = (
      /*                            */
      130023424
    ), ps = (
      /*                             */
      4194304
    ), ld = (
      /*                             */
      8388608
    ), zf = (
      /*                             */
      16777216
    ), ud = (
      /*                             */
      33554432
    ), fd = (
      /*                             */
      67108864
    ), Jh = ps, Ru = (
      /*          */
      134217728
    ), cd = (
      /*                          */
      268435455
    ), ku = (
      /*               */
      268435456
    ), Xs = (
      /*                        */
      536870912
    ), Da = (
      /*                   */
      1073741824
    );
    function kg(re) {
      {
        if (re & Br)
          return "Sync";
        if (re & jo)
          return "InputContinuousHydration";
        if (re & Qa)
          return "InputContinuous";
        if (re & Fl)
          return "DefaultHydration";
        if (re & In)
          return "Default";
        if (re & Dl)
          return "TransitionHydration";
        if (re & Qs)
          return "Transition";
        if (re & Il)
          return "Retry";
        if (re & Ru)
          return "SelectiveHydration";
        if (re & ku)
          return "IdleHydration";
        if (re & Xs)
          return "Idle";
        if (re & Da)
          return "Offscreen";
      }
    }
    var Rn = -1, dd = Ol, hd = ps;
    function Mu(re) {
      switch (yi(re)) {
        case Br:
          return Br;
        case jo:
          return jo;
        case Qa:
          return Qa;
        case Fl:
          return Fl;
        case In:
          return In;
        case Dl:
          return Dl;
        case Ol:
        case mo:
        case Fa:
        case Ll:
        case If:
        case Nf:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case od:
        case $l:
        case sd:
          return re & Qs;
        case ps:
        case ld:
        case zf:
        case ud:
        case fd:
          return re & Il;
        case Ru:
          return Ru;
        case ku:
          return ku;
        case Xs:
          return Xs;
        case Da:
          return Da;
        default:
          return be("Should have found matching lanes. This is a bug in React."), re;
      }
    }
    function Vf(re, ie) {
      var he = re.pendingLanes;
      if (he === Zt)
        return Zt;
      var ve = Zt, Ce = re.suspendedLanes, ke = re.pingedLanes, at = he & cd;
      if (at !== Zt) {
        var mt = at & ~Ce;
        if (mt !== Zt)
          ve = Mu(mt);
        else {
          var gt = at & ke;
          gt !== Zt && (ve = Mu(gt));
        }
      } else {
        var Tt = he & ~Ce;
        Tt !== Zt ? ve = Mu(Tt) : ke !== Zt && (ve = Mu(ke));
      }
      if (ve === Zt)
        return Zt;
      if (ie !== Zt && ie !== ve && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (ie & Ce) === Zt) {
        var Pt = yi(ve), Nt = yi(ie);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Pt >= Nt || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Pt === In && (Nt & Qs) !== Zt
        )
          return ie;
      }
      (ve & Qa) !== Zt && (ve |= he & In);
      var $t = re.entangledLanes;
      if ($t !== Zt)
        for (var Gt = re.entanglements, Wt = ve & $t; Wt > 0; ) {
          var Xt = Ks(Wt), xr = 1 << Xt;
          ve |= Gt[Xt], Wt &= ~xr;
        }
      return ve;
    }
    function pv(re, ie) {
      for (var he = re.eventTimes, ve = Rn; ie > 0; ) {
        var Ce = Ks(ie), ke = 1 << Ce, at = he[Ce];
        at > ve && (ve = at), ie &= ~ke;
      }
      return ve;
    }
    function pd(re, ie) {
      switch (re) {
        case Br:
        case jo:
        case Qa:
          return ie + 250;
        case Fl:
        case In:
        case Dl:
        case Ol:
        case mo:
        case Fa:
        case Ll:
        case If:
        case Nf:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case od:
        case $l:
        case sd:
          return ie + 5e3;
        case ps:
        case ld:
        case zf:
        case ud:
        case fd:
          return Rn;
        case Ru:
        case ku:
        case Xs:
        case Da:
          return Rn;
        default:
          return be("Should have found matching lanes. This is a bug in React."), Rn;
      }
    }
    function Mg(re, ie) {
      for (var he = re.pendingLanes, ve = re.suspendedLanes, Ce = re.pingedLanes, ke = re.expirationTimes, at = he; at > 0; ) {
        var mt = Ks(at), gt = 1 << mt, Tt = ke[mt];
        Tt === Rn ? ((gt & ve) === Zt || (gt & Ce) !== Zt) && (ke[mt] = pd(gt, ie)) : Tt <= ie && (re.expiredLanes |= gt), at &= ~gt;
      }
    }
    function Fg(re) {
      return Mu(re.pendingLanes);
    }
    function Zh(re) {
      var ie = re.pendingLanes & ~Da;
      return ie !== Zt ? ie : ie & Da ? Da : Zt;
    }
    function Fu(re) {
      return (re & Br) !== Zt;
    }
    function Bf(re) {
      return (re & cd) !== Zt;
    }
    function md(re) {
      return (re & Il) === re;
    }
    function Dg(re) {
      var ie = Br | Qa | In;
      return (re & ie) === Zt;
    }
    function mv(re) {
      return (re & Qs) === re;
    }
    function Hf(re, ie) {
      var he = jo | Qa | Fl | In;
      return (ie & he) !== Zt;
    }
    function vv(re, ie) {
      return (ie & re.expiredLanes) !== Zt;
    }
    function ep(re) {
      return (re & Qs) !== Zt;
    }
    function tp() {
      var re = dd;
      return dd <<= 1, (dd & Qs) === Zt && (dd = Ol), re;
    }
    function Og() {
      var re = hd;
      return hd <<= 1, (hd & Il) === Zt && (hd = ps), re;
    }
    function yi(re) {
      return re & -re;
    }
    function wi(re) {
      return yi(re);
    }
    function Ks(re) {
      return 31 - Kc(re);
    }
    function vd(re) {
      return Ks(re);
    }
    function Oa(re, ie) {
      return (re & ie) !== Zt;
    }
    function Nl(re, ie) {
      return (re & ie) === ie;
    }
    function Xr(re, ie) {
      return re | ie;
    }
    function Du(re, ie) {
      return re & ~ie;
    }
    function rp(re, ie) {
      return re & ie;
    }
    function yv(re) {
      return re;
    }
    function gv(re, ie) {
      return re !== on && re < ie ? re : ie;
    }
    function yd(re) {
      for (var ie = [], he = 0; he < $n; he++)
        ie.push(re);
      return ie;
    }
    function zl(re, ie, he) {
      re.pendingLanes |= ie, ie !== Xs && (re.suspendedLanes = Zt, re.pingedLanes = Zt);
      var ve = re.eventTimes, Ce = vd(ie);
      ve[Ce] = he;
    }
    function np(re, ie) {
      re.suspendedLanes |= ie, re.pingedLanes &= ~ie;
      for (var he = re.expirationTimes, ve = ie; ve > 0; ) {
        var Ce = Ks(ve), ke = 1 << Ce;
        he[Ce] = Rn, ve &= ~ke;
      }
    }
    function ap(re, ie, he) {
      re.pingedLanes |= re.suspendedLanes & ie;
    }
    function sp(re, ie) {
      var he = re.pendingLanes & ~ie;
      re.pendingLanes = ie, re.suspendedLanes = Zt, re.pingedLanes = Zt, re.expiredLanes &= ie, re.mutableReadLanes &= ie, re.entangledLanes &= ie;
      for (var ve = re.entanglements, Ce = re.eventTimes, ke = re.expirationTimes, at = he; at > 0; ) {
        var mt = Ks(at), gt = 1 << mt;
        ve[mt] = Zt, Ce[mt] = Rn, ke[mt] = Rn, at &= ~gt;
      }
    }
    function Ou(re, ie) {
      for (var he = re.entangledLanes |= ie, ve = re.entanglements, Ce = he; Ce; ) {
        var ke = Ks(Ce), at = 1 << ke;
        // Is this one of the newly entangled lanes?
        at & ie | // Is this lane transitively entangled with the newly entangled lanes?
        ve[ke] & ie && (ve[ke] |= ie), Ce &= ~at;
      }
    }
    function Lg(re, ie) {
      var he = yi(ie), ve;
      switch (he) {
        case Qa:
          ve = jo;
          break;
        case In:
          ve = Fl;
          break;
        case Ol:
        case mo:
        case Fa:
        case Ll:
        case If:
        case Nf:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case od:
        case $l:
        case sd:
        case ps:
        case ld:
        case zf:
        case ud:
        case fd:
          ve = Dl;
          break;
        case Xs:
          ve = ku;
          break;
        default:
          ve = on;
          break;
      }
      return (ve & (re.suspendedLanes | ie)) !== on ? on : ve;
    }
    function lp(re, ie, he) {
      if (ji)
        for (var ve = re.pendingUpdatersLaneMap; he > 0; ) {
          var Ce = vd(he), ke = 1 << Ce, at = ve[Ce];
          at.add(ie), he &= ~ke;
        }
    }
    function gd(re, ie) {
      if (ji)
        for (var he = re.pendingUpdatersLaneMap, ve = re.memoizedUpdaters; ie > 0; ) {
          var Ce = vd(ie), ke = 1 << Ce, at = he[Ce];
          at.size > 0 && (at.forEach(function(mt) {
            var gt = mt.alternate;
            (gt === null || !ve.has(gt)) && ve.add(mt);
          }), at.clear()), ie &= ~ke;
        }
    }
    function up(re, ie) {
      return null;
    }
    var ta = Br, Gi = Qa, ms = In, Uf = Xs, Vl = on;
    function vo() {
      return Vl;
    }
    function _i(re) {
      Vl = re;
    }
    function jf(re, ie) {
      var he = Vl;
      try {
        return Vl = re, ie();
      } finally {
        Vl = he;
      }
    }
    function ra(re, ie) {
      return re !== 0 && re < ie ? re : ie;
    }
    function $g(re, ie) {
      return re === 0 || re > ie ? re : ie;
    }
    function fp(re, ie) {
      return re !== 0 && re < ie;
    }
    function Gf(re) {
      var ie = yi(re);
      return fp(ta, ie) ? fp(Gi, ie) ? Bf(ie) ? ms : Uf : Gi : ta;
    }
    function Ai(re) {
      var ie = re.current.memoizedState;
      return ie.isDehydrated;
    }
    var Sv;
    function wr(re) {
      Sv = re;
    }
    function Lu(re) {
      Sv(re);
    }
    var Wf;
    function Ev(re) {
      Wf = re;
    }
    var bv;
    function qf(re) {
      bv = re;
    }
    var Yf;
    function cp(re) {
      Yf = re;
    }
    var dp;
    function xv(re) {
      dp = re;
    }
    var Sd = !1, $u = [], Go = null, Gn = null, Ni = null, yo = /* @__PURE__ */ new Map(), Iu = /* @__PURE__ */ new Map(), vs = [], Mo = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Cv(re) {
      return Mo.indexOf(re) > -1;
    }
    function Wo(re, ie, he, ve, Ce) {
      return {
        blockedOn: re,
        domEventName: ie,
        eventSystemFlags: he,
        nativeEvent: Ce,
        targetContainers: [ve]
      };
    }
    function Tv(re, ie) {
      switch (re) {
        case "focusin":
        case "focusout":
          Go = null;
          break;
        case "dragenter":
        case "dragleave":
          Gn = null;
          break;
        case "mouseover":
        case "mouseout":
          Ni = null;
          break;
        case "pointerover":
        case "pointerout": {
          var he = ie.pointerId;
          yo.delete(he);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var ve = ie.pointerId;
          Iu.delete(ve);
          break;
        }
      }
    }
    function Nu(re, ie, he, ve, Ce, ke) {
      if (re === null || re.nativeEvent !== ke) {
        var at = Wo(ie, he, ve, Ce, ke);
        if (ie !== null) {
          var mt = Qu(ie);
          mt !== null && Wf(mt);
        }
        return at;
      }
      re.eventSystemFlags |= ve;
      var gt = re.targetContainers;
      return Ce !== null && gt.indexOf(Ce) === -1 && gt.push(Ce), re;
    }
    function wv(re, ie, he, ve, Ce) {
      switch (ie) {
        case "focusin": {
          var ke = Ce;
          return Go = Nu(Go, re, ie, he, ve, ke), !0;
        }
        case "dragenter": {
          var at = Ce;
          return Gn = Nu(Gn, re, ie, he, ve, at), !0;
        }
        case "mouseover": {
          var mt = Ce;
          return Ni = Nu(Ni, re, ie, he, ve, mt), !0;
        }
        case "pointerover": {
          var gt = Ce, Tt = gt.pointerId;
          return yo.set(Tt, Nu(yo.get(Tt) || null, re, ie, he, ve, gt)), !0;
        }
        case "gotpointercapture": {
          var Pt = Ce, Nt = Pt.pointerId;
          return Iu.set(Nt, Nu(Iu.get(Nt) || null, re, ie, he, ve, Pt)), !0;
        }
      }
      return !1;
    }
    function hp(re) {
      var ie = nc(re.target);
      if (ie !== null) {
        var he = Wa(ie);
        if (he !== null) {
          var ve = he.tag;
          if (ve === xt) {
            var Ce = Vh(he);
            if (Ce !== null) {
              re.blockedOn = Ce, dp(re.priority, function() {
                bv(he);
              });
              return;
            }
          } else if (ve === dt) {
            var ke = he.stateNode;
            if (Ai(ke)) {
              re.blockedOn = Bc(he);
              return;
            }
          }
        }
      }
      re.blockedOn = null;
    }
    function _v(re) {
      for (var ie = Yf(), he = {
        blockedOn: null,
        target: re,
        priority: ie
      }, ve = 0; ve < vs.length && fp(ie, vs[ve].priority); ve++)
        ;
      vs.splice(ve, 0, he), ve === 0 && hp(he);
    }
    function Ed(re) {
      if (re.blockedOn !== null)
        return !1;
      for (var ie = re.targetContainers; ie.length > 0; ) {
        var he = ie[0], ve = Bl(re.domEventName, re.eventSystemFlags, he, re.nativeEvent);
        if (ve === null) {
          var Ce = re.nativeEvent, ke = new Ce.constructor(Ce.type, Ce);
          Af(ke), Ce.target.dispatchEvent(ke), _g();
        } else {
          var at = Qu(ve);
          return at !== null && Wf(at), re.blockedOn = ve, !1;
        }
        ie.shift();
      }
      return !0;
    }
    function Qf(re, ie, he) {
      Ed(re) && he.delete(ie);
    }
    function pp() {
      Sd = !1, Go !== null && Ed(Go) && (Go = null), Gn !== null && Ed(Gn) && (Gn = null), Ni !== null && Ed(Ni) && (Ni = null), yo.forEach(Qf), Iu.forEach(Qf);
    }
    function na(re, ie) {
      re.blockedOn === ie && (re.blockedOn = null, Sd || (Sd = !0, ne.unstable_scheduleCallback(ne.unstable_NormalPriority, pp)));
    }
    function rn(re) {
      if ($u.length > 0) {
        na($u[0], re);
        for (var ie = 1; ie < $u.length; ie++) {
          var he = $u[ie];
          he.blockedOn === re && (he.blockedOn = null);
        }
      }
      Go !== null && na(Go, re), Gn !== null && na(Gn, re), Ni !== null && na(Ni, re);
      var ve = function(mt) {
        return na(mt, re);
      };
      yo.forEach(ve), Iu.forEach(ve);
      for (var Ce = 0; Ce < vs.length; Ce++) {
        var ke = vs[Ce];
        ke.blockedOn === re && (ke.blockedOn = null);
      }
      for (; vs.length > 0; ) {
        var at = vs[0];
        if (at.blockedOn !== null)
          break;
        hp(at), at.blockedOn === null && vs.shift();
      }
    }
    var Qn = oe.ReactCurrentBatchConfig, li = !0;
    function zi(re) {
      li = !!re;
    }
    function Xa() {
      return li;
    }
    function zu(re, ie, he) {
      var ve = ca(ie), Ce;
      switch (ve) {
        case ta:
          Ce = Pi;
          break;
        case Gi:
          Ce = Xf;
          break;
        case ms:
        default:
          Ce = ys;
          break;
      }
      return Ce.bind(null, ie, he, re);
    }
    function Pi(re, ie, he, ve) {
      var Ce = vo(), ke = Qn.transition;
      Qn.transition = null;
      try {
        _i(ta), ys(re, ie, he, ve);
      } finally {
        _i(Ce), Qn.transition = ke;
      }
    }
    function Xf(re, ie, he, ve) {
      var Ce = vo(), ke = Qn.transition;
      Qn.transition = null;
      try {
        _i(Gi), ys(re, ie, he, ve);
      } finally {
        _i(Ce), Qn.transition = ke;
      }
    }
    function ys(re, ie, he, ve) {
      li && bd(re, ie, he, ve);
    }
    function bd(re, ie, he, ve) {
      var Ce = Bl(re, ie, he, ve);
      if (Ce === null) {
        r0(re, ie, ve, Vu, he), Tv(re, ve);
        return;
      }
      if (wv(Ce, re, ie, he, ve)) {
        ve.stopPropagation();
        return;
      }
      if (Tv(re, ve), ie & Cl && Cv(re)) {
        for (; Ce !== null; ) {
          var ke = Qu(Ce);
          ke !== null && Lu(ke);
          var at = Bl(re, ie, he, ve);
          if (at === null && r0(re, ie, ve, Vu, he), at === Ce)
            break;
          Ce = at;
        }
        Ce !== null && ve.stopPropagation();
        return;
      }
      r0(re, ie, ve, null, he);
    }
    var Vu = null;
    function Bl(re, ie, he, ve) {
      Vu = null;
      var Ce = $c(ve), ke = nc(Ce);
      if (ke !== null) {
        var at = Wa(ke);
        if (at === null)
          ke = null;
        else {
          var mt = at.tag;
          if (mt === xt) {
            var gt = Vh(at);
            if (gt !== null)
              return gt;
            ke = null;
          } else if (mt === dt) {
            var Tt = at.stateNode;
            if (Ai(Tt))
              return Bc(at);
            ke = null;
          } else
            at !== ke && (ke = null);
        }
      }
      return Vu = ke, null;
    }
    function ca(re) {
      switch (re) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ta;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Gi;
        case "message": {
          var ie = Uh();
          switch (ie) {
            case Gc:
              return ta;
            case Ya:
              return Gi;
            case Uo:
            case Wc:
              return ms;
            case Us:
              return Uf;
            default:
              return ms;
          }
        }
        default:
          return ms;
      }
    }
    function mp(re, ie, he) {
      return re.addEventListener(ie, he, !1), he;
    }
    function Bu(re, ie, he) {
      return re.addEventListener(ie, he, !0), he;
    }
    function gs(re, ie, he, ve) {
      return re.addEventListener(ie, he, {
        capture: !0,
        passive: ve
      }), he;
    }
    function xd(re, ie, he, ve) {
      return re.addEventListener(ie, he, {
        passive: ve
      }), he;
    }
    var Hl = null, qo = null, Js = null;
    function Zs(re) {
      return Hl = re, qo = Td(), !0;
    }
    function Cd() {
      Hl = null, qo = null, Js = null;
    }
    function Hu() {
      if (Js)
        return Js;
      var re, ie = qo, he = ie.length, ve, Ce = Td(), ke = Ce.length;
      for (re = 0; re < he && ie[re] === Ce[re]; re++)
        ;
      var at = he - re;
      for (ve = 1; ve <= at && ie[he - ve] === Ce[ke - ve]; ve++)
        ;
      var mt = ve > 1 ? 1 - ve : void 0;
      return Js = Ce.slice(re, mt), Js;
    }
    function Td() {
      return "value" in Hl ? Hl.value : Hl.textContent;
    }
    function Ul(re) {
      var ie, he = re.keyCode;
      return "charCode" in re ? (ie = re.charCode, ie === 0 && he === 13 && (ie = 13)) : ie = he, ie === 10 && (ie = 13), ie >= 32 || ie === 13 ? ie : 0;
    }
    function jl() {
      return !0;
    }
    function ia() {
      return !1;
    }
    function gi(re) {
      function ie(he, ve, Ce, ke, at) {
        this._reactName = he, this._targetInst = Ce, this.type = ve, this.nativeEvent = ke, this.target = at, this.currentTarget = null;
        for (var mt in re)
          if (re.hasOwnProperty(mt)) {
            var gt = re[mt];
            gt ? this[mt] = gt(ke) : this[mt] = ke[mt];
          }
        var Tt = ke.defaultPrevented != null ? ke.defaultPrevented : ke.returnValue === !1;
        return Tt ? this.isDefaultPrevented = jl : this.isDefaultPrevented = ia, this.isPropagationStopped = ia, this;
      }
      return Kr(ie.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var he = this.nativeEvent;
          he && (he.preventDefault ? he.preventDefault() : typeof he.returnValue != "unknown" && (he.returnValue = !1), this.isDefaultPrevented = jl);
        },
        stopPropagation: function() {
          var he = this.nativeEvent;
          he && (he.stopPropagation ? he.stopPropagation() : typeof he.cancelBubble != "unknown" && (he.cancelBubble = !0), this.isPropagationStopped = jl);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: jl
      }), ie;
    }
    var aa = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(re) {
        return re.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, oa = gi(aa), Uu = Kr({}, aa, {
      view: 0,
      detail: 0
    }), vp = gi(Uu), Kf, yp, go;
    function Av(re) {
      re !== go && (go && re.type === "mousemove" ? (Kf = re.screenX - go.screenX, yp = re.screenY - go.screenY) : (Kf = 0, yp = 0), go = re);
    }
    var ju = Kr({}, Uu, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ad,
      button: 0,
      buttons: 0,
      relatedTarget: function(re) {
        return re.relatedTarget === void 0 ? re.fromElement === re.srcElement ? re.toElement : re.fromElement : re.relatedTarget;
      },
      movementX: function(re) {
        return "movementX" in re ? re.movementX : (Av(re), Kf);
      },
      movementY: function(re) {
        return "movementY" in re ? re.movementY : yp;
      }
    }), el = gi(ju), gp = Kr({}, ju, {
      dataTransfer: 0
    }), Gl = gi(gp), Pv = Kr({}, Uu, {
      relatedTarget: 0
    }), wd = gi(Pv), Sp = Kr({}, aa, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), _d = gi(Sp), Ig = Kr({}, aa, {
      clipboardData: function(re) {
        return "clipboardData" in re ? re.clipboardData : window.clipboardData;
      }
    }), Ng = gi(Ig), Rv = Kr({}, aa, {
      data: 0
    }), Ep = gi(Rv), Wl = Ep, zg = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Gu = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function kv(re) {
      if (re.key) {
        var ie = zg[re.key] || re.key;
        if (ie !== "Unidentified")
          return ie;
      }
      if (re.type === "keypress") {
        var he = Ul(re);
        return he === 13 ? "Enter" : String.fromCharCode(he);
      }
      return re.type === "keydown" || re.type === "keyup" ? Gu[re.keyCode] || "Unidentified" : "";
    }
    var ui = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Vg(re) {
      var ie = this, he = ie.nativeEvent;
      if (he.getModifierState)
        return he.getModifierState(re);
      var ve = ui[re];
      return ve ? !!he[ve] : !1;
    }
    function Ad(re) {
      return Vg;
    }
    var Bg = Kr({}, Uu, {
      key: kv,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ad,
      // Legacy Interface
      charCode: function(re) {
        return re.type === "keypress" ? Ul(re) : 0;
      },
      keyCode: function(re) {
        return re.type === "keydown" || re.type === "keyup" ? re.keyCode : 0;
      },
      which: function(re) {
        return re.type === "keypress" ? Ul(re) : re.type === "keydown" || re.type === "keyup" ? re.keyCode : 0;
      }
    }), Hg = gi(Bg), Mv = Kr({}, ju, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), bp = gi(Mv), Ug = Kr({}, Uu, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ad
    }), So = gi(Ug), xp = Kr({}, aa, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), jg = gi(xp), tl = Kr({}, ju, {
      deltaX: function(re) {
        return "deltaX" in re ? re.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in re ? -re.wheelDeltaX : 0
        );
      },
      deltaY: function(re) {
        return "deltaY" in re ? re.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in re ? -re.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in re ? -re.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Pd = gi(tl), ql = [9, 13, 27, 32], Jf = 229, Zf = kr && "CompositionEvent" in window, Yl = null;
    kr && "documentMode" in document && (Yl = document.documentMode);
    var Gg = kr && "TextEvent" in window && !Yl, Rd = kr && (!Zf || Yl && Yl > 8 && Yl <= 11), Fv = 32, Cp = String.fromCharCode(Fv);
    function Dv() {
      $r("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), $r("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), $r("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), $r("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var ec = !1;
    function kd(re) {
      return (re.ctrlKey || re.altKey || re.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(re.ctrlKey && re.altKey);
    }
    function Ov(re) {
      switch (re) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Tp(re, ie) {
      return re === "keydown" && ie.keyCode === Jf;
    }
    function Lv(re, ie) {
      switch (re) {
        case "keyup":
          return ql.indexOf(ie.keyCode) !== -1;
        case "keydown":
          return ie.keyCode !== Jf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function wp(re) {
      var ie = re.detail;
      return typeof ie == "object" && "data" in ie ? ie.data : null;
    }
    function Md(re) {
      return re.locale === "ko";
    }
    var Ss = !1;
    function _p(re, ie, he, ve, Ce) {
      var ke, at;
      if (Zf ? ke = Ov(ie) : Ss ? Lv(ie, ve) && (ke = "onCompositionEnd") : Tp(ie, ve) && (ke = "onCompositionStart"), !ke)
        return null;
      Rd && !Md(ve) && (!Ss && ke === "onCompositionStart" ? Ss = Zs(Ce) : ke === "onCompositionEnd" && Ss && (at = Hu()));
      var mt = Vv(he, ke);
      if (mt.length > 0) {
        var gt = new Ep(ke, ie, null, ve, Ce);
        if (re.push({
          event: gt,
          listeners: mt
        }), at)
          gt.data = at;
        else {
          var Tt = wp(ve);
          Tt !== null && (gt.data = Tt);
        }
      }
    }
    function Fd(re, ie) {
      switch (re) {
        case "compositionend":
          return wp(ie);
        case "keypress":
          var he = ie.which;
          return he !== Fv ? null : (ec = !0, Cp);
        case "textInput":
          var ve = ie.data;
          return ve === Cp && ec ? null : ve;
        default:
          return null;
      }
    }
    function $v(re, ie) {
      if (Ss) {
        if (re === "compositionend" || !Zf && Lv(re, ie)) {
          var he = Hu();
          return Cd(), Ss = !1, he;
        }
        return null;
      }
      switch (re) {
        case "paste":
          return null;
        case "keypress":
          if (!kd(ie)) {
            if (ie.char && ie.char.length > 1)
              return ie.char;
            if (ie.which)
              return String.fromCharCode(ie.which);
          }
          return null;
        case "compositionend":
          return Rd && !Md(ie) ? null : ie.data;
        default:
          return null;
      }
    }
    function Wg(re, ie, he, ve, Ce) {
      var ke;
      if (Gg ? ke = Fd(ie, ve) : ke = $v(ie, ve), !ke)
        return null;
      var at = Vv(he, "onBeforeInput");
      if (at.length > 0) {
        var mt = new Wl("onBeforeInput", "beforeinput", null, ve, Ce);
        re.push({
          event: mt,
          listeners: at
        }), mt.data = ke;
      }
    }
    function Dd(re, ie, he, ve, Ce, ke, at) {
      _p(re, ie, he, ve, Ce), Wg(re, ie, he, ve, Ce);
    }
    var qg = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Wu(re) {
      var ie = re && re.nodeName && re.nodeName.toLowerCase();
      return ie === "input" ? !!qg[re.type] : ie === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Yg(re) {
      if (!kr)
        return !1;
      var ie = "on" + re, he = ie in document;
      if (!he) {
        var ve = document.createElement("div");
        ve.setAttribute(ie, "return;"), he = typeof ve[ie] == "function";
      }
      return he;
    }
    function Od() {
      $r("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function fe(re, ie, he, ve) {
      Ic(ve);
      var Ce = Vv(ie, "onChange");
      if (Ce.length > 0) {
        var ke = new oa("onChange", "change", null, he, ve);
        re.push({
          event: ke,
          listeners: Ce
        });
      }
    }
    var ce = null, Ee = null;
    function Te(re) {
      var ie = re.nodeName && re.nodeName.toLowerCase();
      return ie === "select" || ie === "input" && re.type === "file";
    }
    function nt(re) {
      var ie = [];
      fe(ie, Ee, re, $c(re)), Fh(ct, ie);
    }
    function ct(re) {
      JS(re, 0);
    }
    function bt(re) {
      var ie = Vd(re);
      if (ar(ie))
        return re;
    }
    function Mt(re, ie) {
      if (re === "change")
        return ie;
    }
    var Lt = !1;
    kr && (Lt = Yg("input") && (!document.documentMode || document.documentMode > 9));
    function qt(re, ie) {
      ce = re, Ee = ie, ce.attachEvent("onpropertychange", lr);
    }
    function sr() {
      ce && (ce.detachEvent("onpropertychange", lr), ce = null, Ee = null);
    }
    function lr(re) {
      re.propertyName === "value" && bt(Ee) && nt(re);
    }
    function or(re, ie, he) {
      re === "focusin" ? (sr(), qt(ie, he)) : re === "focusout" && sr();
    }
    function Er(re, ie) {
      if (re === "selectionchange" || re === "keyup" || re === "keydown")
        return bt(Ee);
    }
    function _r(re) {
      var ie = re.nodeName;
      return ie && ie.toLowerCase() === "input" && (re.type === "checkbox" || re.type === "radio");
    }
    function Rr(re, ie) {
      if (re === "click")
        return bt(ie);
    }
    function di(re, ie) {
      if (re === "input" || re === "change")
        return bt(ie);
    }
    function Bt(re) {
      var ie = re._wrapperState;
      !ie || !ie.controlled || re.type !== "number" || Di(re, "number", re.value);
    }
    function It(re, ie, he, ve, Ce, ke, at) {
      var mt = he ? Vd(he) : window, gt, Tt;
      if (Te(mt) ? gt = Mt : Wu(mt) ? Lt ? gt = di : (gt = Er, Tt = or) : _r(mt) && (gt = Rr), gt) {
        var Pt = gt(ie, he);
        if (Pt) {
          fe(re, Pt, ve, Ce);
          return;
        }
      }
      Tt && Tt(ie, mt, he), ie === "focusout" && Bt(mt);
    }
    function jt() {
      tn("onMouseEnter", ["mouseout", "mouseover"]), tn("onMouseLeave", ["mouseout", "mouseover"]), tn("onPointerEnter", ["pointerout", "pointerover"]), tn("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function cr(re, ie, he, ve, Ce, ke, at) {
      var mt = ie === "mouseover" || ie === "pointerover", gt = ie === "mouseout" || ie === "pointerout";
      if (mt && !Zm(ve)) {
        var Tt = ve.relatedTarget || ve.fromElement;
        if (Tt && (nc(Tt) || Vp(Tt)))
          return;
      }
      if (!(!gt && !mt)) {
        var Pt;
        if (Ce.window === Ce)
          Pt = Ce;
        else {
          var Nt = Ce.ownerDocument;
          Nt ? Pt = Nt.defaultView || Nt.parentWindow : Pt = window;
        }
        var $t, Gt;
        if (gt) {
          var Wt = ve.relatedTarget || ve.toElement;
          if ($t = he, Gt = Wt ? nc(Wt) : null, Gt !== null) {
            var Xt = Wa(Gt);
            (Gt !== Xt || Gt.tag !== ht && Gt.tag !== it) && (Gt = null);
          }
        } else
          $t = null, Gt = he;
        if ($t !== Gt) {
          var xr = el, Ir = "onMouseLeave", Fr = "onMouseEnter", ln = "mouse";
          (ie === "pointerout" || ie === "pointerover") && (xr = bp, Ir = "onPointerLeave", Fr = "onPointerEnter", ln = "pointer");
          var nn = $t == null ? Pt : Vd($t), Ht = Gt == null ? Pt : Vd(Gt), Kt = new xr(Ir, ln + "leave", $t, ve, Ce);
          Kt.target = nn, Kt.relatedTarget = Ht;
          var Ut = null, ur = nc(Ce);
          if (ur === he) {
            var Cr = new xr(Fr, ln + "enter", Gt, ve, Ce);
            Cr.target = Ht, Cr.relatedTarget = nn, Ut = Cr;
          }
          VC(re, Kt, Ut, $t, Gt);
        }
      }
    }
    function Mr(re, ie) {
      return re === ie && (re !== 0 || 1 / re === 1 / ie) || re !== re && ie !== ie;
    }
    var Ar = typeof Object.is == "function" ? Object.is : Mr;
    function Or(re, ie) {
      if (Ar(re, ie))
        return !0;
      if (typeof re != "object" || re === null || typeof ie != "object" || ie === null)
        return !1;
      var he = Object.keys(re), ve = Object.keys(ie);
      if (he.length !== ve.length)
        return !1;
      for (var Ce = 0; Ce < he.length; Ce++) {
        var ke = he[Ce];
        if (!dr.call(ie, ke) || !Ar(re[ke], ie[ke]))
          return !1;
      }
      return !0;
    }
    function jr(re) {
      for (; re && re.firstChild; )
        re = re.firstChild;
      return re;
    }
    function Vi(re) {
      for (; re; ) {
        if (re.nextSibling)
          return re.nextSibling;
        re = re.parentNode;
      }
    }
    function fn(re, ie) {
      for (var he = jr(re), ve = 0, Ce = 0; he; ) {
        if (he.nodeType === os) {
          if (Ce = ve + he.textContent.length, ve <= ie && Ce >= ie)
            return {
              node: he,
              offset: ie - ve
            };
          ve = Ce;
        }
        he = jr(Vi(he));
      }
    }
    function rl(re) {
      var ie = re.ownerDocument, he = ie && ie.defaultView || window, ve = he.getSelection && he.getSelection();
      if (!ve || ve.rangeCount === 0)
        return null;
      var Ce = ve.anchorNode, ke = ve.anchorOffset, at = ve.focusNode, mt = ve.focusOffset;
      try {
        Ce.nodeType, at.nodeType;
      } catch {
        return null;
      }
      return Qg(re, Ce, ke, at, mt);
    }
    function Qg(re, ie, he, ve, Ce) {
      var ke = 0, at = -1, mt = -1, gt = 0, Tt = 0, Pt = re, Nt = null;
      e:
        for (; ; ) {
          for (var $t = null; Pt === ie && (he === 0 || Pt.nodeType === os) && (at = ke + he), Pt === ve && (Ce === 0 || Pt.nodeType === os) && (mt = ke + Ce), Pt.nodeType === os && (ke += Pt.nodeValue.length), ($t = Pt.firstChild) !== null; )
            Nt = Pt, Pt = $t;
          for (; ; ) {
            if (Pt === re)
              break e;
            if (Nt === ie && ++gt === he && (at = ke), Nt === ve && ++Tt === Ce && (mt = ke), ($t = Pt.nextSibling) !== null)
              break;
            Pt = Nt, Nt = Pt.parentNode;
          }
          Pt = $t;
        }
      return at === -1 || mt === -1 ? null : {
        start: at,
        end: mt
      };
    }
    function bC(re, ie) {
      var he = re.ownerDocument || document, ve = he && he.defaultView || window;
      if (ve.getSelection) {
        var Ce = ve.getSelection(), ke = re.textContent.length, at = Math.min(ie.start, ke), mt = ie.end === void 0 ? at : Math.min(ie.end, ke);
        if (!Ce.extend && at > mt) {
          var gt = mt;
          mt = at, at = gt;
        }
        var Tt = fn(re, at), Pt = fn(re, mt);
        if (Tt && Pt) {
          if (Ce.rangeCount === 1 && Ce.anchorNode === Tt.node && Ce.anchorOffset === Tt.offset && Ce.focusNode === Pt.node && Ce.focusOffset === Pt.offset)
            return;
          var Nt = he.createRange();
          Nt.setStart(Tt.node, Tt.offset), Ce.removeAllRanges(), at > mt ? (Ce.addRange(Nt), Ce.extend(Pt.node, Pt.offset)) : (Nt.setEnd(Pt.node, Pt.offset), Ce.addRange(Nt));
        }
      }
    }
    function VS(re) {
      return re && re.nodeType === os;
    }
    function BS(re, ie) {
      return !re || !ie ? !1 : re === ie ? !0 : VS(re) ? !1 : VS(ie) ? BS(re, ie.parentNode) : "contains" in re ? re.contains(ie) : re.compareDocumentPosition ? !!(re.compareDocumentPosition(ie) & 16) : !1;
    }
    function xC(re) {
      return re && re.ownerDocument && BS(re.ownerDocument.documentElement, re);
    }
    function CC(re) {
      try {
        return typeof re.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function HS() {
      for (var re = window, ie = Sr(); ie instanceof re.HTMLIFrameElement; ) {
        if (CC(ie))
          re = ie.contentWindow;
        else
          return ie;
        ie = Sr(re.document);
      }
      return ie;
    }
    function Xg(re) {
      var ie = re && re.nodeName && re.nodeName.toLowerCase();
      return ie && (ie === "input" && (re.type === "text" || re.type === "search" || re.type === "tel" || re.type === "url" || re.type === "password") || ie === "textarea" || re.contentEditable === "true");
    }
    function TC() {
      var re = HS();
      return {
        focusedElem: re,
        selectionRange: Xg(re) ? _C(re) : null
      };
    }
    function wC(re) {
      var ie = HS(), he = re.focusedElem, ve = re.selectionRange;
      if (ie !== he && xC(he)) {
        ve !== null && Xg(he) && AC(he, ve);
        for (var Ce = [], ke = he; ke = ke.parentNode; )
          ke.nodeType === _a && Ce.push({
            element: ke,
            left: ke.scrollLeft,
            top: ke.scrollTop
          });
        typeof he.focus == "function" && he.focus();
        for (var at = 0; at < Ce.length; at++) {
          var mt = Ce[at];
          mt.element.scrollLeft = mt.left, mt.element.scrollTop = mt.top;
        }
      }
    }
    function _C(re) {
      var ie;
      return "selectionStart" in re ? ie = {
        start: re.selectionStart,
        end: re.selectionEnd
      } : ie = rl(re), ie || {
        start: 0,
        end: 0
      };
    }
    function AC(re, ie) {
      var he = ie.start, ve = ie.end;
      ve === void 0 && (ve = he), "selectionStart" in re ? (re.selectionStart = he, re.selectionEnd = Math.min(ve, re.value.length)) : bC(re, ie);
    }
    var PC = kr && "documentMode" in document && document.documentMode <= 11;
    function RC() {
      $r("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Ld = null, Kg = null, Ap = null, Jg = !1;
    function kC(re) {
      if ("selectionStart" in re && Xg(re))
        return {
          start: re.selectionStart,
          end: re.selectionEnd
        };
      var ie = re.ownerDocument && re.ownerDocument.defaultView || window, he = ie.getSelection();
      return {
        anchorNode: he.anchorNode,
        anchorOffset: he.anchorOffset,
        focusNode: he.focusNode,
        focusOffset: he.focusOffset
      };
    }
    function MC(re) {
      return re.window === re ? re.document : re.nodeType === Ao ? re : re.ownerDocument;
    }
    function US(re, ie, he) {
      var ve = MC(he);
      if (!(Jg || Ld == null || Ld !== Sr(ve))) {
        var Ce = kC(Ld);
        if (!Ap || !Or(Ap, Ce)) {
          Ap = Ce;
          var ke = Vv(Kg, "onSelect");
          if (ke.length > 0) {
            var at = new oa("onSelect", "select", null, ie, he);
            re.push({
              event: at,
              listeners: ke
            }), at.target = Ld;
          }
        }
      }
    }
    function FC(re, ie, he, ve, Ce, ke, at) {
      var mt = he ? Vd(he) : window;
      switch (ie) {
        case "focusin":
          (Wu(mt) || mt.contentEditable === "true") && (Ld = mt, Kg = he, Ap = null);
          break;
        case "focusout":
          Ld = null, Kg = null, Ap = null;
          break;
        case "mousedown":
          Jg = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Jg = !1, US(re, ve, Ce);
          break;
        case "selectionchange":
          if (PC)
            break;
        case "keydown":
        case "keyup":
          US(re, ve, Ce);
      }
    }
    function Iv(re, ie) {
      var he = {};
      return he[re.toLowerCase()] = ie.toLowerCase(), he["Webkit" + re] = "webkit" + ie, he["Moz" + re] = "moz" + ie, he;
    }
    var $d = {
      animationend: Iv("Animation", "AnimationEnd"),
      animationiteration: Iv("Animation", "AnimationIteration"),
      animationstart: Iv("Animation", "AnimationStart"),
      transitionend: Iv("Transition", "TransitionEnd")
    }, Zg = {}, jS = {};
    kr && (jS = document.createElement("div").style, "AnimationEvent" in window || (delete $d.animationend.animation, delete $d.animationiteration.animation, delete $d.animationstart.animation), "TransitionEvent" in window || delete $d.transitionend.transition);
    function Nv(re) {
      if (Zg[re])
        return Zg[re];
      if (!$d[re])
        return re;
      var ie = $d[re];
      for (var he in ie)
        if (ie.hasOwnProperty(he) && he in jS)
          return Zg[re] = ie[he];
      return re;
    }
    var GS = Nv("animationend"), WS = Nv("animationiteration"), qS = Nv("animationstart"), YS = Nv("transitionend"), QS = /* @__PURE__ */ new Map(), XS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function qu(re, ie) {
      QS.set(re, ie), $r(ie, [re]);
    }
    function DC() {
      for (var re = 0; re < XS.length; re++) {
        var ie = XS[re], he = ie.toLowerCase(), ve = ie[0].toUpperCase() + ie.slice(1);
        qu(he, "on" + ve);
      }
      qu(GS, "onAnimationEnd"), qu(WS, "onAnimationIteration"), qu(qS, "onAnimationStart"), qu("dblclick", "onDoubleClick"), qu("focusin", "onFocus"), qu("focusout", "onBlur"), qu(YS, "onTransitionEnd");
    }
    function OC(re, ie, he, ve, Ce, ke, at) {
      var mt = QS.get(ie);
      if (mt !== void 0) {
        var gt = oa, Tt = ie;
        switch (ie) {
          case "keypress":
            if (Ul(ve) === 0)
              return;
          case "keydown":
          case "keyup":
            gt = Hg;
            break;
          case "focusin":
            Tt = "focus", gt = wd;
            break;
          case "focusout":
            Tt = "blur", gt = wd;
            break;
          case "beforeblur":
          case "afterblur":
            gt = wd;
            break;
          case "click":
            if (ve.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            gt = el;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            gt = Gl;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            gt = So;
            break;
          case GS:
          case WS:
          case qS:
            gt = _d;
            break;
          case YS:
            gt = jg;
            break;
          case "scroll":
            gt = vp;
            break;
          case "wheel":
            gt = Pd;
            break;
          case "copy":
          case "cut":
          case "paste":
            gt = Ng;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            gt = bp;
            break;
        }
        var Pt = (ke & Cl) !== 0;
        {
          var Nt = !Pt && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          ie === "scroll", $t = NC(he, mt, ve.type, Pt, Nt);
          if ($t.length > 0) {
            var Gt = new gt(mt, Tt, null, ve, Ce);
            re.push({
              event: Gt,
              listeners: $t
            });
          }
        }
      }
    }
    DC(), jt(), Od(), RC(), Dv();
    function LC(re, ie, he, ve, Ce, ke, at) {
      OC(re, ie, he, ve, Ce, ke);
      var mt = (ke & wg) === 0;
      mt && (cr(re, ie, he, ve, Ce), It(re, ie, he, ve, Ce), FC(re, ie, he, ve, Ce), Dd(re, ie, he, ve, Ce));
    }
    var Pp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], e0 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Pp));
    function KS(re, ie, he) {
      var ve = re.type || "unknown-event";
      re.currentTarget = he, fs(ve, ie, void 0, re), re.currentTarget = null;
    }
    function $C(re, ie, he) {
      var ve;
      if (he)
        for (var Ce = ie.length - 1; Ce >= 0; Ce--) {
          var ke = ie[Ce], at = ke.instance, mt = ke.currentTarget, gt = ke.listener;
          if (at !== ve && re.isPropagationStopped())
            return;
          KS(re, gt, mt), ve = at;
        }
      else
        for (var Tt = 0; Tt < ie.length; Tt++) {
          var Pt = ie[Tt], Nt = Pt.instance, $t = Pt.currentTarget, Gt = Pt.listener;
          if (Nt !== ve && re.isPropagationStopped())
            return;
          KS(re, Gt, $t), ve = Nt;
        }
    }
    function JS(re, ie) {
      for (var he = (ie & Cl) !== 0, ve = 0; ve < re.length; ve++) {
        var Ce = re[ve], ke = Ce.event, at = Ce.listeners;
        $C(ke, at, he);
      }
      $h();
    }
    function IC(re, ie, he, ve, Ce) {
      var ke = $c(he), at = [];
      LC(at, re, ve, he, ke, ie), JS(at, ie);
    }
    function Xn(re, ie) {
      e0.has(re) || be('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', re);
      var he = !1, ve = hw(ie), Ce = BC(re, he);
      ve.has(Ce) || (ZS(ie, re, wf, he), ve.add(Ce));
    }
    function t0(re, ie, he) {
      e0.has(re) && !ie && be('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', re);
      var ve = 0;
      ie && (ve |= Cl), ZS(he, re, ve, ie);
    }
    var zv = "_reactListening" + Math.random().toString(36).slice(2);
    function Rp(re) {
      if (!re[zv]) {
        re[zv] = !0, en.forEach(function(he) {
          he !== "selectionchange" && (e0.has(he) || t0(he, !1, re), t0(he, !0, re));
        });
        var ie = re.nodeType === Ao ? re : re.ownerDocument;
        ie !== null && (ie[zv] || (ie[zv] = !0, t0("selectionchange", !1, ie)));
      }
    }
    function ZS(re, ie, he, ve, Ce) {
      var ke = zu(re, ie, he), at = void 0;
      kf && (ie === "touchstart" || ie === "touchmove" || ie === "wheel") && (at = !0), re = re, ve ? at !== void 0 ? gs(re, ie, ke, at) : Bu(re, ie, ke) : at !== void 0 ? xd(re, ie, ke, at) : mp(re, ie, ke);
    }
    function eE(re, ie) {
      return re === ie || re.nodeType === vi && re.parentNode === ie;
    }
    function r0(re, ie, he, ve, Ce) {
      var ke = ve;
      if (!(ie & ls) && !(ie & wf)) {
        var at = Ce;
        if (ve !== null) {
          var mt = ve;
          e:
            for (; ; ) {
              if (mt === null)
                return;
              var gt = mt.tag;
              if (gt === dt || gt === ut) {
                var Tt = mt.stateNode.containerInfo;
                if (eE(Tt, at))
                  break;
                if (gt === ut)
                  for (var Pt = mt.return; Pt !== null; ) {
                    var Nt = Pt.tag;
                    if (Nt === dt || Nt === ut) {
                      var $t = Pt.stateNode.containerInfo;
                      if (eE($t, at))
                        return;
                    }
                    Pt = Pt.return;
                  }
                for (; Tt !== null; ) {
                  var Gt = nc(Tt);
                  if (Gt === null)
                    return;
                  var Wt = Gt.tag;
                  if (Wt === ht || Wt === it) {
                    mt = ke = Gt;
                    continue e;
                  }
                  Tt = Tt.parentNode;
                }
              }
              mt = mt.return;
            }
        }
      }
      Fh(function() {
        return IC(re, ie, he, ke);
      });
    }
    function kp(re, ie, he) {
      return {
        instance: re,
        listener: ie,
        currentTarget: he
      };
    }
    function NC(re, ie, he, ve, Ce, ke) {
      for (var at = ie !== null ? ie + "Capture" : null, mt = ve ? at : ie, gt = [], Tt = re, Pt = null; Tt !== null; ) {
        var Nt = Tt, $t = Nt.stateNode, Gt = Nt.tag;
        if (Gt === ht && $t !== null && (Pt = $t, mt !== null)) {
          var Wt = wl(Tt, mt);
          Wt != null && gt.push(kp(Tt, Wt, Pt));
        }
        if (Ce)
          break;
        Tt = Tt.return;
      }
      return gt;
    }
    function Vv(re, ie) {
      for (var he = ie + "Capture", ve = [], Ce = re; Ce !== null; ) {
        var ke = Ce, at = ke.stateNode, mt = ke.tag;
        if (mt === ht && at !== null) {
          var gt = at, Tt = wl(Ce, he);
          Tt != null && ve.unshift(kp(Ce, Tt, gt));
          var Pt = wl(Ce, ie);
          Pt != null && ve.push(kp(Ce, Pt, gt));
        }
        Ce = Ce.return;
      }
      return ve;
    }
    function Id(re) {
      if (re === null)
        return null;
      do
        re = re.return;
      while (re && re.tag !== ht);
      return re || null;
    }
    function zC(re, ie) {
      for (var he = re, ve = ie, Ce = 0, ke = he; ke; ke = Id(ke))
        Ce++;
      for (var at = 0, mt = ve; mt; mt = Id(mt))
        at++;
      for (; Ce - at > 0; )
        he = Id(he), Ce--;
      for (; at - Ce > 0; )
        ve = Id(ve), at--;
      for (var gt = Ce; gt--; ) {
        if (he === ve || ve !== null && he === ve.alternate)
          return he;
        he = Id(he), ve = Id(ve);
      }
      return null;
    }
    function tE(re, ie, he, ve, Ce) {
      for (var ke = ie._reactName, at = [], mt = he; mt !== null && mt !== ve; ) {
        var gt = mt, Tt = gt.alternate, Pt = gt.stateNode, Nt = gt.tag;
        if (Tt !== null && Tt === ve)
          break;
        if (Nt === ht && Pt !== null) {
          var $t = Pt;
          if (Ce) {
            var Gt = wl(mt, ke);
            Gt != null && at.unshift(kp(mt, Gt, $t));
          } else if (!Ce) {
            var Wt = wl(mt, ke);
            Wt != null && at.push(kp(mt, Wt, $t));
          }
        }
        mt = mt.return;
      }
      at.length !== 0 && re.push({
        event: ie,
        listeners: at
      });
    }
    function VC(re, ie, he, ve, Ce) {
      var ke = ve && Ce ? zC(ve, Ce) : null;
      ve !== null && tE(re, ie, ve, ke, !1), Ce !== null && he !== null && tE(re, he, Ce, ke, !0);
    }
    function BC(re, ie) {
      return re + "__" + (ie ? "capture" : "bubble");
    }
    var Eo = !1, Mp = "dangerouslySetInnerHTML", Bv = "suppressContentEditableWarning", Yu = "suppressHydrationWarning", rE = "autoFocus", tc = "children", rc = "style", Hv = "__html", n0, Uv, Fp, nE, jv, iE, aE;
    n0 = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Uv = function(re, ie) {
      Lc(re, ie), Ah(re, ie), Jm(re, ie, {
        registrationNameDependencies: Tn,
        possibleRegistrationNames: Mn
      });
    }, iE = kr && !document.documentMode, Fp = function(re, ie, he) {
      if (!Eo) {
        var ve = Gv(he), Ce = Gv(ie);
        Ce !== ve && (Eo = !0, be("Prop `%s` did not match. Server: %s Client: %s", re, JSON.stringify(Ce), JSON.stringify(ve)));
      }
    }, nE = function(re) {
      if (!Eo) {
        Eo = !0;
        var ie = [];
        re.forEach(function(he) {
          ie.push(he);
        }), be("Extra attributes from the server: %s", ie);
      }
    }, jv = function(re, ie) {
      ie === !1 ? be("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", re, re, re) : be("Expected `%s` listener to be a function, instead got a value of `%s` type.", re, typeof ie);
    }, aE = function(re, ie) {
      var he = re.namespaceURI === as ? re.ownerDocument.createElement(re.tagName) : re.ownerDocument.createElementNS(re.namespaceURI, re.tagName);
      return he.innerHTML = ie, he.innerHTML;
    };
    var HC = /\r\n?/g, UC = /\u0000|\uFFFD/g;
    function Gv(re) {
      Mi(re);
      var ie = typeof re == "string" ? re : "" + re;
      return ie.replace(HC, `
`).replace(UC, "");
    }
    function Wv(re, ie, he, ve) {
      var Ce = Gv(ie), ke = Gv(re);
      if (ke !== Ce && (ve && (Eo || (Eo = !0, be('Text content did not match. Server: "%s" Client: "%s"', ke, Ce))), he && Ft))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function oE(re) {
      return re.nodeType === Ao ? re : re.ownerDocument;
    }
    function jC() {
    }
    function qv(re) {
      re.onclick = jC;
    }
    function GC(re, ie, he, ve, Ce) {
      for (var ke in ve)
        if (ve.hasOwnProperty(ke)) {
          var at = ve[ke];
          if (ke === rc)
            at && Object.freeze(at), Hm(ie, at);
          else if (ke === Mp) {
            var mt = at ? at[Hv] : void 0;
            mt != null && Mm(ie, mt);
          } else if (ke === tc)
            if (typeof at == "string") {
              var gt = re !== "textarea" || at !== "";
              gt && Mc(ie, at);
            } else
              typeof at == "number" && Mc(ie, "" + at);
          else
            ke === Bv || ke === Yu || ke === rE || (Tn.hasOwnProperty(ke) ? at != null && (typeof at != "function" && jv(ke, at), ke === "onScroll" && Xn("scroll", ie)) : at != null && ts(ie, ke, at, Ce));
        }
    }
    function WC(re, ie, he, ve) {
      for (var Ce = 0; Ce < ie.length; Ce += 2) {
        var ke = ie[Ce], at = ie[Ce + 1];
        ke === rc ? Hm(re, at) : ke === Mp ? Mm(re, at) : ke === tc ? Mc(re, at) : ts(re, ke, at, ve);
      }
    }
    function qC(re, ie, he, ve) {
      var Ce, ke = oE(he), at, mt = ve;
      if (mt === as && (mt = Rc(re)), mt === as) {
        if (Ce = ss(re, ie), !Ce && re !== re.toLowerCase() && be("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", re), re === "script") {
          var gt = ke.createElement("div");
          gt.innerHTML = "<script><\/script>";
          var Tt = gt.firstChild;
          at = gt.removeChild(Tt);
        } else if (typeof ie.is == "string")
          at = ke.createElement(re, {
            is: ie.is
          });
        else if (at = ke.createElement(re), re === "select") {
          var Pt = at;
          ie.multiple ? Pt.multiple = !0 : ie.size && (Pt.size = ie.size);
        }
      } else
        at = ke.createElementNS(mt, re);
      return mt === as && !Ce && Object.prototype.toString.call(at) === "[object HTMLUnknownElement]" && !dr.call(n0, re) && (n0[re] = !0, be("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", re)), at;
    }
    function YC(re, ie) {
      return oE(ie).createTextNode(re);
    }
    function QC(re, ie, he, ve) {
      var Ce = ss(ie, he);
      Uv(ie, he);
      var ke;
      switch (ie) {
        case "dialog":
          Xn("cancel", re), Xn("close", re), ke = he;
          break;
        case "iframe":
        case "object":
        case "embed":
          Xn("load", re), ke = he;
          break;
        case "video":
        case "audio":
          for (var at = 0; at < Pp.length; at++)
            Xn(Pp[at], re);
          ke = he;
          break;
        case "source":
          Xn("error", re), ke = he;
          break;
        case "img":
        case "image":
        case "link":
          Xn("error", re), Xn("load", re), ke = he;
          break;
        case "details":
          Xn("toggle", re), ke = he;
          break;
        case "input":
          Ci(re, he), ke = bn(re, he), Xn("invalid", re);
          break;
        case "option":
          is(re, he), ke = he;
          break;
        case "select":
          Am(re, he), ke = vh(re, he), Xn("invalid", re);
          break;
        case "textarea":
          Pm(re, he), ke = gh(re, he), Xn("invalid", re);
          break;
        default:
          ke = he;
      }
      switch (Dc(ie, ke), GC(ie, re, ve, ke, Ce), ie) {
        case "input":
          zt(re), Fi(re, he, !1);
          break;
        case "textarea":
          zt(re), km(re);
          break;
        case "option":
          mh(re, he);
          break;
        case "select":
          pg(re, he);
          break;
        default:
          typeof ke.onClick == "function" && qv(re);
          break;
      }
    }
    function XC(re, ie, he, ve, Ce) {
      Uv(ie, ve);
      var ke = null, at, mt;
      switch (ie) {
        case "input":
          at = bn(re, he), mt = bn(re, ve), ke = [];
          break;
        case "select":
          at = vh(re, he), mt = vh(re, ve), ke = [];
          break;
        case "textarea":
          at = gh(re, he), mt = gh(re, ve), ke = [];
          break;
        default:
          at = he, mt = ve, typeof at.onClick != "function" && typeof mt.onClick == "function" && qv(re);
          break;
      }
      Dc(ie, mt);
      var gt, Tt, Pt = null;
      for (gt in at)
        if (!(mt.hasOwnProperty(gt) || !at.hasOwnProperty(gt) || at[gt] == null))
          if (gt === rc) {
            var Nt = at[gt];
            for (Tt in Nt)
              Nt.hasOwnProperty(Tt) && (Pt || (Pt = {}), Pt[Tt] = "");
          } else
            gt === Mp || gt === tc || gt === Bv || gt === Yu || gt === rE || (Tn.hasOwnProperty(gt) ? ke || (ke = []) : (ke = ke || []).push(gt, null));
      for (gt in mt) {
        var $t = mt[gt], Gt = at != null ? at[gt] : void 0;
        if (!(!mt.hasOwnProperty(gt) || $t === Gt || $t == null && Gt == null))
          if (gt === rc)
            if ($t && Object.freeze($t), Gt) {
              for (Tt in Gt)
                Gt.hasOwnProperty(Tt) && (!$t || !$t.hasOwnProperty(Tt)) && (Pt || (Pt = {}), Pt[Tt] = "");
              for (Tt in $t)
                $t.hasOwnProperty(Tt) && Gt[Tt] !== $t[Tt] && (Pt || (Pt = {}), Pt[Tt] = $t[Tt]);
            } else
              Pt || (ke || (ke = []), ke.push(gt, Pt)), Pt = $t;
          else if (gt === Mp) {
            var Wt = $t ? $t[Hv] : void 0, Xt = Gt ? Gt[Hv] : void 0;
            Wt != null && Xt !== Wt && (ke = ke || []).push(gt, Wt);
          } else
            gt === tc ? (typeof $t == "string" || typeof $t == "number") && (ke = ke || []).push(gt, "" + $t) : gt === Bv || gt === Yu || (Tn.hasOwnProperty(gt) ? ($t != null && (typeof $t != "function" && jv(gt, $t), gt === "onScroll" && Xn("scroll", re)), !ke && Gt !== $t && (ke = [])) : (ke = ke || []).push(gt, $t));
      }
      return Pt && (Cf(Pt, mt[rc]), (ke = ke || []).push(rc, Pt)), ke;
    }
    function KC(re, ie, he, ve, Ce) {
      he === "input" && Ce.type === "radio" && Ce.name != null && ua(re, Ce);
      var ke = ss(he, ve), at = ss(he, Ce);
      switch (WC(re, ie, ke, at), he) {
        case "input":
          Wn(re, Ce);
          break;
        case "textarea":
          Rm(re, Ce);
          break;
        case "select":
          mg(re, Ce);
          break;
      }
    }
    function JC(re) {
      {
        var ie = re.toLowerCase();
        return Oc.hasOwnProperty(ie) && Oc[ie] || null;
      }
    }
    function ZC(re, ie, he, ve, Ce, ke, at) {
      var mt, gt;
      switch (mt = ss(ie, he), Uv(ie, he), ie) {
        case "dialog":
          Xn("cancel", re), Xn("close", re);
          break;
        case "iframe":
        case "object":
        case "embed":
          Xn("load", re);
          break;
        case "video":
        case "audio":
          for (var Tt = 0; Tt < Pp.length; Tt++)
            Xn(Pp[Tt], re);
          break;
        case "source":
          Xn("error", re);
          break;
        case "img":
        case "image":
        case "link":
          Xn("error", re), Xn("load", re);
          break;
        case "details":
          Xn("toggle", re);
          break;
        case "input":
          Ci(re, he), Xn("invalid", re);
          break;
        case "option":
          is(re, he);
          break;
        case "select":
          Am(re, he), Xn("invalid", re);
          break;
        case "textarea":
          Pm(re, he), Xn("invalid", re);
          break;
      }
      Dc(ie, he);
      {
        gt = /* @__PURE__ */ new Set();
        for (var Pt = re.attributes, Nt = 0; Nt < Pt.length; Nt++) {
          var $t = Pt[Nt].name.toLowerCase();
          switch ($t) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              gt.add(Pt[Nt].name);
          }
        }
      }
      var Gt = null;
      for (var Wt in he)
        if (he.hasOwnProperty(Wt)) {
          var Xt = he[Wt];
          if (Wt === tc)
            typeof Xt == "string" ? re.textContent !== Xt && (he[Yu] !== !0 && Wv(re.textContent, Xt, ke, at), Gt = [tc, Xt]) : typeof Xt == "number" && re.textContent !== "" + Xt && (he[Yu] !== !0 && Wv(re.textContent, Xt, ke, at), Gt = [tc, "" + Xt]);
          else if (Tn.hasOwnProperty(Wt))
            Xt != null && (typeof Xt != "function" && jv(Wt, Xt), Wt === "onScroll" && Xn("scroll", re));
          else if (at && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof mt == "boolean") {
            var xr = void 0, Ir = mt && yr ? null : Ba(Wt);
            if (he[Yu] !== !0) {
              if (!(Wt === Bv || Wt === Yu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Wt === "value" || Wt === "checked" || Wt === "selected")) {
                if (Wt === Mp) {
                  var Fr = re.innerHTML, ln = Xt ? Xt[Hv] : void 0;
                  if (ln != null) {
                    var nn = aE(re, ln);
                    nn !== Fr && Fp(Wt, Fr, nn);
                  }
                } else if (Wt === rc) {
                  if (gt.delete(Wt), iE) {
                    var Ht = Cg(Xt);
                    xr = re.getAttribute("style"), Ht !== xr && Fp(Wt, xr, Ht);
                  }
                } else if (mt && !yr)
                  gt.delete(Wt.toLowerCase()), xr = fu(re, Wt, Xt), Xt !== xr && Fp(Wt, xr, Xt);
                else if (!ri(Wt, Ir, mt) && !vn(Wt, Xt, Ir, mt)) {
                  var Kt = !1;
                  if (Ir !== null)
                    gt.delete(Ir.attributeName), xr = hl(re, Wt, Xt, Ir);
                  else {
                    var Ut = ve;
                    if (Ut === as && (Ut = Rc(ie)), Ut === as)
                      gt.delete(Wt.toLowerCase());
                    else {
                      var ur = JC(Wt);
                      ur !== null && ur !== Wt && (Kt = !0, gt.delete(ur)), gt.delete(Wt);
                    }
                    xr = fu(re, Wt, Xt);
                  }
                  var Cr = yr;
                  !Cr && Xt !== xr && !Kt && Fp(Wt, xr, Xt);
                }
              }
            }
          }
        }
      switch (at && // $FlowFixMe - Should be inferred as not undefined.
      gt.size > 0 && he[Yu] !== !0 && nE(gt), ie) {
        case "input":
          zt(re), Fi(re, he, !0);
          break;
        case "textarea":
          zt(re), km(re);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof he.onClick == "function" && qv(re);
          break;
      }
      return Gt;
    }
    function eT(re, ie, he) {
      var ve = re.nodeValue !== ie;
      return ve;
    }
    function i0(re, ie) {
      {
        if (Eo)
          return;
        Eo = !0, be("Did not expect server HTML to contain a <%s> in <%s>.", ie.nodeName.toLowerCase(), re.nodeName.toLowerCase());
      }
    }
    function a0(re, ie) {
      {
        if (Eo)
          return;
        Eo = !0, be('Did not expect server HTML to contain the text node "%s" in <%s>.', ie.nodeValue, re.nodeName.toLowerCase());
      }
    }
    function o0(re, ie, he) {
      {
        if (Eo)
          return;
        Eo = !0, be("Expected server HTML to contain a matching <%s> in <%s>.", ie, re.nodeName.toLowerCase());
      }
    }
    function s0(re, ie) {
      {
        if (ie === "" || Eo)
          return;
        Eo = !0, be('Expected server HTML to contain a matching text node for "%s" in <%s>.', ie, re.nodeName.toLowerCase());
      }
    }
    function tT(re, ie, he) {
      switch (ie) {
        case "input":
          fa(re, he);
          return;
        case "textarea":
          Sh(re, he);
          return;
        case "select":
          vg(re, he);
          return;
      }
    }
    var Dp = function() {
    }, Op = function() {
    };
    {
      var rT = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], sE = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], nT = sE.concat(["button"]), iT = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], lE = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Op = function(re, ie) {
        var he = Kr({}, re || lE), ve = {
          tag: ie
        };
        return sE.indexOf(ie) !== -1 && (he.aTagInScope = null, he.buttonTagInScope = null, he.nobrTagInScope = null), nT.indexOf(ie) !== -1 && (he.pTagInButtonScope = null), rT.indexOf(ie) !== -1 && ie !== "address" && ie !== "div" && ie !== "p" && (he.listItemTagAutoclosing = null, he.dlItemTagAutoclosing = null), he.current = ve, ie === "form" && (he.formTag = ve), ie === "a" && (he.aTagInScope = ve), ie === "button" && (he.buttonTagInScope = ve), ie === "nobr" && (he.nobrTagInScope = ve), ie === "p" && (he.pTagInButtonScope = ve), ie === "li" && (he.listItemTagAutoclosing = ve), (ie === "dd" || ie === "dt") && (he.dlItemTagAutoclosing = ve), he;
      };
      var aT = function(re, ie) {
        switch (ie) {
          case "select":
            return re === "option" || re === "optgroup" || re === "#text";
          case "optgroup":
            return re === "option" || re === "#text";
          case "option":
            return re === "#text";
          case "tr":
            return re === "th" || re === "td" || re === "style" || re === "script" || re === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return re === "tr" || re === "style" || re === "script" || re === "template";
          case "colgroup":
            return re === "col" || re === "template";
          case "table":
            return re === "caption" || re === "colgroup" || re === "tbody" || re === "tfoot" || re === "thead" || re === "style" || re === "script" || re === "template";
          case "head":
            return re === "base" || re === "basefont" || re === "bgsound" || re === "link" || re === "meta" || re === "title" || re === "noscript" || re === "noframes" || re === "style" || re === "script" || re === "template";
          case "html":
            return re === "head" || re === "body" || re === "frameset";
          case "frameset":
            return re === "frame";
          case "#document":
            return re === "html";
        }
        switch (re) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ie !== "h1" && ie !== "h2" && ie !== "h3" && ie !== "h4" && ie !== "h5" && ie !== "h6";
          case "rp":
          case "rt":
            return iT.indexOf(ie) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return ie == null;
        }
        return !0;
      }, oT = function(re, ie) {
        switch (re) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ie.pTagInButtonScope;
          case "form":
            return ie.formTag || ie.pTagInButtonScope;
          case "li":
            return ie.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ie.dlItemTagAutoclosing;
          case "button":
            return ie.buttonTagInScope;
          case "a":
            return ie.aTagInScope;
          case "nobr":
            return ie.nobrTagInScope;
        }
        return null;
      }, uE = {};
      Dp = function(re, ie, he) {
        he = he || lE;
        var ve = he.current, Ce = ve && ve.tag;
        ie != null && (re != null && be("validateDOMNesting: when childText is passed, childTag should be null"), re = "#text");
        var ke = aT(re, Ce) ? null : ve, at = ke ? null : oT(re, he), mt = ke || at;
        if (mt) {
          var gt = mt.tag, Tt = !!ke + "|" + re + "|" + gt;
          if (!uE[Tt]) {
            uE[Tt] = !0;
            var Pt = re, Nt = "";
            if (re === "#text" ? /\S/.test(ie) ? Pt = "Text nodes" : (Pt = "Whitespace text nodes", Nt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Pt = "<" + re + ">", ke) {
              var $t = "";
              gt === "table" && re === "tr" && ($t += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), be("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Pt, gt, Nt, $t);
            } else
              be("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Pt, gt);
          }
        }
      };
    }
    var Yv = "suppressHydrationWarning", Qv = "$", Xv = "/$", Lp = "$?", $p = "$!", sT = "style", l0 = null, u0 = null;
    function lT(re) {
      var ie, he, ve = re.nodeType;
      switch (ve) {
        case Ao:
        case bl: {
          ie = ve === Ao ? "#document" : "#fragment";
          var Ce = re.documentElement;
          he = Ce ? Ce.namespaceURI : bh(null, "");
          break;
        }
        default: {
          var ke = ve === vi ? re.parentNode : re, at = ke.namespaceURI || null;
          ie = ke.tagName, he = bh(at, ie);
          break;
        }
      }
      {
        var mt = ie.toLowerCase(), gt = Op(null, mt);
        return {
          namespace: he,
          ancestorInfo: gt
        };
      }
    }
    function uT(re, ie, he) {
      {
        var ve = re, Ce = bh(ve.namespace, ie), ke = Op(ve.ancestorInfo, ie);
        return {
          namespace: Ce,
          ancestorInfo: ke
        };
      }
    }
    function sR(re) {
      return re;
    }
    function fT(re) {
      l0 = Xa(), u0 = TC();
      var ie = null;
      return zi(!1), ie;
    }
    function cT(re) {
      wC(u0), zi(l0), l0 = null, u0 = null;
    }
    function dT(re, ie, he, ve, Ce) {
      var ke;
      {
        var at = ve;
        if (Dp(re, null, at.ancestorInfo), typeof ie.children == "string" || typeof ie.children == "number") {
          var mt = "" + ie.children, gt = Op(at.ancestorInfo, re);
          Dp(null, mt, gt);
        }
        ke = at.namespace;
      }
      var Tt = qC(re, ie, he, ke);
      return zp(Ce, Tt), y0(Tt, ie), Tt;
    }
    function hT(re, ie) {
      re.appendChild(ie);
    }
    function pT(re, ie, he, ve, Ce) {
      switch (QC(re, ie, he, ve), ie) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!he.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function mT(re, ie, he, ve, Ce, ke) {
      {
        var at = ke;
        if (typeof ve.children != typeof he.children && (typeof ve.children == "string" || typeof ve.children == "number")) {
          var mt = "" + ve.children, gt = Op(at.ancestorInfo, ie);
          Dp(null, mt, gt);
        }
      }
      return XC(re, ie, he, ve);
    }
    function f0(re, ie) {
      return re === "textarea" || re === "noscript" || typeof ie.children == "string" || typeof ie.children == "number" || typeof ie.dangerouslySetInnerHTML == "object" && ie.dangerouslySetInnerHTML !== null && ie.dangerouslySetInnerHTML.__html != null;
    }
    function vT(re, ie, he, ve) {
      {
        var Ce = he;
        Dp(null, re, Ce.ancestorInfo);
      }
      var ke = YC(re, ie);
      return zp(ve, ke), ke;
    }
    function yT() {
      var re = window.event;
      return re === void 0 ? ms : ca(re.type);
    }
    var c0 = typeof setTimeout == "function" ? setTimeout : void 0, gT = typeof clearTimeout == "function" ? clearTimeout : void 0, d0 = -1, fE = typeof Promise == "function" ? Promise : void 0, ST = typeof queueMicrotask == "function" ? queueMicrotask : typeof fE < "u" ? function(re) {
      return fE.resolve(null).then(re).catch(ET);
    } : c0;
    function ET(re) {
      setTimeout(function() {
        throw re;
      });
    }
    function bT(re, ie, he, ve) {
      switch (ie) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          he.autoFocus && re.focus();
          return;
        case "img": {
          he.src && (re.src = he.src);
          return;
        }
      }
    }
    function xT(re, ie, he, ve, Ce, ke) {
      KC(re, ie, he, ve, Ce), y0(re, Ce);
    }
    function cE(re) {
      Mc(re, "");
    }
    function CT(re, ie, he) {
      re.nodeValue = he;
    }
    function TT(re, ie) {
      re.appendChild(ie);
    }
    function wT(re, ie) {
      var he;
      re.nodeType === vi ? (he = re.parentNode, he.insertBefore(ie, re)) : (he = re, he.appendChild(ie));
      var ve = re._reactRootContainer;
      ve == null && he.onclick === null && qv(he);
    }
    function _T(re, ie, he) {
      re.insertBefore(ie, he);
    }
    function AT(re, ie, he) {
      re.nodeType === vi ? re.parentNode.insertBefore(ie, he) : re.insertBefore(ie, he);
    }
    function PT(re, ie) {
      re.removeChild(ie);
    }
    function RT(re, ie) {
      re.nodeType === vi ? re.parentNode.removeChild(ie) : re.removeChild(ie);
    }
    function h0(re, ie) {
      var he = ie, ve = 0;
      do {
        var Ce = he.nextSibling;
        if (re.removeChild(he), Ce && Ce.nodeType === vi) {
          var ke = Ce.data;
          if (ke === Xv)
            if (ve === 0) {
              re.removeChild(Ce), rn(ie);
              return;
            } else
              ve--;
          else
            (ke === Qv || ke === Lp || ke === $p) && ve++;
        }
        he = Ce;
      } while (he);
      rn(ie);
    }
    function kT(re, ie) {
      re.nodeType === vi ? h0(re.parentNode, ie) : re.nodeType === _a && h0(re, ie), rn(re);
    }
    function MT(re) {
      re = re;
      var ie = re.style;
      typeof ie.setProperty == "function" ? ie.setProperty("display", "none", "important") : ie.display = "none";
    }
    function FT(re) {
      re.nodeValue = "";
    }
    function DT(re, ie) {
      re = re;
      var he = ie[sT], ve = he != null && he.hasOwnProperty("display") ? he.display : null;
      re.style.display = Fc("display", ve);
    }
    function OT(re, ie) {
      re.nodeValue = ie;
    }
    function LT(re) {
      re.nodeType === _a ? re.textContent = "" : re.nodeType === Ao && re.documentElement && re.removeChild(re.documentElement);
    }
    function $T(re, ie, he) {
      return re.nodeType !== _a || ie.toLowerCase() !== re.nodeName.toLowerCase() ? null : re;
    }
    function IT(re, ie) {
      return ie === "" || re.nodeType !== os ? null : re;
    }
    function NT(re) {
      return re.nodeType !== vi ? null : re;
    }
    function dE(re) {
      return re.data === Lp;
    }
    function p0(re) {
      return re.data === $p;
    }
    function zT(re) {
      var ie = re.nextSibling && re.nextSibling.dataset, he, ve, Ce;
      return ie && (he = ie.dgst, ve = ie.msg, Ce = ie.stck), {
        message: ve,
        digest: he,
        stack: Ce
      };
    }
    function VT(re, ie) {
      re._reactRetry = ie;
    }
    function Kv(re) {
      for (; re != null; re = re.nextSibling) {
        var ie = re.nodeType;
        if (ie === _a || ie === os)
          break;
        if (ie === vi) {
          var he = re.data;
          if (he === Qv || he === $p || he === Lp)
            break;
          if (he === Xv)
            return null;
        }
      }
      return re;
    }
    function Ip(re) {
      return Kv(re.nextSibling);
    }
    function BT(re) {
      return Kv(re.firstChild);
    }
    function HT(re) {
      return Kv(re.firstChild);
    }
    function UT(re) {
      return Kv(re.nextSibling);
    }
    function jT(re, ie, he, ve, Ce, ke, at) {
      zp(ke, re), y0(re, he);
      var mt;
      {
        var gt = Ce;
        mt = gt.namespace;
      }
      var Tt = (ke.mode & Zr) !== zr;
      return ZC(re, ie, he, mt, ve, Tt, at);
    }
    function GT(re, ie, he, ve) {
      return zp(he, re), he.mode & Zr, eT(re, ie);
    }
    function WT(re, ie) {
      zp(ie, re);
    }
    function qT(re) {
      for (var ie = re.nextSibling, he = 0; ie; ) {
        if (ie.nodeType === vi) {
          var ve = ie.data;
          if (ve === Xv) {
            if (he === 0)
              return Ip(ie);
            he--;
          } else
            (ve === Qv || ve === $p || ve === Lp) && he++;
        }
        ie = ie.nextSibling;
      }
      return null;
    }
    function hE(re) {
      for (var ie = re.previousSibling, he = 0; ie; ) {
        if (ie.nodeType === vi) {
          var ve = ie.data;
          if (ve === Qv || ve === $p || ve === Lp) {
            if (he === 0)
              return ie;
            he--;
          } else
            ve === Xv && he++;
        }
        ie = ie.previousSibling;
      }
      return null;
    }
    function YT(re) {
      rn(re);
    }
    function QT(re) {
      rn(re);
    }
    function XT(re) {
      return re !== "head" && re !== "body";
    }
    function KT(re, ie, he, ve) {
      var Ce = !0;
      Wv(ie.nodeValue, he, ve, Ce);
    }
    function JT(re, ie, he, ve, Ce, ke) {
      if (ie[Yv] !== !0) {
        var at = !0;
        Wv(ve.nodeValue, Ce, ke, at);
      }
    }
    function ZT(re, ie) {
      ie.nodeType === _a ? i0(re, ie) : ie.nodeType === vi || a0(re, ie);
    }
    function ew(re, ie) {
      {
        var he = re.parentNode;
        he !== null && (ie.nodeType === _a ? i0(he, ie) : ie.nodeType === vi || a0(he, ie));
      }
    }
    function tw(re, ie, he, ve, Ce) {
      (Ce || ie[Yv] !== !0) && (ve.nodeType === _a ? i0(he, ve) : ve.nodeType === vi || a0(he, ve));
    }
    function rw(re, ie, he) {
      o0(re, ie);
    }
    function nw(re, ie) {
      s0(re, ie);
    }
    function iw(re, ie, he) {
      {
        var ve = re.parentNode;
        ve !== null && o0(ve, ie);
      }
    }
    function aw(re, ie) {
      {
        var he = re.parentNode;
        he !== null && s0(he, ie);
      }
    }
    function ow(re, ie, he, ve, Ce, ke) {
      (ke || ie[Yv] !== !0) && o0(he, ve);
    }
    function sw(re, ie, he, ve, Ce) {
      (Ce || ie[Yv] !== !0) && s0(he, ve);
    }
    function lw(re) {
      be("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", re.nodeName.toLowerCase());
    }
    function uw(re) {
      Rp(re);
    }
    var Nd = Math.random().toString(36).slice(2), zd = "__reactFiber$" + Nd, m0 = "__reactProps$" + Nd, Np = "__reactContainer$" + Nd, v0 = "__reactEvents$" + Nd, fw = "__reactListeners$" + Nd, cw = "__reactHandles$" + Nd;
    function dw(re) {
      delete re[zd], delete re[m0], delete re[v0], delete re[fw], delete re[cw];
    }
    function zp(re, ie) {
      ie[zd] = re;
    }
    function Jv(re, ie) {
      ie[Np] = re;
    }
    function pE(re) {
      re[Np] = null;
    }
    function Vp(re) {
      return !!re[Np];
    }
    function nc(re) {
      var ie = re[zd];
      if (ie)
        return ie;
      for (var he = re.parentNode; he; ) {
        if (ie = he[Np] || he[zd], ie) {
          var ve = ie.alternate;
          if (ie.child !== null || ve !== null && ve.child !== null)
            for (var Ce = hE(re); Ce !== null; ) {
              var ke = Ce[zd];
              if (ke)
                return ke;
              Ce = hE(Ce);
            }
          return ie;
        }
        re = he, he = re.parentNode;
      }
      return null;
    }
    function Qu(re) {
      var ie = re[zd] || re[Np];
      return ie && (ie.tag === ht || ie.tag === it || ie.tag === xt || ie.tag === dt) ? ie : null;
    }
    function Vd(re) {
      if (re.tag === ht || re.tag === it)
        return re.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Zv(re) {
      return re[m0] || null;
    }
    function y0(re, ie) {
      re[m0] = ie;
    }
    function hw(re) {
      var ie = re[v0];
      return ie === void 0 && (ie = re[v0] = /* @__PURE__ */ new Set()), ie;
    }
    var mE = {}, vE = oe.ReactDebugCurrentFrame;
    function ey(re) {
      if (re) {
        var ie = re._owner, he = Ls(re.type, re._source, ie ? ie.type : null);
        vE.setExtraStackFrame(he);
      } else
        vE.setExtraStackFrame(null);
    }
    function Es(re, ie, he, ve, Ce) {
      {
        var ke = Function.call.bind(dr);
        for (var at in re)
          if (ke(re, at)) {
            var mt = void 0;
            try {
              if (typeof re[at] != "function") {
                var gt = Error((ve || "React class") + ": " + he + " type `" + at + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof re[at] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw gt.name = "Invariant Violation", gt;
              }
              mt = re[at](ie, at, ve, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Tt) {
              mt = Tt;
            }
            mt && !(mt instanceof Error) && (ey(Ce), be("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ve || "React class", he, at, typeof mt), ey(null)), mt instanceof Error && !(mt.message in mE) && (mE[mt.message] = !0, ey(Ce), be("Failed %s type: %s", he, mt.message), ey(null));
          }
      }
    }
    var g0 = [], ty;
    ty = [];
    var Ql = -1;
    function Xu(re) {
      return {
        current: re
      };
    }
    function La(re, ie) {
      if (Ql < 0) {
        be("Unexpected pop.");
        return;
      }
      ie !== ty[Ql] && be("Unexpected Fiber popped."), re.current = g0[Ql], g0[Ql] = null, ty[Ql] = null, Ql--;
    }
    function $a(re, ie, he) {
      Ql++, g0[Ql] = re.current, ty[Ql] = he, re.current = ie;
    }
    var S0;
    S0 = {};
    var Fo = {};
    Object.freeze(Fo);
    var Xl = Xu(Fo), nl = Xu(!1), E0 = Fo;
    function Bd(re, ie, he) {
      return he && il(ie) ? E0 : Xl.current;
    }
    function yE(re, ie, he) {
      {
        var ve = re.stateNode;
        ve.__reactInternalMemoizedUnmaskedChildContext = ie, ve.__reactInternalMemoizedMaskedChildContext = he;
      }
    }
    function Hd(re, ie) {
      {
        var he = re.type, ve = he.contextTypes;
        if (!ve)
          return Fo;
        var Ce = re.stateNode;
        if (Ce && Ce.__reactInternalMemoizedUnmaskedChildContext === ie)
          return Ce.__reactInternalMemoizedMaskedChildContext;
        var ke = {};
        for (var at in ve)
          ke[at] = ie[at];
        {
          var mt = Wr(re) || "Unknown";
          Es(ve, ke, "context", mt);
        }
        return Ce && yE(re, ie, ke), ke;
      }
    }
    function ry() {
      return nl.current;
    }
    function il(re) {
      {
        var ie = re.childContextTypes;
        return ie != null;
      }
    }
    function ny(re) {
      La(nl, re), La(Xl, re);
    }
    function b0(re) {
      La(nl, re), La(Xl, re);
    }
    function gE(re, ie, he) {
      {
        if (Xl.current !== Fo)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        $a(Xl, ie, re), $a(nl, he, re);
      }
    }
    function SE(re, ie, he) {
      {
        var ve = re.stateNode, Ce = ie.childContextTypes;
        if (typeof ve.getChildContext != "function") {
          {
            var ke = Wr(re) || "Unknown";
            S0[ke] || (S0[ke] = !0, be("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", ke, ke));
          }
          return he;
        }
        var at = ve.getChildContext();
        for (var mt in at)
          if (!(mt in Ce))
            throw new Error((Wr(re) || "Unknown") + '.getChildContext(): key "' + mt + '" is not defined in childContextTypes.');
        {
          var gt = Wr(re) || "Unknown";
          Es(Ce, at, "child context", gt);
        }
        return Kr({}, he, at);
      }
    }
    function iy(re) {
      {
        var ie = re.stateNode, he = ie && ie.__reactInternalMemoizedMergedChildContext || Fo;
        return E0 = Xl.current, $a(Xl, he, re), $a(nl, nl.current, re), !0;
      }
    }
    function EE(re, ie, he) {
      {
        var ve = re.stateNode;
        if (!ve)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (he) {
          var Ce = SE(re, ie, E0);
          ve.__reactInternalMemoizedMergedChildContext = Ce, La(nl, re), La(Xl, re), $a(Xl, Ce, re), $a(nl, he, re);
        } else
          La(nl, re), $a(nl, he, re);
      }
    }
    function pw(re) {
      {
        if (!Bh(re) || re.tag !== rt)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var ie = re;
        do {
          switch (ie.tag) {
            case dt:
              return ie.stateNode.context;
            case rt: {
              var he = ie.type;
              if (il(he))
                return ie.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          ie = ie.return;
        } while (ie !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ku = 0, ay = 1, Kl = null, x0 = !1, C0 = !1;
    function bE(re) {
      Kl === null ? Kl = [re] : Kl.push(re);
    }
    function mw(re) {
      x0 = !0, bE(re);
    }
    function xE() {
      x0 && Ju();
    }
    function Ju() {
      if (!C0 && Kl !== null) {
        C0 = !0;
        var re = 0, ie = vo();
        try {
          var he = !0, ve = Kl;
          for (_i(ta); re < ve.length; re++) {
            var Ce = ve[re];
            do
              Ce = Ce(he);
            while (Ce !== null);
          }
          Kl = null, x0 = !1;
        } catch (ke) {
          throw Kl !== null && (Kl = Kl.slice(re + 1)), Uc(Gc, Ju), ke;
        } finally {
          _i(ie), C0 = !1;
        }
      }
      return null;
    }
    var Ud = [], jd = 0, oy = null, sy = 0, Yo = [], Qo = 0, ic = null, Jl = 1, Zl = "";
    function vw(re) {
      return oc(), (re.flags & Nh) !== Lr;
    }
    function yw(re) {
      return oc(), sy;
    }
    function gw() {
      var re = Zl, ie = Jl, he = ie & ~Sw(ie);
      return he.toString(32) + re;
    }
    function ac(re, ie) {
      oc(), Ud[jd++] = sy, Ud[jd++] = oy, oy = re, sy = ie;
    }
    function CE(re, ie, he) {
      oc(), Yo[Qo++] = Jl, Yo[Qo++] = Zl, Yo[Qo++] = ic, ic = re;
      var ve = Jl, Ce = Zl, ke = ly(ve) - 1, at = ve & ~(1 << ke), mt = he + 1, gt = ly(ie) + ke;
      if (gt > 30) {
        var Tt = ke - ke % 5, Pt = (1 << Tt) - 1, Nt = (at & Pt).toString(32), $t = at >> Tt, Gt = ke - Tt, Wt = ly(ie) + Gt, Xt = mt << Gt, xr = Xt | $t, Ir = Nt + Ce;
        Jl = 1 << Wt | xr, Zl = Ir;
      } else {
        var Fr = mt << ke, ln = Fr | at, nn = Ce;
        Jl = 1 << gt | ln, Zl = nn;
      }
    }
    function T0(re) {
      oc();
      var ie = re.return;
      if (ie !== null) {
        var he = 1, ve = 0;
        ac(re, he), CE(re, he, ve);
      }
    }
    function ly(re) {
      return 32 - Kc(re);
    }
    function Sw(re) {
      return 1 << ly(re) - 1;
    }
    function w0(re) {
      for (; re === oy; )
        oy = Ud[--jd], Ud[jd] = null, sy = Ud[--jd], Ud[jd] = null;
      for (; re === ic; )
        ic = Yo[--Qo], Yo[Qo] = null, Zl = Yo[--Qo], Yo[Qo] = null, Jl = Yo[--Qo], Yo[Qo] = null;
    }
    function Ew() {
      return oc(), ic !== null ? {
        id: Jl,
        overflow: Zl
      } : null;
    }
    function bw(re, ie) {
      oc(), Yo[Qo++] = Jl, Yo[Qo++] = Zl, Yo[Qo++] = ic, Jl = ie.id, Zl = ie.overflow, ic = re;
    }
    function oc() {
      ha() || be("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var da = null, Xo = null, bs = !1, sc = !1, Zu = null;
    function xw() {
      bs && be("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function TE() {
      sc = !0;
    }
    function Cw() {
      return sc;
    }
    function Tw(re) {
      var ie = re.stateNode.containerInfo;
      return Xo = HT(ie), da = re, bs = !0, Zu = null, sc = !1, !0;
    }
    function ww(re, ie, he) {
      return Xo = UT(ie), da = re, bs = !0, Zu = null, sc = !1, he !== null && bw(re, he), !0;
    }
    function wE(re, ie) {
      switch (re.tag) {
        case dt: {
          ZT(re.stateNode.containerInfo, ie);
          break;
        }
        case ht: {
          var he = (re.mode & Zr) !== zr;
          tw(
            re.type,
            re.memoizedProps,
            re.stateNode,
            ie,
            // TODO: Delete this argument when we remove the legacy root API.
            he
          );
          break;
        }
        case xt: {
          var ve = re.memoizedState;
          ve.dehydrated !== null && ew(ve.dehydrated, ie);
          break;
        }
      }
    }
    function _E(re, ie) {
      wE(re, ie);
      var he = PP();
      he.stateNode = ie, he.return = re;
      var ve = re.deletions;
      ve === null ? (re.deletions = [he], re.flags |= pn) : ve.push(he);
    }
    function _0(re, ie) {
      {
        if (sc)
          return;
        switch (re.tag) {
          case dt: {
            var he = re.stateNode.containerInfo;
            switch (ie.tag) {
              case ht:
                var ve = ie.type;
                ie.pendingProps, rw(he, ve);
                break;
              case it:
                var Ce = ie.pendingProps;
                nw(he, Ce);
                break;
            }
            break;
          }
          case ht: {
            var ke = re.type, at = re.memoizedProps, mt = re.stateNode;
            switch (ie.tag) {
              case ht: {
                var gt = ie.type, Tt = ie.pendingProps, Pt = (re.mode & Zr) !== zr;
                ow(
                  ke,
                  at,
                  mt,
                  gt,
                  Tt,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Pt
                );
                break;
              }
              case it: {
                var Nt = ie.pendingProps, $t = (re.mode & Zr) !== zr;
                sw(
                  ke,
                  at,
                  mt,
                  Nt,
                  // TODO: Delete this argument when we remove the legacy root API.
                  $t
                );
                break;
              }
            }
            break;
          }
          case xt: {
            var Gt = re.memoizedState, Wt = Gt.dehydrated;
            if (Wt !== null)
              switch (ie.tag) {
                case ht:
                  var Xt = ie.type;
                  ie.pendingProps, iw(Wt, Xt);
                  break;
                case it:
                  var xr = ie.pendingProps;
                  aw(Wt, xr);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function AE(re, ie) {
      ie.flags = ie.flags & ~fo | On, _0(re, ie);
    }
    function PE(re, ie) {
      switch (re.tag) {
        case ht: {
          var he = re.type;
          re.pendingProps;
          var ve = $T(ie, he);
          return ve !== null ? (re.stateNode = ve, da = re, Xo = BT(ve), !0) : !1;
        }
        case it: {
          var Ce = re.pendingProps, ke = IT(ie, Ce);
          return ke !== null ? (re.stateNode = ke, da = re, Xo = null, !0) : !1;
        }
        case xt: {
          var at = NT(ie);
          if (at !== null) {
            var mt = {
              dehydrated: at,
              treeContext: Ew(),
              retryLane: Da
            };
            re.memoizedState = mt;
            var gt = RP(at);
            return gt.return = re, re.child = gt, da = re, Xo = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function A0(re) {
      return (re.mode & Zr) !== zr && (re.flags & Ur) === Lr;
    }
    function P0(re) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function R0(re) {
      if (bs) {
        var ie = Xo;
        if (!ie) {
          A0(re) && (_0(da, re), P0()), AE(da, re), bs = !1, da = re;
          return;
        }
        var he = ie;
        if (!PE(re, ie)) {
          A0(re) && (_0(da, re), P0()), ie = Ip(he);
          var ve = da;
          if (!ie || !PE(re, ie)) {
            AE(da, re), bs = !1, da = re;
            return;
          }
          _E(ve, he);
        }
      }
    }
    function _w(re, ie, he) {
      var ve = re.stateNode, Ce = !sc, ke = jT(ve, re.type, re.memoizedProps, ie, he, re, Ce);
      return re.updateQueue = ke, ke !== null;
    }
    function Aw(re) {
      var ie = re.stateNode, he = re.memoizedProps, ve = GT(ie, he, re);
      if (ve) {
        var Ce = da;
        if (Ce !== null)
          switch (Ce.tag) {
            case dt: {
              var ke = Ce.stateNode.containerInfo, at = (Ce.mode & Zr) !== zr;
              KT(
                ke,
                ie,
                he,
                // TODO: Delete this argument when we remove the legacy root API.
                at
              );
              break;
            }
            case ht: {
              var mt = Ce.type, gt = Ce.memoizedProps, Tt = Ce.stateNode, Pt = (Ce.mode & Zr) !== zr;
              JT(
                mt,
                gt,
                Tt,
                ie,
                he,
                // TODO: Delete this argument when we remove the legacy root API.
                Pt
              );
              break;
            }
          }
      }
      return ve;
    }
    function Pw(re) {
      var ie = re.memoizedState, he = ie !== null ? ie.dehydrated : null;
      if (!he)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      WT(he, re);
    }
    function Rw(re) {
      var ie = re.memoizedState, he = ie !== null ? ie.dehydrated : null;
      if (!he)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return qT(he);
    }
    function RE(re) {
      for (var ie = re.return; ie !== null && ie.tag !== ht && ie.tag !== dt && ie.tag !== xt; )
        ie = ie.return;
      da = ie;
    }
    function uy(re) {
      if (re !== da)
        return !1;
      if (!bs)
        return RE(re), bs = !0, !1;
      if (re.tag !== dt && (re.tag !== ht || XT(re.type) && !f0(re.type, re.memoizedProps))) {
        var ie = Xo;
        if (ie)
          if (A0(re))
            kE(re), P0();
          else
            for (; ie; )
              _E(re, ie), ie = Ip(ie);
      }
      return RE(re), re.tag === xt ? Xo = Rw(re) : Xo = da ? Ip(re.stateNode) : null, !0;
    }
    function kw() {
      return bs && Xo !== null;
    }
    function kE(re) {
      for (var ie = Xo; ie; )
        wE(re, ie), ie = Ip(ie);
    }
    function Gd() {
      da = null, Xo = null, bs = !1, sc = !1;
    }
    function ME() {
      Zu !== null && (_x(Zu), Zu = null);
    }
    function ha() {
      return bs;
    }
    function k0(re) {
      Zu === null ? Zu = [re] : Zu.push(re);
    }
    var Mw = oe.ReactCurrentBatchConfig, Fw = null;
    function Dw() {
      return Mw.transition;
    }
    var xs = {
      recordUnsafeLifecycleWarnings: function(re, ie) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(re, ie) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Ow = function(re) {
        for (var ie = null, he = re; he !== null; )
          he.mode & Yn && (ie = he), he = he.return;
        return ie;
      }, lc = function(re) {
        var ie = [];
        return re.forEach(function(he) {
          ie.push(he);
        }), ie.sort().join(", ");
      }, Bp = [], Hp = [], Up = [], jp = [], Gp = [], Wp = [], uc = /* @__PURE__ */ new Set();
      xs.recordUnsafeLifecycleWarnings = function(re, ie) {
        uc.has(re.type) || (typeof ie.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        ie.componentWillMount.__suppressDeprecationWarning !== !0 && Bp.push(re), re.mode & Yn && typeof ie.UNSAFE_componentWillMount == "function" && Hp.push(re), typeof ie.componentWillReceiveProps == "function" && ie.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Up.push(re), re.mode & Yn && typeof ie.UNSAFE_componentWillReceiveProps == "function" && jp.push(re), typeof ie.componentWillUpdate == "function" && ie.componentWillUpdate.__suppressDeprecationWarning !== !0 && Gp.push(re), re.mode & Yn && typeof ie.UNSAFE_componentWillUpdate == "function" && Wp.push(re));
      }, xs.flushPendingUnsafeLifecycleWarnings = function() {
        var re = /* @__PURE__ */ new Set();
        Bp.length > 0 && (Bp.forEach(function($t) {
          re.add(Wr($t) || "Component"), uc.add($t.type);
        }), Bp = []);
        var ie = /* @__PURE__ */ new Set();
        Hp.length > 0 && (Hp.forEach(function($t) {
          ie.add(Wr($t) || "Component"), uc.add($t.type);
        }), Hp = []);
        var he = /* @__PURE__ */ new Set();
        Up.length > 0 && (Up.forEach(function($t) {
          he.add(Wr($t) || "Component"), uc.add($t.type);
        }), Up = []);
        var ve = /* @__PURE__ */ new Set();
        jp.length > 0 && (jp.forEach(function($t) {
          ve.add(Wr($t) || "Component"), uc.add($t.type);
        }), jp = []);
        var Ce = /* @__PURE__ */ new Set();
        Gp.length > 0 && (Gp.forEach(function($t) {
          Ce.add(Wr($t) || "Component"), uc.add($t.type);
        }), Gp = []);
        var ke = /* @__PURE__ */ new Set();
        if (Wp.length > 0 && (Wp.forEach(function($t) {
          ke.add(Wr($t) || "Component"), uc.add($t.type);
        }), Wp = []), ie.size > 0) {
          var at = lc(ie);
          be(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, at);
        }
        if (ve.size > 0) {
          var mt = lc(ve);
          be(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, mt);
        }
        if (ke.size > 0) {
          var gt = lc(ke);
          be(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, gt);
        }
        if (re.size > 0) {
          var Tt = lc(re);
          ge(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Tt);
        }
        if (he.size > 0) {
          var Pt = lc(he);
          ge(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Pt);
        }
        if (Ce.size > 0) {
          var Nt = lc(Ce);
          ge(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Nt);
        }
      };
      var fy = /* @__PURE__ */ new Map(), FE = /* @__PURE__ */ new Set();
      xs.recordLegacyContextWarning = function(re, ie) {
        var he = Ow(re);
        if (he === null) {
          be("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!FE.has(re.type)) {
          var ve = fy.get(he);
          (re.type.contextTypes != null || re.type.childContextTypes != null || ie !== null && typeof ie.getChildContext == "function") && (ve === void 0 && (ve = [], fy.set(he, ve)), ve.push(re));
        }
      }, xs.flushLegacyContextWarning = function() {
        fy.forEach(function(re, ie) {
          if (re.length !== 0) {
            var he = re[0], ve = /* @__PURE__ */ new Set();
            re.forEach(function(ke) {
              ve.add(Wr(ke) || "Component"), FE.add(ke.type);
            });
            var Ce = lc(ve);
            try {
              yn(he), be(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Ce);
            } finally {
              Un();
            }
          }
        });
      }, xs.discardPendingWarnings = function() {
        Bp = [], Hp = [], Up = [], jp = [], Gp = [], Wp = [], fy = /* @__PURE__ */ new Map();
      };
    }
    function Cs(re, ie) {
      if (re && re.defaultProps) {
        var he = Kr({}, ie), ve = re.defaultProps;
        for (var Ce in ve)
          he[Ce] === void 0 && (he[Ce] = ve[Ce]);
        return he;
      }
      return ie;
    }
    var M0 = Xu(null), F0;
    F0 = {};
    var cy = null, Wd = null, D0 = null, dy = !1;
    function hy() {
      cy = null, Wd = null, D0 = null, dy = !1;
    }
    function DE() {
      dy = !0;
    }
    function OE() {
      dy = !1;
    }
    function LE(re, ie, he) {
      $a(M0, ie._currentValue, re), ie._currentValue = he, ie._currentRenderer !== void 0 && ie._currentRenderer !== null && ie._currentRenderer !== F0 && be("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), ie._currentRenderer = F0;
    }
    function O0(re, ie) {
      var he = M0.current;
      La(M0, ie), re._currentValue = he;
    }
    function L0(re, ie, he) {
      for (var ve = re; ve !== null; ) {
        var Ce = ve.alternate;
        if (Nl(ve.childLanes, ie) ? Ce !== null && !Nl(Ce.childLanes, ie) && (Ce.childLanes = Xr(Ce.childLanes, ie)) : (ve.childLanes = Xr(ve.childLanes, ie), Ce !== null && (Ce.childLanes = Xr(Ce.childLanes, ie))), ve === he)
          break;
        ve = ve.return;
      }
      ve !== he && be("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Lw(re, ie, he) {
      $w(re, ie, he);
    }
    function $w(re, ie, he) {
      var ve = re.child;
      for (ve !== null && (ve.return = re); ve !== null; ) {
        var Ce = void 0, ke = ve.dependencies;
        if (ke !== null) {
          Ce = ve.child;
          for (var at = ke.firstContext; at !== null; ) {
            if (at.context === ie) {
              if (ve.tag === rt) {
                var mt = wi(he), gt = eu(Rn, mt);
                gt.tag = my;
                var Tt = ve.updateQueue;
                if (Tt !== null) {
                  var Pt = Tt.shared, Nt = Pt.pending;
                  Nt === null ? gt.next = gt : (gt.next = Nt.next, Nt.next = gt), Pt.pending = gt;
                }
              }
              ve.lanes = Xr(ve.lanes, he);
              var $t = ve.alternate;
              $t !== null && ($t.lanes = Xr($t.lanes, he)), L0(ve.return, he, re), ke.lanes = Xr(ke.lanes, he);
              break;
            }
            at = at.next;
          }
        } else if (ve.tag === pt)
          Ce = ve.type === re.type ? null : ve.child;
        else if (ve.tag === ir) {
          var Gt = ve.return;
          if (Gt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Gt.lanes = Xr(Gt.lanes, he);
          var Wt = Gt.alternate;
          Wt !== null && (Wt.lanes = Xr(Wt.lanes, he)), L0(Gt, he, re), Ce = ve.sibling;
        } else
          Ce = ve.child;
        if (Ce !== null)
          Ce.return = ve;
        else
          for (Ce = ve; Ce !== null; ) {
            if (Ce === re) {
              Ce = null;
              break;
            }
            var Xt = Ce.sibling;
            if (Xt !== null) {
              Xt.return = Ce.return, Ce = Xt;
              break;
            }
            Ce = Ce.return;
          }
        ve = Ce;
      }
    }
    function qd(re, ie) {
      cy = re, Wd = null, D0 = null;
      var he = re.dependencies;
      if (he !== null) {
        var ve = he.firstContext;
        ve !== null && (Oa(he.lanes, ie) && sm(), he.firstContext = null);
      }
    }
    function Bi(re) {
      dy && be("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var ie = re._currentValue;
      if (D0 !== re) {
        var he = {
          context: re,
          memoizedValue: ie,
          next: null
        };
        if (Wd === null) {
          if (cy === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Wd = he, cy.dependencies = {
            lanes: Zt,
            firstContext: he
          };
        } else
          Wd = Wd.next = he;
      }
      return ie;
    }
    var fc = null;
    function $0(re) {
      fc === null ? fc = [re] : fc.push(re);
    }
    function Iw() {
      if (fc !== null) {
        for (var re = 0; re < fc.length; re++) {
          var ie = fc[re], he = ie.interleaved;
          if (he !== null) {
            ie.interleaved = null;
            var ve = he.next, Ce = ie.pending;
            if (Ce !== null) {
              var ke = Ce.next;
              Ce.next = ve, he.next = ke;
            }
            ie.pending = he;
          }
        }
        fc = null;
      }
    }
    function $E(re, ie, he, ve) {
      var Ce = ie.interleaved;
      return Ce === null ? (he.next = he, $0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he, py(re, ve);
    }
    function Nw(re, ie, he, ve) {
      var Ce = ie.interleaved;
      Ce === null ? (he.next = he, $0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he;
    }
    function zw(re, ie, he, ve) {
      var Ce = ie.interleaved;
      return Ce === null ? (he.next = he, $0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he, py(re, ve);
    }
    function bo(re, ie) {
      return py(re, ie);
    }
    var Vw = py;
    function py(re, ie) {
      re.lanes = Xr(re.lanes, ie);
      var he = re.alternate;
      he !== null && (he.lanes = Xr(he.lanes, ie)), he === null && (re.flags & (On | fo)) !== Lr && Nx(re);
      for (var ve = re, Ce = re.return; Ce !== null; )
        Ce.childLanes = Xr(Ce.childLanes, ie), he = Ce.alternate, he !== null ? he.childLanes = Xr(he.childLanes, ie) : (Ce.flags & (On | fo)) !== Lr && Nx(re), ve = Ce, Ce = Ce.return;
      if (ve.tag === dt) {
        var ke = ve.stateNode;
        return ke;
      } else
        return null;
    }
    var IE = 0, NE = 1, my = 2, I0 = 3, vy = !1, N0, yy;
    N0 = !1, yy = null;
    function z0(re) {
      var ie = {
        baseState: re.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Zt
        },
        effects: null
      };
      re.updateQueue = ie;
    }
    function zE(re, ie) {
      var he = ie.updateQueue, ve = re.updateQueue;
      if (he === ve) {
        var Ce = {
          baseState: ve.baseState,
          firstBaseUpdate: ve.firstBaseUpdate,
          lastBaseUpdate: ve.lastBaseUpdate,
          shared: ve.shared,
          effects: ve.effects
        };
        ie.updateQueue = Ce;
      }
    }
    function eu(re, ie) {
      var he = {
        eventTime: re,
        lane: ie,
        tag: IE,
        payload: null,
        callback: null,
        next: null
      };
      return he;
    }
    function ef(re, ie, he) {
      var ve = re.updateQueue;
      if (ve === null)
        return null;
      var Ce = ve.shared;
      if (yy === Ce && !N0 && (be("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), N0 = !0), VA()) {
        var ke = Ce.pending;
        return ke === null ? ie.next = ie : (ie.next = ke.next, ke.next = ie), Ce.pending = ie, Vw(re, he);
      } else
        return zw(re, Ce, ie, he);
    }
    function gy(re, ie, he) {
      var ve = ie.updateQueue;
      if (ve !== null) {
        var Ce = ve.shared;
        if (ep(he)) {
          var ke = Ce.lanes;
          ke = rp(ke, re.pendingLanes);
          var at = Xr(ke, he);
          Ce.lanes = at, Ou(re, at);
        }
      }
    }
    function V0(re, ie) {
      var he = re.updateQueue, ve = re.alternate;
      if (ve !== null) {
        var Ce = ve.updateQueue;
        if (he === Ce) {
          var ke = null, at = null, mt = he.firstBaseUpdate;
          if (mt !== null) {
            var gt = mt;
            do {
              var Tt = {
                eventTime: gt.eventTime,
                lane: gt.lane,
                tag: gt.tag,
                payload: gt.payload,
                callback: gt.callback,
                next: null
              };
              at === null ? ke = at = Tt : (at.next = Tt, at = Tt), gt = gt.next;
            } while (gt !== null);
            at === null ? ke = at = ie : (at.next = ie, at = ie);
          } else
            ke = at = ie;
          he = {
            baseState: Ce.baseState,
            firstBaseUpdate: ke,
            lastBaseUpdate: at,
            shared: Ce.shared,
            effects: Ce.effects
          }, re.updateQueue = he;
          return;
        }
      }
      var Pt = he.lastBaseUpdate;
      Pt === null ? he.firstBaseUpdate = ie : Pt.next = ie, he.lastBaseUpdate = ie;
    }
    function Bw(re, ie, he, ve, Ce, ke) {
      switch (he.tag) {
        case NE: {
          var at = he.payload;
          if (typeof at == "function") {
            DE();
            var mt = at.call(ke, ve, Ce);
            {
              if (re.mode & Yn) {
                Ti(!0);
                try {
                  at.call(ke, ve, Ce);
                } finally {
                  Ti(!1);
                }
              }
              OE();
            }
            return mt;
          }
          return at;
        }
        case I0:
          re.flags = re.flags & ~$i | Ur;
        case IE: {
          var gt = he.payload, Tt;
          if (typeof gt == "function") {
            DE(), Tt = gt.call(ke, ve, Ce);
            {
              if (re.mode & Yn) {
                Ti(!0);
                try {
                  gt.call(ke, ve, Ce);
                } finally {
                  Ti(!1);
                }
              }
              OE();
            }
          } else
            Tt = gt;
          return Tt == null ? ve : Kr({}, ve, Tt);
        }
        case my:
          return vy = !0, ve;
      }
      return ve;
    }
    function Sy(re, ie, he, ve) {
      var Ce = re.updateQueue;
      vy = !1, yy = Ce.shared;
      var ke = Ce.firstBaseUpdate, at = Ce.lastBaseUpdate, mt = Ce.shared.pending;
      if (mt !== null) {
        Ce.shared.pending = null;
        var gt = mt, Tt = gt.next;
        gt.next = null, at === null ? ke = Tt : at.next = Tt, at = gt;
        var Pt = re.alternate;
        if (Pt !== null) {
          var Nt = Pt.updateQueue, $t = Nt.lastBaseUpdate;
          $t !== at && ($t === null ? Nt.firstBaseUpdate = Tt : $t.next = Tt, Nt.lastBaseUpdate = gt);
        }
      }
      if (ke !== null) {
        var Gt = Ce.baseState, Wt = Zt, Xt = null, xr = null, Ir = null, Fr = ke;
        do {
          var ln = Fr.lane, nn = Fr.eventTime;
          if (Nl(ve, ln)) {
            if (Ir !== null) {
              var Kt = {
                eventTime: nn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: on,
                tag: Fr.tag,
                payload: Fr.payload,
                callback: Fr.callback,
                next: null
              };
              Ir = Ir.next = Kt;
            }
            Gt = Bw(re, Ce, Fr, Gt, ie, he);
            var Ut = Fr.callback;
            if (Ut !== null && // If the update was already committed, we should not queue its
            // callback again.
            Fr.lane !== on) {
              re.flags |= Ho;
              var ur = Ce.effects;
              ur === null ? Ce.effects = [Fr] : ur.push(Fr);
            }
          } else {
            var Ht = {
              eventTime: nn,
              lane: ln,
              tag: Fr.tag,
              payload: Fr.payload,
              callback: Fr.callback,
              next: null
            };
            Ir === null ? (xr = Ir = Ht, Xt = Gt) : Ir = Ir.next = Ht, Wt = Xr(Wt, ln);
          }
          if (Fr = Fr.next, Fr === null) {
            if (mt = Ce.shared.pending, mt === null)
              break;
            var Cr = mt, gr = Cr.next;
            Cr.next = null, Fr = gr, Ce.lastBaseUpdate = Cr, Ce.shared.pending = null;
          }
        } while (!0);
        Ir === null && (Xt = Gt), Ce.baseState = Xt, Ce.firstBaseUpdate = xr, Ce.lastBaseUpdate = Ir;
        var Hr = Ce.shared.interleaved;
        if (Hr !== null) {
          var Yr = Hr;
          do
            Wt = Xr(Wt, Yr.lane), Yr = Yr.next;
          while (Yr !== Hr);
        } else
          ke === null && (Ce.shared.lanes = Zt);
        Sm(Wt), re.lanes = Wt, re.memoizedState = Gt;
      }
      yy = null;
    }
    function Hw(re, ie) {
      if (typeof re != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + re));
      re.call(ie);
    }
    function VE() {
      vy = !1;
    }
    function Ey() {
      return vy;
    }
    function BE(re, ie, he) {
      var ve = ie.effects;
      if (ie.effects = null, ve !== null)
        for (var Ce = 0; Ce < ve.length; Ce++) {
          var ke = ve[Ce], at = ke.callback;
          at !== null && (ke.callback = null, Hw(at, he));
        }
    }
    var B0 = {}, HE = new L.Component().refs, H0, U0, j0, G0, W0, UE, by, q0, Y0, Q0;
    {
      H0 = /* @__PURE__ */ new Set(), U0 = /* @__PURE__ */ new Set(), j0 = /* @__PURE__ */ new Set(), G0 = /* @__PURE__ */ new Set(), q0 = /* @__PURE__ */ new Set(), W0 = /* @__PURE__ */ new Set(), Y0 = /* @__PURE__ */ new Set(), Q0 = /* @__PURE__ */ new Set();
      var jE = /* @__PURE__ */ new Set();
      by = function(re, ie) {
        if (!(re === null || typeof re == "function")) {
          var he = ie + "_" + re;
          jE.has(he) || (jE.add(he), be("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ie, re));
        }
      }, UE = function(re, ie) {
        if (ie === void 0) {
          var he = an(re) || "Component";
          W0.has(he) || (W0.add(he), be("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", he));
        }
      }, Object.defineProperty(B0, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(B0);
    }
    function X0(re, ie, he, ve) {
      var Ce = re.memoizedState, ke = he(ve, Ce);
      {
        if (re.mode & Yn) {
          Ti(!0);
          try {
            ke = he(ve, Ce);
          } finally {
            Ti(!1);
          }
        }
        UE(ie, ke);
      }
      var at = ke == null ? Ce : Kr({}, Ce, ke);
      if (re.memoizedState = at, re.lanes === Zt) {
        var mt = re.updateQueue;
        mt.baseState = at;
      }
    }
    var K0 = {
      isMounted: qa,
      enqueueSetState: function(re, ie, he) {
        var ve = lo(re), Ce = Za(), ke = uf(ve), at = eu(Ce, ke);
        at.payload = ie, he != null && (by(he, "setState"), at.callback = he);
        var mt = ef(ve, at, ke);
        mt !== null && (Zi(mt, ve, ke, Ce), gy(mt, ve, ke)), Ys(ve, ke);
      },
      enqueueReplaceState: function(re, ie, he) {
        var ve = lo(re), Ce = Za(), ke = uf(ve), at = eu(Ce, ke);
        at.tag = NE, at.payload = ie, he != null && (by(he, "replaceState"), at.callback = he);
        var mt = ef(ve, at, ke);
        mt !== null && (Zi(mt, ve, ke, Ce), gy(mt, ve, ke)), Ys(ve, ke);
      },
      enqueueForceUpdate: function(re, ie) {
        var he = lo(re), ve = Za(), Ce = uf(he), ke = eu(ve, Ce);
        ke.tag = my, ie != null && (by(ie, "forceUpdate"), ke.callback = ie);
        var at = ef(he, ke, Ce);
        at !== null && (Zi(at, he, Ce, ve), gy(at, he, Ce)), Xh(he, Ce);
      }
    };
    function GE(re, ie, he, ve, Ce, ke, at) {
      var mt = re.stateNode;
      if (typeof mt.shouldComponentUpdate == "function") {
        var gt = mt.shouldComponentUpdate(ve, ke, at);
        {
          if (re.mode & Yn) {
            Ti(!0);
            try {
              gt = mt.shouldComponentUpdate(ve, ke, at);
            } finally {
              Ti(!1);
            }
          }
          gt === void 0 && be("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", an(ie) || "Component");
        }
        return gt;
      }
      return ie.prototype && ie.prototype.isPureReactComponent ? !Or(he, ve) || !Or(Ce, ke) : !0;
    }
    function Uw(re, ie, he) {
      var ve = re.stateNode;
      {
        var Ce = an(ie) || "Component", ke = ve.render;
        ke || (ie.prototype && typeof ie.prototype.render == "function" ? be("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", Ce) : be("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", Ce)), ve.getInitialState && !ve.getInitialState.isReactClassApproved && !ve.state && be("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", Ce), ve.getDefaultProps && !ve.getDefaultProps.isReactClassApproved && be("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", Ce), ve.propTypes && be("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", Ce), ve.contextType && be("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", Ce), ve.contextTypes && be("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", Ce), ie.contextType && ie.contextTypes && !Y0.has(ie) && (Y0.add(ie), be("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", Ce)), typeof ve.componentShouldUpdate == "function" && be("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", Ce), ie.prototype && ie.prototype.isPureReactComponent && typeof ve.shouldComponentUpdate < "u" && be("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", an(ie) || "A pure component"), typeof ve.componentDidUnmount == "function" && be("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", Ce), typeof ve.componentDidReceiveProps == "function" && be("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", Ce), typeof ve.componentWillRecieveProps == "function" && be("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", Ce), typeof ve.UNSAFE_componentWillRecieveProps == "function" && be("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", Ce);
        var at = ve.props !== he;
        ve.props !== void 0 && at && be("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", Ce, Ce), ve.defaultProps && be("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", Ce, Ce), typeof ve.getSnapshotBeforeUpdate == "function" && typeof ve.componentDidUpdate != "function" && !j0.has(ie) && (j0.add(ie), be("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", an(ie))), typeof ve.getDerivedStateFromProps == "function" && be("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Ce), typeof ve.getDerivedStateFromError == "function" && be("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Ce), typeof ie.getSnapshotBeforeUpdate == "function" && be("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", Ce);
        var mt = ve.state;
        mt && (typeof mt != "object" || Oi(mt)) && be("%s.state: must be set to an object or null", Ce), typeof ve.getChildContext == "function" && typeof ie.childContextTypes != "object" && be("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", Ce);
      }
    }
    function WE(re, ie) {
      ie.updater = K0, re.stateNode = ie, Tu(ie, re), ie._reactInternalInstance = B0;
    }
    function qE(re, ie, he) {
      var ve = !1, Ce = Fo, ke = Fo, at = ie.contextType;
      if ("contextType" in ie) {
        var mt = (
          // Allow null for conditional declaration
          at === null || at !== void 0 && at.$$typeof === pf && at._context === void 0
        );
        if (!mt && !Q0.has(ie)) {
          Q0.add(ie);
          var gt = "";
          at === void 0 ? gt = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof at != "object" ? gt = " However, it is set to a " + typeof at + "." : at.$$typeof === hf ? gt = " Did you accidentally pass the Context.Provider instead?" : at._context !== void 0 ? gt = " Did you accidentally pass the Context.Consumer instead?" : gt = " However, it is set to an object with keys {" + Object.keys(at).join(", ") + "}.", be("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", an(ie) || "Component", gt);
        }
      }
      if (typeof at == "object" && at !== null)
        ke = Bi(at);
      else {
        Ce = Bd(re, ie, !0);
        var Tt = ie.contextTypes;
        ve = Tt != null, ke = ve ? Hd(re, Ce) : Fo;
      }
      var Pt = new ie(he, ke);
      if (re.mode & Yn) {
        Ti(!0);
        try {
          Pt = new ie(he, ke);
        } finally {
          Ti(!1);
        }
      }
      var Nt = re.memoizedState = Pt.state !== null && Pt.state !== void 0 ? Pt.state : null;
      WE(re, Pt);
      {
        if (typeof ie.getDerivedStateFromProps == "function" && Nt === null) {
          var $t = an(ie) || "Component";
          U0.has($t) || (U0.add($t), be("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $t, Pt.state === null ? "null" : "undefined", $t));
        }
        if (typeof ie.getDerivedStateFromProps == "function" || typeof Pt.getSnapshotBeforeUpdate == "function") {
          var Gt = null, Wt = null, Xt = null;
          if (typeof Pt.componentWillMount == "function" && Pt.componentWillMount.__suppressDeprecationWarning !== !0 ? Gt = "componentWillMount" : typeof Pt.UNSAFE_componentWillMount == "function" && (Gt = "UNSAFE_componentWillMount"), typeof Pt.componentWillReceiveProps == "function" && Pt.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Wt = "componentWillReceiveProps" : typeof Pt.UNSAFE_componentWillReceiveProps == "function" && (Wt = "UNSAFE_componentWillReceiveProps"), typeof Pt.componentWillUpdate == "function" && Pt.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Xt = "componentWillUpdate" : typeof Pt.UNSAFE_componentWillUpdate == "function" && (Xt = "UNSAFE_componentWillUpdate"), Gt !== null || Wt !== null || Xt !== null) {
            var xr = an(ie) || "Component", Ir = typeof ie.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            G0.has(xr) || (G0.add(xr), be(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, xr, Ir, Gt !== null ? `
  ` + Gt : "", Wt !== null ? `
  ` + Wt : "", Xt !== null ? `
  ` + Xt : ""));
          }
        }
      }
      return ve && yE(re, Ce, ke), Pt;
    }
    function jw(re, ie) {
      var he = ie.state;
      typeof ie.componentWillMount == "function" && ie.componentWillMount(), typeof ie.UNSAFE_componentWillMount == "function" && ie.UNSAFE_componentWillMount(), he !== ie.state && (be("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Wr(re) || "Component"), K0.enqueueReplaceState(ie, ie.state, null));
    }
    function YE(re, ie, he, ve) {
      var Ce = ie.state;
      if (typeof ie.componentWillReceiveProps == "function" && ie.componentWillReceiveProps(he, ve), typeof ie.UNSAFE_componentWillReceiveProps == "function" && ie.UNSAFE_componentWillReceiveProps(he, ve), ie.state !== Ce) {
        {
          var ke = Wr(re) || "Component";
          H0.has(ke) || (H0.add(ke), be("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ke));
        }
        K0.enqueueReplaceState(ie, ie.state, null);
      }
    }
    function J0(re, ie, he, ve) {
      Uw(re, ie, he);
      var Ce = re.stateNode;
      Ce.props = he, Ce.state = re.memoizedState, Ce.refs = HE, z0(re);
      var ke = ie.contextType;
      if (typeof ke == "object" && ke !== null)
        Ce.context = Bi(ke);
      else {
        var at = Bd(re, ie, !0);
        Ce.context = Hd(re, at);
      }
      {
        if (Ce.state === he) {
          var mt = an(ie) || "Component";
          q0.has(mt) || (q0.add(mt), be("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", mt));
        }
        re.mode & Yn && xs.recordLegacyContextWarning(re, Ce), xs.recordUnsafeLifecycleWarnings(re, Ce);
      }
      Ce.state = re.memoizedState;
      var gt = ie.getDerivedStateFromProps;
      if (typeof gt == "function" && (X0(re, ie, gt, he), Ce.state = re.memoizedState), typeof ie.getDerivedStateFromProps != "function" && typeof Ce.getSnapshotBeforeUpdate != "function" && (typeof Ce.UNSAFE_componentWillMount == "function" || typeof Ce.componentWillMount == "function") && (jw(re, Ce), Sy(re, he, Ce, ve), Ce.state = re.memoizedState), typeof Ce.componentDidMount == "function") {
        var Tt = Qr;
        Tt |= Pa, (re.mode & po) !== zr && (Tt |= Ra), re.flags |= Tt;
      }
    }
    function Gw(re, ie, he, ve) {
      var Ce = re.stateNode, ke = re.memoizedProps;
      Ce.props = ke;
      var at = Ce.context, mt = ie.contextType, gt = Fo;
      if (typeof mt == "object" && mt !== null)
        gt = Bi(mt);
      else {
        var Tt = Bd(re, ie, !0);
        gt = Hd(re, Tt);
      }
      var Pt = ie.getDerivedStateFromProps, Nt = typeof Pt == "function" || typeof Ce.getSnapshotBeforeUpdate == "function";
      !Nt && (typeof Ce.UNSAFE_componentWillReceiveProps == "function" || typeof Ce.componentWillReceiveProps == "function") && (ke !== he || at !== gt) && YE(re, Ce, he, gt), VE();
      var $t = re.memoizedState, Gt = Ce.state = $t;
      if (Sy(re, he, Ce, ve), Gt = re.memoizedState, ke === he && $t === Gt && !ry() && !Ey()) {
        if (typeof Ce.componentDidMount == "function") {
          var Wt = Qr;
          Wt |= Pa, (re.mode & po) !== zr && (Wt |= Ra), re.flags |= Wt;
        }
        return !1;
      }
      typeof Pt == "function" && (X0(re, ie, Pt, he), Gt = re.memoizedState);
      var Xt = Ey() || GE(re, ie, ke, he, $t, Gt, gt);
      if (Xt) {
        if (!Nt && (typeof Ce.UNSAFE_componentWillMount == "function" || typeof Ce.componentWillMount == "function") && (typeof Ce.componentWillMount == "function" && Ce.componentWillMount(), typeof Ce.UNSAFE_componentWillMount == "function" && Ce.UNSAFE_componentWillMount()), typeof Ce.componentDidMount == "function") {
          var xr = Qr;
          xr |= Pa, (re.mode & po) !== zr && (xr |= Ra), re.flags |= xr;
        }
      } else {
        if (typeof Ce.componentDidMount == "function") {
          var Ir = Qr;
          Ir |= Pa, (re.mode & po) !== zr && (Ir |= Ra), re.flags |= Ir;
        }
        re.memoizedProps = he, re.memoizedState = Gt;
      }
      return Ce.props = he, Ce.state = Gt, Ce.context = gt, Xt;
    }
    function Ww(re, ie, he, ve, Ce) {
      var ke = ie.stateNode;
      zE(re, ie);
      var at = ie.memoizedProps, mt = ie.type === ie.elementType ? at : Cs(ie.type, at);
      ke.props = mt;
      var gt = ie.pendingProps, Tt = ke.context, Pt = he.contextType, Nt = Fo;
      if (typeof Pt == "object" && Pt !== null)
        Nt = Bi(Pt);
      else {
        var $t = Bd(ie, he, !0);
        Nt = Hd(ie, $t);
      }
      var Gt = he.getDerivedStateFromProps, Wt = typeof Gt == "function" || typeof ke.getSnapshotBeforeUpdate == "function";
      !Wt && (typeof ke.UNSAFE_componentWillReceiveProps == "function" || typeof ke.componentWillReceiveProps == "function") && (at !== gt || Tt !== Nt) && YE(ie, ke, ve, Nt), VE();
      var Xt = ie.memoizedState, xr = ke.state = Xt;
      if (Sy(ie, ve, ke, Ce), xr = ie.memoizedState, at === gt && Xt === xr && !ry() && !Ey() && !Et)
        return typeof ke.componentDidUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= Qr), typeof ke.getSnapshotBeforeUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= uo), !1;
      typeof Gt == "function" && (X0(ie, he, Gt, ve), xr = ie.memoizedState);
      var Ir = Ey() || GE(ie, he, mt, ve, Xt, xr, Nt) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Et;
      return Ir ? (!Wt && (typeof ke.UNSAFE_componentWillUpdate == "function" || typeof ke.componentWillUpdate == "function") && (typeof ke.componentWillUpdate == "function" && ke.componentWillUpdate(ve, xr, Nt), typeof ke.UNSAFE_componentWillUpdate == "function" && ke.UNSAFE_componentWillUpdate(ve, xr, Nt)), typeof ke.componentDidUpdate == "function" && (ie.flags |= Qr), typeof ke.getSnapshotBeforeUpdate == "function" && (ie.flags |= uo)) : (typeof ke.componentDidUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= Qr), typeof ke.getSnapshotBeforeUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= uo), ie.memoizedProps = ve, ie.memoizedState = xr), ke.props = ve, ke.state = xr, ke.context = Nt, Ir;
    }
    var Z0, e1, t1, r1, n1, QE = function(re, ie) {
    };
    Z0 = !1, e1 = !1, t1 = {}, r1 = {}, n1 = {}, QE = function(re, ie) {
      if (!(re === null || typeof re != "object") && !(!re._store || re._store.validated || re.key != null)) {
        if (typeof re._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        re._store.validated = !0;
        var he = Wr(ie) || "Component";
        r1[he] || (r1[he] = !0, be('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function qp(re, ie, he) {
      var ve = he.ref;
      if (ve !== null && typeof ve != "function" && typeof ve != "object") {
        if ((re.mode & Yn || mr) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(he._owner && he._self && he._owner.stateNode !== he._self)) {
          var Ce = Wr(re) || "Component";
          t1[Ce] || (be('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ve), t1[Ce] = !0);
        }
        if (he._owner) {
          var ke = he._owner, at;
          if (ke) {
            var mt = ke;
            if (mt.tag !== rt)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            at = mt.stateNode;
          }
          if (!at)
            throw new Error("Missing owner for string ref " + ve + ". This error is likely caused by a bug in React. Please file an issue.");
          var gt = at;
          Ei(ve, "ref");
          var Tt = "" + ve;
          if (ie !== null && ie.ref !== null && typeof ie.ref == "function" && ie.ref._stringRef === Tt)
            return ie.ref;
          var Pt = function(Nt) {
            var $t = gt.refs;
            $t === HE && ($t = gt.refs = {}), Nt === null ? delete $t[Tt] : $t[Tt] = Nt;
          };
          return Pt._stringRef = Tt, Pt;
        } else {
          if (typeof ve != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!he._owner)
            throw new Error("Element ref was specified as a string (" + ve + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return ve;
    }
    function xy(re, ie) {
      var he = Object.prototype.toString.call(ie);
      throw new Error("Objects are not valid as a React child (found: " + (he === "[object Object]" ? "object with keys {" + Object.keys(ie).join(", ") + "}" : he) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Cy(re) {
      {
        var ie = Wr(re) || "Component";
        if (n1[ie])
          return;
        n1[ie] = !0, be("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function XE(re) {
      var ie = re._payload, he = re._init;
      return he(ie);
    }
    function KE(re) {
      function ie(Ht, Kt) {
        if (re) {
          var Ut = Ht.deletions;
          Ut === null ? (Ht.deletions = [Kt], Ht.flags |= pn) : Ut.push(Kt);
        }
      }
      function he(Ht, Kt) {
        if (!re)
          return null;
        for (var Ut = Kt; Ut !== null; )
          ie(Ht, Ut), Ut = Ut.sibling;
        return null;
      }
      function ve(Ht, Kt) {
        for (var Ut = /* @__PURE__ */ new Map(), ur = Kt; ur !== null; )
          ur.key !== null ? Ut.set(ur.key, ur) : Ut.set(ur.index, ur), ur = ur.sibling;
        return Ut;
      }
      function Ce(Ht, Kt) {
        var Ut = gc(Ht, Kt);
        return Ut.index = 0, Ut.sibling = null, Ut;
      }
      function ke(Ht, Kt, Ut) {
        if (Ht.index = Ut, !re)
          return Ht.flags |= Nh, Kt;
        var ur = Ht.alternate;
        if (ur !== null) {
          var Cr = ur.index;
          return Cr < Kt ? (Ht.flags |= On, Kt) : Cr;
        } else
          return Ht.flags |= On, Kt;
      }
      function at(Ht) {
        return re && Ht.alternate === null && (Ht.flags |= On), Ht;
      }
      function mt(Ht, Kt, Ut, ur) {
        if (Kt === null || Kt.tag !== it) {
          var Cr = kS(Ut, Ht.mode, ur);
          return Cr.return = Ht, Cr;
        } else {
          var gr = Ce(Kt, Ut);
          return gr.return = Ht, gr;
        }
      }
      function gt(Ht, Kt, Ut, ur) {
        var Cr = Ut.type;
        if (Cr === Ha)
          return Pt(Ht, Kt, Ut.props.children, ur, Ut.key);
        if (Kt !== null && (Kt.elementType === Cr || // Keep this check inline so it only runs on the false path:
        Hx(Kt, Ut) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Cr == "object" && Cr !== null && Cr.$$typeof === Hi && XE(Cr) === Kt.type)) {
          var gr = Ce(Kt, Ut.props);
          return gr.ref = qp(Ht, Kt, Ut), gr.return = Ht, gr._debugSource = Ut._source, gr._debugOwner = Ut._owner, gr;
        }
        var Hr = RS(Ut, Ht.mode, ur);
        return Hr.ref = qp(Ht, Kt, Ut), Hr.return = Ht, Hr;
      }
      function Tt(Ht, Kt, Ut, ur) {
        if (Kt === null || Kt.tag !== ut || Kt.stateNode.containerInfo !== Ut.containerInfo || Kt.stateNode.implementation !== Ut.implementation) {
          var Cr = MS(Ut, Ht.mode, ur);
          return Cr.return = Ht, Cr;
        } else {
          var gr = Ce(Kt, Ut.children || []);
          return gr.return = Ht, gr;
        }
      }
      function Pt(Ht, Kt, Ut, ur, Cr) {
        if (Kt === null || Kt.tag !== lt) {
          var gr = cf(Ut, Ht.mode, ur, Cr);
          return gr.return = Ht, gr;
        } else {
          var Hr = Ce(Kt, Ut);
          return Hr.return = Ht, Hr;
        }
      }
      function Nt(Ht, Kt, Ut) {
        if (typeof Kt == "string" && Kt !== "" || typeof Kt == "number") {
          var ur = kS("" + Kt, Ht.mode, Ut);
          return ur.return = Ht, ur;
        }
        if (typeof Kt == "object" && Kt !== null) {
          switch (Kt.$$typeof) {
            case Fs: {
              var Cr = RS(Kt, Ht.mode, Ut);
              return Cr.ref = qp(Ht, null, Kt), Cr.return = Ht, Cr;
            }
            case xa: {
              var gr = MS(Kt, Ht.mode, Ut);
              return gr.return = Ht, gr;
            }
            case Hi: {
              var Hr = Kt._payload, Yr = Kt._init;
              return Nt(Ht, Yr(Hr), Ut);
            }
          }
          if (Oi(Kt) || wo(Kt)) {
            var Cn = cf(Kt, Ht.mode, Ut, null);
            return Cn.return = Ht, Cn;
          }
          xy(Ht, Kt);
        }
        return typeof Kt == "function" && Cy(Ht), null;
      }
      function $t(Ht, Kt, Ut, ur) {
        var Cr = Kt !== null ? Kt.key : null;
        if (typeof Ut == "string" && Ut !== "" || typeof Ut == "number")
          return Cr !== null ? null : mt(Ht, Kt, "" + Ut, ur);
        if (typeof Ut == "object" && Ut !== null) {
          switch (Ut.$$typeof) {
            case Fs:
              return Ut.key === Cr ? gt(Ht, Kt, Ut, ur) : null;
            case xa:
              return Ut.key === Cr ? Tt(Ht, Kt, Ut, ur) : null;
            case Hi: {
              var gr = Ut._payload, Hr = Ut._init;
              return $t(Ht, Kt, Hr(gr), ur);
            }
          }
          if (Oi(Ut) || wo(Ut))
            return Cr !== null ? null : Pt(Ht, Kt, Ut, ur, null);
          xy(Ht, Ut);
        }
        return typeof Ut == "function" && Cy(Ht), null;
      }
      function Gt(Ht, Kt, Ut, ur, Cr) {
        if (typeof ur == "string" && ur !== "" || typeof ur == "number") {
          var gr = Ht.get(Ut) || null;
          return mt(Kt, gr, "" + ur, Cr);
        }
        if (typeof ur == "object" && ur !== null) {
          switch (ur.$$typeof) {
            case Fs: {
              var Hr = Ht.get(ur.key === null ? Ut : ur.key) || null;
              return gt(Kt, Hr, ur, Cr);
            }
            case xa: {
              var Yr = Ht.get(ur.key === null ? Ut : ur.key) || null;
              return Tt(Kt, Yr, ur, Cr);
            }
            case Hi:
              var Cn = ur._payload, dn = ur._init;
              return Gt(Ht, Kt, Ut, dn(Cn), Cr);
          }
          if (Oi(ur) || wo(ur)) {
            var Ri = Ht.get(Ut) || null;
            return Pt(Kt, Ri, ur, Cr, null);
          }
          xy(Kt, ur);
        }
        return typeof ur == "function" && Cy(Kt), null;
      }
      function Wt(Ht, Kt, Ut) {
        {
          if (typeof Ht != "object" || Ht === null)
            return Kt;
          switch (Ht.$$typeof) {
            case Fs:
            case xa:
              QE(Ht, Ut);
              var ur = Ht.key;
              if (typeof ur != "string")
                break;
              if (Kt === null) {
                Kt = /* @__PURE__ */ new Set(), Kt.add(ur);
                break;
              }
              if (!Kt.has(ur)) {
                Kt.add(ur);
                break;
              }
              be("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", ur);
              break;
            case Hi:
              var Cr = Ht._payload, gr = Ht._init;
              Wt(gr(Cr), Kt, Ut);
              break;
          }
        }
        return Kt;
      }
      function Xt(Ht, Kt, Ut, ur) {
        for (var Cr = null, gr = 0; gr < Ut.length; gr++) {
          var Hr = Ut[gr];
          Cr = Wt(Hr, Cr, Ht);
        }
        for (var Yr = null, Cn = null, dn = Kt, Ri = 0, hn = 0, Si = null; dn !== null && hn < Ut.length; hn++) {
          dn.index > hn ? (Si = dn, dn = null) : Si = dn.sibling;
          var Na = $t(Ht, dn, Ut[hn], ur);
          if (Na === null) {
            dn === null && (dn = Si);
            break;
          }
          re && dn && Na.alternate === null && ie(Ht, dn), Ri = ke(Na, Ri, hn), Cn === null ? Yr = Na : Cn.sibling = Na, Cn = Na, dn = Si;
        }
        if (hn === Ut.length) {
          if (he(Ht, dn), ha()) {
            var Ea = hn;
            ac(Ht, Ea);
          }
          return Yr;
        }
        if (dn === null) {
          for (; hn < Ut.length; hn++) {
            var Oo = Nt(Ht, Ut[hn], ur);
            Oo !== null && (Ri = ke(Oo, Ri, hn), Cn === null ? Yr = Oo : Cn.sibling = Oo, Cn = Oo);
          }
          if (ha()) {
            var eo = hn;
            ac(Ht, eo);
          }
          return Yr;
        }
        for (var to = ve(Ht, dn); hn < Ut.length; hn++) {
          var za = Gt(to, Ht, hn, Ut[hn], ur);
          za !== null && (re && za.alternate !== null && to.delete(za.key === null ? hn : za.key), Ri = ke(za, Ri, hn), Cn === null ? Yr = za : Cn.sibling = za, Cn = za);
        }
        if (re && to.forEach(function(fh) {
          return ie(Ht, fh);
        }), ha()) {
          var ou = hn;
          ac(Ht, ou);
        }
        return Yr;
      }
      function xr(Ht, Kt, Ut, ur) {
        var Cr = wo(Ut);
        if (typeof Cr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ut[Symbol.toStringTag] === "Generator" && (e1 || be("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), e1 = !0), Ut.entries === Cr && (Z0 || be("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Z0 = !0);
          var gr = Cr.call(Ut);
          if (gr)
            for (var Hr = null, Yr = gr.next(); !Yr.done; Yr = gr.next()) {
              var Cn = Yr.value;
              Hr = Wt(Cn, Hr, Ht);
            }
        }
        var dn = Cr.call(Ut);
        if (dn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Ri = null, hn = null, Si = Kt, Na = 0, Ea = 0, Oo = null, eo = dn.next(); Si !== null && !eo.done; Ea++, eo = dn.next()) {
          Si.index > Ea ? (Oo = Si, Si = null) : Oo = Si.sibling;
          var to = $t(Ht, Si, eo.value, ur);
          if (to === null) {
            Si === null && (Si = Oo);
            break;
          }
          re && Si && to.alternate === null && ie(Ht, Si), Na = ke(to, Na, Ea), hn === null ? Ri = to : hn.sibling = to, hn = to, Si = Oo;
        }
        if (eo.done) {
          if (he(Ht, Si), ha()) {
            var za = Ea;
            ac(Ht, za);
          }
          return Ri;
        }
        if (Si === null) {
          for (; !eo.done; Ea++, eo = dn.next()) {
            var ou = Nt(Ht, eo.value, ur);
            ou !== null && (Na = ke(ou, Na, Ea), hn === null ? Ri = ou : hn.sibling = ou, hn = ou);
          }
          if (ha()) {
            var fh = Ea;
            ac(Ht, fh);
          }
          return Ri;
        }
        for (var Tm = ve(Ht, Si); !eo.done; Ea++, eo = dn.next()) {
          var dl = Gt(Tm, Ht, Ea, eo.value, ur);
          dl !== null && (re && dl.alternate !== null && Tm.delete(dl.key === null ? Ea : dl.key), Na = ke(dl, Na, Ea), hn === null ? Ri = dl : hn.sibling = dl, hn = dl);
        }
        if (re && Tm.forEach(function(oR) {
          return ie(Ht, oR);
        }), ha()) {
          var aR = Ea;
          ac(Ht, aR);
        }
        return Ri;
      }
      function Ir(Ht, Kt, Ut, ur) {
        if (Kt !== null && Kt.tag === it) {
          he(Ht, Kt.sibling);
          var Cr = Ce(Kt, Ut);
          return Cr.return = Ht, Cr;
        }
        he(Ht, Kt);
        var gr = kS(Ut, Ht.mode, ur);
        return gr.return = Ht, gr;
      }
      function Fr(Ht, Kt, Ut, ur) {
        for (var Cr = Ut.key, gr = Kt; gr !== null; ) {
          if (gr.key === Cr) {
            var Hr = Ut.type;
            if (Hr === Ha) {
              if (gr.tag === lt) {
                he(Ht, gr.sibling);
                var Yr = Ce(gr, Ut.props.children);
                return Yr.return = Ht, Yr._debugSource = Ut._source, Yr._debugOwner = Ut._owner, Yr;
              }
            } else if (gr.elementType === Hr || // Keep this check inline so it only runs on the false path:
            Hx(gr, Ut) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Hr == "object" && Hr !== null && Hr.$$typeof === Hi && XE(Hr) === gr.type) {
              he(Ht, gr.sibling);
              var Cn = Ce(gr, Ut.props);
              return Cn.ref = qp(Ht, gr, Ut), Cn.return = Ht, Cn._debugSource = Ut._source, Cn._debugOwner = Ut._owner, Cn;
            }
            he(Ht, gr);
            break;
          } else
            ie(Ht, gr);
          gr = gr.sibling;
        }
        if (Ut.type === Ha) {
          var dn = cf(Ut.props.children, Ht.mode, ur, Ut.key);
          return dn.return = Ht, dn;
        } else {
          var Ri = RS(Ut, Ht.mode, ur);
          return Ri.ref = qp(Ht, Kt, Ut), Ri.return = Ht, Ri;
        }
      }
      function ln(Ht, Kt, Ut, ur) {
        for (var Cr = Ut.key, gr = Kt; gr !== null; ) {
          if (gr.key === Cr)
            if (gr.tag === ut && gr.stateNode.containerInfo === Ut.containerInfo && gr.stateNode.implementation === Ut.implementation) {
              he(Ht, gr.sibling);
              var Hr = Ce(gr, Ut.children || []);
              return Hr.return = Ht, Hr;
            } else {
              he(Ht, gr);
              break;
            }
          else
            ie(Ht, gr);
          gr = gr.sibling;
        }
        var Yr = MS(Ut, Ht.mode, ur);
        return Yr.return = Ht, Yr;
      }
      function nn(Ht, Kt, Ut, ur) {
        var Cr = typeof Ut == "object" && Ut !== null && Ut.type === Ha && Ut.key === null;
        if (Cr && (Ut = Ut.props.children), typeof Ut == "object" && Ut !== null) {
          switch (Ut.$$typeof) {
            case Fs:
              return at(Fr(Ht, Kt, Ut, ur));
            case xa:
              return at(ln(Ht, Kt, Ut, ur));
            case Hi:
              var gr = Ut._payload, Hr = Ut._init;
              return nn(Ht, Kt, Hr(gr), ur);
          }
          if (Oi(Ut))
            return Xt(Ht, Kt, Ut, ur);
          if (wo(Ut))
            return xr(Ht, Kt, Ut, ur);
          xy(Ht, Ut);
        }
        return typeof Ut == "string" && Ut !== "" || typeof Ut == "number" ? at(Ir(Ht, Kt, "" + Ut, ur)) : (typeof Ut == "function" && Cy(Ht), he(Ht, Kt));
      }
      return nn;
    }
    var Yd = KE(!0), JE = KE(!1);
    function qw(re, ie) {
      if (re !== null && ie.child !== re.child)
        throw new Error("Resuming work not yet implemented.");
      if (ie.child !== null) {
        var he = ie.child, ve = gc(he, he.pendingProps);
        for (ie.child = ve, ve.return = ie; he.sibling !== null; )
          he = he.sibling, ve = ve.sibling = gc(he, he.pendingProps), ve.return = ie;
        ve.sibling = null;
      }
    }
    function Yw(re, ie) {
      for (var he = re.child; he !== null; )
        CP(he, ie), he = he.sibling;
    }
    var Yp = {}, tf = Xu(Yp), Qp = Xu(Yp), Ty = Xu(Yp);
    function wy(re) {
      if (re === Yp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return re;
    }
    function ZE() {
      var re = wy(Ty.current);
      return re;
    }
    function i1(re, ie) {
      $a(Ty, ie, re), $a(Qp, re, re), $a(tf, Yp, re);
      var he = lT(ie);
      La(tf, re), $a(tf, he, re);
    }
    function Qd(re) {
      La(tf, re), La(Qp, re), La(Ty, re);
    }
    function a1() {
      var re = wy(tf.current);
      return re;
    }
    function eb(re) {
      wy(Ty.current);
      var ie = wy(tf.current), he = uT(ie, re.type);
      ie !== he && ($a(Qp, re, re), $a(tf, he, re));
    }
    function o1(re) {
      Qp.current === re && (La(tf, re), La(Qp, re));
    }
    var Qw = 0, tb = 1, rb = 1, Xp = 2, Ts = Xu(Qw);
    function s1(re, ie) {
      return (re & ie) !== 0;
    }
    function Xd(re) {
      return re & tb;
    }
    function l1(re, ie) {
      return re & tb | ie;
    }
    function Xw(re, ie) {
      return re | ie;
    }
    function rf(re, ie) {
      $a(Ts, ie, re);
    }
    function Kd(re) {
      La(Ts, re);
    }
    function Kw(re, ie) {
      var he = re.memoizedState;
      return he !== null ? he.dehydrated !== null : (re.memoizedProps, !0);
    }
    function _y(re) {
      for (var ie = re; ie !== null; ) {
        if (ie.tag === xt) {
          var he = ie.memoizedState;
          if (he !== null) {
            var ve = he.dehydrated;
            if (ve === null || dE(ve) || p0(ve))
              return ie;
          }
        } else if (ie.tag === er && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        ie.memoizedProps.revealOrder !== void 0) {
          var Ce = (ie.flags & Ur) !== Lr;
          if (Ce)
            return ie;
        } else if (ie.child !== null) {
          ie.child.return = ie, ie = ie.child;
          continue;
        }
        if (ie === re)
          return null;
        for (; ie.sibling === null; ) {
          if (ie.return === null || ie.return === re)
            return null;
          ie = ie.return;
        }
        ie.sibling.return = ie.return, ie = ie.sibling;
      }
      return null;
    }
    var xo = (
      /*   */
      0
    ), Wi = (
      /* */
      1
    ), al = (
      /*  */
      2
    ), qi = (
      /*    */
      4
    ), pa = (
      /*   */
      8
    ), u1 = [];
    function f1() {
      for (var re = 0; re < u1.length; re++) {
        var ie = u1[re];
        ie._workInProgressVersionPrimary = null;
      }
      u1.length = 0;
    }
    function Jw(re, ie) {
      var he = ie._getVersion, ve = he(ie._source);
      re.mutableSourceEagerHydrationData == null ? re.mutableSourceEagerHydrationData = [ie, ve] : re.mutableSourceEagerHydrationData.push(ie, ve);
    }
    var br = oe.ReactCurrentDispatcher, Kp = oe.ReactCurrentBatchConfig, c1, Jd;
    c1 = /* @__PURE__ */ new Set();
    var cc = Zt, xn = null, Yi = null, Qi = null, Ay = !1, Jp = !1, Zp = 0, Zw = 0, e_ = 25, tr = null, Ko = null, nf = -1, d1 = !1;
    function En() {
      {
        var re = tr;
        Ko === null ? Ko = [re] : Ko.push(re);
      }
    }
    function pr() {
      {
        var re = tr;
        Ko !== null && (nf++, Ko[nf] !== re && t_(re));
      }
    }
    function Zd(re) {
      re != null && !Oi(re) && be("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", tr, typeof re);
    }
    function t_(re) {
      {
        var ie = Wr(xn);
        if (!c1.has(ie) && (c1.add(ie), Ko !== null)) {
          for (var he = "", ve = 30, Ce = 0; Ce <= nf; Ce++) {
            for (var ke = Ko[Ce], at = Ce === nf ? re : ke, mt = Ce + 1 + ". " + ke; mt.length < ve; )
              mt += " ";
            mt += at + `
`, he += mt;
          }
          be(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, ie, he);
        }
      }
    }
    function Ia() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function h1(re, ie) {
      if (d1)
        return !1;
      if (ie === null)
        return be("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", tr), !1;
      re.length !== ie.length && be(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, tr, "[" + ie.join(", ") + "]", "[" + re.join(", ") + "]");
      for (var he = 0; he < ie.length && he < re.length; he++)
        if (!Ar(re[he], ie[he]))
          return !1;
      return !0;
    }
    function eh(re, ie, he, ve, Ce, ke) {
      cc = ke, xn = ie, Ko = re !== null ? re._debugHookTypes : null, nf = -1, d1 = re !== null && re.type !== ie.type, ie.memoizedState = null, ie.updateQueue = null, ie.lanes = Zt, re !== null && re.memoizedState !== null ? br.current = wb : Ko !== null ? br.current = Tb : br.current = Cb;
      var at = he(ve, Ce);
      if (Jp) {
        var mt = 0;
        do {
          if (Jp = !1, Zp = 0, mt >= e_)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          mt += 1, d1 = !1, Yi = null, Qi = null, ie.updateQueue = null, nf = -1, br.current = _b, at = he(ve, Ce);
        } while (Jp);
      }
      br.current = Vy, ie._debugHookTypes = Ko;
      var gt = Yi !== null && Yi.next !== null;
      if (cc = Zt, xn = null, Yi = null, Qi = null, tr = null, Ko = null, nf = -1, re !== null && (re.flags & Ui) !== (ie.flags & Ui) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (re.mode & Zr) !== zr && be("Internal React error: Expected static flag was missing. Please notify the React team."), Ay = !1, gt)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return at;
    }
    function th() {
      var re = Zp !== 0;
      return Zp = 0, re;
    }
    function nb(re, ie, he) {
      ie.updateQueue = re.updateQueue, (ie.mode & po) !== zr ? ie.flags &= ~(Pl | Ra | jn | Qr) : ie.flags &= ~(jn | Qr), re.lanes = Du(re.lanes, he);
    }
    function ib() {
      if (br.current = Vy, Ay) {
        for (var re = xn.memoizedState; re !== null; ) {
          var ie = re.queue;
          ie !== null && (ie.pending = null), re = re.next;
        }
        Ay = !1;
      }
      cc = Zt, xn = null, Yi = null, Qi = null, Ko = null, nf = -1, tr = null, gb = !1, Jp = !1, Zp = 0;
    }
    function ol() {
      var re = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Qi === null ? xn.memoizedState = Qi = re : Qi = Qi.next = re, Qi;
    }
    function Jo() {
      var re;
      if (Yi === null) {
        var ie = xn.alternate;
        ie !== null ? re = ie.memoizedState : re = null;
      } else
        re = Yi.next;
      var he;
      if (Qi === null ? he = xn.memoizedState : he = Qi.next, he !== null)
        Qi = he, he = Qi.next, Yi = re;
      else {
        if (re === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Yi = re;
        var ve = {
          memoizedState: Yi.memoizedState,
          baseState: Yi.baseState,
          baseQueue: Yi.baseQueue,
          queue: Yi.queue,
          next: null
        };
        Qi === null ? xn.memoizedState = Qi = ve : Qi = Qi.next = ve;
      }
      return Qi;
    }
    function ab() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function p1(re, ie) {
      return typeof ie == "function" ? ie(re) : ie;
    }
    function m1(re, ie, he) {
      var ve = ol(), Ce;
      he !== void 0 ? Ce = he(ie) : Ce = ie, ve.memoizedState = ve.baseState = Ce;
      var ke = {
        pending: null,
        interleaved: null,
        lanes: Zt,
        dispatch: null,
        lastRenderedReducer: re,
        lastRenderedState: Ce
      };
      ve.queue = ke;
      var at = ke.dispatch = a_.bind(null, xn, ke);
      return [ve.memoizedState, at];
    }
    function v1(re, ie, he) {
      var ve = Jo(), Ce = ve.queue;
      if (Ce === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Ce.lastRenderedReducer = re;
      var ke = Yi, at = ke.baseQueue, mt = Ce.pending;
      if (mt !== null) {
        if (at !== null) {
          var gt = at.next, Tt = mt.next;
          at.next = Tt, mt.next = gt;
        }
        ke.baseQueue !== at && be("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), ke.baseQueue = at = mt, Ce.pending = null;
      }
      if (at !== null) {
        var Pt = at.next, Nt = ke.baseState, $t = null, Gt = null, Wt = null, Xt = Pt;
        do {
          var xr = Xt.lane;
          if (Nl(cc, xr)) {
            if (Wt !== null) {
              var Fr = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: on,
                action: Xt.action,
                hasEagerState: Xt.hasEagerState,
                eagerState: Xt.eagerState,
                next: null
              };
              Wt = Wt.next = Fr;
            }
            if (Xt.hasEagerState)
              Nt = Xt.eagerState;
            else {
              var ln = Xt.action;
              Nt = re(Nt, ln);
            }
          } else {
            var Ir = {
              lane: xr,
              action: Xt.action,
              hasEagerState: Xt.hasEagerState,
              eagerState: Xt.eagerState,
              next: null
            };
            Wt === null ? (Gt = Wt = Ir, $t = Nt) : Wt = Wt.next = Ir, xn.lanes = Xr(xn.lanes, xr), Sm(xr);
          }
          Xt = Xt.next;
        } while (Xt !== null && Xt !== Pt);
        Wt === null ? $t = Nt : Wt.next = Gt, Ar(Nt, ve.memoizedState) || sm(), ve.memoizedState = Nt, ve.baseState = $t, ve.baseQueue = Wt, Ce.lastRenderedState = Nt;
      }
      var nn = Ce.interleaved;
      if (nn !== null) {
        var Ht = nn;
        do {
          var Kt = Ht.lane;
          xn.lanes = Xr(xn.lanes, Kt), Sm(Kt), Ht = Ht.next;
        } while (Ht !== nn);
      } else
        at === null && (Ce.lanes = Zt);
      var Ut = Ce.dispatch;
      return [ve.memoizedState, Ut];
    }
    function y1(re, ie, he) {
      var ve = Jo(), Ce = ve.queue;
      if (Ce === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Ce.lastRenderedReducer = re;
      var ke = Ce.dispatch, at = Ce.pending, mt = ve.memoizedState;
      if (at !== null) {
        Ce.pending = null;
        var gt = at.next, Tt = gt;
        do {
          var Pt = Tt.action;
          mt = re(mt, Pt), Tt = Tt.next;
        } while (Tt !== gt);
        Ar(mt, ve.memoizedState) || sm(), ve.memoizedState = mt, ve.baseQueue === null && (ve.baseState = mt), Ce.lastRenderedState = mt;
      }
      return [mt, ke];
    }
    function lR(re, ie, he) {
    }
    function uR(re, ie, he) {
    }
    function g1(re, ie, he) {
      var ve = xn, Ce = ol(), ke, at = ha();
      if (at) {
        if (he === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        ke = he(), Jd || ke !== he() && (be("The result of getServerSnapshot should be cached to avoid an infinite loop"), Jd = !0);
      } else {
        if (ke = ie(), !Jd) {
          var mt = ie();
          Ar(ke, mt) || (be("The result of getSnapshot should be cached to avoid an infinite loop"), Jd = !0);
        }
        var gt = ig();
        if (gt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Hf(gt, cc) || sb(ve, ie, ke);
      }
      Ce.memoizedState = ke;
      var Tt = {
        value: ke,
        getSnapshot: ie
      };
      return Ce.queue = Tt, Fy(ub.bind(null, ve, Tt, re), [re]), ve.flags |= jn, em(Wi | pa, lb.bind(null, ve, Tt, ke, ie), void 0, null), ke;
    }
    function Py(re, ie, he) {
      var ve = xn, Ce = Jo(), ke = ie();
      if (!Jd) {
        var at = ie();
        Ar(ke, at) || (be("The result of getSnapshot should be cached to avoid an infinite loop"), Jd = !0);
      }
      var mt = Ce.memoizedState, gt = !Ar(mt, ke);
      gt && (Ce.memoizedState = ke, sm());
      var Tt = Ce.queue;
      if (rm(ub.bind(null, ve, Tt, re), [re]), Tt.getSnapshot !== ie || gt || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Qi !== null && Qi.memoizedState.tag & Wi) {
        ve.flags |= jn, em(Wi | pa, lb.bind(null, ve, Tt, ke, ie), void 0, null);
        var Pt = ig();
        if (Pt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Hf(Pt, cc) || sb(ve, ie, ke);
      }
      return ke;
    }
    function sb(re, ie, he) {
      re.flags |= Df;
      var ve = {
        getSnapshot: ie,
        value: he
      }, Ce = xn.updateQueue;
      if (Ce === null)
        Ce = ab(), xn.updateQueue = Ce, Ce.stores = [ve];
      else {
        var ke = Ce.stores;
        ke === null ? Ce.stores = [ve] : ke.push(ve);
      }
    }
    function lb(re, ie, he, ve) {
      ie.value = he, ie.getSnapshot = ve, fb(ie) && cb(re);
    }
    function ub(re, ie, he) {
      var ve = function() {
        fb(ie) && cb(re);
      };
      return he(ve);
    }
    function fb(re) {
      var ie = re.getSnapshot, he = re.value;
      try {
        var ve = ie();
        return !Ar(he, ve);
      } catch {
        return !0;
      }
    }
    function cb(re) {
      var ie = bo(re, Br);
      ie !== null && Zi(ie, re, Br, Rn);
    }
    function Ry(re) {
      var ie = ol();
      typeof re == "function" && (re = re()), ie.memoizedState = ie.baseState = re;
      var he = {
        pending: null,
        interleaved: null,
        lanes: Zt,
        dispatch: null,
        lastRenderedReducer: p1,
        lastRenderedState: re
      };
      ie.queue = he;
      var ve = he.dispatch = o_.bind(null, xn, he);
      return [ie.memoizedState, ve];
    }
    function S1(re) {
      return v1(p1);
    }
    function E1(re) {
      return y1(p1);
    }
    function em(re, ie, he, ve) {
      var Ce = {
        tag: re,
        create: ie,
        destroy: he,
        deps: ve,
        // Circular
        next: null
      }, ke = xn.updateQueue;
      if (ke === null)
        ke = ab(), xn.updateQueue = ke, ke.lastEffect = Ce.next = Ce;
      else {
        var at = ke.lastEffect;
        if (at === null)
          ke.lastEffect = Ce.next = Ce;
        else {
          var mt = at.next;
          at.next = Ce, Ce.next = mt, ke.lastEffect = Ce;
        }
      }
      return Ce;
    }
    function b1(re) {
      var ie = ol();
      {
        var he = {
          current: re
        };
        return ie.memoizedState = he, he;
      }
    }
    function ky(re) {
      var ie = Jo();
      return ie.memoizedState;
    }
    function tm(re, ie, he, ve) {
      var Ce = ol(), ke = ve === void 0 ? null : ve;
      xn.flags |= re, Ce.memoizedState = em(Wi | ie, he, void 0, ke);
    }
    function My(re, ie, he, ve) {
      var Ce = Jo(), ke = ve === void 0 ? null : ve, at = void 0;
      if (Yi !== null) {
        var mt = Yi.memoizedState;
        if (at = mt.destroy, ke !== null) {
          var gt = mt.deps;
          if (h1(ke, gt)) {
            Ce.memoizedState = em(ie, he, at, ke);
            return;
          }
        }
      }
      xn.flags |= re, Ce.memoizedState = em(Wi | ie, he, at, ke);
    }
    function Fy(re, ie) {
      return (xn.mode & po) !== zr ? tm(Pl | jn | Hs, pa, re, ie) : tm(jn | Hs, pa, re, ie);
    }
    function rm(re, ie) {
      return My(jn, pa, re, ie);
    }
    function x1(re, ie) {
      return tm(Qr, al, re, ie);
    }
    function Dy(re, ie) {
      return My(Qr, al, re, ie);
    }
    function C1(re, ie) {
      var he = Qr;
      return he |= Pa, (xn.mode & po) !== zr && (he |= Ra), tm(he, qi, re, ie);
    }
    function Oy(re, ie) {
      return My(Qr, qi, re, ie);
    }
    function db(re, ie) {
      if (typeof ie == "function") {
        var he = ie, ve = re();
        return he(ve), function() {
          he(null);
        };
      } else if (ie != null) {
        var Ce = ie;
        Ce.hasOwnProperty("current") || be("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(Ce).join(", ") + "}");
        var ke = re();
        return Ce.current = ke, function() {
          Ce.current = null;
        };
      }
    }
    function T1(re, ie, he) {
      typeof ie != "function" && be("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ie !== null ? typeof ie : "null");
      var ve = he != null ? he.concat([re]) : null, Ce = Qr;
      return Ce |= Pa, (xn.mode & po) !== zr && (Ce |= Ra), tm(Ce, qi, db.bind(null, ie, re), ve);
    }
    function Ly(re, ie, he) {
      typeof ie != "function" && be("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ie !== null ? typeof ie : "null");
      var ve = he != null ? he.concat([re]) : null;
      return My(Qr, qi, db.bind(null, ie, re), ve);
    }
    function r_(re, ie) {
    }
    var $y = r_;
    function w1(re, ie) {
      var he = ol(), ve = ie === void 0 ? null : ie;
      return he.memoizedState = [re, ve], re;
    }
    function Iy(re, ie) {
      var he = Jo(), ve = ie === void 0 ? null : ie, Ce = he.memoizedState;
      if (Ce !== null && ve !== null) {
        var ke = Ce[1];
        if (h1(ve, ke))
          return Ce[0];
      }
      return he.memoizedState = [re, ve], re;
    }
    function _1(re, ie) {
      var he = ol(), ve = ie === void 0 ? null : ie, Ce = re();
      return he.memoizedState = [Ce, ve], Ce;
    }
    function Ny(re, ie) {
      var he = Jo(), ve = ie === void 0 ? null : ie, Ce = he.memoizedState;
      if (Ce !== null && ve !== null) {
        var ke = Ce[1];
        if (h1(ve, ke))
          return Ce[0];
      }
      var at = re();
      return he.memoizedState = [at, ve], at;
    }
    function A1(re) {
      var ie = ol();
      return ie.memoizedState = re, re;
    }
    function hb(re) {
      var ie = Jo(), he = Yi, ve = he.memoizedState;
      return mb(ie, ve, re);
    }
    function pb(re) {
      var ie = Jo();
      if (Yi === null)
        return ie.memoizedState = re, re;
      var he = Yi.memoizedState;
      return mb(ie, he, re);
    }
    function mb(re, ie, he) {
      var ve = !Dg(cc);
      if (ve) {
        if (!Ar(he, ie)) {
          var Ce = tp();
          xn.lanes = Xr(xn.lanes, Ce), Sm(Ce), re.baseState = !0;
        }
        return ie;
      } else
        return re.baseState && (re.baseState = !1, sm()), re.memoizedState = he, he;
    }
    function n_(re, ie, he) {
      var ve = vo();
      _i(ra(ve, Gi)), re(!0);
      var Ce = Kp.transition;
      Kp.transition = {};
      var ke = Kp.transition;
      Kp.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        re(!1), ie();
      } finally {
        if (_i(ve), Kp.transition = Ce, Ce === null && ke._updatedFibers) {
          var at = ke._updatedFibers.size;
          at > 10 && ge("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ke._updatedFibers.clear();
        }
      }
    }
    function P1() {
      var re = Ry(!1), ie = re[0], he = re[1], ve = n_.bind(null, he), Ce = ol();
      return Ce.memoizedState = ve, [ie, ve];
    }
    function vb() {
      var re = S1(), ie = re[0], he = Jo(), ve = he.memoizedState;
      return [ie, ve];
    }
    function yb() {
      var re = E1(), ie = re[0], he = Jo(), ve = he.memoizedState;
      return [ie, ve];
    }
    var gb = !1;
    function i_() {
      return gb;
    }
    function R1() {
      var re = ol(), ie = ig(), he = ie.identifierPrefix, ve;
      if (ha()) {
        var Ce = gw();
        ve = ":" + he + "R" + Ce;
        var ke = Zp++;
        ke > 0 && (ve += "H" + ke.toString(32)), ve += ":";
      } else {
        var at = Zw++;
        ve = ":" + he + "r" + at.toString(32) + ":";
      }
      return re.memoizedState = ve, ve;
    }
    function zy() {
      var re = Jo(), ie = re.memoizedState;
      return ie;
    }
    function a_(re, ie, he) {
      typeof arguments[3] == "function" && be("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var ve = uf(re), Ce = {
        lane: ve,
        action: he,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Sb(re))
        Eb(ie, Ce);
      else {
        var ke = $E(re, ie, Ce, ve);
        if (ke !== null) {
          var at = Za();
          Zi(ke, re, ve, at), bb(ke, ie, ve);
        }
      }
      xb(re, ve);
    }
    function o_(re, ie, he) {
      typeof arguments[3] == "function" && be("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var ve = uf(re), Ce = {
        lane: ve,
        action: he,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Sb(re))
        Eb(ie, Ce);
      else {
        var ke = re.alternate;
        if (re.lanes === Zt && (ke === null || ke.lanes === Zt)) {
          var at = ie.lastRenderedReducer;
          if (at !== null) {
            var mt;
            mt = br.current, br.current = ws;
            try {
              var gt = ie.lastRenderedState, Tt = at(gt, he);
              if (Ce.hasEagerState = !0, Ce.eagerState = Tt, Ar(Tt, gt)) {
                Nw(re, ie, Ce, ve);
                return;
              }
            } catch {
            } finally {
              br.current = mt;
            }
          }
        }
        var Pt = $E(re, ie, Ce, ve);
        if (Pt !== null) {
          var Nt = Za();
          Zi(Pt, re, ve, Nt), bb(Pt, ie, ve);
        }
      }
      xb(re, ve);
    }
    function Sb(re) {
      var ie = re.alternate;
      return re === xn || ie !== null && ie === xn;
    }
    function Eb(re, ie) {
      Jp = Ay = !0;
      var he = re.pending;
      he === null ? ie.next = ie : (ie.next = he.next, he.next = ie), re.pending = ie;
    }
    function bb(re, ie, he) {
      if (ep(he)) {
        var ve = ie.lanes;
        ve = rp(ve, re.pendingLanes);
        var Ce = Xr(ve, he);
        ie.lanes = Ce, Ou(re, Ce);
      }
    }
    function xb(re, ie, he) {
      Ys(re, ie);
    }
    var Vy = {
      readContext: Bi,
      useCallback: Ia,
      useContext: Ia,
      useEffect: Ia,
      useImperativeHandle: Ia,
      useInsertionEffect: Ia,
      useLayoutEffect: Ia,
      useMemo: Ia,
      useReducer: Ia,
      useRef: Ia,
      useState: Ia,
      useDebugValue: Ia,
      useDeferredValue: Ia,
      useTransition: Ia,
      useMutableSource: Ia,
      useSyncExternalStore: Ia,
      useId: Ia,
      unstable_isNewReconciler: yt
    }, Cb = null, Tb = null, wb = null, _b = null, sl = null, ws = null, By = null;
    {
      var k1 = function() {
        be("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, qr = function() {
        be("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Cb = {
        readContext: function(re) {
          return Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", En(), Zd(ie), w1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", En(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", En(), Zd(ie), Fy(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", En(), Zd(he), T1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", En(), Zd(ie), x1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", En(), Zd(ie), C1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", En(), Zd(ie);
          var he = br.current;
          br.current = sl;
          try {
            return _1(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", En();
          var ve = br.current;
          br.current = sl;
          try {
            return m1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", En(), b1(re);
        },
        useState: function(re) {
          tr = "useState", En();
          var ie = br.current;
          br.current = sl;
          try {
            return Ry(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", En(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", En(), A1(re);
        },
        useTransition: function() {
          return tr = "useTransition", En(), P1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", En(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", En(), g1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", En(), R1();
        },
        unstable_isNewReconciler: yt
      }, Tb = {
        readContext: function(re) {
          return Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", pr(), w1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", pr(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", pr(), Fy(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", pr(), T1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", pr(), x1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", pr(), C1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", pr();
          var he = br.current;
          br.current = sl;
          try {
            return _1(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", pr();
          var ve = br.current;
          br.current = sl;
          try {
            return m1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", pr(), b1(re);
        },
        useState: function(re) {
          tr = "useState", pr();
          var ie = br.current;
          br.current = sl;
          try {
            return Ry(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", pr(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", pr(), A1(re);
        },
        useTransition: function() {
          return tr = "useTransition", pr(), P1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", pr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", pr(), g1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", pr(), R1();
        },
        unstable_isNewReconciler: yt
      }, wb = {
        readContext: function(re) {
          return Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", pr(), Iy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", pr(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", pr(), rm(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", pr(), Ly(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", pr(), Dy(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", pr(), Oy(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", pr();
          var he = br.current;
          br.current = ws;
          try {
            return Ny(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", pr();
          var ve = br.current;
          br.current = ws;
          try {
            return v1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", pr(), ky();
        },
        useState: function(re) {
          tr = "useState", pr();
          var ie = br.current;
          br.current = ws;
          try {
            return S1(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", pr(), $y();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", pr(), hb(re);
        },
        useTransition: function() {
          return tr = "useTransition", pr(), vb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", pr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", pr(), Py(re, ie);
        },
        useId: function() {
          return tr = "useId", pr(), zy();
        },
        unstable_isNewReconciler: yt
      }, _b = {
        readContext: function(re) {
          return Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", pr(), Iy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", pr(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", pr(), rm(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", pr(), Ly(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", pr(), Dy(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", pr(), Oy(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", pr();
          var he = br.current;
          br.current = By;
          try {
            return Ny(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", pr();
          var ve = br.current;
          br.current = By;
          try {
            return y1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", pr(), ky();
        },
        useState: function(re) {
          tr = "useState", pr();
          var ie = br.current;
          br.current = By;
          try {
            return E1(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", pr(), $y();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", pr(), pb(re);
        },
        useTransition: function() {
          return tr = "useTransition", pr(), yb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", pr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", pr(), Py(re, ie);
        },
        useId: function() {
          return tr = "useId", pr(), zy();
        },
        unstable_isNewReconciler: yt
      }, sl = {
        readContext: function(re) {
          return k1(), Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", qr(), En(), w1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", qr(), En(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", qr(), En(), Fy(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", qr(), En(), T1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", qr(), En(), x1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", qr(), En(), C1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", qr(), En();
          var he = br.current;
          br.current = sl;
          try {
            return _1(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", qr(), En();
          var ve = br.current;
          br.current = sl;
          try {
            return m1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", qr(), En(), b1(re);
        },
        useState: function(re) {
          tr = "useState", qr(), En();
          var ie = br.current;
          br.current = sl;
          try {
            return Ry(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", qr(), En(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", qr(), En(), A1(re);
        },
        useTransition: function() {
          return tr = "useTransition", qr(), En(), P1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", qr(), En(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", qr(), En(), g1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", qr(), En(), R1();
        },
        unstable_isNewReconciler: yt
      }, ws = {
        readContext: function(re) {
          return k1(), Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", qr(), pr(), Iy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", qr(), pr(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", qr(), pr(), rm(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", qr(), pr(), Ly(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", qr(), pr(), Dy(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", qr(), pr(), Oy(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", qr(), pr();
          var he = br.current;
          br.current = ws;
          try {
            return Ny(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", qr(), pr();
          var ve = br.current;
          br.current = ws;
          try {
            return v1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", qr(), pr(), ky();
        },
        useState: function(re) {
          tr = "useState", qr(), pr();
          var ie = br.current;
          br.current = ws;
          try {
            return S1(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", qr(), pr(), $y();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", qr(), pr(), hb(re);
        },
        useTransition: function() {
          return tr = "useTransition", qr(), pr(), vb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", qr(), pr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", qr(), pr(), Py(re, ie);
        },
        useId: function() {
          return tr = "useId", qr(), pr(), zy();
        },
        unstable_isNewReconciler: yt
      }, By = {
        readContext: function(re) {
          return k1(), Bi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", qr(), pr(), Iy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", qr(), pr(), Bi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", qr(), pr(), rm(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", qr(), pr(), Ly(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", qr(), pr(), Dy(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", qr(), pr(), Oy(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", qr(), pr();
          var he = br.current;
          br.current = ws;
          try {
            return Ny(re, ie);
          } finally {
            br.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", qr(), pr();
          var ve = br.current;
          br.current = ws;
          try {
            return y1(re, ie, he);
          } finally {
            br.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", qr(), pr(), ky();
        },
        useState: function(re) {
          tr = "useState", qr(), pr();
          var ie = br.current;
          br.current = ws;
          try {
            return E1(re);
          } finally {
            br.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", qr(), pr(), $y();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", qr(), pr(), pb(re);
        },
        useTransition: function() {
          return tr = "useTransition", qr(), pr(), yb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", qr(), pr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", qr(), pr(), Py(re, ie);
        },
        useId: function() {
          return tr = "useId", qr(), pr(), zy();
        },
        unstable_isNewReconciler: yt
      };
    }
    var af = ne.unstable_now, Ab = 0, Hy = -1, im = -1, Uy = -1, M1 = !1, jy = !1;
    function Pb() {
      return M1;
    }
    function s_() {
      jy = !0;
    }
    function l_() {
      M1 = !1, jy = !1;
    }
    function u_() {
      M1 = jy, jy = !1;
    }
    function Rb() {
      return Ab;
    }
    function kb() {
      Ab = af();
    }
    function F1(re) {
      im = af(), re.actualStartTime < 0 && (re.actualStartTime = af());
    }
    function Mb(re) {
      im = -1;
    }
    function Gy(re, ie) {
      if (im >= 0) {
        var he = af() - im;
        re.actualDuration += he, ie && (re.selfBaseDuration = he), im = -1;
      }
    }
    function ll(re) {
      if (Hy >= 0) {
        var ie = af() - Hy;
        Hy = -1;
        for (var he = re.return; he !== null; ) {
          switch (he.tag) {
            case dt:
              var ve = he.stateNode;
              ve.effectDuration += ie;
              return;
            case vt:
              var Ce = he.stateNode;
              Ce.effectDuration += ie;
              return;
          }
          he = he.return;
        }
      }
    }
    function D1(re) {
      if (Uy >= 0) {
        var ie = af() - Uy;
        Uy = -1;
        for (var he = re.return; he !== null; ) {
          switch (he.tag) {
            case dt:
              var ve = he.stateNode;
              ve !== null && (ve.passiveEffectDuration += ie);
              return;
            case vt:
              var Ce = he.stateNode;
              Ce !== null && (Ce.passiveEffectDuration += ie);
              return;
          }
          he = he.return;
        }
      }
    }
    function ul() {
      Hy = af();
    }
    function O1() {
      Uy = af();
    }
    function L1(re) {
      for (var ie = re.child; ie; )
        re.actualDuration += ie.actualDuration, ie = ie.sibling;
    }
    function dc(re, ie) {
      return {
        value: re,
        source: ie,
        stack: Vo(ie),
        digest: null
      };
    }
    function $1(re, ie, he) {
      return {
        value: re,
        source: null,
        stack: he ?? null,
        digest: ie ?? null
      };
    }
    function f_(re, ie) {
      return !0;
    }
    function I1(re, ie) {
      try {
        var he = f_(re, ie);
        if (he === !1)
          return;
        var ve = ie.value, Ce = ie.source, ke = ie.stack, at = ke !== null ? ke : "";
        if (ve != null && ve._suppressLogging) {
          if (re.tag === rt)
            return;
          console.error(ve);
        }
        var mt = Ce ? Wr(Ce) : null, gt = mt ? "The above error occurred in the <" + mt + "> component:" : "The above error occurred in one of your React components:", Tt;
        if (re.tag === dt)
          Tt = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Pt = Wr(re) || "Anonymous";
          Tt = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Pt + ".");
        }
        var Nt = gt + `
` + at + `

` + ("" + Tt);
        console.error(Nt);
      } catch ($t) {
        setTimeout(function() {
          throw $t;
        });
      }
    }
    var c_ = typeof WeakMap == "function" ? WeakMap : Map;
    function Fb(re, ie, he) {
      var ve = eu(Rn, he);
      ve.tag = I0, ve.payload = {
        element: null
      };
      var Ce = ie.value;
      return ve.callback = function() {
        nP(Ce), I1(re, ie);
      }, ve;
    }
    function N1(re, ie, he) {
      var ve = eu(Rn, he);
      ve.tag = I0;
      var Ce = re.type.getDerivedStateFromError;
      if (typeof Ce == "function") {
        var ke = ie.value;
        ve.payload = function() {
          return Ce(ke);
        }, ve.callback = function() {
          Ux(re), I1(re, ie);
        };
      }
      var at = re.stateNode;
      return at !== null && typeof at.componentDidCatch == "function" && (ve.callback = function() {
        Ux(re), I1(re, ie), typeof Ce != "function" && tP(this);
        var gt = ie.value, Tt = ie.stack;
        this.componentDidCatch(gt, {
          componentStack: Tt !== null ? Tt : ""
        }), typeof Ce != "function" && (Oa(re.lanes, Br) || be("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Wr(re) || "Unknown"));
      }), ve;
    }
    function Db(re, ie, he) {
      var ve = re.pingCache, Ce;
      if (ve === null ? (ve = re.pingCache = new c_(), Ce = /* @__PURE__ */ new Set(), ve.set(ie, Ce)) : (Ce = ve.get(ie), Ce === void 0 && (Ce = /* @__PURE__ */ new Set(), ve.set(ie, Ce))), !Ce.has(he)) {
        Ce.add(he);
        var ke = iP.bind(null, re, ie, he);
        ji && Em(re, he), ie.then(ke, ke);
      }
    }
    function d_(re, ie, he, ve) {
      var Ce = re.updateQueue;
      if (Ce === null) {
        var ke = /* @__PURE__ */ new Set();
        ke.add(he), re.updateQueue = ke;
      } else
        Ce.add(he);
    }
    function h_(re, ie) {
      var he = re.tag;
      if ((re.mode & Zr) === zr && (he === Ae || he === ft || he === At)) {
        var ve = re.alternate;
        ve ? (re.updateQueue = ve.updateQueue, re.memoizedState = ve.memoizedState, re.lanes = ve.lanes) : (re.updateQueue = null, re.memoizedState = null);
      }
    }
    function Ob(re) {
      var ie = re;
      do {
        if (ie.tag === xt && Kw(ie))
          return ie;
        ie = ie.return;
      } while (ie !== null);
      return null;
    }
    function Lb(re, ie, he, ve, Ce) {
      if ((re.mode & Zr) === zr) {
        if (re === ie)
          re.flags |= $i;
        else {
          if (re.flags |= Ur, he.flags |= Of, he.flags &= ~(Vc | Ga), he.tag === rt) {
            var ke = he.alternate;
            if (ke === null)
              he.tag = Vt;
            else {
              var at = eu(Rn, Br);
              at.tag = my, ef(he, at, Br);
            }
          }
          he.lanes = Xr(he.lanes, Br);
        }
        return re;
      }
      return re.flags |= $i, re.lanes = Ce, re;
    }
    function p_(re, ie, he, ve, Ce) {
      if (he.flags |= Ga, ji && Em(re, Ce), ve !== null && typeof ve == "object" && typeof ve.then == "function") {
        var ke = ve;
        h_(he), ha() && he.mode & Zr && TE();
        var at = Ob(ie);
        if (at !== null) {
          at.flags &= ~si, Lb(at, ie, he, re, Ce), at.mode & Zr && Db(re, ke, Ce), d_(at, re, ke);
          return;
        } else {
          if (!Fu(Ce)) {
            Db(re, ke, Ce), yS();
            return;
          }
          var mt = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          ve = mt;
        }
      } else if (ha() && he.mode & Zr) {
        TE();
        var gt = Ob(ie);
        if (gt !== null) {
          (gt.flags & $i) === Lr && (gt.flags |= si), Lb(gt, ie, he, re, Ce), k0(dc(ve, he));
          return;
        }
      }
      ve = dc(ve, he), qA(ve);
      var Tt = ie;
      do {
        switch (Tt.tag) {
          case dt: {
            var Pt = ve;
            Tt.flags |= $i;
            var Nt = wi(Ce);
            Tt.lanes = Xr(Tt.lanes, Nt);
            var $t = Fb(Tt, Pt, Nt);
            V0(Tt, $t);
            return;
          }
          case rt:
            var Gt = ve, Wt = Tt.type, Xt = Tt.stateNode;
            if ((Tt.flags & Ur) === Lr && (typeof Wt.getDerivedStateFromError == "function" || Xt !== null && typeof Xt.componentDidCatch == "function" && !Ox(Xt))) {
              Tt.flags |= $i;
              var xr = wi(Ce);
              Tt.lanes = Xr(Tt.lanes, xr);
              var Ir = N1(Tt, Gt, xr);
              V0(Tt, Ir);
              return;
            }
            break;
        }
        Tt = Tt.return;
      } while (Tt !== null);
    }
    function m_() {
      return null;
    }
    var am = oe.ReactCurrentOwner, _s = !1, z1, om, V1, B1, H1, hc, U1, Wy;
    z1 = {}, om = {}, V1 = {}, B1 = {}, H1 = {}, hc = !1, U1 = {}, Wy = {};
    function Ka(re, ie, he, ve) {
      re === null ? ie.child = JE(ie, null, he, ve) : ie.child = Yd(ie, re.child, he, ve);
    }
    function v_(re, ie, he, ve) {
      ie.child = Yd(ie, re.child, null, ve), ie.child = Yd(ie, null, he, ve);
    }
    function $b(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = he.propTypes;
        ke && Es(
          ke,
          ve,
          // Resolved props
          "prop",
          an(he)
        );
      }
      var at = he.render, mt = ie.ref, gt, Tt;
      qd(ie, Ce), qs(ie);
      {
        if (am.current = ie, ja(!0), gt = eh(re, ie, at, ve, mt, Ce), Tt = th(), ie.mode & Yn) {
          Ti(!0);
          try {
            gt = eh(re, ie, at, ve, mt, Ce), Tt = th();
          } finally {
            Ti(!1);
          }
        }
        ja(!1);
      }
      return Rl(), re !== null && !_s ? (nb(re, ie, Ce), tu(re, ie, Ce)) : (ha() && Tt && T0(ie), ie.flags |= Vs, Ka(re, ie, gt, Ce), ie.child);
    }
    function Ib(re, ie, he, ve, Ce) {
      if (re === null) {
        var ke = he.type;
        if (bP(ke) && he.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        he.defaultProps === void 0) {
          var at = ke;
          return at = uh(ke), ie.tag = At, ie.type = at, W1(ie, ke), Nb(re, ie, at, ve, Ce);
        }
        {
          var mt = ke.propTypes;
          mt && Es(
            mt,
            ve,
            // Resolved props
            "prop",
            an(ke)
          );
        }
        var gt = PS(he.type, null, ve, ie, ie.mode, Ce);
        return gt.ref = ie.ref, gt.return = ie, ie.child = gt, gt;
      }
      {
        var Tt = he.type, Pt = Tt.propTypes;
        Pt && Es(
          Pt,
          ve,
          // Resolved props
          "prop",
          an(Tt)
        );
      }
      var Nt = re.child, $t = J1(re, Ce);
      if (!$t) {
        var Gt = Nt.memoizedProps, Wt = he.compare;
        if (Wt = Wt !== null ? Wt : Or, Wt(Gt, ve) && re.ref === ie.ref)
          return tu(re, ie, Ce);
      }
      ie.flags |= Vs;
      var Xt = gc(Nt, ve);
      return Xt.ref = ie.ref, Xt.return = ie, ie.child = Xt, Xt;
    }
    function Nb(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = ie.elementType;
        if (ke.$$typeof === Hi) {
          var at = ke, mt = at._payload, gt = at._init;
          try {
            ke = gt(mt);
          } catch {
            ke = null;
          }
          var Tt = ke && ke.propTypes;
          Tt && Es(
            Tt,
            ve,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            an(ke)
          );
        }
      }
      if (re !== null) {
        var Pt = re.memoizedProps;
        if (Or(Pt, ve) && re.ref === ie.ref && // Prevent bailout if the implementation changed due to hot reload.
        ie.type === re.type)
          if (_s = !1, ie.pendingProps = ve = Pt, J1(re, Ce))
            (re.flags & Of) !== Lr && (_s = !0);
          else
            return ie.lanes = re.lanes, tu(re, ie, Ce);
      }
      return j1(re, ie, he, ve, Ce);
    }
    function zb(re, ie, he) {
      var ve = ie.pendingProps, Ce = ve.children, ke = re !== null ? re.memoizedState : null;
      if (ve.mode === "hidden" || Dt)
        if ((ie.mode & Zr) === zr) {
          var at = {
            baseLanes: Zt,
            cachePool: null,
            transitions: null
          };
          ie.memoizedState = at, ag(ie, he);
        } else if (Oa(he, Da)) {
          var Nt = {
            baseLanes: Zt,
            cachePool: null,
            transitions: null
          };
          ie.memoizedState = Nt;
          var $t = ke !== null ? ke.baseLanes : he;
          ag(ie, $t);
        } else {
          var mt = null, gt;
          if (ke !== null) {
            var Tt = ke.baseLanes;
            gt = Xr(Tt, he);
          } else
            gt = he;
          ie.lanes = ie.childLanes = Da;
          var Pt = {
            baseLanes: gt,
            cachePool: mt,
            transitions: null
          };
          return ie.memoizedState = Pt, ie.updateQueue = null, ag(ie, gt), null;
        }
      else {
        var Gt;
        ke !== null ? (Gt = Xr(ke.baseLanes, he), ie.memoizedState = null) : Gt = he, ag(ie, Gt);
      }
      return Ka(re, ie, Ce, he), ie.child;
    }
    function y_(re, ie, he) {
      var ve = ie.pendingProps;
      return Ka(re, ie, ve, he), ie.child;
    }
    function g_(re, ie, he) {
      var ve = ie.pendingProps.children;
      return Ka(re, ie, ve, he), ie.child;
    }
    function S_(re, ie, he) {
      {
        ie.flags |= Qr;
        {
          var ve = ie.stateNode;
          ve.effectDuration = 0, ve.passiveEffectDuration = 0;
        }
      }
      var Ce = ie.pendingProps, ke = Ce.children;
      return Ka(re, ie, ke, he), ie.child;
    }
    function Vb(re, ie) {
      var he = ie.ref;
      (re === null && he !== null || re !== null && re.ref !== he) && (ie.flags |= Aa, ie.flags |= zh);
    }
    function j1(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = he.propTypes;
        ke && Es(
          ke,
          ve,
          // Resolved props
          "prop",
          an(he)
        );
      }
      var at;
      {
        var mt = Bd(ie, he, !0);
        at = Hd(ie, mt);
      }
      var gt, Tt;
      qd(ie, Ce), qs(ie);
      {
        if (am.current = ie, ja(!0), gt = eh(re, ie, he, ve, at, Ce), Tt = th(), ie.mode & Yn) {
          Ti(!0);
          try {
            gt = eh(re, ie, he, ve, at, Ce), Tt = th();
          } finally {
            Ti(!1);
          }
        }
        ja(!1);
      }
      return Rl(), re !== null && !_s ? (nb(re, ie, Ce), tu(re, ie, Ce)) : (ha() && Tt && T0(ie), ie.flags |= Vs, Ka(re, ie, gt, Ce), ie.child);
    }
    function Bb(re, ie, he, ve, Ce) {
      {
        switch ($P(ie)) {
          case !1: {
            var ke = ie.stateNode, at = ie.type, mt = new at(ie.memoizedProps, ke.context), gt = mt.state;
            ke.updater.enqueueSetState(ke, gt, null);
            break;
          }
          case !0: {
            ie.flags |= Ur, ie.flags |= $i;
            var Tt = new Error("Simulated error coming from DevTools"), Pt = wi(Ce);
            ie.lanes = Xr(ie.lanes, Pt);
            var Nt = N1(ie, dc(Tt, ie), Pt);
            V0(ie, Nt);
            break;
          }
        }
        if (ie.type !== ie.elementType) {
          var $t = he.propTypes;
          $t && Es(
            $t,
            ve,
            // Resolved props
            "prop",
            an(he)
          );
        }
      }
      var Gt;
      il(he) ? (Gt = !0, iy(ie)) : Gt = !1, qd(ie, Ce);
      var Wt = ie.stateNode, Xt;
      Wt === null ? (Yy(re, ie), qE(ie, he, ve), J0(ie, he, ve, Ce), Xt = !0) : re === null ? Xt = Gw(ie, he, ve, Ce) : Xt = Ww(re, ie, he, ve, Ce);
      var xr = G1(re, ie, he, Xt, Gt, Ce);
      {
        var Ir = ie.stateNode;
        Xt && Ir.props !== ve && (hc || be("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Wr(ie) || "a component"), hc = !0);
      }
      return xr;
    }
    function G1(re, ie, he, ve, Ce, ke) {
      Vb(re, ie);
      var at = (ie.flags & Ur) !== Lr;
      if (!ve && !at)
        return Ce && EE(ie, he, !1), tu(re, ie, ke);
      var mt = ie.stateNode;
      am.current = ie;
      var gt;
      if (at && typeof he.getDerivedStateFromError != "function")
        gt = null, Mb();
      else {
        qs(ie);
        {
          if (ja(!0), gt = mt.render(), ie.mode & Yn) {
            Ti(!0);
            try {
              mt.render();
            } finally {
              Ti(!1);
            }
          }
          ja(!1);
        }
        Rl();
      }
      return ie.flags |= Vs, re !== null && at ? v_(re, ie, gt, ke) : Ka(re, ie, gt, ke), ie.memoizedState = mt.state, Ce && EE(ie, he, !0), ie.child;
    }
    function Hb(re) {
      var ie = re.stateNode;
      ie.pendingContext ? gE(re, ie.pendingContext, ie.pendingContext !== ie.context) : ie.context && gE(re, ie.context, !1), i1(re, ie.containerInfo);
    }
    function E_(re, ie, he) {
      if (Hb(ie), re === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var ve = ie.pendingProps, Ce = ie.memoizedState, ke = Ce.element;
      zE(re, ie), Sy(ie, ve, null, he);
      var at = ie.memoizedState;
      ie.stateNode;
      var mt = at.element;
      if (Ce.isDehydrated) {
        var gt = {
          element: mt,
          isDehydrated: !1,
          cache: at.cache,
          pendingSuspenseBoundaries: at.pendingSuspenseBoundaries,
          transitions: at.transitions
        }, Tt = ie.updateQueue;
        if (Tt.baseState = gt, ie.memoizedState = gt, ie.flags & si) {
          var Pt = dc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), ie);
          return Ub(re, ie, mt, he, Pt);
        } else if (mt !== ke) {
          var Nt = dc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), ie);
          return Ub(re, ie, mt, he, Nt);
        } else {
          Tw(ie);
          var $t = JE(ie, null, mt, he);
          ie.child = $t;
          for (var Gt = $t; Gt; )
            Gt.flags = Gt.flags & ~On | fo, Gt = Gt.sibling;
        }
      } else {
        if (Gd(), mt === ke)
          return tu(re, ie, he);
        Ka(re, ie, mt, he);
      }
      return ie.child;
    }
    function Ub(re, ie, he, ve, Ce) {
      return Gd(), k0(Ce), ie.flags |= si, Ka(re, ie, he, ve), ie.child;
    }
    function b_(re, ie, he) {
      eb(ie), re === null && R0(ie);
      var ve = ie.type, Ce = ie.pendingProps, ke = re !== null ? re.memoizedProps : null, at = Ce.children, mt = f0(ve, Ce);
      return mt ? at = null : ke !== null && f0(ve, ke) && (ie.flags |= Sn), Vb(re, ie), Ka(re, ie, at, he), ie.child;
    }
    function x_(re, ie) {
      return re === null && R0(ie), null;
    }
    function C_(re, ie, he, ve) {
      Yy(re, ie);
      var Ce = ie.pendingProps, ke = he, at = ke._payload, mt = ke._init, gt = mt(at);
      ie.type = gt;
      var Tt = ie.tag = xP(gt), Pt = Cs(gt, Ce), Nt;
      switch (Tt) {
        case Ae:
          return W1(ie, gt), ie.type = gt = uh(gt), Nt = j1(null, ie, gt, Pt, ve), Nt;
        case rt:
          return ie.type = gt = xS(gt), Nt = Bb(null, ie, gt, Pt, ve), Nt;
        case ft:
          return ie.type = gt = CS(gt), Nt = $b(null, ie, gt, Pt, ve), Nt;
        case Ct: {
          if (ie.type !== ie.elementType) {
            var $t = gt.propTypes;
            $t && Es(
              $t,
              Pt,
              // Resolved for outer only
              "prop",
              an(gt)
            );
          }
          return Nt = Ib(
            null,
            ie,
            gt,
            Cs(gt.type, Pt),
            // The inner type can have defaults too
            ve
          ), Nt;
        }
      }
      var Gt = "";
      throw gt !== null && typeof gt == "object" && gt.$$typeof === Hi && (Gt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + gt + ". " + ("Lazy element type must resolve to a class or function." + Gt));
    }
    function T_(re, ie, he, ve, Ce) {
      Yy(re, ie), ie.tag = rt;
      var ke;
      return il(he) ? (ke = !0, iy(ie)) : ke = !1, qd(ie, Ce), qE(ie, he, ve), J0(ie, he, ve, Ce), G1(null, ie, he, !0, ke, Ce);
    }
    function w_(re, ie, he, ve) {
      Yy(re, ie);
      var Ce = ie.pendingProps, ke;
      {
        var at = Bd(ie, he, !1);
        ke = Hd(ie, at);
      }
      qd(ie, ve);
      var mt, gt;
      qs(ie);
      {
        if (he.prototype && typeof he.prototype.render == "function") {
          var Tt = an(he) || "Unknown";
          z1[Tt] || (be("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Tt, Tt), z1[Tt] = !0);
        }
        ie.mode & Yn && xs.recordLegacyContextWarning(ie, null), ja(!0), am.current = ie, mt = eh(null, ie, he, Ce, ke, ve), gt = th(), ja(!1);
      }
      if (Rl(), ie.flags |= Vs, typeof mt == "object" && mt !== null && typeof mt.render == "function" && mt.$$typeof === void 0) {
        var Pt = an(he) || "Unknown";
        om[Pt] || (be("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Pt, Pt, Pt), om[Pt] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof mt == "object" && mt !== null && typeof mt.render == "function" && mt.$$typeof === void 0
      ) {
        {
          var Nt = an(he) || "Unknown";
          om[Nt] || (be("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Nt, Nt, Nt), om[Nt] = !0);
        }
        ie.tag = rt, ie.memoizedState = null, ie.updateQueue = null;
        var $t = !1;
        return il(he) ? ($t = !0, iy(ie)) : $t = !1, ie.memoizedState = mt.state !== null && mt.state !== void 0 ? mt.state : null, z0(ie), WE(ie, mt), J0(ie, he, Ce, ve), G1(null, ie, he, !0, $t, ve);
      } else {
        if (ie.tag = Ae, ie.mode & Yn) {
          Ti(!0);
          try {
            mt = eh(null, ie, he, Ce, ke, ve), gt = th();
          } finally {
            Ti(!1);
          }
        }
        return ha() && gt && T0(ie), Ka(null, ie, mt, ve), W1(ie, he), ie.child;
      }
    }
    function W1(re, ie) {
      {
        if (ie && ie.childContextTypes && be("%s(...): childContextTypes cannot be defined on a function component.", ie.displayName || ie.name || "Component"), re.ref !== null) {
          var he = "", ve = la();
          ve && (he += `

Check the render method of \`` + ve + "`.");
          var Ce = ve || "", ke = re._debugSource;
          ke && (Ce = ke.fileName + ":" + ke.lineNumber), H1[Ce] || (H1[Ce] = !0, be("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", he));
        }
        if (typeof ie.getDerivedStateFromProps == "function") {
          var at = an(ie) || "Unknown";
          B1[at] || (be("%s: Function components do not support getDerivedStateFromProps.", at), B1[at] = !0);
        }
        if (typeof ie.contextType == "object" && ie.contextType !== null) {
          var mt = an(ie) || "Unknown";
          V1[mt] || (be("%s: Function components do not support contextType.", mt), V1[mt] = !0);
        }
      }
    }
    var q1 = {
      dehydrated: null,
      treeContext: null,
      retryLane: on
    };
    function Y1(re) {
      return {
        baseLanes: re,
        cachePool: m_(),
        transitions: null
      };
    }
    function __(re, ie) {
      var he = null;
      return {
        baseLanes: Xr(re.baseLanes, ie),
        cachePool: he,
        transitions: re.transitions
      };
    }
    function A_(re, ie, he, ve) {
      if (ie !== null) {
        var Ce = ie.memoizedState;
        if (Ce === null)
          return !1;
      }
      return s1(re, Xp);
    }
    function P_(re, ie) {
      return Du(re.childLanes, ie);
    }
    function jb(re, ie, he) {
      var ve = ie.pendingProps;
      IP(ie) && (ie.flags |= Ur);
      var Ce = Ts.current, ke = !1, at = (ie.flags & Ur) !== Lr;
      if (at || A_(Ce, re) ? (ke = !0, ie.flags &= ~Ur) : (re === null || re.memoizedState !== null) && (Ce = Xw(Ce, rb)), Ce = Xd(Ce), rf(ie, Ce), re === null) {
        R0(ie);
        var mt = ie.memoizedState;
        if (mt !== null) {
          var gt = mt.dehydrated;
          if (gt !== null)
            return D_(ie, gt);
        }
        var Tt = ve.children, Pt = ve.fallback;
        if (ke) {
          var Nt = R_(ie, Tt, Pt, he), $t = ie.child;
          return $t.memoizedState = Y1(he), ie.memoizedState = q1, Nt;
        } else
          return Q1(ie, Tt);
      } else {
        var Gt = re.memoizedState;
        if (Gt !== null) {
          var Wt = Gt.dehydrated;
          if (Wt !== null)
            return O_(re, ie, at, ve, Wt, Gt, he);
        }
        if (ke) {
          var Xt = ve.fallback, xr = ve.children, Ir = M_(re, ie, xr, Xt, he), Fr = ie.child, ln = re.child.memoizedState;
          return Fr.memoizedState = ln === null ? Y1(he) : __(ln, he), Fr.childLanes = P_(re, he), ie.memoizedState = q1, Ir;
        } else {
          var nn = ve.children, Ht = k_(re, ie, nn, he);
          return ie.memoizedState = null, Ht;
        }
      }
    }
    function Q1(re, ie, he) {
      var ve = re.mode, Ce = {
        mode: "visible",
        children: ie
      }, ke = X1(Ce, ve);
      return ke.return = re, re.child = ke, ke;
    }
    function R_(re, ie, he, ve) {
      var Ce = re.mode, ke = re.child, at = {
        mode: "hidden",
        children: ie
      }, mt, gt;
      return (Ce & Zr) === zr && ke !== null ? (mt = ke, mt.childLanes = Zt, mt.pendingProps = at, re.mode & Vr && (mt.actualDuration = 0, mt.actualStartTime = -1, mt.selfBaseDuration = 0, mt.treeBaseDuration = 0), gt = cf(he, Ce, ve, null)) : (mt = X1(at, Ce), gt = cf(he, Ce, ve, null)), mt.return = re, gt.return = re, mt.sibling = gt, re.child = mt, gt;
    }
    function X1(re, ie, he) {
      return Gx(re, ie, Zt, null);
    }
    function Gb(re, ie) {
      return gc(re, ie);
    }
    function k_(re, ie, he, ve) {
      var Ce = re.child, ke = Ce.sibling, at = Gb(Ce, {
        mode: "visible",
        children: he
      });
      if ((ie.mode & Zr) === zr && (at.lanes = ve), at.return = ie, at.sibling = null, ke !== null) {
        var mt = ie.deletions;
        mt === null ? (ie.deletions = [ke], ie.flags |= pn) : mt.push(ke);
      }
      return ie.child = at, at;
    }
    function M_(re, ie, he, ve, Ce) {
      var ke = ie.mode, at = re.child, mt = at.sibling, gt = {
        mode: "hidden",
        children: he
      }, Tt;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (ke & Zr) === zr && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        ie.child !== at
      ) {
        var Pt = ie.child;
        Tt = Pt, Tt.childLanes = Zt, Tt.pendingProps = gt, ie.mode & Vr && (Tt.actualDuration = 0, Tt.actualStartTime = -1, Tt.selfBaseDuration = at.selfBaseDuration, Tt.treeBaseDuration = at.treeBaseDuration), ie.deletions = null;
      } else
        Tt = Gb(at, gt), Tt.subtreeFlags = at.subtreeFlags & Ui;
      var Nt;
      return mt !== null ? Nt = gc(mt, ve) : (Nt = cf(ve, ke, Ce, null), Nt.flags |= On), Nt.return = ie, Tt.return = ie, Tt.sibling = Nt, ie.child = Tt, Nt;
    }
    function qy(re, ie, he, ve) {
      ve !== null && k0(ve), Yd(ie, re.child, null, he);
      var Ce = ie.pendingProps, ke = Ce.children, at = Q1(ie, ke);
      return at.flags |= On, ie.memoizedState = null, at;
    }
    function F_(re, ie, he, ve, Ce) {
      var ke = ie.mode, at = {
        mode: "visible",
        children: he
      }, mt = X1(at, ke), gt = cf(ve, ke, Ce, null);
      return gt.flags |= On, mt.return = ie, gt.return = ie, mt.sibling = gt, ie.child = mt, (ie.mode & Zr) !== zr && Yd(ie, re.child, null, Ce), gt;
    }
    function D_(re, ie, he) {
      return (re.mode & Zr) === zr ? (be("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), re.lanes = Br) : p0(ie) ? re.lanes = Fl : re.lanes = Da, null;
    }
    function O_(re, ie, he, ve, Ce, ke, at) {
      if (he)
        if (ie.flags & si) {
          ie.flags &= ~si;
          var Ht = $1(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return qy(re, ie, at, Ht);
        } else {
          if (ie.memoizedState !== null)
            return ie.child = re.child, ie.flags |= Ur, null;
          var Kt = ve.children, Ut = ve.fallback, ur = F_(re, ie, Kt, Ut, at), Cr = ie.child;
          return Cr.memoizedState = Y1(at), ie.memoizedState = q1, ur;
        }
      else {
        if (xw(), (ie.mode & Zr) === zr)
          return qy(
            re,
            ie,
            at,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (p0(Ce)) {
          var mt, gt, Tt;
          {
            var Pt = zT(Ce);
            mt = Pt.digest, gt = Pt.message, Tt = Pt.stack;
          }
          var Nt;
          gt ? Nt = new Error(gt) : Nt = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var $t = $1(Nt, mt, Tt);
          return qy(re, ie, at, $t);
        }
        var Gt = Oa(at, re.childLanes);
        if (_s || Gt) {
          var Wt = ig();
          if (Wt !== null) {
            var Xt = Lg(Wt, at);
            if (Xt !== on && Xt !== ke.retryLane) {
              ke.retryLane = Xt;
              var xr = Rn;
              bo(re, Xt), Zi(Wt, re, Xt, xr);
            }
          }
          yS();
          var Ir = $1(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return qy(re, ie, at, Ir);
        } else if (dE(Ce)) {
          ie.flags |= Ur, ie.child = re.child;
          var Fr = aP.bind(null, re);
          return VT(Ce, Fr), null;
        } else {
          ww(ie, Ce, ke.treeContext);
          var ln = ve.children, nn = Q1(ie, ln);
          return nn.flags |= fo, nn;
        }
      }
    }
    function Wb(re, ie, he) {
      re.lanes = Xr(re.lanes, ie);
      var ve = re.alternate;
      ve !== null && (ve.lanes = Xr(ve.lanes, ie)), L0(re.return, ie, he);
    }
    function L_(re, ie, he) {
      for (var ve = ie; ve !== null; ) {
        if (ve.tag === xt) {
          var Ce = ve.memoizedState;
          Ce !== null && Wb(ve, he, re);
        } else if (ve.tag === er)
          Wb(ve, he, re);
        else if (ve.child !== null) {
          ve.child.return = ve, ve = ve.child;
          continue;
        }
        if (ve === re)
          return;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === re)
            return;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
    }
    function $_(re) {
      for (var ie = re, he = null; ie !== null; ) {
        var ve = ie.alternate;
        ve !== null && _y(ve) === null && (he = ie), ie = ie.sibling;
      }
      return he;
    }
    function I_(re) {
      if (re !== void 0 && re !== "forwards" && re !== "backwards" && re !== "together" && !U1[re])
        if (U1[re] = !0, typeof re == "string")
          switch (re.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              be('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', re, re.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              be('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', re, re.toLowerCase());
              break;
            }
            default:
              be('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', re);
              break;
          }
        else
          be('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', re);
    }
    function N_(re, ie) {
      re !== void 0 && !Wy[re] && (re !== "collapsed" && re !== "hidden" ? (Wy[re] = !0, be('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', re)) : ie !== "forwards" && ie !== "backwards" && (Wy[re] = !0, be('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', re)));
    }
    function qb(re, ie) {
      {
        var he = Oi(re), ve = !he && typeof wo(re) == "function";
        if (he || ve) {
          var Ce = he ? "array" : "iterable";
          return be("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", Ce, ie, Ce), !1;
        }
      }
      return !0;
    }
    function z_(re, ie) {
      if ((ie === "forwards" || ie === "backwards") && re !== void 0 && re !== null && re !== !1)
        if (Oi(re)) {
          for (var he = 0; he < re.length; he++)
            if (!qb(re[he], he))
              return;
        } else {
          var ve = wo(re);
          if (typeof ve == "function") {
            var Ce = ve.call(re);
            if (Ce)
              for (var ke = Ce.next(), at = 0; !ke.done; ke = Ce.next()) {
                if (!qb(ke.value, at))
                  return;
                at++;
              }
          } else
            be('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', ie);
        }
    }
    function K1(re, ie, he, ve, Ce) {
      var ke = re.memoizedState;
      ke === null ? re.memoizedState = {
        isBackwards: ie,
        rendering: null,
        renderingStartTime: 0,
        last: ve,
        tail: he,
        tailMode: Ce
      } : (ke.isBackwards = ie, ke.rendering = null, ke.renderingStartTime = 0, ke.last = ve, ke.tail = he, ke.tailMode = Ce);
    }
    function Yb(re, ie, he) {
      var ve = ie.pendingProps, Ce = ve.revealOrder, ke = ve.tail, at = ve.children;
      I_(Ce), N_(ke, Ce), z_(at, Ce), Ka(re, ie, at, he);
      var mt = Ts.current, gt = s1(mt, Xp);
      if (gt)
        mt = l1(mt, Xp), ie.flags |= Ur;
      else {
        var Tt = re !== null && (re.flags & Ur) !== Lr;
        Tt && L_(ie, ie.child, he), mt = Xd(mt);
      }
      if (rf(ie, mt), (ie.mode & Zr) === zr)
        ie.memoizedState = null;
      else
        switch (Ce) {
          case "forwards": {
            var Pt = $_(ie.child), Nt;
            Pt === null ? (Nt = ie.child, ie.child = null) : (Nt = Pt.sibling, Pt.sibling = null), K1(
              ie,
              !1,
              // isBackwards
              Nt,
              Pt,
              ke
            );
            break;
          }
          case "backwards": {
            var $t = null, Gt = ie.child;
            for (ie.child = null; Gt !== null; ) {
              var Wt = Gt.alternate;
              if (Wt !== null && _y(Wt) === null) {
                ie.child = Gt;
                break;
              }
              var Xt = Gt.sibling;
              Gt.sibling = $t, $t = Gt, Gt = Xt;
            }
            K1(
              ie,
              !0,
              // isBackwards
              $t,
              null,
              // last
              ke
            );
            break;
          }
          case "together": {
            K1(
              ie,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            ie.memoizedState = null;
        }
      return ie.child;
    }
    function V_(re, ie, he) {
      i1(ie, ie.stateNode.containerInfo);
      var ve = ie.pendingProps;
      return re === null ? ie.child = Yd(ie, null, ve, he) : Ka(re, ie, ve, he), ie.child;
    }
    var Qb = !1;
    function B_(re, ie, he) {
      var ve = ie.type, Ce = ve._context, ke = ie.pendingProps, at = ie.memoizedProps, mt = ke.value;
      {
        "value" in ke || Qb || (Qb = !0, be("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var gt = ie.type.propTypes;
        gt && Es(gt, ke, "prop", "Context.Provider");
      }
      if (LE(ie, Ce, mt), at !== null) {
        var Tt = at.value;
        if (Ar(Tt, mt)) {
          if (at.children === ke.children && !ry())
            return tu(re, ie, he);
        } else
          Lw(ie, Ce, he);
      }
      var Pt = ke.children;
      return Ka(re, ie, Pt, he), ie.child;
    }
    var Xb = !1;
    function H_(re, ie, he) {
      var ve = ie.type;
      ve._context === void 0 ? ve !== ve.Consumer && (Xb || (Xb = !0, be("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : ve = ve._context;
      var Ce = ie.pendingProps, ke = Ce.children;
      typeof ke != "function" && be("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), qd(ie, he);
      var at = Bi(ve);
      qs(ie);
      var mt;
      return am.current = ie, ja(!0), mt = ke(at), ja(!1), Rl(), ie.flags |= Vs, Ka(re, ie, mt, he), ie.child;
    }
    function sm() {
      _s = !0;
    }
    function Yy(re, ie) {
      (ie.mode & Zr) === zr && re !== null && (re.alternate = null, ie.alternate = null, ie.flags |= On);
    }
    function tu(re, ie, he) {
      return re !== null && (ie.dependencies = re.dependencies), Mb(), Sm(ie.lanes), Oa(he, ie.childLanes) ? (qw(re, ie), ie.child) : null;
    }
    function U_(re, ie, he) {
      {
        var ve = ie.return;
        if (ve === null)
          throw new Error("Cannot swap the root fiber.");
        if (re.alternate = null, ie.alternate = null, he.index = ie.index, he.sibling = ie.sibling, he.return = ie.return, he.ref = ie.ref, ie === ve.child)
          ve.child = he;
        else {
          var Ce = ve.child;
          if (Ce === null)
            throw new Error("Expected parent to have a child.");
          for (; Ce.sibling !== ie; )
            if (Ce = Ce.sibling, Ce === null)
              throw new Error("Expected to find the previous sibling.");
          Ce.sibling = he;
        }
        var ke = ve.deletions;
        return ke === null ? (ve.deletions = [re], ve.flags |= pn) : ke.push(re), he.flags |= On, he;
      }
    }
    function J1(re, ie) {
      var he = re.lanes;
      return !!Oa(he, ie);
    }
    function j_(re, ie, he) {
      switch (ie.tag) {
        case dt:
          Hb(ie), ie.stateNode, Gd();
          break;
        case ht:
          eb(ie);
          break;
        case rt: {
          var ve = ie.type;
          il(ve) && iy(ie);
          break;
        }
        case ut:
          i1(ie, ie.stateNode.containerInfo);
          break;
        case pt: {
          var Ce = ie.memoizedProps.value, ke = ie.type._context;
          LE(ie, ke, Ce);
          break;
        }
        case vt:
          {
            var at = Oa(he, ie.childLanes);
            at && (ie.flags |= Qr);
            {
              var mt = ie.stateNode;
              mt.effectDuration = 0, mt.passiveEffectDuration = 0;
            }
          }
          break;
        case xt: {
          var gt = ie.memoizedState;
          if (gt !== null) {
            if (gt.dehydrated !== null)
              return rf(ie, Xd(Ts.current)), ie.flags |= Ur, null;
            var Tt = ie.child, Pt = Tt.childLanes;
            if (Oa(he, Pt))
              return jb(re, ie, he);
            rf(ie, Xd(Ts.current));
            var Nt = tu(re, ie, he);
            return Nt !== null ? Nt.sibling : null;
          } else
            rf(ie, Xd(Ts.current));
          break;
        }
        case er: {
          var $t = (re.flags & Ur) !== Lr, Gt = Oa(he, ie.childLanes);
          if ($t) {
            if (Gt)
              return Yb(re, ie, he);
            ie.flags |= Ur;
          }
          var Wt = ie.memoizedState;
          if (Wt !== null && (Wt.rendering = null, Wt.tail = null, Wt.lastEffect = null), rf(ie, Ts.current), Gt)
            break;
          return null;
        }
        case Jt:
        case rr:
          return ie.lanes = Zt, zb(re, ie, he);
      }
      return tu(re, ie, he);
    }
    function Kb(re, ie, he) {
      if (ie._debugNeedsRemount && re !== null)
        return U_(re, ie, PS(ie.type, ie.key, ie.pendingProps, ie._debugOwner || null, ie.mode, ie.lanes));
      if (re !== null) {
        var ve = re.memoizedProps, Ce = ie.pendingProps;
        if (ve !== Ce || ry() || // Force a re-render if the implementation changed due to hot reload:
        ie.type !== re.type)
          _s = !0;
        else {
          var ke = J1(re, he);
          if (!ke && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (ie.flags & Ur) === Lr)
            return _s = !1, j_(re, ie, he);
          (re.flags & Of) !== Lr ? _s = !0 : _s = !1;
        }
      } else if (_s = !1, ha() && vw(ie)) {
        var at = ie.index, mt = yw();
        CE(ie, mt, at);
      }
      switch (ie.lanes = Zt, ie.tag) {
        case st:
          return w_(re, ie, ie.type, he);
        case kt: {
          var gt = ie.elementType;
          return C_(re, ie, gt, he);
        }
        case Ae: {
          var Tt = ie.type, Pt = ie.pendingProps, Nt = ie.elementType === Tt ? Pt : Cs(Tt, Pt);
          return j1(re, ie, Tt, Nt, he);
        }
        case rt: {
          var $t = ie.type, Gt = ie.pendingProps, Wt = ie.elementType === $t ? Gt : Cs($t, Gt);
          return Bb(re, ie, $t, Wt, he);
        }
        case dt:
          return E_(re, ie, he);
        case ht:
          return b_(re, ie, he);
        case it:
          return x_(re, ie);
        case xt:
          return jb(re, ie, he);
        case ut:
          return V_(re, ie, he);
        case ft: {
          var Xt = ie.type, xr = ie.pendingProps, Ir = ie.elementType === Xt ? xr : Cs(Xt, xr);
          return $b(re, ie, Xt, Ir, he);
        }
        case lt:
          return y_(re, ie, he);
        case St:
          return g_(re, ie, he);
        case vt:
          return S_(re, ie, he);
        case pt:
          return B_(re, ie, he);
        case ot:
          return H_(re, ie, he);
        case Ct: {
          var Fr = ie.type, ln = ie.pendingProps, nn = Cs(Fr, ln);
          if (ie.type !== ie.elementType) {
            var Ht = Fr.propTypes;
            Ht && Es(
              Ht,
              nn,
              // Resolved for outer only
              "prop",
              an(Fr)
            );
          }
          return nn = Cs(Fr.type, nn), Ib(re, ie, Fr, nn, he);
        }
        case At:
          return Nb(re, ie, ie.type, ie.pendingProps, he);
        case Vt: {
          var Kt = ie.type, Ut = ie.pendingProps, ur = ie.elementType === Kt ? Ut : Cs(Kt, Ut);
          return T_(re, ie, Kt, ur, he);
        }
        case er:
          return Yb(re, ie, he);
        case Yt:
          break;
        case Jt:
          return zb(re, ie, he);
      }
      throw new Error("Unknown unit of work tag (" + ie.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function rh(re) {
      re.flags |= Qr;
    }
    function Jb(re) {
      re.flags |= Aa, re.flags |= zh;
    }
    var Zb, Z1, ex, tx;
    Zb = function(re, ie, he, ve) {
      for (var Ce = ie.child; Ce !== null; ) {
        if (Ce.tag === ht || Ce.tag === it)
          hT(re, Ce.stateNode);
        else if (Ce.tag !== ut) {
          if (Ce.child !== null) {
            Ce.child.return = Ce, Ce = Ce.child;
            continue;
          }
        }
        if (Ce === ie)
          return;
        for (; Ce.sibling === null; ) {
          if (Ce.return === null || Ce.return === ie)
            return;
          Ce = Ce.return;
        }
        Ce.sibling.return = Ce.return, Ce = Ce.sibling;
      }
    }, Z1 = function(re, ie) {
    }, ex = function(re, ie, he, ve, Ce) {
      var ke = re.memoizedProps;
      if (ke !== ve) {
        var at = ie.stateNode, mt = a1(), gt = mT(at, he, ke, ve, Ce, mt);
        ie.updateQueue = gt, gt && rh(ie);
      }
    }, tx = function(re, ie, he, ve) {
      he !== ve && rh(ie);
    };
    function lm(re, ie) {
      if (!ha())
        switch (re.tailMode) {
          case "hidden": {
            for (var he = re.tail, ve = null; he !== null; )
              he.alternate !== null && (ve = he), he = he.sibling;
            ve === null ? re.tail = null : ve.sibling = null;
            break;
          }
          case "collapsed": {
            for (var Ce = re.tail, ke = null; Ce !== null; )
              Ce.alternate !== null && (ke = Ce), Ce = Ce.sibling;
            ke === null ? !ie && re.tail !== null ? re.tail.sibling = null : re.tail = null : ke.sibling = null;
            break;
          }
        }
    }
    function ma(re) {
      var ie = re.alternate !== null && re.alternate.child === re.child, he = Zt, ve = Lr;
      if (ie) {
        if ((re.mode & Vr) !== zr) {
          for (var gt = re.selfBaseDuration, Tt = re.child; Tt !== null; )
            he = Xr(he, Xr(Tt.lanes, Tt.childLanes)), ve |= Tt.subtreeFlags & Ui, ve |= Tt.flags & Ui, gt += Tt.treeBaseDuration, Tt = Tt.sibling;
          re.treeBaseDuration = gt;
        } else
          for (var Pt = re.child; Pt !== null; )
            he = Xr(he, Xr(Pt.lanes, Pt.childLanes)), ve |= Pt.subtreeFlags & Ui, ve |= Pt.flags & Ui, Pt.return = re, Pt = Pt.sibling;
        re.subtreeFlags |= ve;
      } else {
        if ((re.mode & Vr) !== zr) {
          for (var Ce = re.actualDuration, ke = re.selfBaseDuration, at = re.child; at !== null; )
            he = Xr(he, Xr(at.lanes, at.childLanes)), ve |= at.subtreeFlags, ve |= at.flags, Ce += at.actualDuration, ke += at.treeBaseDuration, at = at.sibling;
          re.actualDuration = Ce, re.treeBaseDuration = ke;
        } else
          for (var mt = re.child; mt !== null; )
            he = Xr(he, Xr(mt.lanes, mt.childLanes)), ve |= mt.subtreeFlags, ve |= mt.flags, mt.return = re, mt = mt.sibling;
        re.subtreeFlags |= ve;
      }
      return re.childLanes = he, ie;
    }
    function G_(re, ie, he) {
      if (kw() && (ie.mode & Zr) !== zr && (ie.flags & Ur) === Lr)
        return kE(ie), Gd(), ie.flags |= si | Ga | $i, !1;
      var ve = uy(ie);
      if (he !== null && he.dehydrated !== null)
        if (re === null) {
          if (!ve)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (Pw(ie), ma(ie), (ie.mode & Vr) !== zr) {
            var Ce = he !== null;
            if (Ce) {
              var ke = ie.child;
              ke !== null && (ie.treeBaseDuration -= ke.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Gd(), (ie.flags & Ur) === Lr && (ie.memoizedState = null), ie.flags |= Qr, ma(ie), (ie.mode & Vr) !== zr) {
            var at = he !== null;
            if (at) {
              var mt = ie.child;
              mt !== null && (ie.treeBaseDuration -= mt.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return ME(), !0;
    }
    function rx(re, ie, he) {
      var ve = ie.pendingProps;
      switch (w0(ie), ie.tag) {
        case st:
        case kt:
        case At:
        case Ae:
        case ft:
        case lt:
        case St:
        case vt:
        case ot:
        case Ct:
          return ma(ie), null;
        case rt: {
          var Ce = ie.type;
          return il(Ce) && ny(ie), ma(ie), null;
        }
        case dt: {
          var ke = ie.stateNode;
          if (Qd(ie), b0(ie), f1(), ke.pendingContext && (ke.context = ke.pendingContext, ke.pendingContext = null), re === null || re.child === null) {
            var at = uy(ie);
            if (at)
              rh(ie);
            else if (re !== null) {
              var mt = re.memoizedState;
              // Check if this is a client root
              (!mt.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (ie.flags & si) !== Lr) && (ie.flags |= uo, ME());
            }
          }
          return Z1(re, ie), ma(ie), null;
        }
        case ht: {
          o1(ie);
          var gt = ZE(), Tt = ie.type;
          if (re !== null && ie.stateNode != null)
            ex(re, ie, Tt, ve, gt), re.ref !== ie.ref && Jb(ie);
          else {
            if (!ve) {
              if (ie.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return ma(ie), null;
            }
            var Pt = a1(), Nt = uy(ie);
            if (Nt)
              _w(ie, gt, Pt) && rh(ie);
            else {
              var $t = dT(Tt, ve, gt, Pt, ie);
              Zb($t, ie, !1, !1), ie.stateNode = $t, pT($t, Tt, ve, gt) && rh(ie);
            }
            ie.ref !== null && Jb(ie);
          }
          return ma(ie), null;
        }
        case it: {
          var Gt = ve;
          if (re && ie.stateNode != null) {
            var Wt = re.memoizedProps;
            tx(re, ie, Wt, Gt);
          } else {
            if (typeof Gt != "string" && ie.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Xt = ZE(), xr = a1(), Ir = uy(ie);
            Ir ? Aw(ie) && rh(ie) : ie.stateNode = vT(Gt, Xt, xr, ie);
          }
          return ma(ie), null;
        }
        case xt: {
          Kd(ie);
          var Fr = ie.memoizedState;
          if (re === null || re.memoizedState !== null && re.memoizedState.dehydrated !== null) {
            var ln = G_(re, ie, Fr);
            if (!ln)
              return ie.flags & $i ? ie : null;
          }
          if ((ie.flags & Ur) !== Lr)
            return ie.lanes = he, (ie.mode & Vr) !== zr && L1(ie), ie;
          var nn = Fr !== null, Ht = re !== null && re.memoizedState !== null;
          if (nn !== Ht && nn) {
            var Kt = ie.child;
            if (Kt.flags |= Bs, (ie.mode & Zr) !== zr) {
              var Ut = re === null && (ie.memoizedProps.unstable_avoidThisFallback !== !0 || !Ot);
              Ut || s1(Ts.current, rb) ? WA() : yS();
            }
          }
          var ur = ie.updateQueue;
          if (ur !== null && (ie.flags |= Qr), ma(ie), (ie.mode & Vr) !== zr && nn) {
            var Cr = ie.child;
            Cr !== null && (ie.treeBaseDuration -= Cr.treeBaseDuration);
          }
          return null;
        }
        case ut:
          return Qd(ie), Z1(re, ie), re === null && uw(ie.stateNode.containerInfo), ma(ie), null;
        case pt:
          var gr = ie.type._context;
          return O0(gr, ie), ma(ie), null;
        case Vt: {
          var Hr = ie.type;
          return il(Hr) && ny(ie), ma(ie), null;
        }
        case er: {
          Kd(ie);
          var Yr = ie.memoizedState;
          if (Yr === null)
            return ma(ie), null;
          var Cn = (ie.flags & Ur) !== Lr, dn = Yr.rendering;
          if (dn === null)
            if (Cn)
              lm(Yr, !1);
            else {
              var Ri = YA() && (re === null || (re.flags & Ur) === Lr);
              if (!Ri)
                for (var hn = ie.child; hn !== null; ) {
                  var Si = _y(hn);
                  if (Si !== null) {
                    Cn = !0, ie.flags |= Ur, lm(Yr, !1);
                    var Na = Si.updateQueue;
                    return Na !== null && (ie.updateQueue = Na, ie.flags |= Qr), ie.subtreeFlags = Lr, Yw(ie, he), rf(ie, l1(Ts.current, Xp)), ie.child;
                  }
                  hn = hn.sibling;
                }
              Yr.tail !== null && qn() > Cx() && (ie.flags |= Ur, Cn = !0, lm(Yr, !1), ie.lanes = Jh);
            }
          else {
            if (!Cn) {
              var Ea = _y(dn);
              if (Ea !== null) {
                ie.flags |= Ur, Cn = !0;
                var Oo = Ea.updateQueue;
                if (Oo !== null && (ie.updateQueue = Oo, ie.flags |= Qr), lm(Yr, !0), Yr.tail === null && Yr.tailMode === "hidden" && !dn.alternate && !ha())
                  return ma(ie), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                qn() * 2 - Yr.renderingStartTime > Cx() && he !== Da && (ie.flags |= Ur, Cn = !0, lm(Yr, !1), ie.lanes = Jh);
            }
            if (Yr.isBackwards)
              dn.sibling = ie.child, ie.child = dn;
            else {
              var eo = Yr.last;
              eo !== null ? eo.sibling = dn : ie.child = dn, Yr.last = dn;
            }
          }
          if (Yr.tail !== null) {
            var to = Yr.tail;
            Yr.rendering = to, Yr.tail = to.sibling, Yr.renderingStartTime = qn(), to.sibling = null;
            var za = Ts.current;
            return Cn ? za = l1(za, Xp) : za = Xd(za), rf(ie, za), to;
          }
          return ma(ie), null;
        }
        case Yt:
          break;
        case Jt:
        case rr: {
          vS(ie);
          var ou = ie.memoizedState, fh = ou !== null;
          if (re !== null) {
            var Tm = re.memoizedState, dl = Tm !== null;
            dl !== fh && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !Dt && (ie.flags |= Bs);
          }
          return !fh || (ie.mode & Zr) === zr ? ma(ie) : Oa(cl, Da) && (ma(ie), ie.subtreeFlags & (On | Qr) && (ie.flags |= Bs)), null;
        }
        case Qt:
          return null;
        case wt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + ie.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function W_(re, ie, he) {
      switch (w0(ie), ie.tag) {
        case rt: {
          var ve = ie.type;
          il(ve) && ny(ie);
          var Ce = ie.flags;
          return Ce & $i ? (ie.flags = Ce & ~$i | Ur, (ie.mode & Vr) !== zr && L1(ie), ie) : null;
        }
        case dt: {
          ie.stateNode, Qd(ie), b0(ie), f1();
          var ke = ie.flags;
          return (ke & $i) !== Lr && (ke & Ur) === Lr ? (ie.flags = ke & ~$i | Ur, ie) : null;
        }
        case ht:
          return o1(ie), null;
        case xt: {
          Kd(ie);
          var at = ie.memoizedState;
          if (at !== null && at.dehydrated !== null) {
            if (ie.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Gd();
          }
          var mt = ie.flags;
          return mt & $i ? (ie.flags = mt & ~$i | Ur, (ie.mode & Vr) !== zr && L1(ie), ie) : null;
        }
        case er:
          return Kd(ie), null;
        case ut:
          return Qd(ie), null;
        case pt:
          var gt = ie.type._context;
          return O0(gt, ie), null;
        case Jt:
        case rr:
          return vS(ie), null;
        case Qt:
          return null;
        default:
          return null;
      }
    }
    function nx(re, ie, he) {
      switch (w0(ie), ie.tag) {
        case rt: {
          var ve = ie.type.childContextTypes;
          ve != null && ny(ie);
          break;
        }
        case dt: {
          ie.stateNode, Qd(ie), b0(ie), f1();
          break;
        }
        case ht: {
          o1(ie);
          break;
        }
        case ut:
          Qd(ie);
          break;
        case xt:
          Kd(ie);
          break;
        case er:
          Kd(ie);
          break;
        case pt:
          var Ce = ie.type._context;
          O0(Ce, ie);
          break;
        case Jt:
        case rr:
          vS(ie);
          break;
      }
    }
    var ix = null;
    ix = /* @__PURE__ */ new Set();
    var Qy = !1, va = !1, q_ = typeof WeakSet == "function" ? WeakSet : Set, Pr = null, nh = null, ih = null;
    function Y_(re) {
      Al(null, function() {
        throw re;
      }), Ih();
    }
    var Q_ = function(re, ie) {
      if (ie.props = re.memoizedProps, ie.state = re.memoizedState, re.mode & Vr)
        try {
          ul(), ie.componentWillUnmount();
        } finally {
          ll(re);
        }
      else
        ie.componentWillUnmount();
    };
    function ax(re, ie) {
      try {
        of(qi, re);
      } catch (he) {
        Nn(re, ie, he);
      }
    }
    function eS(re, ie, he) {
      try {
        Q_(re, he);
      } catch (ve) {
        Nn(re, ie, ve);
      }
    }
    function X_(re, ie, he) {
      try {
        he.componentDidMount();
      } catch (ve) {
        Nn(re, ie, ve);
      }
    }
    function ox(re, ie) {
      try {
        lx(re);
      } catch (he) {
        Nn(re, ie, he);
      }
    }
    function ah(re, ie) {
      var he = re.ref;
      if (he !== null)
        if (typeof he == "function") {
          var ve;
          try {
            if (Nr && cn && re.mode & Vr)
              try {
                ul(), ve = he(null);
              } finally {
                ll(re);
              }
            else
              ve = he(null);
          } catch (Ce) {
            Nn(re, ie, Ce);
          }
          typeof ve == "function" && be("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Wr(re));
        } else
          he.current = null;
    }
    function Xy(re, ie, he) {
      try {
        he();
      } catch (ve) {
        Nn(re, ie, ve);
      }
    }
    var sx = !1;
    function K_(re, ie) {
      fT(re.containerInfo), Pr = ie, J_();
      var he = sx;
      return sx = !1, he;
    }
    function J_() {
      for (; Pr !== null; ) {
        var re = Pr, ie = re.child;
        (re.subtreeFlags & wu) !== Lr && ie !== null ? (ie.return = re, Pr = ie) : Z_();
      }
    }
    function Z_() {
      for (; Pr !== null; ) {
        var re = Pr;
        yn(re);
        try {
          eA(re);
        } catch (he) {
          Nn(re, re.return, he);
        }
        Un();
        var ie = re.sibling;
        if (ie !== null) {
          ie.return = re.return, Pr = ie;
          return;
        }
        Pr = re.return;
      }
    }
    function eA(re) {
      var ie = re.alternate, he = re.flags;
      if ((he & uo) !== Lr) {
        switch (yn(re), re.tag) {
          case Ae:
          case ft:
          case At:
            break;
          case rt: {
            if (ie !== null) {
              var ve = ie.memoizedProps, Ce = ie.memoizedState, ke = re.stateNode;
              re.type === re.elementType && !hc && (ke.props !== re.memoizedProps && be("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Wr(re) || "instance"), ke.state !== re.memoizedState && be("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Wr(re) || "instance"));
              var at = ke.getSnapshotBeforeUpdate(re.elementType === re.type ? ve : Cs(re.type, ve), Ce);
              {
                var mt = ix;
                at === void 0 && !mt.has(re.type) && (mt.add(re.type), be("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Wr(re)));
              }
              ke.__reactInternalSnapshotBeforeUpdate = at;
            }
            break;
          }
          case dt: {
            {
              var gt = re.stateNode;
              LT(gt.containerInfo);
            }
            break;
          }
          case ht:
          case it:
          case ut:
          case Vt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Un();
      }
    }
    function As(re, ie, he) {
      var ve = ie.updateQueue, Ce = ve !== null ? ve.lastEffect : null;
      if (Ce !== null) {
        var ke = Ce.next, at = ke;
        do {
          if ((at.tag & re) === re) {
            var mt = at.destroy;
            at.destroy = void 0, mt !== void 0 && ((re & pa) !== xo ? Yc(ie) : (re & qi) !== xo && Qc(ie), (re & al) !== xo && bm(!0), Xy(ie, he, mt), (re & al) !== xo && bm(!1), (re & pa) !== xo ? lv() : (re & qi) !== xo && _u());
          }
          at = at.next;
        } while (at !== ke);
      }
    }
    function of(re, ie) {
      var he = ie.updateQueue, ve = he !== null ? he.lastEffect : null;
      if (ve !== null) {
        var Ce = ve.next, ke = Ce;
        do {
          if ((ke.tag & re) === re) {
            (re & pa) !== xo ? sv(ie) : (re & qi) !== xo && uv(ie);
            var at = ke.create;
            (re & al) !== xo && bm(!0), ke.destroy = at(), (re & al) !== xo && bm(!1), (re & pa) !== xo ? Qh() : (re & qi) !== xo && fv();
            {
              var mt = ke.destroy;
              if (mt !== void 0 && typeof mt != "function") {
                var gt = void 0;
                (ke.tag & qi) !== Lr ? gt = "useLayoutEffect" : (ke.tag & al) !== Lr ? gt = "useInsertionEffect" : gt = "useEffect";
                var Tt = void 0;
                mt === null ? Tt = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof mt.then == "function" ? Tt = `

It looks like you wrote ` + gt + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + gt + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Tt = " You returned: " + mt, be("%s must not return anything besides a function, which is used for clean-up.%s", gt, Tt);
              }
            }
          }
          ke = ke.next;
        } while (ke !== Ce);
      }
    }
    function tA(re, ie) {
      if ((ie.flags & Qr) !== Lr)
        switch (ie.tag) {
          case vt: {
            var he = ie.stateNode.passiveEffectDuration, ve = ie.memoizedProps, Ce = ve.id, ke = ve.onPostCommit, at = Rb(), mt = ie.alternate === null ? "mount" : "update";
            Pb() && (mt = "nested-update"), typeof ke == "function" && ke(Ce, mt, he, at);
            var gt = ie.return;
            e:
              for (; gt !== null; ) {
                switch (gt.tag) {
                  case dt:
                    var Tt = gt.stateNode;
                    Tt.passiveEffectDuration += he;
                    break e;
                  case vt:
                    var Pt = gt.stateNode;
                    Pt.passiveEffectDuration += he;
                    break e;
                }
                gt = gt.return;
              }
            break;
          }
        }
    }
    function rA(re, ie, he, ve) {
      if ((he.flags & ea) !== Lr)
        switch (he.tag) {
          case Ae:
          case ft:
          case At: {
            if (!va)
              if (he.mode & Vr)
                try {
                  ul(), of(qi | Wi, he);
                } finally {
                  ll(he);
                }
              else
                of(qi | Wi, he);
            break;
          }
          case rt: {
            var Ce = he.stateNode;
            if (he.flags & Qr && !va)
              if (ie === null)
                if (he.type === he.elementType && !hc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Wr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Wr(he) || "instance")), he.mode & Vr)
                  try {
                    ul(), Ce.componentDidMount();
                  } finally {
                    ll(he);
                  }
                else
                  Ce.componentDidMount();
              else {
                var ke = he.elementType === he.type ? ie.memoizedProps : Cs(he.type, ie.memoizedProps), at = ie.memoizedState;
                if (he.type === he.elementType && !hc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Wr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Wr(he) || "instance")), he.mode & Vr)
                  try {
                    ul(), Ce.componentDidUpdate(ke, at, Ce.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ll(he);
                  }
                else
                  Ce.componentDidUpdate(ke, at, Ce.__reactInternalSnapshotBeforeUpdate);
              }
            var mt = he.updateQueue;
            mt !== null && (he.type === he.elementType && !hc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Wr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Wr(he) || "instance")), BE(he, mt, Ce));
            break;
          }
          case dt: {
            var gt = he.updateQueue;
            if (gt !== null) {
              var Tt = null;
              if (he.child !== null)
                switch (he.child.tag) {
                  case ht:
                    Tt = he.child.stateNode;
                    break;
                  case rt:
                    Tt = he.child.stateNode;
                    break;
                }
              BE(he, gt, Tt);
            }
            break;
          }
          case ht: {
            var Pt = he.stateNode;
            if (ie === null && he.flags & Qr) {
              var Nt = he.type, $t = he.memoizedProps;
              bT(Pt, Nt, $t);
            }
            break;
          }
          case it:
            break;
          case ut:
            break;
          case vt: {
            {
              var Gt = he.memoizedProps, Wt = Gt.onCommit, Xt = Gt.onRender, xr = he.stateNode.effectDuration, Ir = Rb(), Fr = ie === null ? "mount" : "update";
              Pb() && (Fr = "nested-update"), typeof Xt == "function" && Xt(he.memoizedProps.id, Fr, he.actualDuration, he.treeBaseDuration, he.actualStartTime, Ir);
              {
                typeof Wt == "function" && Wt(he.memoizedProps.id, Fr, xr, Ir), ZA(he);
                var ln = he.return;
                e:
                  for (; ln !== null; ) {
                    switch (ln.tag) {
                      case dt:
                        var nn = ln.stateNode;
                        nn.effectDuration += xr;
                        break e;
                      case vt:
                        var Ht = ln.stateNode;
                        Ht.effectDuration += xr;
                        break e;
                    }
                    ln = ln.return;
                  }
              }
            }
            break;
          }
          case xt: {
            fA(re, he);
            break;
          }
          case er:
          case Vt:
          case Yt:
          case Jt:
          case rr:
          case wt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      va || he.flags & Aa && lx(he);
    }
    function nA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          if (re.mode & Vr)
            try {
              ul(), ax(re, re.return);
            } finally {
              ll(re);
            }
          else
            ax(re, re.return);
          break;
        }
        case rt: {
          var ie = re.stateNode;
          typeof ie.componentDidMount == "function" && X_(re, re.return, ie), ox(re, re.return);
          break;
        }
        case ht: {
          ox(re, re.return);
          break;
        }
      }
    }
    function iA(re, ie) {
      for (var he = null, ve = re; ; ) {
        if (ve.tag === ht) {
          if (he === null) {
            he = ve;
            try {
              var Ce = ve.stateNode;
              ie ? MT(Ce) : DT(ve.stateNode, ve.memoizedProps);
            } catch (at) {
              Nn(re, re.return, at);
            }
          }
        } else if (ve.tag === it) {
          if (he === null)
            try {
              var ke = ve.stateNode;
              ie ? FT(ke) : OT(ke, ve.memoizedProps);
            } catch (at) {
              Nn(re, re.return, at);
            }
        } else if (!((ve.tag === Jt || ve.tag === rr) && ve.memoizedState !== null && ve !== re)) {
          if (ve.child !== null) {
            ve.child.return = ve, ve = ve.child;
            continue;
          }
        }
        if (ve === re)
          return;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === re)
            return;
          he === ve && (he = null), ve = ve.return;
        }
        he === ve && (he = null), ve.sibling.return = ve.return, ve = ve.sibling;
      }
    }
    function lx(re) {
      var ie = re.ref;
      if (ie !== null) {
        var he = re.stateNode, ve;
        switch (re.tag) {
          case ht:
            ve = he;
            break;
          default:
            ve = he;
        }
        if (typeof ie == "function") {
          var Ce;
          if (re.mode & Vr)
            try {
              ul(), Ce = ie(ve);
            } finally {
              ll(re);
            }
          else
            Ce = ie(ve);
          typeof Ce == "function" && be("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Wr(re));
        } else
          ie.hasOwnProperty("current") || be("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Wr(re)), ie.current = ve;
      }
    }
    function aA(re) {
      var ie = re.alternate;
      ie !== null && (ie.return = null), re.return = null;
    }
    function ux(re) {
      var ie = re.alternate;
      ie !== null && (re.alternate = null, ux(ie));
      {
        if (re.child = null, re.deletions = null, re.sibling = null, re.tag === ht) {
          var he = re.stateNode;
          he !== null && dw(he);
        }
        re.stateNode = null, re._debugOwner = null, re.return = null, re.dependencies = null, re.memoizedProps = null, re.memoizedState = null, re.pendingProps = null, re.stateNode = null, re.updateQueue = null;
      }
    }
    function oA(re) {
      for (var ie = re.return; ie !== null; ) {
        if (fx(ie))
          return ie;
        ie = ie.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function fx(re) {
      return re.tag === ht || re.tag === dt || re.tag === ut;
    }
    function cx(re) {
      var ie = re;
      e:
        for (; ; ) {
          for (; ie.sibling === null; ) {
            if (ie.return === null || fx(ie.return))
              return null;
            ie = ie.return;
          }
          for (ie.sibling.return = ie.return, ie = ie.sibling; ie.tag !== ht && ie.tag !== it && ie.tag !== ir; ) {
            if (ie.flags & On || ie.child === null || ie.tag === ut)
              continue e;
            ie.child.return = ie, ie = ie.child;
          }
          if (!(ie.flags & On))
            return ie.stateNode;
        }
    }
    function sA(re) {
      var ie = oA(re);
      switch (ie.tag) {
        case ht: {
          var he = ie.stateNode;
          ie.flags & Sn && (cE(he), ie.flags &= ~Sn);
          var ve = cx(re);
          rS(re, ve, he);
          break;
        }
        case dt:
        case ut: {
          var Ce = ie.stateNode.containerInfo, ke = cx(re);
          tS(re, ke, Ce);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function tS(re, ie, he) {
      var ve = re.tag, Ce = ve === ht || ve === it;
      if (Ce) {
        var ke = re.stateNode;
        ie ? AT(he, ke, ie) : wT(he, ke);
      } else if (ve !== ut) {
        var at = re.child;
        if (at !== null) {
          tS(at, ie, he);
          for (var mt = at.sibling; mt !== null; )
            tS(mt, ie, he), mt = mt.sibling;
        }
      }
    }
    function rS(re, ie, he) {
      var ve = re.tag, Ce = ve === ht || ve === it;
      if (Ce) {
        var ke = re.stateNode;
        ie ? _T(he, ke, ie) : TT(he, ke);
      } else if (ve !== ut) {
        var at = re.child;
        if (at !== null) {
          rS(at, ie, he);
          for (var mt = at.sibling; mt !== null; )
            rS(mt, ie, he), mt = mt.sibling;
        }
      }
    }
    var ya = null, Ps = !1;
    function lA(re, ie, he) {
      {
        var ve = ie;
        e:
          for (; ve !== null; ) {
            switch (ve.tag) {
              case ht: {
                ya = ve.stateNode, Ps = !1;
                break e;
              }
              case dt: {
                ya = ve.stateNode.containerInfo, Ps = !0;
                break e;
              }
              case ut: {
                ya = ve.stateNode.containerInfo, Ps = !0;
                break e;
              }
            }
            ve = ve.return;
          }
        if (ya === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        dx(re, ie, he), ya = null, Ps = !1;
      }
      aA(he);
    }
    function sf(re, ie, he) {
      for (var ve = he.child; ve !== null; )
        dx(re, ie, ve), ve = ve.sibling;
    }
    function dx(re, ie, he) {
      switch (qh(he), he.tag) {
        case ht:
          va || ah(he, ie);
        case it: {
          {
            var ve = ya, Ce = Ps;
            ya = null, sf(re, ie, he), ya = ve, Ps = Ce, ya !== null && (Ps ? RT(ya, he.stateNode) : PT(ya, he.stateNode));
          }
          return;
        }
        case ir: {
          ya !== null && (Ps ? kT(ya, he.stateNode) : h0(ya, he.stateNode));
          return;
        }
        case ut: {
          {
            var ke = ya, at = Ps;
            ya = he.stateNode.containerInfo, Ps = !0, sf(re, ie, he), ya = ke, Ps = at;
          }
          return;
        }
        case Ae:
        case ft:
        case Ct:
        case At: {
          if (!va) {
            var mt = he.updateQueue;
            if (mt !== null) {
              var gt = mt.lastEffect;
              if (gt !== null) {
                var Tt = gt.next, Pt = Tt;
                do {
                  var Nt = Pt, $t = Nt.destroy, Gt = Nt.tag;
                  $t !== void 0 && ((Gt & al) !== xo ? Xy(he, ie, $t) : (Gt & qi) !== xo && (Qc(he), he.mode & Vr ? (ul(), Xy(he, ie, $t), ll(he)) : Xy(he, ie, $t), _u())), Pt = Pt.next;
                } while (Pt !== Tt);
              }
            }
          }
          sf(re, ie, he);
          return;
        }
        case rt: {
          if (!va) {
            ah(he, ie);
            var Wt = he.stateNode;
            typeof Wt.componentWillUnmount == "function" && eS(he, ie, Wt);
          }
          sf(re, ie, he);
          return;
        }
        case Yt: {
          sf(re, ie, he);
          return;
        }
        case Jt: {
          if (
            // TODO: Remove this dead flag
            he.mode & Zr
          ) {
            var Xt = va;
            va = Xt || he.memoizedState !== null, sf(re, ie, he), va = Xt;
          } else
            sf(re, ie, he);
          break;
        }
        default: {
          sf(re, ie, he);
          return;
        }
      }
    }
    function uA(re) {
      re.memoizedState;
    }
    function fA(re, ie) {
      var he = ie.memoizedState;
      if (he === null) {
        var ve = ie.alternate;
        if (ve !== null) {
          var Ce = ve.memoizedState;
          if (Ce !== null) {
            var ke = Ce.dehydrated;
            ke !== null && QT(ke);
          }
        }
      }
    }
    function hx(re) {
      var ie = re.updateQueue;
      if (ie !== null) {
        re.updateQueue = null;
        var he = re.stateNode;
        he === null && (he = re.stateNode = new q_()), ie.forEach(function(ve) {
          var Ce = oP.bind(null, re, ve);
          if (!he.has(ve)) {
            if (he.add(ve), ji)
              if (nh !== null && ih !== null)
                Em(ih, nh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            ve.then(Ce, Ce);
          }
        });
      }
    }
    function cA(re, ie, he) {
      nh = he, ih = re, yn(ie), px(ie, re), yn(ie), nh = null, ih = null;
    }
    function Rs(re, ie, he) {
      var ve = ie.deletions;
      if (ve !== null)
        for (var Ce = 0; Ce < ve.length; Ce++) {
          var ke = ve[Ce];
          try {
            lA(re, ie, ke);
          } catch (gt) {
            Nn(ke, ie, gt);
          }
        }
      var at = Sf();
      if (ie.subtreeFlags & ka)
        for (var mt = ie.child; mt !== null; )
          yn(mt), px(mt, re), mt = mt.sibling;
      yn(at);
    }
    function px(re, ie, he) {
      var ve = re.alternate, Ce = re.flags;
      switch (re.tag) {
        case Ae:
        case ft:
        case Ct:
        case At: {
          if (Rs(ie, re), fl(re), Ce & Qr) {
            try {
              As(al | Wi, re, re.return), of(al | Wi, re);
            } catch (Hr) {
              Nn(re, re.return, Hr);
            }
            if (re.mode & Vr) {
              try {
                ul(), As(qi | Wi, re, re.return);
              } catch (Hr) {
                Nn(re, re.return, Hr);
              }
              ll(re);
            } else
              try {
                As(qi | Wi, re, re.return);
              } catch (Hr) {
                Nn(re, re.return, Hr);
              }
          }
          return;
        }
        case rt: {
          Rs(ie, re), fl(re), Ce & Aa && ve !== null && ah(ve, ve.return);
          return;
        }
        case ht: {
          Rs(ie, re), fl(re), Ce & Aa && ve !== null && ah(ve, ve.return);
          {
            if (re.flags & Sn) {
              var ke = re.stateNode;
              try {
                cE(ke);
              } catch (Hr) {
                Nn(re, re.return, Hr);
              }
            }
            if (Ce & Qr) {
              var at = re.stateNode;
              if (at != null) {
                var mt = re.memoizedProps, gt = ve !== null ? ve.memoizedProps : mt, Tt = re.type, Pt = re.updateQueue;
                if (re.updateQueue = null, Pt !== null)
                  try {
                    xT(at, Pt, Tt, gt, mt, re);
                  } catch (Hr) {
                    Nn(re, re.return, Hr);
                  }
              }
            }
          }
          return;
        }
        case it: {
          if (Rs(ie, re), fl(re), Ce & Qr) {
            if (re.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Nt = re.stateNode, $t = re.memoizedProps, Gt = ve !== null ? ve.memoizedProps : $t;
            try {
              CT(Nt, Gt, $t);
            } catch (Hr) {
              Nn(re, re.return, Hr);
            }
          }
          return;
        }
        case dt: {
          if (Rs(ie, re), fl(re), Ce & Qr && ve !== null) {
            var Wt = ve.memoizedState;
            if (Wt.isDehydrated)
              try {
                YT(ie.containerInfo);
              } catch (Hr) {
                Nn(re, re.return, Hr);
              }
          }
          return;
        }
        case ut: {
          Rs(ie, re), fl(re);
          return;
        }
        case xt: {
          Rs(ie, re), fl(re);
          var Xt = re.child;
          if (Xt.flags & Bs) {
            var xr = Xt.stateNode, Ir = Xt.memoizedState, Fr = Ir !== null;
            if (xr.isHidden = Fr, Fr) {
              var ln = Xt.alternate !== null && Xt.alternate.memoizedState !== null;
              ln || GA();
            }
          }
          if (Ce & Qr) {
            try {
              uA(re);
            } catch (Hr) {
              Nn(re, re.return, Hr);
            }
            hx(re);
          }
          return;
        }
        case Jt: {
          var nn = ve !== null && ve.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            re.mode & Zr
          ) {
            var Ht = va;
            va = Ht || nn, Rs(ie, re), va = Ht;
          } else
            Rs(ie, re);
          if (fl(re), Ce & Bs) {
            var Kt = re.stateNode, Ut = re.memoizedState, ur = Ut !== null, Cr = re;
            if (Kt.isHidden = ur, ur && !nn && (Cr.mode & Zr) !== zr) {
              Pr = Cr;
              for (var gr = Cr.child; gr !== null; )
                Pr = gr, hA(gr), gr = gr.sibling;
            }
            iA(Cr, ur);
          }
          return;
        }
        case er: {
          Rs(ie, re), fl(re), Ce & Qr && hx(re);
          return;
        }
        case Yt:
          return;
        default: {
          Rs(ie, re), fl(re);
          return;
        }
      }
    }
    function fl(re) {
      var ie = re.flags;
      if (ie & On) {
        try {
          sA(re);
        } catch (he) {
          Nn(re, re.return, he);
        }
        re.flags &= ~On;
      }
      ie & fo && (re.flags &= ~fo);
    }
    function dA(re, ie, he) {
      nh = he, ih = ie, Pr = re, mx(re, ie, he), nh = null, ih = null;
    }
    function mx(re, ie, he) {
      for (var ve = (re.mode & Zr) !== zr; Pr !== null; ) {
        var Ce = Pr, ke = Ce.child;
        if (Ce.tag === Jt && ve) {
          var at = Ce.memoizedState !== null, mt = at || Qy;
          if (mt) {
            nS(re, ie, he);
            continue;
          } else {
            var gt = Ce.alternate, Tt = gt !== null && gt.memoizedState !== null, Pt = Tt || va, Nt = Qy, $t = va;
            Qy = mt, va = Pt, va && !$t && (Pr = Ce, pA(Ce));
            for (var Gt = ke; Gt !== null; )
              Pr = Gt, mx(
                Gt,
                // New root; bubble back up to here and stop.
                ie,
                he
              ), Gt = Gt.sibling;
            Pr = Ce, Qy = Nt, va = $t, nS(re, ie, he);
            continue;
          }
        }
        (Ce.subtreeFlags & ea) !== Lr && ke !== null ? (ke.return = Ce, Pr = ke) : nS(re, ie, he);
      }
    }
    function nS(re, ie, he) {
      for (; Pr !== null; ) {
        var ve = Pr;
        if ((ve.flags & ea) !== Lr) {
          var Ce = ve.alternate;
          yn(ve);
          try {
            rA(ie, Ce, ve, he);
          } catch (at) {
            Nn(ve, ve.return, at);
          }
          Un();
        }
        if (ve === re) {
          Pr = null;
          return;
        }
        var ke = ve.sibling;
        if (ke !== null) {
          ke.return = ve.return, Pr = ke;
          return;
        }
        Pr = ve.return;
      }
    }
    function hA(re) {
      for (; Pr !== null; ) {
        var ie = Pr, he = ie.child;
        switch (ie.tag) {
          case Ae:
          case ft:
          case Ct:
          case At: {
            if (ie.mode & Vr)
              try {
                ul(), As(qi, ie, ie.return);
              } finally {
                ll(ie);
              }
            else
              As(qi, ie, ie.return);
            break;
          }
          case rt: {
            ah(ie, ie.return);
            var ve = ie.stateNode;
            typeof ve.componentWillUnmount == "function" && eS(ie, ie.return, ve);
            break;
          }
          case ht: {
            ah(ie, ie.return);
            break;
          }
          case Jt: {
            var Ce = ie.memoizedState !== null;
            if (Ce) {
              vx(re);
              continue;
            }
            break;
          }
        }
        he !== null ? (he.return = ie, Pr = he) : vx(re);
      }
    }
    function vx(re) {
      for (; Pr !== null; ) {
        var ie = Pr;
        if (ie === re) {
          Pr = null;
          return;
        }
        var he = ie.sibling;
        if (he !== null) {
          he.return = ie.return, Pr = he;
          return;
        }
        Pr = ie.return;
      }
    }
    function pA(re) {
      for (; Pr !== null; ) {
        var ie = Pr, he = ie.child;
        if (ie.tag === Jt) {
          var ve = ie.memoizedState !== null;
          if (ve) {
            yx(re);
            continue;
          }
        }
        he !== null ? (he.return = ie, Pr = he) : yx(re);
      }
    }
    function yx(re) {
      for (; Pr !== null; ) {
        var ie = Pr;
        yn(ie);
        try {
          nA(ie);
        } catch (ve) {
          Nn(ie, ie.return, ve);
        }
        if (Un(), ie === re) {
          Pr = null;
          return;
        }
        var he = ie.sibling;
        if (he !== null) {
          he.return = ie.return, Pr = he;
          return;
        }
        Pr = ie.return;
      }
    }
    function mA(re, ie, he, ve) {
      Pr = ie, vA(ie, re, he, ve);
    }
    function vA(re, ie, he, ve) {
      for (; Pr !== null; ) {
        var Ce = Pr, ke = Ce.child;
        (Ce.subtreeFlags & co) !== Lr && ke !== null ? (ke.return = Ce, Pr = ke) : yA(re, ie, he, ve);
      }
    }
    function yA(re, ie, he, ve) {
      for (; Pr !== null; ) {
        var Ce = Pr;
        if ((Ce.flags & jn) !== Lr) {
          yn(Ce);
          try {
            gA(ie, Ce, he, ve);
          } catch (at) {
            Nn(Ce, Ce.return, at);
          }
          Un();
        }
        if (Ce === re) {
          Pr = null;
          return;
        }
        var ke = Ce.sibling;
        if (ke !== null) {
          ke.return = Ce.return, Pr = ke;
          return;
        }
        Pr = Ce.return;
      }
    }
    function gA(re, ie, he, ve) {
      switch (ie.tag) {
        case Ae:
        case ft:
        case At: {
          if (ie.mode & Vr) {
            O1();
            try {
              of(pa | Wi, ie);
            } finally {
              D1(ie);
            }
          } else
            of(pa | Wi, ie);
          break;
        }
      }
    }
    function SA(re) {
      Pr = re, EA();
    }
    function EA() {
      for (; Pr !== null; ) {
        var re = Pr, ie = re.child;
        if ((Pr.flags & pn) !== Lr) {
          var he = re.deletions;
          if (he !== null) {
            for (var ve = 0; ve < he.length; ve++) {
              var Ce = he[ve];
              Pr = Ce, CA(Ce, re);
            }
            {
              var ke = re.alternate;
              if (ke !== null) {
                var at = ke.child;
                if (at !== null) {
                  ke.child = null;
                  do {
                    var mt = at.sibling;
                    at.sibling = null, at = mt;
                  } while (at !== null);
                }
              }
            }
            Pr = re;
          }
        }
        (re.subtreeFlags & co) !== Lr && ie !== null ? (ie.return = re, Pr = ie) : bA();
      }
    }
    function bA() {
      for (; Pr !== null; ) {
        var re = Pr;
        (re.flags & jn) !== Lr && (yn(re), xA(re), Un());
        var ie = re.sibling;
        if (ie !== null) {
          ie.return = re.return, Pr = ie;
          return;
        }
        Pr = re.return;
      }
    }
    function xA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          re.mode & Vr ? (O1(), As(pa | Wi, re, re.return), D1(re)) : As(pa | Wi, re, re.return);
          break;
        }
      }
    }
    function CA(re, ie) {
      for (; Pr !== null; ) {
        var he = Pr;
        yn(he), wA(he, ie), Un();
        var ve = he.child;
        ve !== null ? (ve.return = he, Pr = ve) : TA(re);
      }
    }
    function TA(re) {
      for (; Pr !== null; ) {
        var ie = Pr, he = ie.sibling, ve = ie.return;
        if (ux(ie), ie === re) {
          Pr = null;
          return;
        }
        if (he !== null) {
          he.return = ve, Pr = he;
          return;
        }
        Pr = ve;
      }
    }
    function wA(re, ie) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          re.mode & Vr ? (O1(), As(pa, re, ie), D1(re)) : As(pa, re, ie);
          break;
        }
      }
    }
    function _A(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            of(qi | Wi, re);
          } catch (he) {
            Nn(re, re.return, he);
          }
          break;
        }
        case rt: {
          var ie = re.stateNode;
          try {
            ie.componentDidMount();
          } catch (he) {
            Nn(re, re.return, he);
          }
          break;
        }
      }
    }
    function AA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            of(pa | Wi, re);
          } catch (ie) {
            Nn(re, re.return, ie);
          }
          break;
        }
      }
    }
    function PA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            As(qi | Wi, re, re.return);
          } catch (he) {
            Nn(re, re.return, he);
          }
          break;
        }
        case rt: {
          var ie = re.stateNode;
          typeof ie.componentWillUnmount == "function" && eS(re, re.return, ie);
          break;
        }
      }
    }
    function RA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At:
          try {
            As(pa | Wi, re, re.return);
          } catch (ie) {
            Nn(re, re.return, ie);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var um = Symbol.for;
      um("selector.component"), um("selector.has_pseudo_class"), um("selector.role"), um("selector.test_id"), um("selector.text");
    }
    var kA = [];
    function MA() {
      kA.forEach(function(re) {
        return re();
      });
    }
    var FA = oe.ReactCurrentActQueue;
    function DA(re) {
      {
        var ie = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), he = typeof jest < "u";
        return he && ie !== !1;
      }
    }
    function gx() {
      {
        var re = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !re && FA.current !== null && be("The current testing environment is not configured to support act(...)"), re;
      }
    }
    var OA = Math.ceil, iS = oe.ReactCurrentDispatcher, aS = oe.ReactCurrentOwner, ga = oe.ReactCurrentBatchConfig, ks = oe.ReactCurrentActQueue, Xi = (
      /*             */
      0
    ), Sx = (
      /*               */
      1
    ), Sa = (
      /*                */
      2
    ), Zo = (
      /*                */
      4
    ), ru = 0, fm = 1, pc = 2, Ky = 3, cm = 4, Ex = 5, oS = 6, sn = Xi, Ja = null, hi = null, Ki = Zt, cl = Zt, sS = Xu(Zt), Ji = ru, dm = null, Jy = Zt, hm = Zt, Zy = Zt, pm = null, Co = null, lS = 0, bx = 500, xx = 1 / 0, LA = 500, nu = null;
    function mm() {
      xx = qn() + LA;
    }
    function Cx() {
      return xx;
    }
    var eg = !1, uS = null, oh = null, mc = !1, lf = null, vm = Zt, fS = [], cS = null, $A = 50, ym = 0, dS = null, hS = !1, tg = !1, IA = 50, sh = 0, rg = null, gm = Rn, ng = Zt, Tx = !1;
    function ig() {
      return Ja;
    }
    function Za() {
      return (sn & (Sa | Zo)) !== Xi ? qn() : (gm !== Rn || (gm = qn()), gm);
    }
    function uf(re) {
      var ie = re.mode;
      if ((ie & Zr) === zr)
        return Br;
      if ((sn & Sa) !== Xi && Ki !== Zt)
        return wi(Ki);
      var he = Dw() !== Fw;
      if (he) {
        if (ga.transition !== null) {
          var ve = ga.transition;
          ve._updatedFibers || (ve._updatedFibers = /* @__PURE__ */ new Set()), ve._updatedFibers.add(re);
        }
        return ng === on && (ng = tp()), ng;
      }
      var Ce = vo();
      if (Ce !== on)
        return Ce;
      var ke = yT();
      return ke;
    }
    function NA(re) {
      var ie = re.mode;
      return (ie & Zr) === zr ? Br : Og();
    }
    function Zi(re, ie, he, ve) {
      lP(), Tx && be("useInsertionEffect must not schedule updates."), hS && (tg = !0), zl(re, he, ve), (sn & Sa) !== Zt && re === Ja ? cP(ie) : (ji && lp(re, ie, he), dP(ie), re === Ja && ((sn & Sa) === Xi && (hm = Xr(hm, he)), Ji === cm && ff(re, Ki)), To(re, ve), he === Br && sn === Xi && (ie.mode & Zr) === zr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ks.isBatchingLegacy && (mm(), xE()));
    }
    function zA(re, ie, he) {
      var ve = re.current;
      ve.lanes = ie, zl(re, ie, he), To(re, he);
    }
    function VA(re) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (sn & Sa) !== Xi
      );
    }
    function To(re, ie) {
      var he = re.callbackNode;
      Mg(re, ie);
      var ve = Vf(re, re === Ja ? Ki : Zt);
      if (ve === Zt) {
        he !== null && Vx(he), re.callbackNode = null, re.callbackPriority = on;
        return;
      }
      var Ce = yi(ve), ke = re.callbackPriority;
      if (ke === Ce && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ks.current !== null && he !== ES)) {
        he == null && ke !== Br && be("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      he != null && Vx(he);
      var at;
      if (Ce === Br)
        re.tag === Ku ? (ks.isBatchingLegacy !== null && (ks.didScheduleLegacyUpdate = !0), mw(Ax.bind(null, re))) : bE(Ax.bind(null, re)), ks.current !== null ? ks.current.push(Ju) : ST(function() {
          (sn & (Sa | Zo)) === Xi && Ju();
        }), at = null;
      else {
        var mt;
        switch (Gf(ve)) {
          case ta:
            mt = Gc;
            break;
          case Gi:
            mt = Ya;
            break;
          case ms:
            mt = Uo;
            break;
          case Uf:
            mt = Us;
            break;
          default:
            mt = Uo;
            break;
        }
        at = bS(mt, wx.bind(null, re));
      }
      re.callbackPriority = Ce, re.callbackNode = at;
    }
    function wx(re, ie) {
      if (l_(), gm = Rn, ng = Zt, (sn & (Sa | Zo)) !== Xi)
        throw new Error("Should not already be working.");
      var he = re.callbackNode, ve = au();
      if (ve && re.callbackNode !== he)
        return null;
      var Ce = Vf(re, re === Ja ? Ki : Zt);
      if (Ce === Zt)
        return null;
      var ke = !Hf(re, Ce) && !vv(re, Ce) && !ie, at = ke ? XA(re, Ce) : og(re, Ce);
      if (at !== ru) {
        if (at === pc) {
          var mt = Zh(re);
          mt !== Zt && (Ce = mt, at = pS(re, mt));
        }
        if (at === fm) {
          var gt = dm;
          throw vc(re, Zt), ff(re, Ce), To(re, qn()), gt;
        }
        if (at === oS)
          ff(re, Ce);
        else {
          var Tt = !Hf(re, Ce), Pt = re.current.alternate;
          if (Tt && !HA(Pt)) {
            if (at = og(re, Ce), at === pc) {
              var Nt = Zh(re);
              Nt !== Zt && (Ce = Nt, at = pS(re, Nt));
            }
            if (at === fm) {
              var $t = dm;
              throw vc(re, Zt), ff(re, Ce), To(re, qn()), $t;
            }
          }
          re.finishedWork = Pt, re.finishedLanes = Ce, BA(re, at, Ce);
        }
      }
      return To(re, qn()), re.callbackNode === he ? wx.bind(null, re) : null;
    }
    function pS(re, ie) {
      var he = pm;
      if (Ai(re)) {
        var ve = vc(re, ie);
        ve.flags |= si, lw(re.containerInfo);
      }
      var Ce = og(re, ie);
      if (Ce !== pc) {
        var ke = Co;
        Co = he, ke !== null && _x(ke);
      }
      return Ce;
    }
    function _x(re) {
      Co === null ? Co = re : Co.push.apply(Co, re);
    }
    function BA(re, ie, he) {
      switch (ie) {
        case ru:
        case fm:
          throw new Error("Root did not complete. This is a bug in React.");
        case pc: {
          yc(re, Co, nu);
          break;
        }
        case Ky: {
          if (ff(re, he), md(he) && // do not delay if we're inside an act() scope
          !Bx()) {
            var ve = lS + bx - qn();
            if (ve > 10) {
              var Ce = Vf(re, Zt);
              if (Ce !== Zt)
                break;
              var ke = re.suspendedLanes;
              if (!Nl(ke, he)) {
                Za(), ap(re, ke);
                break;
              }
              re.timeoutHandle = c0(yc.bind(null, re, Co, nu), ve);
              break;
            }
          }
          yc(re, Co, nu);
          break;
        }
        case cm: {
          if (ff(re, he), mv(he))
            break;
          if (!Bx()) {
            var at = pv(re, he), mt = at, gt = qn() - mt, Tt = sP(gt) - gt;
            if (Tt > 10) {
              re.timeoutHandle = c0(yc.bind(null, re, Co, nu), Tt);
              break;
            }
          }
          yc(re, Co, nu);
          break;
        }
        case Ex: {
          yc(re, Co, nu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function HA(re) {
      for (var ie = re; ; ) {
        if (ie.flags & Df) {
          var he = ie.updateQueue;
          if (he !== null) {
            var ve = he.stores;
            if (ve !== null)
              for (var Ce = 0; Ce < ve.length; Ce++) {
                var ke = ve[Ce], at = ke.getSnapshot, mt = ke.value;
                try {
                  if (!Ar(at(), mt))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var gt = ie.child;
        if (ie.subtreeFlags & Df && gt !== null) {
          gt.return = ie, ie = gt;
          continue;
        }
        if (ie === re)
          return !0;
        for (; ie.sibling === null; ) {
          if (ie.return === null || ie.return === re)
            return !0;
          ie = ie.return;
        }
        ie.sibling.return = ie.return, ie = ie.sibling;
      }
      return !0;
    }
    function ff(re, ie) {
      ie = Du(ie, Zy), ie = Du(ie, hm), np(re, ie);
    }
    function Ax(re) {
      if (u_(), (sn & (Sa | Zo)) !== Xi)
        throw new Error("Should not already be working.");
      au();
      var ie = Vf(re, Zt);
      if (!Oa(ie, Br))
        return To(re, qn()), null;
      var he = og(re, ie);
      if (re.tag !== Ku && he === pc) {
        var ve = Zh(re);
        ve !== Zt && (ie = ve, he = pS(re, ve));
      }
      if (he === fm) {
        var Ce = dm;
        throw vc(re, Zt), ff(re, ie), To(re, qn()), Ce;
      }
      if (he === oS)
        throw new Error("Root did not complete. This is a bug in React.");
      var ke = re.current.alternate;
      return re.finishedWork = ke, re.finishedLanes = ie, yc(re, Co, nu), To(re, qn()), null;
    }
    function UA(re, ie) {
      ie !== Zt && (Ou(re, Xr(ie, Br)), To(re, qn()), (sn & (Sa | Zo)) === Xi && (mm(), Ju()));
    }
    function mS(re, ie) {
      var he = sn;
      sn |= Sx;
      try {
        return re(ie);
      } finally {
        sn = he, sn === Xi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ks.isBatchingLegacy && (mm(), xE());
      }
    }
    function jA(re, ie, he, ve, Ce) {
      var ke = vo(), at = ga.transition;
      try {
        return ga.transition = null, _i(ta), re(ie, he, ve, Ce);
      } finally {
        _i(ke), ga.transition = at, sn === Xi && mm();
      }
    }
    function iu(re) {
      lf !== null && lf.tag === Ku && (sn & (Sa | Zo)) === Xi && au();
      var ie = sn;
      sn |= Sx;
      var he = ga.transition, ve = vo();
      try {
        return ga.transition = null, _i(ta), re ? re() : void 0;
      } finally {
        _i(ve), ga.transition = he, sn = ie, (sn & (Sa | Zo)) === Xi && Ju();
      }
    }
    function Px() {
      return (sn & (Sa | Zo)) !== Xi;
    }
    function ag(re, ie) {
      $a(sS, cl, re), cl = Xr(cl, ie);
    }
    function vS(re) {
      cl = sS.current, La(sS, re);
    }
    function vc(re, ie) {
      re.finishedWork = null, re.finishedLanes = Zt;
      var he = re.timeoutHandle;
      if (he !== d0 && (re.timeoutHandle = d0, gT(he)), hi !== null)
        for (var ve = hi.return; ve !== null; ) {
          var Ce = ve.alternate;
          nx(Ce, ve), ve = ve.return;
        }
      Ja = re;
      var ke = gc(re.current, null);
      return hi = ke, Ki = cl = ie, Ji = ru, dm = null, Jy = Zt, hm = Zt, Zy = Zt, pm = null, Co = null, Iw(), xs.discardPendingWarnings(), ke;
    }
    function Rx(re, ie) {
      do {
        var he = hi;
        try {
          if (hy(), ib(), Un(), aS.current = null, he === null || he.return === null) {
            Ji = fm, dm = ie, hi = null;
            return;
          }
          if (Nr && he.mode & Vr && Gy(he, !0), Tr)
            if (Rl(), ie !== null && typeof ie == "object" && typeof ie.then == "function") {
              var ve = ie;
              cv(he, ve, Ki);
            } else
              Xc(he, ie, Ki);
          p_(re, he.return, he, ie, Ki), Dx(he);
        } catch (Ce) {
          ie = Ce, hi === he && he !== null ? (he = he.return, hi = he) : he = hi;
          continue;
        }
        return;
      } while (!0);
    }
    function kx() {
      var re = iS.current;
      return iS.current = Vy, re === null ? Vy : re;
    }
    function Mx(re) {
      iS.current = re;
    }
    function GA() {
      lS = qn();
    }
    function Sm(re) {
      Jy = Xr(re, Jy);
    }
    function WA() {
      Ji === ru && (Ji = Ky);
    }
    function yS() {
      (Ji === ru || Ji === Ky || Ji === pc) && (Ji = cm), Ja !== null && (Bf(Jy) || Bf(hm)) && ff(Ja, Ki);
    }
    function qA(re) {
      Ji !== cm && (Ji = pc), pm === null ? pm = [re] : pm.push(re);
    }
    function YA() {
      return Ji === ru;
    }
    function og(re, ie) {
      var he = sn;
      sn |= Sa;
      var ve = kx();
      if (Ja !== re || Ki !== ie) {
        if (ji) {
          var Ce = re.memoizedUpdaters;
          Ce.size > 0 && (Em(re, Ki), Ce.clear()), gd(re, ie);
        }
        nu = up(), vc(re, ie);
      }
      ko(ie);
      do
        try {
          QA();
          break;
        } catch (ke) {
          Rx(re, ke);
        }
      while (!0);
      if (hy(), sn = he, Mx(ve), hi !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Pu(), Ja = null, Ki = Zt, Ji;
    }
    function QA() {
      for (; hi !== null; )
        Fx(hi);
    }
    function XA(re, ie) {
      var he = sn;
      sn |= Sa;
      var ve = kx();
      if (Ja !== re || Ki !== ie) {
        if (ji) {
          var Ce = re.memoizedUpdaters;
          Ce.size > 0 && (Em(re, Ki), Ce.clear()), gd(re, ie);
        }
        nu = up(), mm(), vc(re, ie);
      }
      ko(ie);
      do
        try {
          KA();
          break;
        } catch (ke) {
          Rx(re, ke);
        }
      while (!0);
      return hy(), Mx(ve), sn = he, hi !== null ? ($f(), ru) : (Pu(), Ja = null, Ki = Zt, Ji);
    }
    function KA() {
      for (; hi !== null && !jc(); )
        Fx(hi);
    }
    function Fx(re) {
      var ie = re.alternate;
      yn(re);
      var he;
      (re.mode & Vr) !== zr ? (F1(re), he = gS(ie, re, cl), Gy(re, !0)) : he = gS(ie, re, cl), Un(), re.memoizedProps = re.pendingProps, he === null ? Dx(re) : hi = he, aS.current = null;
    }
    function Dx(re) {
      var ie = re;
      do {
        var he = ie.alternate, ve = ie.return;
        if ((ie.flags & Ga) === Lr) {
          yn(ie);
          var Ce = void 0;
          if ((ie.mode & Vr) === zr ? Ce = rx(he, ie, cl) : (F1(ie), Ce = rx(he, ie, cl), Gy(ie, !1)), Un(), Ce !== null) {
            hi = Ce;
            return;
          }
        } else {
          var ke = W_(he, ie);
          if (ke !== null) {
            ke.flags &= rv, hi = ke;
            return;
          }
          if ((ie.mode & Vr) !== zr) {
            Gy(ie, !1);
            for (var at = ie.actualDuration, mt = ie.child; mt !== null; )
              at += mt.actualDuration, mt = mt.sibling;
            ie.actualDuration = at;
          }
          if (ve !== null)
            ve.flags |= Ga, ve.subtreeFlags = Lr, ve.deletions = null;
          else {
            Ji = oS, hi = null;
            return;
          }
        }
        var gt = ie.sibling;
        if (gt !== null) {
          hi = gt;
          return;
        }
        ie = ve, hi = ie;
      } while (ie !== null);
      Ji === ru && (Ji = Ex);
    }
    function yc(re, ie, he) {
      var ve = vo(), Ce = ga.transition;
      try {
        ga.transition = null, _i(ta), JA(re, ie, he, ve);
      } finally {
        ga.transition = Ce, _i(ve);
      }
      return null;
    }
    function JA(re, ie, he, ve) {
      do
        au();
      while (lf !== null);
      if (uP(), (sn & (Sa | Zo)) !== Xi)
        throw new Error("Should not already be working.");
      var Ce = re.finishedWork, ke = re.finishedLanes;
      if (qc(ke), Ce === null)
        return Yh(), null;
      if (ke === Zt && be("root.finishedLanes should not be empty during a commit. This is a bug in React."), re.finishedWork = null, re.finishedLanes = Zt, Ce === re.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      re.callbackNode = null, re.callbackPriority = on;
      var at = Xr(Ce.lanes, Ce.childLanes);
      sp(re, at), re === Ja && (Ja = null, hi = null, Ki = Zt), ((Ce.subtreeFlags & co) !== Lr || (Ce.flags & co) !== Lr) && (mc || (mc = !0, cS = he, bS(Uo, function() {
        return au(), null;
      })));
      var mt = (Ce.subtreeFlags & (wu | ka | ea | co)) !== Lr, gt = (Ce.flags & (wu | ka | ea | co)) !== Lr;
      if (mt || gt) {
        var Tt = ga.transition;
        ga.transition = null;
        var Pt = vo();
        _i(ta);
        var Nt = sn;
        sn |= Zo, aS.current = null, K_(re, Ce), kb(), cA(re, Ce, ke), cT(re.containerInfo), re.current = Ce, dv(ke), dA(Ce, re, ke), Au(), av(), sn = Nt, _i(Pt), ga.transition = Tt;
      } else
        re.current = Ce, kb();
      var $t = mc;
      if (mc ? (mc = !1, lf = re, vm = ke) : (sh = 0, rg = null), at = re.pendingLanes, at === Zt && (oh = null), $t || Ix(re.current, !1), ds(Ce.stateNode, ve), ji && re.memoizedUpdaters.clear(), MA(), To(re, qn()), ie !== null)
        for (var Gt = re.onRecoverableError, Wt = 0; Wt < ie.length; Wt++) {
          var Xt = ie[Wt], xr = Xt.stack, Ir = Xt.digest;
          Gt(Xt.value, {
            componentStack: xr,
            digest: Ir
          });
        }
      if (eg) {
        eg = !1;
        var Fr = uS;
        throw uS = null, Fr;
      }
      return Oa(vm, Br) && re.tag !== Ku && au(), at = re.pendingLanes, Oa(at, Br) ? (s_(), re === dS ? ym++ : (ym = 0, dS = re)) : ym = 0, Ju(), Yh(), null;
    }
    function au() {
      if (lf !== null) {
        var re = Gf(vm), ie = $g(ms, re), he = ga.transition, ve = vo();
        try {
          return ga.transition = null, _i(ie), eP();
        } finally {
          _i(ve), ga.transition = he;
        }
      }
      return !1;
    }
    function ZA(re) {
      fS.push(re), mc || (mc = !0, bS(Uo, function() {
        return au(), null;
      }));
    }
    function eP() {
      if (lf === null)
        return !1;
      var re = cS;
      cS = null;
      var ie = lf, he = vm;
      if (lf = null, vm = Zt, (sn & (Sa | Zo)) !== Xi)
        throw new Error("Cannot flush passive effects while already rendering.");
      hS = !0, tg = !1, hv(he);
      var ve = sn;
      sn |= Zo, SA(ie.current), mA(ie, ie.current, he, re);
      {
        var Ce = fS;
        fS = [];
        for (var ke = 0; ke < Ce.length; ke++) {
          var at = Ce[ke];
          tA(ie, at);
        }
      }
      Lf(), Ix(ie.current, !0), sn = ve, Ju(), tg ? ie === rg ? sh++ : (sh = 0, rg = ie) : sh = 0, hS = !1, tg = !1, Gs(ie);
      {
        var mt = ie.current.stateNode;
        mt.effectDuration = 0, mt.passiveEffectDuration = 0;
      }
      return !0;
    }
    function Ox(re) {
      return oh !== null && oh.has(re);
    }
    function tP(re) {
      oh === null ? oh = /* @__PURE__ */ new Set([re]) : oh.add(re);
    }
    function rP(re) {
      eg || (eg = !0, uS = re);
    }
    var nP = rP;
    function Lx(re, ie, he) {
      var ve = dc(he, ie), Ce = Fb(re, ve, Br), ke = ef(re, Ce, Br), at = Za();
      ke !== null && (zl(ke, Br, at), To(ke, at));
    }
    function Nn(re, ie, he) {
      if (Y_(he), bm(!1), re.tag === dt) {
        Lx(re, re, he);
        return;
      }
      var ve = null;
      for (ve = ie; ve !== null; ) {
        if (ve.tag === dt) {
          Lx(ve, re, he);
          return;
        } else if (ve.tag === rt) {
          var Ce = ve.type, ke = ve.stateNode;
          if (typeof Ce.getDerivedStateFromError == "function" || typeof ke.componentDidCatch == "function" && !Ox(ke)) {
            var at = dc(he, re), mt = N1(ve, at, Br), gt = ef(ve, mt, Br), Tt = Za();
            gt !== null && (zl(gt, Br, Tt), To(gt, Tt));
            return;
          }
        }
        ve = ve.return;
      }
      be(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, he);
    }
    function iP(re, ie, he) {
      var ve = re.pingCache;
      ve !== null && ve.delete(ie);
      var Ce = Za();
      ap(re, he), hP(re), Ja === re && Nl(Ki, he) && (Ji === cm || Ji === Ky && md(Ki) && qn() - lS < bx ? vc(re, Zt) : Zy = Xr(Zy, he)), To(re, Ce);
    }
    function $x(re, ie) {
      ie === on && (ie = NA(re));
      var he = Za(), ve = bo(re, ie);
      ve !== null && (zl(ve, ie, he), To(ve, he));
    }
    function aP(re) {
      var ie = re.memoizedState, he = on;
      ie !== null && (he = ie.retryLane), $x(re, he);
    }
    function oP(re, ie) {
      var he = on, ve;
      switch (re.tag) {
        case xt:
          ve = re.stateNode;
          var Ce = re.memoizedState;
          Ce !== null && (he = Ce.retryLane);
          break;
        case er:
          ve = re.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      ve !== null && ve.delete(ie), $x(re, he);
    }
    function sP(re) {
      return re < 120 ? 120 : re < 480 ? 480 : re < 1080 ? 1080 : re < 1920 ? 1920 : re < 3e3 ? 3e3 : re < 4320 ? 4320 : OA(re / 1960) * 1960;
    }
    function lP() {
      if (ym > $A)
        throw ym = 0, dS = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      sh > IA && (sh = 0, rg = null, be("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function uP() {
      xs.flushLegacyContextWarning(), xs.flushPendingUnsafeLifecycleWarnings();
    }
    function Ix(re, ie) {
      yn(re), sg(re, Ra, PA), ie && sg(re, Pl, RA), sg(re, Ra, _A), ie && sg(re, Pl, AA), Un();
    }
    function sg(re, ie, he) {
      for (var ve = re, Ce = null; ve !== null; ) {
        var ke = ve.subtreeFlags & ie;
        ve !== Ce && ve.child !== null && ke !== Lr ? ve = ve.child : ((ve.flags & ie) !== Lr && he(ve), ve.sibling !== null ? ve = ve.sibling : ve = Ce = ve.return);
      }
    }
    var lg = null;
    function Nx(re) {
      {
        if ((sn & Sa) !== Xi || !(re.mode & Zr))
          return;
        var ie = re.tag;
        if (ie !== st && ie !== dt && ie !== rt && ie !== Ae && ie !== ft && ie !== Ct && ie !== At)
          return;
        var he = Wr(re) || "ReactComponent";
        if (lg !== null) {
          if (lg.has(he))
            return;
          lg.add(he);
        } else
          lg = /* @__PURE__ */ new Set([he]);
        var ve = ii;
        try {
          yn(re), be("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          ve ? yn(re) : Un();
        }
      }
    }
    var gS;
    {
      var fP = null;
      gS = function(re, ie, he) {
        var ve = Wx(fP, ie);
        try {
          return Kb(re, ie, he);
        } catch (ke) {
          if (Cw() || ke !== null && typeof ke == "object" && typeof ke.then == "function")
            throw ke;
          if (hy(), ib(), nx(re, ie), Wx(ie, ve), ie.mode & Vr && F1(ie), Al(null, Kb, null, re, ie, he), Rg()) {
            var Ce = Ih();
            typeof Ce == "object" && Ce !== null && Ce._suppressLogging && typeof ke == "object" && ke !== null && !ke._suppressLogging && (ke._suppressLogging = !0);
          }
          throw ke;
        }
      };
    }
    var zx = !1, SS;
    SS = /* @__PURE__ */ new Set();
    function cP(re) {
      if (mi && !i_())
        switch (re.tag) {
          case Ae:
          case ft:
          case At: {
            var ie = hi && Wr(hi) || "Unknown", he = ie;
            if (!SS.has(he)) {
              SS.add(he);
              var ve = Wr(re) || "Unknown";
              be("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", ve, ie, ie);
            }
            break;
          }
          case rt: {
            zx || (be("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), zx = !0);
            break;
          }
        }
    }
    function Em(re, ie) {
      if (ji) {
        var he = re.memoizedUpdaters;
        he.forEach(function(ve) {
          lp(re, ve, ie);
        });
      }
    }
    var ES = {};
    function bS(re, ie) {
      {
        var he = ks.current;
        return he !== null ? (he.push(ie), ES) : Uc(re, ie);
      }
    }
    function Vx(re) {
      if (re !== ES)
        return iv(re);
    }
    function Bx() {
      return ks.current !== null;
    }
    function dP(re) {
      {
        if (re.mode & Zr) {
          if (!gx())
            return;
        } else if (!DA() || sn !== Xi || re.tag !== Ae && re.tag !== ft && re.tag !== At)
          return;
        if (ks.current === null) {
          var ie = ii;
          try {
            yn(re), be(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Wr(re));
          } finally {
            ie ? yn(re) : Un();
          }
        }
      }
    }
    function hP(re) {
      re.tag !== Ku && gx() && ks.current === null && be(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function bm(re) {
      Tx = re;
    }
    var es = null, lh = null, pP = function(re) {
      es = re;
    };
    function uh(re) {
      {
        if (es === null)
          return re;
        var ie = es(re);
        return ie === void 0 ? re : ie.current;
      }
    }
    function xS(re) {
      return uh(re);
    }
    function CS(re) {
      {
        if (es === null)
          return re;
        var ie = es(re);
        if (ie === void 0) {
          if (re != null && typeof re.render == "function") {
            var he = uh(re.render);
            if (re.render !== he) {
              var ve = {
                $$typeof: Ds,
                render: he
              };
              return re.displayName !== void 0 && (ve.displayName = re.displayName), ve;
            }
          }
          return re;
        }
        return ie.current;
      }
    }
    function Hx(re, ie) {
      {
        if (es === null)
          return !1;
        var he = re.elementType, ve = ie.type, Ce = !1, ke = typeof ve == "object" && ve !== null ? ve.$$typeof : null;
        switch (re.tag) {
          case rt: {
            typeof ve == "function" && (Ce = !0);
            break;
          }
          case Ae: {
            (typeof ve == "function" || ke === Hi) && (Ce = !0);
            break;
          }
          case ft: {
            (ke === Ds || ke === Hi) && (Ce = !0);
            break;
          }
          case Ct:
          case At: {
            (ke === Os || ke === Hi) && (Ce = !0);
            break;
          }
          default:
            return !1;
        }
        if (Ce) {
          var at = es(he);
          if (at !== void 0 && at === es(ve))
            return !0;
        }
        return !1;
      }
    }
    function Ux(re) {
      {
        if (es === null || typeof WeakSet != "function")
          return;
        lh === null && (lh = /* @__PURE__ */ new WeakSet()), lh.add(re);
      }
    }
    var mP = function(re, ie) {
      {
        if (es === null)
          return;
        var he = ie.staleFamilies, ve = ie.updatedFamilies;
        au(), iu(function() {
          TS(re.current, ve, he);
        });
      }
    }, vP = function(re, ie) {
      {
        if (re.context !== Fo)
          return;
        au(), iu(function() {
          xm(ie, re, null, null);
        });
      }
    };
    function TS(re, ie, he) {
      {
        var ve = re.alternate, Ce = re.child, ke = re.sibling, at = re.tag, mt = re.type, gt = null;
        switch (at) {
          case Ae:
          case At:
          case rt:
            gt = mt;
            break;
          case ft:
            gt = mt.render;
            break;
        }
        if (es === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Tt = !1, Pt = !1;
        if (gt !== null) {
          var Nt = es(gt);
          Nt !== void 0 && (he.has(Nt) ? Pt = !0 : ie.has(Nt) && (at === rt ? Pt = !0 : Tt = !0));
        }
        if (lh !== null && (lh.has(re) || ve !== null && lh.has(ve)) && (Pt = !0), Pt && (re._debugNeedsRemount = !0), Pt || Tt) {
          var $t = bo(re, Br);
          $t !== null && Zi($t, re, Br, Rn);
        }
        Ce !== null && !Pt && TS(Ce, ie, he), ke !== null && TS(ke, ie, he);
      }
    }
    var yP = function(re, ie) {
      {
        var he = /* @__PURE__ */ new Set(), ve = new Set(ie.map(function(Ce) {
          return Ce.current;
        }));
        return wS(re.current, ve, he), he;
      }
    };
    function wS(re, ie, he) {
      {
        var ve = re.child, Ce = re.sibling, ke = re.tag, at = re.type, mt = null;
        switch (ke) {
          case Ae:
          case At:
          case rt:
            mt = at;
            break;
          case ft:
            mt = at.render;
            break;
        }
        var gt = !1;
        mt !== null && ie.has(mt) && (gt = !0), gt ? gP(re, he) : ve !== null && wS(ve, ie, he), Ce !== null && wS(Ce, ie, he);
      }
    }
    function gP(re, ie) {
      {
        var he = SP(re, ie);
        if (he)
          return;
        for (var ve = re; ; ) {
          switch (ve.tag) {
            case ht:
              ie.add(ve.stateNode);
              return;
            case ut:
              ie.add(ve.stateNode.containerInfo);
              return;
            case dt:
              ie.add(ve.stateNode.containerInfo);
              return;
          }
          if (ve.return === null)
            throw new Error("Expected to reach root first.");
          ve = ve.return;
        }
      }
    }
    function SP(re, ie) {
      for (var he = re, ve = !1; ; ) {
        if (he.tag === ht)
          ve = !0, ie.add(he.stateNode);
        else if (he.child !== null) {
          he.child.return = he, he = he.child;
          continue;
        }
        if (he === re)
          return ve;
        for (; he.sibling === null; ) {
          if (he.return === null || he.return === re)
            return ve;
          he = he.return;
        }
        he.sibling.return = he.return, he = he.sibling;
      }
      return !1;
    }
    var _S;
    {
      _S = !1;
      try {
        var jx = Object.preventExtensions({});
      } catch {
        _S = !0;
      }
    }
    function EP(re, ie, he, ve) {
      this.tag = re, this.key = he, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = ie, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = ve, this.flags = Lr, this.subtreeFlags = Lr, this.deletions = null, this.lanes = Zt, this.childLanes = Zt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !_S && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Do = function(re, ie, he, ve) {
      return new EP(re, ie, he, ve);
    };
    function AS(re) {
      var ie = re.prototype;
      return !!(ie && ie.isReactComponent);
    }
    function bP(re) {
      return typeof re == "function" && !AS(re) && re.defaultProps === void 0;
    }
    function xP(re) {
      if (typeof re == "function")
        return AS(re) ? rt : Ae;
      if (re != null) {
        var ie = re.$$typeof;
        if (ie === Ds)
          return ft;
        if (ie === Os)
          return Ct;
      }
      return st;
    }
    function gc(re, ie) {
      var he = re.alternate;
      he === null ? (he = Do(re.tag, ie, re.key, re.mode), he.elementType = re.elementType, he.type = re.type, he.stateNode = re.stateNode, he._debugSource = re._debugSource, he._debugOwner = re._debugOwner, he._debugHookTypes = re._debugHookTypes, he.alternate = re, re.alternate = he) : (he.pendingProps = ie, he.type = re.type, he.flags = Lr, he.subtreeFlags = Lr, he.deletions = null, he.actualDuration = 0, he.actualStartTime = -1), he.flags = re.flags & Ui, he.childLanes = re.childLanes, he.lanes = re.lanes, he.child = re.child, he.memoizedProps = re.memoizedProps, he.memoizedState = re.memoizedState, he.updateQueue = re.updateQueue;
      var ve = re.dependencies;
      switch (he.dependencies = ve === null ? null : {
        lanes: ve.lanes,
        firstContext: ve.firstContext
      }, he.sibling = re.sibling, he.index = re.index, he.ref = re.ref, he.selfBaseDuration = re.selfBaseDuration, he.treeBaseDuration = re.treeBaseDuration, he._debugNeedsRemount = re._debugNeedsRemount, he.tag) {
        case st:
        case Ae:
        case At:
          he.type = uh(re.type);
          break;
        case rt:
          he.type = xS(re.type);
          break;
        case ft:
          he.type = CS(re.type);
          break;
      }
      return he;
    }
    function CP(re, ie) {
      re.flags &= Ui | On;
      var he = re.alternate;
      if (he === null)
        re.childLanes = Zt, re.lanes = ie, re.child = null, re.subtreeFlags = Lr, re.memoizedProps = null, re.memoizedState = null, re.updateQueue = null, re.dependencies = null, re.stateNode = null, re.selfBaseDuration = 0, re.treeBaseDuration = 0;
      else {
        re.childLanes = he.childLanes, re.lanes = he.lanes, re.child = he.child, re.subtreeFlags = Lr, re.deletions = null, re.memoizedProps = he.memoizedProps, re.memoizedState = he.memoizedState, re.updateQueue = he.updateQueue, re.type = he.type;
        var ve = he.dependencies;
        re.dependencies = ve === null ? null : {
          lanes: ve.lanes,
          firstContext: ve.firstContext
        }, re.selfBaseDuration = he.selfBaseDuration, re.treeBaseDuration = he.treeBaseDuration;
      }
      return re;
    }
    function TP(re, ie, he) {
      var ve;
      return re === ay ? (ve = Zr, ie === !0 && (ve |= Yn, ve |= po)) : ve = zr, ji && (ve |= Vr), Do(dt, null, null, ve);
    }
    function PS(re, ie, he, ve, Ce, ke) {
      var at = st, mt = re;
      if (typeof re == "function")
        AS(re) ? (at = rt, mt = xS(mt)) : mt = uh(mt);
      else if (typeof re == "string")
        at = ht;
      else
        e:
          switch (re) {
            case Ha:
              return cf(he.children, Ce, ke, ie);
            case Ca:
              at = St, Ce |= Yn, (Ce & Zr) !== zr && (Ce |= po);
              break;
            case pl:
              return wP(he, Ce, ke, ie);
            case ro:
              return _P(he, Ce, ke, ie);
            case sa:
              return AP(he, Ce, ke, ie);
            case mf:
              return Gx(he, Ce, ke, ie);
            case Io:
            case Sc:
            case ch:
            case dh:
            case Ec:
            default: {
              if (typeof re == "object" && re !== null)
                switch (re.$$typeof) {
                  case hf:
                    at = pt;
                    break e;
                  case pf:
                    at = ot;
                    break e;
                  case Ds:
                    at = ft, mt = CS(mt);
                    break e;
                  case Os:
                    at = Ct;
                    break e;
                  case Hi:
                    at = kt, mt = null;
                    break e;
                }
              var gt = "";
              {
                (re === void 0 || typeof re == "object" && re !== null && Object.keys(re).length === 0) && (gt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Tt = ve ? Wr(ve) : null;
                Tt && (gt += `

Check the render method of \`` + Tt + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (re == null ? re : typeof re) + "." + gt));
            }
          }
      var Pt = Do(at, he, ie, Ce);
      return Pt.elementType = re, Pt.type = mt, Pt.lanes = ke, Pt._debugOwner = ve, Pt;
    }
    function RS(re, ie, he) {
      var ve = null;
      ve = re._owner;
      var Ce = re.type, ke = re.key, at = re.props, mt = PS(Ce, ke, at, ve, ie, he);
      return mt._debugSource = re._source, mt._debugOwner = re._owner, mt;
    }
    function cf(re, ie, he, ve) {
      var Ce = Do(lt, re, ve, ie);
      return Ce.lanes = he, Ce;
    }
    function wP(re, ie, he, ve) {
      typeof re.id != "string" && be('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof re.id);
      var Ce = Do(vt, re, ve, ie | Vr);
      return Ce.elementType = pl, Ce.lanes = he, Ce.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, Ce;
    }
    function _P(re, ie, he, ve) {
      var Ce = Do(xt, re, ve, ie);
      return Ce.elementType = ro, Ce.lanes = he, Ce;
    }
    function AP(re, ie, he, ve) {
      var Ce = Do(er, re, ve, ie);
      return Ce.elementType = sa, Ce.lanes = he, Ce;
    }
    function Gx(re, ie, he, ve) {
      var Ce = Do(Jt, re, ve, ie);
      Ce.elementType = mf, Ce.lanes = he;
      var ke = {
        isHidden: !1
      };
      return Ce.stateNode = ke, Ce;
    }
    function kS(re, ie, he) {
      var ve = Do(it, re, null, ie);
      return ve.lanes = he, ve;
    }
    function PP() {
      var re = Do(ht, null, null, zr);
      return re.elementType = "DELETED", re;
    }
    function RP(re) {
      var ie = Do(ir, null, null, zr);
      return ie.stateNode = re, ie;
    }
    function MS(re, ie, he) {
      var ve = re.children !== null ? re.children : [], Ce = Do(ut, ve, re.key, ie);
      return Ce.lanes = he, Ce.stateNode = {
        containerInfo: re.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: re.implementation
      }, Ce;
    }
    function Wx(re, ie) {
      return re === null && (re = Do(st, null, null, zr)), re.tag = ie.tag, re.key = ie.key, re.elementType = ie.elementType, re.type = ie.type, re.stateNode = ie.stateNode, re.return = ie.return, re.child = ie.child, re.sibling = ie.sibling, re.index = ie.index, re.ref = ie.ref, re.pendingProps = ie.pendingProps, re.memoizedProps = ie.memoizedProps, re.updateQueue = ie.updateQueue, re.memoizedState = ie.memoizedState, re.dependencies = ie.dependencies, re.mode = ie.mode, re.flags = ie.flags, re.subtreeFlags = ie.subtreeFlags, re.deletions = ie.deletions, re.lanes = ie.lanes, re.childLanes = ie.childLanes, re.alternate = ie.alternate, re.actualDuration = ie.actualDuration, re.actualStartTime = ie.actualStartTime, re.selfBaseDuration = ie.selfBaseDuration, re.treeBaseDuration = ie.treeBaseDuration, re._debugSource = ie._debugSource, re._debugOwner = ie._debugOwner, re._debugNeedsRemount = ie._debugNeedsRemount, re._debugHookTypes = ie._debugHookTypes, re;
    }
    function kP(re, ie, he, ve, Ce) {
      this.tag = ie, this.containerInfo = re, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = d0, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = on, this.eventTimes = yd(Zt), this.expirationTimes = yd(Rn), this.pendingLanes = Zt, this.suspendedLanes = Zt, this.pingedLanes = Zt, this.expiredLanes = Zt, this.mutableReadLanes = Zt, this.finishedLanes = Zt, this.entangledLanes = Zt, this.entanglements = yd(Zt), this.identifierPrefix = ve, this.onRecoverableError = Ce, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var ke = this.pendingUpdatersLaneMap = [], at = 0; at < $n; at++)
          ke.push(/* @__PURE__ */ new Set());
      }
      switch (ie) {
        case ay:
          this._debugRootType = he ? "hydrateRoot()" : "createRoot()";
          break;
        case Ku:
          this._debugRootType = he ? "hydrate()" : "render()";
          break;
      }
    }
    function qx(re, ie, he, ve, Ce, ke, at, mt, gt, Tt) {
      var Pt = new kP(re, ie, he, mt, gt), Nt = TP(ie, ke);
      Pt.current = Nt, Nt.stateNode = Pt;
      {
        var $t = {
          element: ve,
          isDehydrated: he,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Nt.memoizedState = $t;
      }
      return z0(Nt), Pt;
    }
    var FS = "18.2.0";
    function MP(re, ie, he) {
      var ve = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return ki(ve), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: xa,
        key: ve == null ? null : "" + ve,
        children: re,
        containerInfo: ie,
        implementation: he
      };
    }
    var DS, OS;
    DS = !1, OS = {};
    function Yx(re) {
      if (!re)
        return Fo;
      var ie = lo(re), he = pw(ie);
      if (ie.tag === rt) {
        var ve = ie.type;
        if (il(ve))
          return SE(ie, ve, he);
      }
      return he;
    }
    function FP(re, ie) {
      {
        var he = lo(re);
        if (he === void 0) {
          if (typeof re.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var ve = Object.keys(re).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + ve);
        }
        var Ce = ho(he);
        if (Ce === null)
          return null;
        if (Ce.mode & Yn) {
          var ke = Wr(he) || "Component";
          if (!OS[ke]) {
            OS[ke] = !0;
            var at = ii;
            try {
              yn(Ce), he.mode & Yn ? be("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ie, ie, ke) : be("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ie, ie, ke);
            } finally {
              at ? yn(at) : Un();
            }
          }
        }
        return Ce.stateNode;
      }
    }
    function Qx(re, ie, he, ve, Ce, ke, at, mt) {
      var gt = !1, Tt = null;
      return qx(re, ie, gt, Tt, he, ve, Ce, ke, at);
    }
    function Xx(re, ie, he, ve, Ce, ke, at, mt, gt, Tt) {
      var Pt = !0, Nt = qx(he, ve, Pt, re, Ce, ke, at, mt, gt);
      Nt.context = Yx(null);
      var $t = Nt.current, Gt = Za(), Wt = uf($t), Xt = eu(Gt, Wt);
      return Xt.callback = ie ?? null, ef($t, Xt, Wt), zA(Nt, Wt, Gt), Nt;
    }
    function xm(re, ie, he, ve) {
      ov(ie, re);
      var Ce = ie.current, ke = Za(), at = uf(Ce);
      kl(at);
      var mt = Yx(he);
      ie.context === null ? ie.context = mt : ie.pendingContext = mt, mi && ii !== null && !DS && (DS = !0, be(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Wr(ii) || "Unknown"));
      var gt = eu(ke, at);
      gt.payload = {
        element: re
      }, ve = ve === void 0 ? null : ve, ve !== null && (typeof ve != "function" && be("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve), gt.callback = ve);
      var Tt = ef(Ce, gt, at);
      return Tt !== null && (Zi(Tt, Ce, at, ke), gy(Tt, Ce, at)), at;
    }
    function ug(re) {
      var ie = re.current;
      if (!ie.child)
        return null;
      switch (ie.child.tag) {
        case ht:
          return ie.child.stateNode;
        default:
          return ie.child.stateNode;
      }
    }
    function DP(re) {
      switch (re.tag) {
        case dt: {
          var ie = re.stateNode;
          if (Ai(ie)) {
            var he = Fg(ie);
            UA(ie, he);
          }
          break;
        }
        case xt: {
          iu(function() {
            var Ce = bo(re, Br);
            if (Ce !== null) {
              var ke = Za();
              Zi(Ce, re, Br, ke);
            }
          });
          var ve = Br;
          LS(re, ve);
          break;
        }
      }
    }
    function Kx(re, ie) {
      var he = re.memoizedState;
      he !== null && he.dehydrated !== null && (he.retryLane = gv(he.retryLane, ie));
    }
    function LS(re, ie) {
      Kx(re, ie);
      var he = re.alternate;
      he && Kx(he, ie);
    }
    function OP(re) {
      if (re.tag === xt) {
        var ie = Ru, he = bo(re, ie);
        if (he !== null) {
          var ve = Za();
          Zi(he, re, ie, ve);
        }
        LS(re, ie);
      }
    }
    function LP(re) {
      if (re.tag === xt) {
        var ie = uf(re), he = bo(re, ie);
        if (he !== null) {
          var ve = Za();
          Zi(he, re, ie, ve);
        }
        LS(re, ie);
      }
    }
    function Jx(re) {
      var ie = nv(re);
      return ie === null ? null : ie.stateNode;
    }
    var Zx = function(re) {
      return null;
    };
    function $P(re) {
      return Zx(re);
    }
    var eC = function(re) {
      return !1;
    };
    function IP(re) {
      return eC(re);
    }
    var tC = null, rC = null, nC = null, iC = null, aC = null, oC = null, sC = null, lC = null, uC = null;
    {
      var fC = function(re, ie, he) {
        var ve = ie[he], Ce = Oi(re) ? re.slice() : Kr({}, re);
        return he + 1 === ie.length ? (Oi(Ce) ? Ce.splice(ve, 1) : delete Ce[ve], Ce) : (Ce[ve] = fC(re[ve], ie, he + 1), Ce);
      }, cC = function(re, ie) {
        return fC(re, ie, 0);
      }, dC = function(re, ie, he, ve) {
        var Ce = ie[ve], ke = Oi(re) ? re.slice() : Kr({}, re);
        if (ve + 1 === ie.length) {
          var at = he[ve];
          ke[at] = ke[Ce], Oi(ke) ? ke.splice(Ce, 1) : delete ke[Ce];
        } else
          ke[Ce] = dC(
            // $FlowFixMe number or string is fine here
            re[Ce],
            ie,
            he,
            ve + 1
          );
        return ke;
      }, hC = function(re, ie, he) {
        if (ie.length !== he.length) {
          ge("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var ve = 0; ve < he.length - 1; ve++)
            if (ie[ve] !== he[ve]) {
              ge("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return dC(re, ie, he, 0);
      }, pC = function(re, ie, he, ve) {
        if (he >= ie.length)
          return ve;
        var Ce = ie[he], ke = Oi(re) ? re.slice() : Kr({}, re);
        return ke[Ce] = pC(re[Ce], ie, he + 1, ve), ke;
      }, mC = function(re, ie, he) {
        return pC(re, ie, 0, he);
      }, $S = function(re, ie) {
        for (var he = re.memoizedState; he !== null && ie > 0; )
          he = he.next, ie--;
        return he;
      };
      tC = function(re, ie, he, ve) {
        var Ce = $S(re, ie);
        if (Ce !== null) {
          var ke = mC(Ce.memoizedState, he, ve);
          Ce.memoizedState = ke, Ce.baseState = ke, re.memoizedProps = Kr({}, re.memoizedProps);
          var at = bo(re, Br);
          at !== null && Zi(at, re, Br, Rn);
        }
      }, rC = function(re, ie, he) {
        var ve = $S(re, ie);
        if (ve !== null) {
          var Ce = cC(ve.memoizedState, he);
          ve.memoizedState = Ce, ve.baseState = Ce, re.memoizedProps = Kr({}, re.memoizedProps);
          var ke = bo(re, Br);
          ke !== null && Zi(ke, re, Br, Rn);
        }
      }, nC = function(re, ie, he, ve) {
        var Ce = $S(re, ie);
        if (Ce !== null) {
          var ke = hC(Ce.memoizedState, he, ve);
          Ce.memoizedState = ke, Ce.baseState = ke, re.memoizedProps = Kr({}, re.memoizedProps);
          var at = bo(re, Br);
          at !== null && Zi(at, re, Br, Rn);
        }
      }, iC = function(re, ie, he) {
        re.pendingProps = mC(re.memoizedProps, ie, he), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var ve = bo(re, Br);
        ve !== null && Zi(ve, re, Br, Rn);
      }, aC = function(re, ie) {
        re.pendingProps = cC(re.memoizedProps, ie), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var he = bo(re, Br);
        he !== null && Zi(he, re, Br, Rn);
      }, oC = function(re, ie, he) {
        re.pendingProps = hC(re.memoizedProps, ie, he), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var ve = bo(re, Br);
        ve !== null && Zi(ve, re, Br, Rn);
      }, sC = function(re) {
        var ie = bo(re, Br);
        ie !== null && Zi(ie, re, Br, Rn);
      }, lC = function(re) {
        Zx = re;
      }, uC = function(re) {
        eC = re;
      };
    }
    function NP(re) {
      var ie = ho(re);
      return ie === null ? null : ie.stateNode;
    }
    function zP(re) {
      return null;
    }
    function VP() {
      return ii;
    }
    function BP(re) {
      var ie = re.findFiberByHostInstance, he = oe.ReactCurrentDispatcher;
      return Wh({
        bundleType: re.bundleType,
        version: re.version,
        rendererPackageName: re.rendererPackageName,
        rendererConfig: re.rendererConfig,
        overrideHookState: tC,
        overrideHookStateDeletePath: rC,
        overrideHookStateRenamePath: nC,
        overrideProps: iC,
        overridePropsDeletePath: aC,
        overridePropsRenamePath: oC,
        setErrorHandler: lC,
        setSuspenseHandler: uC,
        scheduleUpdate: sC,
        currentDispatcherRef: he,
        findHostInstanceByFiber: NP,
        findFiberByHostInstance: ie || zP,
        // React Refresh
        findHostInstancesForRefresh: yP,
        scheduleRefresh: mP,
        scheduleRoot: vP,
        setRefreshHandler: pP,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: VP,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: FS
      });
    }
    var vC = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(re) {
      console.error(re);
    };
    function IS(re) {
      this._internalRoot = re;
    }
    fg.prototype.render = IS.prototype.render = function(re) {
      var ie = this._internalRoot;
      if (ie === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? be("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : cg(arguments[1]) ? be("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && be("You passed a second argument to root.render(...) but it only accepts one argument.");
        var he = ie.containerInfo;
        if (he.nodeType !== vi) {
          var ve = Jx(ie.current);
          ve && ve.parentNode !== he && be("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      xm(re, ie, null, null);
    }, fg.prototype.unmount = IS.prototype.unmount = function() {
      typeof arguments[0] == "function" && be("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var re = this._internalRoot;
      if (re !== null) {
        this._internalRoot = null;
        var ie = re.containerInfo;
        Px() && be("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), iu(function() {
          xm(null, re, null, null);
        }), pE(ie);
      }
    };
    function HP(re, ie) {
      if (!cg(re))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      yC(re);
      var he = !1, ve = !1, Ce = "", ke = vC;
      ie != null && (ie.hydrate ? ge("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof ie == "object" && ie !== null && ie.$$typeof === Fs && be(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), ie.unstable_strictMode === !0 && (he = !0), ie.identifierPrefix !== void 0 && (Ce = ie.identifierPrefix), ie.onRecoverableError !== void 0 && (ke = ie.onRecoverableError), ie.transitionCallbacks !== void 0 && ie.transitionCallbacks);
      var at = Qx(re, ay, null, he, ve, Ce, ke);
      Jv(at.current, re);
      var mt = re.nodeType === vi ? re.parentNode : re;
      return Rp(mt), new IS(at);
    }
    function fg(re) {
      this._internalRoot = re;
    }
    function UP(re) {
      re && _v(re);
    }
    fg.prototype.unstable_scheduleHydration = UP;
    function jP(re, ie, he) {
      if (!cg(re))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      yC(re), ie === void 0 && be("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var ve = he ?? null, Ce = he != null && he.hydratedSources || null, ke = !1, at = !1, mt = "", gt = vC;
      he != null && (he.unstable_strictMode === !0 && (ke = !0), he.identifierPrefix !== void 0 && (mt = he.identifierPrefix), he.onRecoverableError !== void 0 && (gt = he.onRecoverableError));
      var Tt = Xx(ie, null, re, ay, ve, ke, at, mt, gt);
      if (Jv(Tt.current, re), Rp(re), Ce)
        for (var Pt = 0; Pt < Ce.length; Pt++) {
          var Nt = Ce[Pt];
          Jw(Tt, Nt);
        }
      return new fg(Tt);
    }
    function cg(re) {
      return !!(re && (re.nodeType === _a || re.nodeType === Ao || re.nodeType === bl || !nr));
    }
    function Cm(re) {
      return !!(re && (re.nodeType === _a || re.nodeType === Ao || re.nodeType === bl || re.nodeType === vi && re.nodeValue === " react-mount-point-unstable "));
    }
    function yC(re) {
      re.nodeType === _a && re.tagName && re.tagName.toUpperCase() === "BODY" && be("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Vp(re) && (re._reactRootContainer ? be("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : be("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var GP = oe.ReactCurrentOwner, gC;
    gC = function(re) {
      if (re._reactRootContainer && re.nodeType !== vi) {
        var ie = Jx(re._reactRootContainer.current);
        ie && ie.parentNode !== re && be("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var he = !!re._reactRootContainer, ve = NS(re), Ce = !!(ve && Qu(ve));
      Ce && !he && be("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), re.nodeType === _a && re.tagName && re.tagName.toUpperCase() === "BODY" && be("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function NS(re) {
      return re ? re.nodeType === Ao ? re.documentElement : re.firstChild : null;
    }
    function SC() {
    }
    function WP(re, ie, he, ve, Ce) {
      if (Ce) {
        if (typeof ve == "function") {
          var ke = ve;
          ve = function() {
            var $t = ug(at);
            ke.call($t);
          };
        }
        var at = Xx(
          ie,
          ve,
          re,
          Ku,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          SC
        );
        re._reactRootContainer = at, Jv(at.current, re);
        var mt = re.nodeType === vi ? re.parentNode : re;
        return Rp(mt), iu(), at;
      } else {
        for (var gt; gt = re.lastChild; )
          re.removeChild(gt);
        if (typeof ve == "function") {
          var Tt = ve;
          ve = function() {
            var $t = ug(Pt);
            Tt.call($t);
          };
        }
        var Pt = Qx(
          re,
          Ku,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          SC
        );
        re._reactRootContainer = Pt, Jv(Pt.current, re);
        var Nt = re.nodeType === vi ? re.parentNode : re;
        return Rp(Nt), iu(function() {
          xm(ie, Pt, he, ve);
        }), Pt;
      }
    }
    function qP(re, ie) {
      re !== null && typeof re != "function" && be("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ie, re);
    }
    function dg(re, ie, he, ve, Ce) {
      gC(he), qP(Ce === void 0 ? null : Ce, "render");
      var ke = he._reactRootContainer, at;
      if (!ke)
        at = WP(he, ie, re, Ce, ve);
      else {
        if (at = ke, typeof Ce == "function") {
          var mt = Ce;
          Ce = function() {
            var gt = ug(at);
            mt.call(gt);
          };
        }
        xm(ie, at, re, Ce);
      }
      return ug(at);
    }
    function YP(re) {
      {
        var ie = GP.current;
        if (ie !== null && ie.stateNode !== null) {
          var he = ie.stateNode._warnedAboutRefsInRender;
          he || be("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", an(ie.type) || "A component"), ie.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return re == null ? null : re.nodeType === _a ? re : FP(re, "findDOMNode");
    }
    function QP(re, ie, he) {
      if (be("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Cm(ie))
        throw new Error("Target container is not a DOM element.");
      {
        var ve = Vp(ie) && ie._reactRootContainer === void 0;
        ve && be("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return dg(null, re, ie, !0, he);
    }
    function XP(re, ie, he) {
      if (be("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Cm(ie))
        throw new Error("Target container is not a DOM element.");
      {
        var ve = Vp(ie) && ie._reactRootContainer === void 0;
        ve && be("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return dg(null, re, ie, !1, he);
    }
    function KP(re, ie, he, ve) {
      if (be("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Cm(he))
        throw new Error("Target container is not a DOM element.");
      if (re == null || !Ff(re))
        throw new Error("parentComponent must be a valid React Component");
      return dg(re, ie, he, !1, ve);
    }
    function JP(re) {
      if (!Cm(re))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var ie = Vp(re) && re._reactRootContainer === void 0;
        ie && be("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (re._reactRootContainer) {
        {
          var he = NS(re), ve = he && !Qu(he);
          ve && be("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return iu(function() {
          dg(null, null, re, !1, function() {
            re._reactRootContainer = null, pE(re);
          });
        }), !0;
      } else {
        {
          var Ce = NS(re), ke = !!(Ce && Qu(Ce)), at = re.nodeType === _a && Cm(re.parentNode) && !!re.parentNode._reactRootContainer;
          ke && be("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", at ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    wr(DP), Ev(OP), qf(LP), cp(vo), xv(jf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && be("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), ev(tT), Nc(mS, jA, iu);
    function ZP(re, ie) {
      var he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!cg(ie))
        throw new Error("Target container is not a DOM element.");
      return MP(re, ie, null, he);
    }
    function eR(re, ie, he, ve) {
      return KP(re, ie, he, ve);
    }
    var zS = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Qu, Vd, Zv, Ic, Rf, mS]
    };
    function tR(re, ie) {
      return zS.usingClientEntryPoint || be('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), HP(re, ie);
    }
    function rR(re, ie, he) {
      return zS.usingClientEntryPoint || be('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), jP(re, ie, he);
    }
    function nR(re) {
      return Px() && be("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), iu(re);
    }
    var iR = BP({
      findFiberByHostInstance: nc,
      bundleType: 1,
      version: FS,
      rendererPackageName: "react-dom"
    });
    if (!iR && kr && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var EC = window.location.protocol;
      /^(https?|file):$/.test(EC) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (EC === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = zS, reactDom_development.createPortal = ZP, reactDom_development.createRoot = tR, reactDom_development.findDOMNode = YP, reactDom_development.flushSync = nR, reactDom_development.hydrate = QP, reactDom_development.hydrateRoot = rR, reactDom_development.render = XP, reactDom_development.unmountComponentAtNode = JP, reactDom_development.unstable_batchedUpdates = mS, reactDom_development.unstable_renderSubtreeIntoContainer = eR, reactDom_development.version = FS, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), reactDom_development;
}
var reactDom_production_min = {};
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min)
    return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var L = React__default, ne = requireScheduler();
  function oe(fe) {
    for (var ce = "https://reactjs.org/docs/error-decoder.html?invariant=" + fe, Ee = 1; Ee < arguments.length; Ee++)
      ce += "&args[]=" + encodeURIComponent(arguments[Ee]);
    return "Minified React error #" + fe + "; visit " + ce + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var pe = /* @__PURE__ */ new Set(), me = {};
  function ge(fe, ce) {
    be(fe, ce), be(fe + "Capture", ce);
  }
  function be(fe, ce) {
    for (me[fe] = ce, fe = 0; fe < ce.length; fe++)
      pe.add(ce[fe]);
  }
  var Ie = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Ae = Object.prototype.hasOwnProperty, rt = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, st = {}, dt = {};
  function ut(fe) {
    return Ae.call(dt, fe) ? !0 : Ae.call(st, fe) ? !1 : rt.test(fe) ? dt[fe] = !0 : (st[fe] = !0, !1);
  }
  function ht(fe, ce, Ee, Te) {
    if (Ee !== null && Ee.type === 0)
      return !1;
    switch (typeof ce) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return Te ? !1 : Ee !== null ? !Ee.acceptsBooleans : (fe = fe.toLowerCase().slice(0, 5), fe !== "data-" && fe !== "aria-");
      default:
        return !1;
    }
  }
  function it(fe, ce, Ee, Te) {
    if (ce === null || typeof ce > "u" || ht(fe, ce, Ee, Te))
      return !0;
    if (Te)
      return !1;
    if (Ee !== null)
      switch (Ee.type) {
        case 3:
          return !ce;
        case 4:
          return ce === !1;
        case 5:
          return isNaN(ce);
        case 6:
          return isNaN(ce) || 1 > ce;
      }
    return !1;
  }
  function lt(fe, ce, Ee, Te, nt, ct, bt) {
    this.acceptsBooleans = ce === 2 || ce === 3 || ce === 4, this.attributeName = Te, this.attributeNamespace = nt, this.mustUseProperty = Ee, this.propertyName = fe, this.type = ce, this.sanitizeURL = ct, this.removeEmptyString = bt;
  }
  var St = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(fe) {
    St[fe] = new lt(fe, 0, !1, fe, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(fe) {
    var ce = fe[0];
    St[ce] = new lt(ce, 1, !1, fe[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(fe) {
    St[fe] = new lt(fe, 2, !1, fe.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(fe) {
    St[fe] = new lt(fe, 2, !1, fe, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(fe) {
    St[fe] = new lt(fe, 3, !1, fe.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(fe) {
    St[fe] = new lt(fe, 3, !0, fe, null, !1, !1);
  }), ["capture", "download"].forEach(function(fe) {
    St[fe] = new lt(fe, 4, !1, fe, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(fe) {
    St[fe] = new lt(fe, 6, !1, fe, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(fe) {
    St[fe] = new lt(fe, 5, !1, fe.toLowerCase(), null, !1, !1);
  });
  var ot = /[\-:]([a-z])/g;
  function pt(fe) {
    return fe[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(fe) {
    var ce = fe.replace(
      ot,
      pt
    );
    St[ce] = new lt(ce, 1, !1, fe, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(fe) {
    var ce = fe.replace(ot, pt);
    St[ce] = new lt(ce, 1, !1, fe, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(fe) {
    var ce = fe.replace(ot, pt);
    St[ce] = new lt(ce, 1, !1, fe, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(fe) {
    St[fe] = new lt(fe, 1, !1, fe.toLowerCase(), null, !1, !1);
  }), St.xlinkHref = new lt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(fe) {
    St[fe] = new lt(fe, 1, !1, fe.toLowerCase(), null, !0, !0);
  });
  function ft(fe, ce, Ee, Te) {
    var nt = St.hasOwnProperty(ce) ? St[ce] : null;
    (nt !== null ? nt.type !== 0 : Te || !(2 < ce.length) || ce[0] !== "o" && ce[0] !== "O" || ce[1] !== "n" && ce[1] !== "N") && (it(ce, Ee, nt, Te) && (Ee = null), Te || nt === null ? ut(ce) && (Ee === null ? fe.removeAttribute(ce) : fe.setAttribute(ce, "" + Ee)) : nt.mustUseProperty ? fe[nt.propertyName] = Ee === null ? nt.type === 3 ? !1 : "" : Ee : (ce = nt.attributeName, Te = nt.attributeNamespace, Ee === null ? fe.removeAttribute(ce) : (nt = nt.type, Ee = nt === 3 || nt === 4 && Ee === !0 ? "" : "" + Ee, Te ? fe.setAttributeNS(Te, ce, Ee) : fe.setAttribute(ce, Ee))));
  }
  var vt = L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, xt = Symbol.for("react.element"), Ct = Symbol.for("react.portal"), At = Symbol.for("react.fragment"), kt = Symbol.for("react.strict_mode"), Vt = Symbol.for("react.profiler"), ir = Symbol.for("react.provider"), er = Symbol.for("react.context"), Yt = Symbol.for("react.forward_ref"), Jt = Symbol.for("react.suspense"), rr = Symbol.for("react.suspense_list"), Qt = Symbol.for("react.memo"), wt = Symbol.for("react.lazy"), Ft = Symbol.for("react.offscreen"), yt = Symbol.iterator;
  function Et(fe) {
    return fe === null || typeof fe != "object" ? null : (fe = yt && fe[yt] || fe["@@iterator"], typeof fe == "function" ? fe : null);
  }
  var Dt = Object.assign, Ot;
  function nr(fe) {
    if (Ot === void 0)
      try {
        throw Error();
      } catch (Ee) {
        var ce = Ee.stack.trim().match(/\n( *(at )?)/);
        Ot = ce && ce[1] || "";
      }
    return `
` + Ot + fe;
  }
  var yr = !1;
  function mr(fe, ce) {
    if (!fe || yr)
      return "";
    yr = !0;
    var Ee = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (ce)
        if (ce = function() {
          throw Error();
        }, Object.defineProperty(ce.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(ce, []);
          } catch (qt) {
            var Te = qt;
          }
          Reflect.construct(fe, [], ce);
        } else {
          try {
            ce.call();
          } catch (qt) {
            Te = qt;
          }
          fe.call(ce.prototype);
        }
      else {
        try {
          throw Error();
        } catch (qt) {
          Te = qt;
        }
        fe();
      }
    } catch (qt) {
      if (qt && Te && typeof qt.stack == "string") {
        for (var nt = qt.stack.split(`
`), ct = Te.stack.split(`
`), bt = nt.length - 1, Mt = ct.length - 1; 1 <= bt && 0 <= Mt && nt[bt] !== ct[Mt]; )
          Mt--;
        for (; 1 <= bt && 0 <= Mt; bt--, Mt--)
          if (nt[bt] !== ct[Mt]) {
            if (bt !== 1 || Mt !== 1)
              do
                if (bt--, Mt--, 0 > Mt || nt[bt] !== ct[Mt]) {
                  var Lt = `
` + nt[bt].replace(" at new ", " at ");
                  return fe.displayName && Lt.includes("<anonymous>") && (Lt = Lt.replace("<anonymous>", fe.displayName)), Lt;
                }
              while (1 <= bt && 0 <= Mt);
            break;
          }
      }
    } finally {
      yr = !1, Error.prepareStackTrace = Ee;
    }
    return (fe = fe ? fe.displayName || fe.name : "") ? nr(fe) : "";
  }
  function Tr(fe) {
    switch (fe.tag) {
      case 5:
        return nr(fe.type);
      case 16:
        return nr("Lazy");
      case 13:
        return nr("Suspense");
      case 19:
        return nr("SuspenseList");
      case 0:
      case 2:
      case 15:
        return fe = mr(fe.type, !1), fe;
      case 11:
        return fe = mr(fe.type.render, !1), fe;
      case 1:
        return fe = mr(fe.type, !0), fe;
      default:
        return "";
    }
  }
  function Nr(fe) {
    if (fe == null)
      return null;
    if (typeof fe == "function")
      return fe.displayName || fe.name || null;
    if (typeof fe == "string")
      return fe;
    switch (fe) {
      case At:
        return "Fragment";
      case Ct:
        return "Portal";
      case Vt:
        return "Profiler";
      case kt:
        return "StrictMode";
      case Jt:
        return "Suspense";
      case rr:
        return "SuspenseList";
    }
    if (typeof fe == "object")
      switch (fe.$$typeof) {
        case er:
          return (fe.displayName || "Context") + ".Consumer";
        case ir:
          return (fe._context.displayName || "Context") + ".Provider";
        case Yt:
          var ce = fe.render;
          return fe = fe.displayName, fe || (fe = ce.displayName || ce.name || "", fe = fe !== "" ? "ForwardRef(" + fe + ")" : "ForwardRef"), fe;
        case Qt:
          return ce = fe.displayName || null, ce !== null ? ce : Nr(fe.type) || "Memo";
        case wt:
          ce = fe._payload, fe = fe._init;
          try {
            return Nr(fe(ce));
          } catch {
          }
      }
    return null;
  }
  function cn(fe) {
    var ce = fe.type;
    switch (fe.tag) {
      case 24:
        return "Cache";
      case 9:
        return (ce.displayName || "Context") + ".Consumer";
      case 10:
        return (ce._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return fe = ce.render, fe = fe.displayName || fe.name || "", ce.displayName || (fe !== "" ? "ForwardRef(" + fe + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return ce;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Nr(ce);
      case 8:
        return ce === kt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof ce == "function")
          return ce.displayName || ce.name || null;
        if (typeof ce == "string")
          return ce;
    }
    return null;
  }
  function en(fe) {
    switch (typeof fe) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return fe;
      case "object":
        return fe;
      default:
        return "";
    }
  }
  function Tn(fe) {
    var ce = fe.type;
    return (fe = fe.nodeName) && fe.toLowerCase() === "input" && (ce === "checkbox" || ce === "radio");
  }
  function Mn(fe) {
    var ce = Tn(fe) ? "checked" : "value", Ee = Object.getOwnPropertyDescriptor(fe.constructor.prototype, ce), Te = "" + fe[ce];
    if (!fe.hasOwnProperty(ce) && typeof Ee < "u" && typeof Ee.get == "function" && typeof Ee.set == "function") {
      var nt = Ee.get, ct = Ee.set;
      return Object.defineProperty(fe, ce, { configurable: !0, get: function() {
        return nt.call(this);
      }, set: function(bt) {
        Te = "" + bt, ct.call(this, bt);
      } }), Object.defineProperty(fe, ce, { enumerable: Ee.enumerable }), { getValue: function() {
        return Te;
      }, setValue: function(bt) {
        Te = "" + bt;
      }, stopTracking: function() {
        fe._valueTracker = null, delete fe[ce];
      } };
    }
  }
  function $r(fe) {
    fe._valueTracker || (fe._valueTracker = Mn(fe));
  }
  function tn(fe) {
    if (!fe)
      return !1;
    var ce = fe._valueTracker;
    if (!ce)
      return !0;
    var Ee = ce.getValue(), Te = "";
    return fe && (Te = Tn(fe) ? fe.checked ? "true" : "false" : fe.value), fe = Te, fe !== Ee ? (ce.setValue(fe), !0) : !1;
  }
  function kr(fe) {
    if (fe = fe || (typeof document < "u" ? document : void 0), typeof fe > "u")
      return null;
    try {
      return fe.activeElement || fe.body;
    } catch {
      return fe.body;
    }
  }
  function dr(fe, ce) {
    var Ee = ce.checked;
    return Dt({}, ce, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Ee ?? fe._wrapperState.initialChecked });
  }
  function zn(fe, ce) {
    var Ee = ce.defaultValue == null ? "" : ce.defaultValue, Te = ce.checked != null ? ce.checked : ce.defaultChecked;
    Ee = en(ce.value != null ? ce.value : Ee), fe._wrapperState = { initialChecked: Te, initialValue: Ee, controlled: ce.type === "checkbox" || ce.type === "radio" ? ce.checked != null : ce.value != null };
  }
  function Kn(fe, ce) {
    ce = ce.checked, ce != null && ft(fe, "checked", ce, !1);
  }
  function Fn(fe, ce) {
    Kn(fe, ce);
    var Ee = en(ce.value), Te = ce.type;
    if (Ee != null)
      Te === "number" ? (Ee === 0 && fe.value === "" || fe.value != Ee) && (fe.value = "" + Ee) : fe.value !== "" + Ee && (fe.value = "" + Ee);
    else if (Te === "submit" || Te === "reset") {
      fe.removeAttribute("value");
      return;
    }
    ce.hasOwnProperty("value") ? ki(fe, ce.type, Ee) : ce.hasOwnProperty("defaultValue") && ki(fe, ce.type, en(ce.defaultValue)), ce.checked == null && ce.defaultChecked != null && (fe.defaultChecked = !!ce.defaultChecked);
  }
  function Jn(fe, ce, Ee) {
    if (ce.hasOwnProperty("value") || ce.hasOwnProperty("defaultValue")) {
      var Te = ce.type;
      if (!(Te !== "submit" && Te !== "reset" || ce.value !== void 0 && ce.value !== null))
        return;
      ce = "" + fe._wrapperState.initialValue, Ee || ce === fe.value || (fe.value = ce), fe.defaultValue = ce;
    }
    Ee = fe.name, Ee !== "" && (fe.name = ""), fe.defaultChecked = !!fe._wrapperState.initialChecked, Ee !== "" && (fe.name = Ee);
  }
  function ki(fe, ce, Ee) {
    (ce !== "number" || kr(fe.ownerDocument) !== fe) && (Ee == null ? fe.defaultValue = "" + fe._wrapperState.initialValue : fe.defaultValue !== "" + Ee && (fe.defaultValue = "" + Ee));
  }
  var Ei = Array.isArray;
  function Dn(fe, ce, Ee, Te) {
    if (fe = fe.options, ce) {
      ce = {};
      for (var nt = 0; nt < Ee.length; nt++)
        ce["$" + Ee[nt]] = !0;
      for (Ee = 0; Ee < fe.length; Ee++)
        nt = ce.hasOwnProperty("$" + fe[Ee].value), fe[Ee].selected !== nt && (fe[Ee].selected = nt), nt && Te && (fe[Ee].defaultSelected = !0);
    } else {
      for (Ee = "" + en(Ee), ce = null, nt = 0; nt < fe.length; nt++) {
        if (fe[nt].value === Ee) {
          fe[nt].selected = !0, Te && (fe[nt].defaultSelected = !0);
          return;
        }
        ce !== null || fe[nt].disabled || (ce = fe[nt]);
      }
      ce !== null && (ce.selected = !0);
    }
  }
  function Mi(fe, ce) {
    if (ce.dangerouslySetInnerHTML != null)
      throw Error(oe(91));
    return Dt({}, ce, { value: void 0, defaultValue: void 0, children: "" + fe._wrapperState.initialValue });
  }
  function Zn(fe, ce) {
    var Ee = ce.value;
    if (Ee == null) {
      if (Ee = ce.children, ce = ce.defaultValue, Ee != null) {
        if (ce != null)
          throw Error(oe(92));
        if (Ei(Ee)) {
          if (1 < Ee.length)
            throw Error(oe(93));
          Ee = Ee[0];
        }
        ce = Ee;
      }
      ce == null && (ce = ""), Ee = ce;
    }
    fe._wrapperState = { initialValue: en(Ee) };
  }
  function ei(fe, ce) {
    var Ee = en(ce.value), Te = en(ce.defaultValue);
    Ee != null && (Ee = "" + Ee, Ee !== fe.value && (fe.value = Ee), ce.defaultValue == null && fe.defaultValue !== Ee && (fe.defaultValue = Ee)), Te != null && (fe.defaultValue = "" + Te);
  }
  function fi(fe) {
    var ce = fe.textContent;
    ce === fe._wrapperState.initialValue && ce !== "" && ce !== null && (fe.value = ce);
  }
  function ti(fe) {
    switch (fe) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function wn(fe, ce) {
    return fe == null || fe === "http://www.w3.org/1999/xhtml" ? ti(ce) : fe === "http://www.w3.org/2000/svg" && ce === "foreignObject" ? "http://www.w3.org/1999/xhtml" : fe;
  }
  var pi, Va = function(fe) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ce, Ee, Te, nt) {
      MSApp.execUnsafeLocalFunction(function() {
        return fe(ce, Ee, Te, nt);
      });
    } : fe;
  }(function(fe, ce) {
    if (fe.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in fe)
      fe.innerHTML = ce;
    else {
      for (pi = pi || document.createElement("div"), pi.innerHTML = "<svg>" + ce.valueOf().toString() + "</svg>", ce = pi.firstChild; fe.firstChild; )
        fe.removeChild(fe.firstChild);
      for (; ce.firstChild; )
        fe.appendChild(ce.firstChild);
    }
  });
  function Vn(fe, ce) {
    if (ce) {
      var Ee = fe.firstChild;
      if (Ee && Ee === fe.lastChild && Ee.nodeType === 3) {
        Ee.nodeValue = ce;
        return;
      }
    }
    fe.textContent = ce;
  }
  var vr = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Dr = ["Webkit", "ms", "Moz", "O"];
  Object.keys(vr).forEach(function(fe) {
    Dr.forEach(function(ce) {
      ce = ce + fe.charAt(0).toUpperCase() + fe.substring(1), vr[ce] = vr[fe];
    });
  });
  function Jr(fe, ce, Ee) {
    return ce == null || typeof ce == "boolean" || ce === "" ? "" : Ee || typeof ce != "number" || ce === 0 || vr.hasOwnProperty(fe) && vr[fe] ? ("" + ce).trim() : ce + "px";
  }
  function mn(fe, ce) {
    fe = fe.style;
    for (var Ee in ce)
      if (ce.hasOwnProperty(Ee)) {
        var Te = Ee.indexOf("--") === 0, nt = Jr(Ee, ce[Ee], Te);
        Ee === "float" && (Ee = "cssFloat"), Te ? fe.setProperty(Ee, nt) : fe[Ee] = nt;
      }
  }
  var kn = Dt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function bi(fe, ce) {
    if (ce) {
      if (kn[fe] && (ce.children != null || ce.dangerouslySetInnerHTML != null))
        throw Error(oe(137, fe));
      if (ce.dangerouslySetInnerHTML != null) {
        if (ce.children != null)
          throw Error(oe(60));
        if (typeof ce.dangerouslySetInnerHTML != "object" || !("__html" in ce.dangerouslySetInnerHTML))
          throw Error(oe(61));
      }
      if (ce.style != null && typeof ce.style != "object")
        throw Error(oe(62));
    }
  }
  function ri(fe, ce) {
    if (fe.indexOf("-") === -1)
      return typeof ce.is == "string";
    switch (fe) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ba = null;
  function vn(fe) {
    return fe = fe.target || fe.srcElement || window, fe.correspondingUseElement && (fe = fe.correspondingUseElement), fe.nodeType === 3 ? fe.parentNode : fe;
  }
  var Ba = null, ni = null, Bn = null;
  function su(fe) {
    if (fe = Ff(fe)) {
      if (typeof Ba != "function")
        throw Error(oe(280));
      var ce = fe.stateNode;
      ce && (ce = Lr(ce), Ba(fe.stateNode, fe.type, ce));
    }
  }
  function Lo(fe) {
    ni ? Bn ? Bn.push(fe) : Bn = [fe] : ni = fe;
  }
  function Ms() {
    if (ni) {
      var fe = ni, ce = Bn;
      if (Bn = ni = null, su(fe), ce)
        for (fe = 0; fe < ce.length; fe++)
          su(ce[fe]);
    }
  }
  function lu(fe, ce) {
    return fe(ce);
  }
  function uu() {
  }
  var $o = !1;
  function df(fe, ce, Ee) {
    if ($o)
      return fe(ce, Ee);
    $o = !0;
    try {
      return lu(fe, ce, Ee);
    } finally {
      $o = !1, (ni !== null || Bn !== null) && (uu(), Ms());
    }
  }
  function hl(fe, ce) {
    var Ee = fe.stateNode;
    if (Ee === null)
      return null;
    var Te = Lr(Ee);
    if (Te === null)
      return null;
    Ee = Te[ce];
    e:
      switch (ce) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (Te = !Te.disabled) || (fe = fe.type, Te = !(fe === "button" || fe === "input" || fe === "select" || fe === "textarea")), fe = !Te;
          break e;
        default:
          fe = !1;
      }
    if (fe)
      return null;
    if (Ee && typeof Ee != "function")
      throw Error(oe(231, ce, typeof Ee));
    return Ee;
  }
  var fu = !1;
  if (Ie)
    try {
      var ts = {};
      Object.defineProperty(ts, "passive", { get: function() {
        fu = !0;
      } }), window.addEventListener("test", ts, ts), window.removeEventListener("test", ts, ts);
    } catch {
      fu = !1;
    }
  function Fs(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    var qt = Array.prototype.slice.call(arguments, 3);
    try {
      ce.apply(Ee, qt);
    } catch (sr) {
      this.onError(sr);
    }
  }
  var xa = !1, Ha = null, Ca = !1, pl = null, hf = { onError: function(fe) {
    xa = !0, Ha = fe;
  } };
  function pf(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    xa = !1, Ha = null, Fs.apply(hf, arguments);
  }
  function Ds(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    if (pf.apply(this, arguments), xa) {
      if (xa) {
        var qt = Ha;
        xa = !1, Ha = null;
      } else
        throw Error(oe(198));
      Ca || (Ca = !0, pl = qt);
    }
  }
  function ro(fe) {
    var ce = fe, Ee = fe;
    if (fe.alternate)
      for (; ce.return; )
        ce = ce.return;
    else {
      fe = ce;
      do
        ce = fe, ce.flags & 4098 && (Ee = ce.return), fe = ce.return;
      while (fe);
    }
    return ce.tag === 3 ? Ee : null;
  }
  function sa(fe) {
    if (fe.tag === 13) {
      var ce = fe.memoizedState;
      if (ce === null && (fe = fe.alternate, fe !== null && (ce = fe.memoizedState)), ce !== null)
        return ce.dehydrated;
    }
    return null;
  }
  function Os(fe) {
    if (ro(fe) !== fe)
      throw Error(oe(188));
  }
  function Hi(fe) {
    var ce = fe.alternate;
    if (!ce) {
      if (ce = ro(fe), ce === null)
        throw Error(oe(188));
      return ce !== fe ? null : fe;
    }
    for (var Ee = fe, Te = ce; ; ) {
      var nt = Ee.return;
      if (nt === null)
        break;
      var ct = nt.alternate;
      if (ct === null) {
        if (Te = nt.return, Te !== null) {
          Ee = Te;
          continue;
        }
        break;
      }
      if (nt.child === ct.child) {
        for (ct = nt.child; ct; ) {
          if (ct === Ee)
            return Os(nt), fe;
          if (ct === Te)
            return Os(nt), ce;
          ct = ct.sibling;
        }
        throw Error(oe(188));
      }
      if (Ee.return !== Te.return)
        Ee = nt, Te = ct;
      else {
        for (var bt = !1, Mt = nt.child; Mt; ) {
          if (Mt === Ee) {
            bt = !0, Ee = nt, Te = ct;
            break;
          }
          if (Mt === Te) {
            bt = !0, Te = nt, Ee = ct;
            break;
          }
          Mt = Mt.sibling;
        }
        if (!bt) {
          for (Mt = ct.child; Mt; ) {
            if (Mt === Ee) {
              bt = !0, Ee = ct, Te = nt;
              break;
            }
            if (Mt === Te) {
              bt = !0, Te = ct, Ee = nt;
              break;
            }
            Mt = Mt.sibling;
          }
          if (!bt)
            throw Error(oe(189));
        }
      }
      if (Ee.alternate !== Te)
        throw Error(oe(190));
    }
    if (Ee.tag !== 3)
      throw Error(oe(188));
    return Ee.stateNode.current === Ee ? fe : ce;
  }
  function Sc(fe) {
    return fe = Hi(fe), fe !== null ? Ec(fe) : null;
  }
  function Ec(fe) {
    if (fe.tag === 5 || fe.tag === 6)
      return fe;
    for (fe = fe.child; fe !== null; ) {
      var ce = Ec(fe);
      if (ce !== null)
        return ce;
      fe = fe.sibling;
    }
    return null;
  }
  var mf = ne.unstable_scheduleCallback, Io = ne.unstable_cancelCallback, ch = ne.unstable_shouldYield, dh = ne.unstable_requestPaint, Hn = ne.unstable_now, hh = ne.unstable_getCurrentPriorityLevel, wo = ne.unstable_ImmediatePriority, Kr = ne.unstable_UserBlockingPriority, No = ne.unstable_NormalPriority, bc = ne.unstable_LowPriority, no = ne.unstable_IdlePriority, ml = null, Ua = null;
  function xc(fe) {
    if (Ua && typeof Ua.onCommitFiberRoot == "function")
      try {
        Ua.onCommitFiberRoot(ml, fe, void 0, (fe.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ta = Math.clz32 ? Math.clz32 : cu, Cc = Math.log, Tc = Math.LN2;
  function cu(fe) {
    return fe >>>= 0, fe === 0 ? 32 : 31 - (Cc(fe) / Tc | 0) | 0;
  }
  var du = 64, io = 4194304;
  function zo(fe) {
    switch (fe & -fe) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return fe & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return fe & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return fe;
    }
  }
  function wa(fe, ce) {
    var Ee = fe.pendingLanes;
    if (Ee === 0)
      return 0;
    var Te = 0, nt = fe.suspendedLanes, ct = fe.pingedLanes, bt = Ee & 268435455;
    if (bt !== 0) {
      var Mt = bt & ~nt;
      Mt !== 0 ? Te = zo(Mt) : (ct &= bt, ct !== 0 && (Te = zo(ct)));
    } else
      bt = Ee & ~nt, bt !== 0 ? Te = zo(bt) : ct !== 0 && (Te = zo(ct));
    if (Te === 0)
      return 0;
    if (ce !== 0 && ce !== Te && !(ce & nt) && (nt = Te & -Te, ct = ce & -ce, nt >= ct || nt === 16 && (ct & 4194240) !== 0))
      return ce;
    if (Te & 4 && (Te |= Ee & 16), ce = fe.entangledLanes, ce !== 0)
      for (fe = fe.entanglements, ce &= Te; 0 < ce; )
        Ee = 31 - Ta(ce), nt = 1 << Ee, Te |= fe[Ee], ce &= ~nt;
    return Te;
  }
  function vf(fe, ce) {
    switch (fe) {
      case 1:
      case 2:
      case 4:
        return ce + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return ce + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function hu(fe, ce) {
    for (var Ee = fe.suspendedLanes, Te = fe.pingedLanes, nt = fe.expirationTimes, ct = fe.pendingLanes; 0 < ct; ) {
      var bt = 31 - Ta(ct), Mt = 1 << bt, Lt = nt[bt];
      Lt === -1 ? (!(Mt & Ee) || Mt & Te) && (nt[bt] = vf(Mt, ce)) : Lt <= ce && (fe.expiredLanes |= Mt), ct &= ~Mt;
    }
  }
  function yf(fe) {
    return fe = fe.pendingLanes & -1073741825, fe !== 0 ? fe : fe & 1073741824 ? 1073741824 : 0;
  }
  function pu() {
    var fe = du;
    return du <<= 1, !(du & 4194240) && (du = 64), fe;
  }
  function mu(fe) {
    for (var ce = [], Ee = 0; 31 > Ee; Ee++)
      ce.push(fe);
    return ce;
  }
  function rs(fe, ce, Ee) {
    fe.pendingLanes |= ce, ce !== 536870912 && (fe.suspendedLanes = 0, fe.pingedLanes = 0), fe = fe.eventTimes, ce = 31 - Ta(ce), fe[ce] = Ee;
  }
  function ph(fe, ce) {
    var Ee = fe.pendingLanes & ~ce;
    fe.pendingLanes = ce, fe.suspendedLanes = 0, fe.pingedLanes = 0, fe.expiredLanes &= ce, fe.mutableReadLanes &= ce, fe.entangledLanes &= ce, ce = fe.entanglements;
    var Te = fe.eventTimes;
    for (fe = fe.expirationTimes; 0 < Ee; ) {
      var nt = 31 - Ta(Ee), ct = 1 << nt;
      ce[nt] = 0, Te[nt] = -1, fe[nt] = -1, Ee &= ~ct;
    }
  }
  function Ls(fe, ce) {
    var Ee = fe.entangledLanes |= ce;
    for (fe = fe.entanglements; Ee; ) {
      var Te = 31 - Ta(Ee), nt = 1 << Te;
      nt & ce | fe[Te] & ce && (fe[Te] |= ce), Ee &= ~nt;
    }
  }
  var un = 0;
  function Vo(fe) {
    return fe &= -fe, 1 < fe ? 4 < fe ? fe & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var wc, vu, an, _c, gf, Wr = !1, vl = [], ii = null, mi = null, la = null, yl = /* @__PURE__ */ new Map(), Un = /* @__PURE__ */ new Map(), yn = [], Sf = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function ja(fe, ce) {
    switch (fe) {
      case "focusin":
      case "focusout":
        ii = null;
        break;
      case "dragenter":
      case "dragleave":
        mi = null;
        break;
      case "mouseover":
      case "mouseout":
        la = null;
        break;
      case "pointerover":
      case "pointerout":
        yl.delete(ce.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Un.delete(ce.pointerId);
    }
  }
  function xi(fe, ce, Ee, Te, nt, ct) {
    return fe === null || fe.nativeEvent !== ct ? (fe = { blockedOn: ce, domEventName: Ee, eventSystemFlags: Te, nativeEvent: ct, targetContainers: [nt] }, ce !== null && (ce = Ff(ce), ce !== null && vu(ce)), fe) : (fe.eventSystemFlags |= Te, ce = fe.targetContainers, nt !== null && ce.indexOf(nt) === -1 && ce.push(nt), fe);
  }
  function _o(fe, ce, Ee, Te, nt) {
    switch (ce) {
      case "focusin":
        return ii = xi(ii, fe, ce, Ee, Te, nt), !0;
      case "dragenter":
        return mi = xi(mi, fe, ce, Ee, Te, nt), !0;
      case "mouseover":
        return la = xi(la, fe, ce, Ee, Te, nt), !0;
      case "pointerover":
        var ct = nt.pointerId;
        return yl.set(ct, xi(yl.get(ct) || null, fe, ce, Ee, Te, nt)), !0;
      case "gotpointercapture":
        return ct = nt.pointerId, Un.set(ct, xi(Un.get(ct) || null, fe, ce, Ee, Te, nt)), !0;
    }
    return !1;
  }
  function Ef(fe) {
    var ce = lo(fe.target);
    if (ce !== null) {
      var Ee = ro(ce);
      if (Ee !== null) {
        if (ce = Ee.tag, ce === 13) {
          if (ce = sa(Ee), ce !== null) {
            fe.blockedOn = ce, gf(fe.priority, function() {
              an(Ee);
            });
            return;
          }
        } else if (ce === 3 && Ee.stateNode.current.memoizedState.isDehydrated) {
          fe.blockedOn = Ee.tag === 3 ? Ee.stateNode.containerInfo : null;
          return;
        }
      }
    }
    fe.blockedOn = null;
  }
  function ao(fe) {
    if (fe.blockedOn !== null)
      return !1;
    for (var ce = fe.targetContainers; 0 < ce.length; ) {
      var Ee = _n(fe.domEventName, fe.eventSystemFlags, ce[0], fe.nativeEvent);
      if (Ee === null) {
        Ee = fe.nativeEvent;
        var Te = new Ee.constructor(Ee.type, Ee);
        ba = Te, Ee.target.dispatchEvent(Te), ba = null;
      } else
        return ce = Ff(Ee), ce !== null && vu(ce), fe.blockedOn = Ee, !1;
      ce.shift();
    }
    return !0;
  }
  function yu(fe, ce, Ee) {
    ao(fe) && Ee.delete(ce);
  }
  function Ac() {
    Wr = !1, ii !== null && ao(ii) && (ii = null), mi !== null && ao(mi) && (mi = null), la !== null && ao(la) && (la = null), yl.forEach(yu), Un.forEach(yu);
  }
  function gl(fe, ce) {
    fe.blockedOn === ce && (fe.blockedOn = null, Wr || (Wr = !0, ne.unstable_scheduleCallback(ne.unstable_NormalPriority, Ac)));
  }
  function Sl(fe) {
    function ce(nt) {
      return gl(nt, fe);
    }
    if (0 < vl.length) {
      gl(vl[0], fe);
      for (var Ee = 1; Ee < vl.length; Ee++) {
        var Te = vl[Ee];
        Te.blockedOn === fe && (Te.blockedOn = null);
      }
    }
    for (ii !== null && gl(ii, fe), mi !== null && gl(mi, fe), la !== null && gl(la, fe), yl.forEach(ce), Un.forEach(ce), Ee = 0; Ee < yn.length; Ee++)
      Te = yn[Ee], Te.blockedOn === fe && (Te.blockedOn = null);
    for (; 0 < yn.length && (Ee = yn[0], Ee.blockedOn === null); )
      Ef(Ee), Ee.blockedOn === null && yn.shift();
  }
  var Rt = vt.ReactCurrentBatchConfig, zt = !0;
  function ar(fe, ce, Ee, Te) {
    var nt = un, ct = Rt.transition;
    Rt.transition = null;
    try {
      un = 1, gn(fe, ce, Ee, Te);
    } finally {
      un = nt, Rt.transition = ct;
    }
  }
  function Sr(fe, ce, Ee, Te) {
    var nt = un, ct = Rt.transition;
    Rt.transition = null;
    try {
      un = 4, gn(fe, ce, Ee, Te);
    } finally {
      un = nt, Rt.transition = ct;
    }
  }
  function gn(fe, ce, Ee, Te) {
    if (zt) {
      var nt = _n(fe, ce, Ee, Te);
      if (nt === null)
        Ic(fe, ce, Te, Gr, Ee), ja(fe, Te);
      else if (_o(nt, fe, ce, Ee, Te))
        Te.stopPropagation();
      else if (ja(fe, Te), ce & 4 && -1 < Sf.indexOf(fe)) {
        for (; nt !== null; ) {
          var ct = Ff(nt);
          if (ct !== null && wc(ct), ct = _n(fe, ce, Ee, Te), ct === null && Ic(fe, ce, Te, Gr, Ee), ct === nt)
            break;
          nt = ct;
        }
        nt !== null && Te.stopPropagation();
      } else
        Ic(fe, ce, Te, null, Ee);
    }
  }
  var Gr = null;
  function _n(fe, ce, Ee, Te) {
    if (Gr = null, fe = vn(Te), fe = lo(fe), fe !== null)
      if (ce = ro(fe), ce === null)
        fe = null;
      else if (Ee = ce.tag, Ee === 13) {
        if (fe = sa(ce), fe !== null)
          return fe;
        fe = null;
      } else if (Ee === 3) {
        if (ce.stateNode.current.memoizedState.isDehydrated)
          return ce.tag === 3 ? ce.stateNode.containerInfo : null;
        fe = null;
      } else
        ce !== fe && (fe = null);
    return Gr = fe, null;
  }
  function ai(fe) {
    switch (fe) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (hh()) {
          case wo:
            return 1;
          case Kr:
            return 4;
          case No:
          case bc:
            return 16;
          case no:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var An = null, bn = null, Ci = null;
  function ua() {
    if (Ci)
      return Ci;
    var fe, ce = bn, Ee = ce.length, Te, nt = "value" in An ? An.value : An.textContent, ct = nt.length;
    for (fe = 0; fe < Ee && ce[fe] === nt[fe]; fe++)
      ;
    var bt = Ee - fe;
    for (Te = 1; Te <= bt && ce[Ee - Te] === nt[ct - Te]; Te++)
      ;
    return Ci = nt.slice(fe, 1 < Te ? 1 - Te : void 0);
  }
  function Wn(fe) {
    var ce = fe.keyCode;
    return "charCode" in fe ? (fe = fe.charCode, fe === 0 && ce === 13 && (fe = 13)) : fe = ce, fe === 10 && (fe = 13), 32 <= fe || fe === 13 ? fe : 0;
  }
  function Fi() {
    return !0;
  }
  function fa() {
    return !1;
  }
  function oi(fe) {
    function ce(Ee, Te, nt, ct, bt) {
      this._reactName = Ee, this._targetInst = nt, this.type = Te, this.nativeEvent = ct, this.target = bt, this.currentTarget = null;
      for (var Mt in fe)
        fe.hasOwnProperty(Mt) && (Ee = fe[Mt], this[Mt] = Ee ? Ee(ct) : ct[Mt]);
      return this.isDefaultPrevented = (ct.defaultPrevented != null ? ct.defaultPrevented : ct.returnValue === !1) ? Fi : fa, this.isPropagationStopped = fa, this;
    }
    return Dt(ce.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var Ee = this.nativeEvent;
      Ee && (Ee.preventDefault ? Ee.preventDefault() : typeof Ee.returnValue != "unknown" && (Ee.returnValue = !1), this.isDefaultPrevented = Fi);
    }, stopPropagation: function() {
      var Ee = this.nativeEvent;
      Ee && (Ee.stopPropagation ? Ee.stopPropagation() : typeof Ee.cancelBubble != "unknown" && (Ee.cancelBubble = !0), this.isPropagationStopped = Fi);
    }, persist: function() {
    }, isPersistent: Fi }), ce;
  }
  var Di = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(fe) {
    return fe.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, oo = oi(Di), ns = Dt({}, Di, { view: 0, detail: 0 }), El = oi(ns), is, mh, bf, Oi = Dt({}, ns, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Sh, button: 0, buttons: 0, relatedTarget: function(fe) {
    return fe.relatedTarget === void 0 ? fe.fromElement === fe.srcElement ? fe.toElement : fe.fromElement : fe.relatedTarget;
  }, movementX: function(fe) {
    return "movementX" in fe ? fe.movementX : (fe !== bf && (bf && fe.type === "mousemove" ? (is = fe.screenX - bf.screenX, mh = fe.screenY - bf.screenY) : mh = is = 0, bf = fe), is);
  }, movementY: function(fe) {
    return "movementY" in fe ? fe.movementY : mh;
  } }), Pc = oi(Oi), wm = Dt({}, Oi, { dataTransfer: 0 }), _m = oi(wm), hg = Dt({}, ns, { relatedTarget: 0 }), $s = oi(hg), vh = Dt({}, Di, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Am = oi(vh), pg = Dt({}, Di, { clipboardData: function(fe) {
    return "clipboardData" in fe ? fe.clipboardData : window.clipboardData;
  } }), mg = oi(pg), vg = Dt({}, Di, { data: 0 }), yh = oi(vg), gh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Pm = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Rm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function km(fe) {
    var ce = this.nativeEvent;
    return ce.getModifierState ? ce.getModifierState(fe) : (fe = Rm[fe]) ? !!ce[fe] : !1;
  }
  function Sh() {
    return km;
  }
  var as = Dt({}, ns, { key: function(fe) {
    if (fe.key) {
      var ce = gh[fe.key] || fe.key;
      if (ce !== "Unidentified")
        return ce;
    }
    return fe.type === "keypress" ? (fe = Wn(fe), fe === 13 ? "Enter" : String.fromCharCode(fe)) : fe.type === "keydown" || fe.type === "keyup" ? Pm[fe.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Sh, charCode: function(fe) {
    return fe.type === "keypress" ? Wn(fe) : 0;
  }, keyCode: function(fe) {
    return fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0;
  }, which: function(fe) {
    return fe.type === "keypress" ? Wn(fe) : fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0;
  } }), yg = oi(as), Eh = Dt({}, Oi, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Rc = oi(Eh), bh = Dt({}, ns, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Sh }), gg = oi(bh), kc = Dt({}, Di, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Mm = oi(kc), _a = Dt({}, Oi, {
    deltaX: function(fe) {
      return "deltaX" in fe ? fe.deltaX : "wheelDeltaX" in fe ? -fe.wheelDeltaX : 0;
    },
    deltaY: function(fe) {
      return "deltaY" in fe ? fe.deltaY : "wheelDeltaY" in fe ? -fe.wheelDeltaY : "wheelDelta" in fe ? -fe.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), os = oi(_a), vi = [9, 13, 27, 32], Ao = Ie && "CompositionEvent" in window, bl = null;
  Ie && "documentMode" in document && (bl = document.documentMode);
  var Mc = Ie && "TextEvent" in window && !bl, Fm = Ie && (!Ao || bl && 8 < bl && 11 >= bl), gu = " ", Dm = !1;
  function Om(fe, ce) {
    switch (fe) {
      case "keyup":
        return vi.indexOf(ce.keyCode) !== -1;
      case "keydown":
        return ce.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Fc(fe) {
    return fe = fe.detail, typeof fe == "object" && "data" in fe ? fe.data : null;
  }
  var Su = !1;
  function Sg(fe, ce) {
    switch (fe) {
      case "compositionend":
        return Fc(ce);
      case "keypress":
        return ce.which !== 32 ? null : (Dm = !0, gu);
      case "textInput":
        return fe = ce.data, fe === gu && Dm ? null : fe;
      default:
        return null;
    }
  }
  function Eg(fe, ce) {
    if (Su)
      return fe === "compositionend" || !Ao && Om(fe, ce) ? (fe = ua(), Ci = bn = An = null, Su = !1, fe) : null;
    switch (fe) {
      case "paste":
        return null;
      case "keypress":
        if (!(ce.ctrlKey || ce.altKey || ce.metaKey) || ce.ctrlKey && ce.altKey) {
          if (ce.char && 1 < ce.char.length)
            return ce.char;
          if (ce.which)
            return String.fromCharCode(ce.which);
        }
        return null;
      case "compositionend":
        return Fm && ce.locale !== "ko" ? null : ce.data;
      default:
        return null;
    }
  }
  var Lm = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function $m(fe) {
    var ce = fe && fe.nodeName && fe.nodeName.toLowerCase();
    return ce === "input" ? !!Lm[fe.type] : ce === "textarea";
  }
  function Im(fe, ce, Ee, Te) {
    Lo(Te), ce = Rf(ce, "onChange"), 0 < ce.length && (Ee = new oo("onChange", "change", null, Ee, Te), fe.push({ event: Ee, listeners: ce }));
  }
  var xf = null, Eu = null;
  function bu(fe) {
    $c(fe, 0);
  }
  function xu(fe) {
    var ce = Tu(fe);
    if (tn(ce))
      return fe;
  }
  function Nm(fe, ce) {
    if (fe === "change")
      return ce;
  }
  var xh = !1;
  if (Ie) {
    var Ch;
    if (Ie) {
      var Th = "oninput" in document;
      if (!Th) {
        var zm = document.createElement("div");
        zm.setAttribute("oninput", "return;"), Th = typeof zm.oninput == "function";
      }
      Ch = Th;
    } else
      Ch = !1;
    xh = Ch && (!document.documentMode || 9 < document.documentMode);
  }
  function Vm() {
    xf && (xf.detachEvent("onpropertychange", Bm), Eu = xf = null);
  }
  function Bm(fe) {
    if (fe.propertyName === "value" && xu(Eu)) {
      var ce = [];
      Im(ce, Eu, fe, vn(fe)), df(bu, ce);
    }
  }
  function bg(fe, ce, Ee) {
    fe === "focusin" ? (Vm(), xf = ce, Eu = Ee, xf.attachEvent("onpropertychange", Bm)) : fe === "focusout" && Vm();
  }
  function xg(fe) {
    if (fe === "selectionchange" || fe === "keyup" || fe === "keydown")
      return xu(Eu);
  }
  function Cg(fe, ce) {
    if (fe === "click")
      return xu(ce);
  }
  function Hm(fe, ce) {
    if (fe === "input" || fe === "change")
      return xu(ce);
  }
  function Tg(fe, ce) {
    return fe === ce && (fe !== 0 || 1 / fe === 1 / ce) || fe !== fe && ce !== ce;
  }
  var so = typeof Object.is == "function" ? Object.is : Tg;
  function Cf(fe, ce) {
    if (so(fe, ce))
      return !0;
    if (typeof fe != "object" || fe === null || typeof ce != "object" || ce === null)
      return !1;
    var Ee = Object.keys(fe), Te = Object.keys(ce);
    if (Ee.length !== Te.length)
      return !1;
    for (Te = 0; Te < Ee.length; Te++) {
      var nt = Ee[Te];
      if (!Ae.call(ce, nt) || !so(fe[nt], ce[nt]))
        return !1;
    }
    return !0;
  }
  function Um(fe) {
    for (; fe && fe.firstChild; )
      fe = fe.firstChild;
    return fe;
  }
  function jm(fe, ce) {
    var Ee = Um(fe);
    fe = 0;
    for (var Te; Ee; ) {
      if (Ee.nodeType === 3) {
        if (Te = fe + Ee.textContent.length, fe <= ce && Te >= ce)
          return { node: Ee, offset: ce - fe };
        fe = Te;
      }
      e: {
        for (; Ee; ) {
          if (Ee.nextSibling) {
            Ee = Ee.nextSibling;
            break e;
          }
          Ee = Ee.parentNode;
        }
        Ee = void 0;
      }
      Ee = Um(Ee);
    }
  }
  function Gm(fe, ce) {
    return fe && ce ? fe === ce ? !0 : fe && fe.nodeType === 3 ? !1 : ce && ce.nodeType === 3 ? Gm(fe, ce.parentNode) : "contains" in fe ? fe.contains(ce) : fe.compareDocumentPosition ? !!(fe.compareDocumentPosition(ce) & 16) : !1 : !1;
  }
  function Dc() {
    for (var fe = window, ce = kr(); ce instanceof fe.HTMLIFrameElement; ) {
      try {
        var Ee = typeof ce.contentWindow.location.href == "string";
      } catch {
        Ee = !1;
      }
      if (Ee)
        fe = ce.contentWindow;
      else
        break;
      ce = kr(fe.document);
    }
    return ce;
  }
  function ss(fe) {
    var ce = fe && fe.nodeName && fe.nodeName.toLowerCase();
    return ce && (ce === "input" && (fe.type === "text" || fe.type === "search" || fe.type === "tel" || fe.type === "url" || fe.type === "password") || ce === "textarea" || fe.contentEditable === "true");
  }
  function Oc(fe) {
    var ce = Dc(), Ee = fe.focusedElem, Te = fe.selectionRange;
    if (ce !== Ee && Ee && Ee.ownerDocument && Gm(Ee.ownerDocument.documentElement, Ee)) {
      if (Te !== null && ss(Ee)) {
        if (ce = Te.start, fe = Te.end, fe === void 0 && (fe = ce), "selectionStart" in Ee)
          Ee.selectionStart = ce, Ee.selectionEnd = Math.min(fe, Ee.value.length);
        else if (fe = (ce = Ee.ownerDocument || document) && ce.defaultView || window, fe.getSelection) {
          fe = fe.getSelection();
          var nt = Ee.textContent.length, ct = Math.min(Te.start, nt);
          Te = Te.end === void 0 ? ct : Math.min(Te.end, nt), !fe.extend && ct > Te && (nt = Te, Te = ct, ct = nt), nt = jm(Ee, ct);
          var bt = jm(
            Ee,
            Te
          );
          nt && bt && (fe.rangeCount !== 1 || fe.anchorNode !== nt.node || fe.anchorOffset !== nt.offset || fe.focusNode !== bt.node || fe.focusOffset !== bt.offset) && (ce = ce.createRange(), ce.setStart(nt.node, nt.offset), fe.removeAllRanges(), ct > Te ? (fe.addRange(ce), fe.extend(bt.node, bt.offset)) : (ce.setEnd(bt.node, bt.offset), fe.addRange(ce)));
        }
      }
      for (ce = [], fe = Ee; fe = fe.parentNode; )
        fe.nodeType === 1 && ce.push({ element: fe, left: fe.scrollLeft, top: fe.scrollTop });
      for (typeof Ee.focus == "function" && Ee.focus(), Ee = 0; Ee < ce.length; Ee++)
        fe = ce[Ee], fe.element.scrollLeft = fe.left, fe.element.scrollTop = fe.top;
    }
  }
  var Wm = Ie && "documentMode" in document && 11 >= document.documentMode, Po = null, wh = null, Tf = null, _h = !1;
  function qm(fe, ce, Ee) {
    var Te = Ee.window === Ee ? Ee.document : Ee.nodeType === 9 ? Ee : Ee.ownerDocument;
    _h || Po == null || Po !== kr(Te) || (Te = Po, "selectionStart" in Te && ss(Te) ? Te = { start: Te.selectionStart, end: Te.selectionEnd } : (Te = (Te.ownerDocument && Te.ownerDocument.defaultView || window).getSelection(), Te = { anchorNode: Te.anchorNode, anchorOffset: Te.anchorOffset, focusNode: Te.focusNode, focusOffset: Te.focusOffset }), Tf && Cf(Tf, Te) || (Tf = Te, Te = Rf(wh, "onSelect"), 0 < Te.length && (ce = new oo("onSelect", "select", null, ce, Ee), fe.push({ event: ce, listeners: Te }), ce.target = Po)));
  }
  function Lc(fe, ce) {
    var Ee = {};
    return Ee[fe.toLowerCase()] = ce.toLowerCase(), Ee["Webkit" + fe] = "webkit" + ce, Ee["Moz" + fe] = "moz" + ce, Ee;
  }
  var xl = { animationend: Lc("Animation", "AnimationEnd"), animationiteration: Lc("Animation", "AnimationIteration"), animationstart: Lc("Animation", "AnimationStart"), transitionend: Lc("Transition", "TransitionEnd") }, Ah = {}, Ph = {};
  Ie && (Ph = document.createElement("div").style, "AnimationEvent" in window || (delete xl.animationend.animation, delete xl.animationiteration.animation, delete xl.animationstart.animation), "TransitionEvent" in window || delete xl.transitionend.transition);
  function Li(fe) {
    if (Ah[fe])
      return Ah[fe];
    if (!xl[fe])
      return fe;
    var ce = xl[fe], Ee;
    for (Ee in ce)
      if (ce.hasOwnProperty(Ee) && Ee in Ph)
        return Ah[fe] = ce[Ee];
    return fe;
  }
  var Rh = Li("animationend"), Ym = Li("animationiteration"), Qm = Li("animationstart"), Xm = Li("transitionend"), Km = /* @__PURE__ */ new Map(), Jm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ls(fe, ce) {
    Km.set(fe, ce), ge(ce, [fe]);
  }
  for (var wf = 0; wf < Jm.length; wf++) {
    var Cl = Jm[wf], wg = Cl.toLowerCase(), _f = Cl[0].toUpperCase() + Cl.slice(1);
    ls(wg, "on" + _f);
  }
  ls(Rh, "onAnimationEnd"), ls(Ym, "onAnimationIteration"), ls(Qm, "onAnimationStart"), ls("dblclick", "onDoubleClick"), ls("focusin", "onFocus"), ls("focusout", "onBlur"), ls(Xm, "onTransitionEnd"), be("onMouseEnter", ["mouseout", "mouseover"]), be("onMouseLeave", ["mouseout", "mouseover"]), be("onPointerEnter", ["pointerout", "pointerover"]), be("onPointerLeave", ["pointerout", "pointerover"]), ge("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ge("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ge("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ge("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ge("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ge("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Af = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), _g = new Set("cancel close invalid load scroll toggle".split(" ").concat(Af));
  function Zm(fe, ce, Ee) {
    var Te = fe.type || "unknown-event";
    fe.currentTarget = Ee, Ds(Te, ce, void 0, fe), fe.currentTarget = null;
  }
  function $c(fe, ce) {
    ce = (ce & 4) !== 0;
    for (var Ee = 0; Ee < fe.length; Ee++) {
      var Te = fe[Ee], nt = Te.event;
      Te = Te.listeners;
      e: {
        var ct = void 0;
        if (ce)
          for (var bt = Te.length - 1; 0 <= bt; bt--) {
            var Mt = Te[bt], Lt = Mt.instance, qt = Mt.currentTarget;
            if (Mt = Mt.listener, Lt !== ct && nt.isPropagationStopped())
              break e;
            Zm(nt, Mt, qt), ct = Lt;
          }
        else
          for (bt = 0; bt < Te.length; bt++) {
            if (Mt = Te[bt], Lt = Mt.instance, qt = Mt.currentTarget, Mt = Mt.listener, Lt !== ct && nt.isPropagationStopped())
              break e;
            Zm(nt, Mt, qt), ct = Lt;
          }
      }
    }
    if (Ca)
      throw fe = pl, Ca = !1, pl = null, fe;
  }
  function Pn(fe, ce) {
    var Ee = ce[$h];
    Ee === void 0 && (Ee = ce[$h] = /* @__PURE__ */ new Set());
    var Te = fe + "__bubble";
    Ee.has(Te) || (ev(ce, fe, 2, !1), Ee.add(Te));
  }
  function Is(fe, ce, Ee) {
    var Te = 0;
    ce && (Te |= 4), ev(Ee, fe, Te, ce);
  }
  var us = "_reactListening" + Math.random().toString(36).slice(2);
  function Cu(fe) {
    if (!fe[us]) {
      fe[us] = !0, pe.forEach(function(Ee) {
        Ee !== "selectionchange" && (_g.has(Ee) || Is(Ee, !1, fe), Is(Ee, !0, fe));
      });
      var ce = fe.nodeType === 9 ? fe : fe.ownerDocument;
      ce === null || ce[us] || (ce[us] = !0, Is("selectionchange", !1, ce));
    }
  }
  function ev(fe, ce, Ee, Te) {
    switch (ai(ce)) {
      case 1:
        var nt = ar;
        break;
      case 4:
        nt = Sr;
        break;
      default:
        nt = gn;
    }
    Ee = nt.bind(null, ce, Ee, fe), nt = void 0, !fu || ce !== "touchstart" && ce !== "touchmove" && ce !== "wheel" || (nt = !0), Te ? nt !== void 0 ? fe.addEventListener(ce, Ee, { capture: !0, passive: nt }) : fe.addEventListener(ce, Ee, !0) : nt !== void 0 ? fe.addEventListener(ce, Ee, { passive: nt }) : fe.addEventListener(ce, Ee, !1);
  }
  function Ic(fe, ce, Ee, Te, nt) {
    var ct = Te;
    if (!(ce & 1) && !(ce & 2) && Te !== null)
      e:
        for (; ; ) {
          if (Te === null)
            return;
          var bt = Te.tag;
          if (bt === 3 || bt === 4) {
            var Mt = Te.stateNode.containerInfo;
            if (Mt === nt || Mt.nodeType === 8 && Mt.parentNode === nt)
              break;
            if (bt === 4)
              for (bt = Te.return; bt !== null; ) {
                var Lt = bt.tag;
                if ((Lt === 3 || Lt === 4) && (Lt = bt.stateNode.containerInfo, Lt === nt || Lt.nodeType === 8 && Lt.parentNode === nt))
                  return;
                bt = bt.return;
              }
            for (; Mt !== null; ) {
              if (bt = lo(Mt), bt === null)
                return;
              if (Lt = bt.tag, Lt === 5 || Lt === 6) {
                Te = ct = bt;
                continue e;
              }
              Mt = Mt.parentNode;
            }
          }
          Te = Te.return;
        }
    df(function() {
      var qt = ct, sr = vn(Ee), lr = [];
      e: {
        var or = Km.get(fe);
        if (or !== void 0) {
          var Er = oo, _r = fe;
          switch (fe) {
            case "keypress":
              if (Wn(Ee) === 0)
                break e;
            case "keydown":
            case "keyup":
              Er = yg;
              break;
            case "focusin":
              _r = "focus", Er = $s;
              break;
            case "focusout":
              _r = "blur", Er = $s;
              break;
            case "beforeblur":
            case "afterblur":
              Er = $s;
              break;
            case "click":
              if (Ee.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Er = Pc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Er = _m;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Er = gg;
              break;
            case Rh:
            case Ym:
            case Qm:
              Er = Am;
              break;
            case Xm:
              Er = Mm;
              break;
            case "scroll":
              Er = El;
              break;
            case "wheel":
              Er = os;
              break;
            case "copy":
            case "cut":
            case "paste":
              Er = mg;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Er = Rc;
          }
          var Rr = (ce & 4) !== 0, di = !Rr && fe === "scroll", Bt = Rr ? or !== null ? or + "Capture" : null : or;
          Rr = [];
          for (var It = qt, jt; It !== null; ) {
            jt = It;
            var cr = jt.stateNode;
            if (jt.tag === 5 && cr !== null && (jt = cr, Bt !== null && (cr = hl(It, Bt), cr != null && Rr.push(Pf(It, cr, jt)))), di)
              break;
            It = It.return;
          }
          0 < Rr.length && (or = new Er(or, _r, null, Ee, sr), lr.push({ event: or, listeners: Rr }));
        }
      }
      if (!(ce & 7)) {
        e: {
          if (or = fe === "mouseover" || fe === "pointerover", Er = fe === "mouseout" || fe === "pointerout", or && Ee !== ba && (_r = Ee.relatedTarget || Ee.fromElement) && (lo(_r) || _r[fs]))
            break e;
          if ((Er || or) && (or = sr.window === sr ? sr : (or = sr.ownerDocument) ? or.defaultView || or.parentWindow : window, Er ? (_r = Ee.relatedTarget || Ee.toElement, Er = qt, _r = _r ? lo(_r) : null, _r !== null && (di = ro(_r), _r !== di || _r.tag !== 5 && _r.tag !== 6) && (_r = null)) : (Er = null, _r = qt), Er !== _r)) {
            if (Rr = Pc, cr = "onMouseLeave", Bt = "onMouseEnter", It = "mouse", (fe === "pointerout" || fe === "pointerover") && (Rr = Rc, cr = "onPointerLeave", Bt = "onPointerEnter", It = "pointer"), di = Er == null ? or : Tu(Er), jt = _r == null ? or : Tu(_r), or = new Rr(cr, It + "leave", Er, Ee, sr), or.target = di, or.relatedTarget = jt, cr = null, lo(sr) === qt && (Rr = new Rr(Bt, It + "enter", _r, Ee, sr), Rr.target = jt, Rr.relatedTarget = di, cr = Rr), di = cr, Er && _r)
              t: {
                for (Rr = Er, Bt = _r, It = 0, jt = Rr; jt; jt = Tl(jt))
                  It++;
                for (jt = 0, cr = Bt; cr; cr = Tl(cr))
                  jt++;
                for (; 0 < It - jt; )
                  Rr = Tl(Rr), It--;
                for (; 0 < jt - It; )
                  Bt = Tl(Bt), jt--;
                for (; It--; ) {
                  if (Rr === Bt || Bt !== null && Rr === Bt.alternate)
                    break t;
                  Rr = Tl(Rr), Bt = Tl(Bt);
                }
                Rr = null;
              }
            else
              Rr = null;
            Er !== null && kh(lr, or, Er, Rr, !1), _r !== null && di !== null && kh(lr, di, _r, Rr, !0);
          }
        }
        e: {
          if (or = qt ? Tu(qt) : window, Er = or.nodeName && or.nodeName.toLowerCase(), Er === "select" || Er === "input" && or.type === "file")
            var Mr = Nm;
          else if ($m(or))
            if (xh)
              Mr = Hm;
            else {
              Mr = xg;
              var Ar = bg;
            }
          else
            (Er = or.nodeName) && Er.toLowerCase() === "input" && (or.type === "checkbox" || or.type === "radio") && (Mr = Cg);
          if (Mr && (Mr = Mr(fe, qt))) {
            Im(lr, Mr, Ee, sr);
            break e;
          }
          Ar && Ar(fe, or, qt), fe === "focusout" && (Ar = or._wrapperState) && Ar.controlled && or.type === "number" && ki(or, "number", or.value);
        }
        switch (Ar = qt ? Tu(qt) : window, fe) {
          case "focusin":
            ($m(Ar) || Ar.contentEditable === "true") && (Po = Ar, wh = qt, Tf = null);
            break;
          case "focusout":
            Tf = wh = Po = null;
            break;
          case "mousedown":
            _h = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            _h = !1, qm(lr, Ee, sr);
            break;
          case "selectionchange":
            if (Wm)
              break;
          case "keydown":
          case "keyup":
            qm(lr, Ee, sr);
        }
        var Or;
        if (Ao)
          e: {
            switch (fe) {
              case "compositionstart":
                var jr = "onCompositionStart";
                break e;
              case "compositionend":
                jr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                jr = "onCompositionUpdate";
                break e;
            }
            jr = void 0;
          }
        else
          Su ? Om(fe, Ee) && (jr = "onCompositionEnd") : fe === "keydown" && Ee.keyCode === 229 && (jr = "onCompositionStart");
        jr && (Fm && Ee.locale !== "ko" && (Su || jr !== "onCompositionStart" ? jr === "onCompositionEnd" && Su && (Or = ua()) : (An = sr, bn = "value" in An ? An.value : An.textContent, Su = !0)), Ar = Rf(qt, jr), 0 < Ar.length && (jr = new yh(jr, fe, null, Ee, sr), lr.push({ event: jr, listeners: Ar }), Or ? jr.data = Or : (Or = Fc(Ee), Or !== null && (jr.data = Or)))), (Or = Mc ? Sg(fe, Ee) : Eg(fe, Ee)) && (qt = Rf(qt, "onBeforeInput"), 0 < qt.length && (sr = new yh("onBeforeInput", "beforeinput", null, Ee, sr), lr.push({ event: sr, listeners: qt }), sr.data = Or));
      }
      $c(lr, ce);
    });
  }
  function Pf(fe, ce, Ee) {
    return { instance: fe, listener: ce, currentTarget: Ee };
  }
  function Rf(fe, ce) {
    for (var Ee = ce + "Capture", Te = []; fe !== null; ) {
      var nt = fe, ct = nt.stateNode;
      nt.tag === 5 && ct !== null && (nt = ct, ct = hl(fe, Ee), ct != null && Te.unshift(Pf(fe, ct, nt)), ct = hl(fe, ce), ct != null && Te.push(Pf(fe, ct, nt))), fe = fe.return;
    }
    return Te;
  }
  function Tl(fe) {
    if (fe === null)
      return null;
    do
      fe = fe.return;
    while (fe && fe.tag !== 5);
    return fe || null;
  }
  function kh(fe, ce, Ee, Te, nt) {
    for (var ct = ce._reactName, bt = []; Ee !== null && Ee !== Te; ) {
      var Mt = Ee, Lt = Mt.alternate, qt = Mt.stateNode;
      if (Lt !== null && Lt === Te)
        break;
      Mt.tag === 5 && qt !== null && (Mt = qt, nt ? (Lt = hl(Ee, ct), Lt != null && bt.unshift(Pf(Ee, Lt, Mt))) : nt || (Lt = hl(Ee, ct), Lt != null && bt.push(Pf(Ee, Lt, Mt)))), Ee = Ee.return;
    }
    bt.length !== 0 && fe.push({ event: ce, listeners: bt });
  }
  var Mh = /\r\n?/g, Ag = /\u0000|\uFFFD/g;
  function Fh(fe) {
    return (typeof fe == "string" ? fe : "" + fe).replace(Mh, `
`).replace(Ag, "");
  }
  function Nc(fe, ce, Ee) {
    if (ce = Fh(ce), Fh(fe) !== ce && Ee)
      throw Error(oe(425));
  }
  function zc() {
  }
  var Dh = null, wl = null;
  function kf(fe, ce) {
    return fe === "textarea" || fe === "noscript" || typeof ce.children == "string" || typeof ce.children == "number" || typeof ce.dangerouslySetInnerHTML == "object" && ce.dangerouslySetInnerHTML !== null && ce.dangerouslySetInnerHTML.__html != null;
  }
  var _l = typeof setTimeout == "function" ? setTimeout : void 0, tv = typeof clearTimeout == "function" ? clearTimeout : void 0, Oh = typeof Promise == "function" ? Promise : void 0, Lh = typeof queueMicrotask == "function" ? queueMicrotask : typeof Oh < "u" ? function(fe) {
    return Oh.resolve(null).then(fe).catch(Pg);
  } : _l;
  function Pg(fe) {
    setTimeout(function() {
      throw fe;
    });
  }
  function Ns(fe, ce) {
    var Ee = ce, Te = 0;
    do {
      var nt = Ee.nextSibling;
      if (fe.removeChild(Ee), nt && nt.nodeType === 8)
        if (Ee = nt.data, Ee === "/$") {
          if (Te === 0) {
            fe.removeChild(nt), Sl(ce);
            return;
          }
          Te--;
        } else
          Ee !== "$" && Ee !== "$?" && Ee !== "$!" || Te++;
      Ee = nt;
    } while (Ee);
    Sl(ce);
  }
  function Ro(fe) {
    for (; fe != null; fe = fe.nextSibling) {
      var ce = fe.nodeType;
      if (ce === 1 || ce === 3)
        break;
      if (ce === 8) {
        if (ce = fe.data, ce === "$" || ce === "$!" || ce === "$?")
          break;
        if (ce === "/$")
          return null;
      }
    }
    return fe;
  }
  function Mf(fe) {
    fe = fe.previousSibling;
    for (var ce = 0; fe; ) {
      if (fe.nodeType === 8) {
        var Ee = fe.data;
        if (Ee === "$" || Ee === "$!" || Ee === "$?") {
          if (ce === 0)
            return fe;
          ce--;
        } else
          Ee === "/$" && ce++;
      }
      fe = fe.previousSibling;
    }
    return null;
  }
  var zs = Math.random().toString(36).slice(2), Bo = "__reactFiber$" + zs, Al = "__reactProps$" + zs, fs = "__reactContainer$" + zs, $h = "__reactEvents$" + zs, Rg = "__reactListeners$" + zs, Ih = "__reactHandles$" + zs;
  function lo(fe) {
    var ce = fe[Bo];
    if (ce)
      return ce;
    for (var Ee = fe.parentNode; Ee; ) {
      if (ce = Ee[fs] || Ee[Bo]) {
        if (Ee = ce.alternate, ce.child !== null || Ee !== null && Ee.child !== null)
          for (fe = Mf(fe); fe !== null; ) {
            if (Ee = fe[Bo])
              return Ee;
            fe = Mf(fe);
          }
        return ce;
      }
      fe = Ee, Ee = fe.parentNode;
    }
    return null;
  }
  function Ff(fe) {
    return fe = fe[Bo] || fe[fs], !fe || fe.tag !== 5 && fe.tag !== 6 && fe.tag !== 13 && fe.tag !== 3 ? null : fe;
  }
  function Tu(fe) {
    if (fe.tag === 5 || fe.tag === 6)
      return fe.stateNode;
    throw Error(oe(33));
  }
  function Lr(fe) {
    return fe[Al] || null;
  }
  var Vs = [], On = -1;
  function Qr(fe) {
    return { current: fe };
  }
  function pn(fe) {
    0 > On || (fe.current = Vs[On], Vs[On] = null, On--);
  }
  function Sn(fe, ce) {
    On++, Vs[On] = fe.current, fe.current = ce;
  }
  var Ho = {}, Ur = Qr(Ho), si = Qr(!1), Aa = Ho;
  function uo(fe, ce) {
    var Ee = fe.type.contextTypes;
    if (!Ee)
      return Ho;
    var Te = fe.stateNode;
    if (Te && Te.__reactInternalMemoizedUnmaskedChildContext === ce)
      return Te.__reactInternalMemoizedMaskedChildContext;
    var nt = {}, ct;
    for (ct in Ee)
      nt[ct] = ce[ct];
    return Te && (fe = fe.stateNode, fe.__reactInternalMemoizedUnmaskedChildContext = ce, fe.__reactInternalMemoizedMaskedChildContext = nt), nt;
  }
  function jn(fe) {
    return fe = fe.childContextTypes, fe != null;
  }
  function fo() {
    pn(si), pn(Ur);
  }
  function Bs(fe, ce, Ee) {
    if (Ur.current !== Ho)
      throw Error(oe(168));
    Sn(Ur, ce), Sn(si, Ee);
  }
  function Df(fe, ce, Ee) {
    var Te = fe.stateNode;
    if (ce = ce.childContextTypes, typeof Te.getChildContext != "function")
      return Ee;
    Te = Te.getChildContext();
    for (var nt in Te)
      if (!(nt in ce))
        throw Error(oe(108, cn(fe) || "Unknown", nt));
    return Dt({}, Ee, Te);
  }
  function Vc(fe) {
    return fe = (fe = fe.stateNode) && fe.__reactInternalMemoizedMergedChildContext || Ho, Aa = Ur.current, Sn(Ur, fe), Sn(si, si.current), !0;
  }
  function rv(fe, ce, Ee) {
    var Te = fe.stateNode;
    if (!Te)
      throw Error(oe(169));
    Ee ? (fe = Df(fe, ce, Aa), Te.__reactInternalMemoizedMergedChildContext = fe, pn(si), pn(Ur), Sn(Ur, fe)) : pn(si), Sn(si, Ee);
  }
  var Ga = null, $i = !1, Of = !1;
  function Nh(fe) {
    Ga === null ? Ga = [fe] : Ga.push(fe);
  }
  function zh(fe) {
    $i = !0, Nh(fe);
  }
  function Pa() {
    if (!Of && Ga !== null) {
      Of = !0;
      var fe = 0, ce = un;
      try {
        var Ee = Ga;
        for (un = 1; fe < Ee.length; fe++) {
          var Te = Ee[fe];
          do
            Te = Te(!0);
          while (Te !== null);
        }
        Ga = null, $i = !1;
      } catch (nt) {
        throw Ga !== null && (Ga = Ga.slice(fe + 1)), mf(wo, Pa), nt;
      } finally {
        un = ce, Of = !1;
      }
    }
    return null;
  }
  var Hs = [], Ra = 0, Pl = null, wu = 0, ka = [], ea = 0, co = null, Ui = 1, cs = "";
  function Wa(fe, ce) {
    Hs[Ra++] = wu, Hs[Ra++] = Pl, Pl = fe, wu = ce;
  }
  function Vh(fe, ce, Ee) {
    ka[ea++] = Ui, ka[ea++] = cs, ka[ea++] = co, co = fe;
    var Te = Ui;
    fe = cs;
    var nt = 32 - Ta(Te) - 1;
    Te &= ~(1 << nt), Ee += 1;
    var ct = 32 - Ta(ce) + nt;
    if (30 < ct) {
      var bt = nt - nt % 5;
      ct = (Te & (1 << bt) - 1).toString(32), Te >>= bt, nt -= bt, Ui = 1 << 32 - Ta(ce) + nt | Ee << nt | Te, cs = ct + fe;
    } else
      Ui = 1 << ct | Ee << nt | Te, cs = fe;
  }
  function Bc(fe) {
    fe.return !== null && (Wa(fe, 1), Vh(fe, 1, 0));
  }
  function Bh(fe) {
    for (; fe === Pl; )
      Pl = Hs[--Ra], Hs[Ra] = null, wu = Hs[--Ra], Hs[Ra] = null;
    for (; fe === co; )
      co = ka[--ea], ka[ea] = null, cs = ka[--ea], ka[ea] = null, Ui = ka[--ea], ka[ea] = null;
  }
  var qa = null, Ma = null, Ln = !1, ho = null;
  function Hh(fe, ce) {
    var Ee = So(5, null, null, 0);
    Ee.elementType = "DELETED", Ee.stateNode = ce, Ee.return = fe, ce = fe.deletions, ce === null ? (fe.deletions = [Ee], fe.flags |= 16) : ce.push(Ee);
  }
  function nv(fe, ce) {
    switch (fe.tag) {
      case 5:
        var Ee = fe.type;
        return ce = ce.nodeType !== 1 || Ee.toLowerCase() !== ce.nodeName.toLowerCase() ? null : ce, ce !== null ? (fe.stateNode = ce, qa = fe, Ma = Ro(ce.firstChild), !0) : !1;
      case 6:
        return ce = fe.pendingProps === "" || ce.nodeType !== 3 ? null : ce, ce !== null ? (fe.stateNode = ce, qa = fe, Ma = null, !0) : !1;
      case 13:
        return ce = ce.nodeType !== 8 ? null : ce, ce !== null ? (Ee = co !== null ? { id: Ui, overflow: cs } : null, fe.memoizedState = { dehydrated: ce, treeContext: Ee, retryLane: 1073741824 }, Ee = So(18, null, null, 0), Ee.stateNode = ce, Ee.return = fe, fe.child = Ee, qa = fe, Ma = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Hc(fe) {
    return (fe.mode & 1) !== 0 && (fe.flags & 128) === 0;
  }
  function Uc(fe) {
    if (Ln) {
      var ce = Ma;
      if (ce) {
        var Ee = ce;
        if (!nv(fe, ce)) {
          if (Hc(fe))
            throw Error(oe(418));
          ce = Ro(Ee.nextSibling);
          var Te = qa;
          ce && nv(fe, ce) ? Hh(Te, Ee) : (fe.flags = fe.flags & -4097 | 2, Ln = !1, qa = fe);
        }
      } else {
        if (Hc(fe))
          throw Error(oe(418));
        fe.flags = fe.flags & -4097 | 2, Ln = !1, qa = fe;
      }
    }
  }
  function iv(fe) {
    for (fe = fe.return; fe !== null && fe.tag !== 5 && fe.tag !== 3 && fe.tag !== 13; )
      fe = fe.return;
    qa = fe;
  }
  function jc(fe) {
    if (fe !== qa)
      return !1;
    if (!Ln)
      return iv(fe), Ln = !0, !1;
    var ce;
    if ((ce = fe.tag !== 3) && !(ce = fe.tag !== 5) && (ce = fe.type, ce = ce !== "head" && ce !== "body" && !kf(fe.type, fe.memoizedProps)), ce && (ce = Ma)) {
      if (Hc(fe))
        throw av(), Error(oe(418));
      for (; ce; )
        Hh(fe, ce), ce = Ro(ce.nextSibling);
    }
    if (iv(fe), fe.tag === 13) {
      if (fe = fe.memoizedState, fe = fe !== null ? fe.dehydrated : null, !fe)
        throw Error(oe(317));
      e: {
        for (fe = fe.nextSibling, ce = 0; fe; ) {
          if (fe.nodeType === 8) {
            var Ee = fe.data;
            if (Ee === "/$") {
              if (ce === 0) {
                Ma = Ro(fe.nextSibling);
                break e;
              }
              ce--;
            } else
              Ee !== "$" && Ee !== "$!" && Ee !== "$?" || ce++;
          }
          fe = fe.nextSibling;
        }
        Ma = null;
      }
    } else
      Ma = qa ? Ro(fe.stateNode.nextSibling) : null;
    return !0;
  }
  function av() {
    for (var fe = Ma; fe; )
      fe = Ro(fe.nextSibling);
  }
  function qn() {
    Ma = qa = null, Ln = !1;
  }
  function Uh(fe) {
    ho === null ? ho = [fe] : ho.push(fe);
  }
  var Gc = vt.ReactCurrentBatchConfig;
  function Ya(fe, ce) {
    if (fe && fe.defaultProps) {
      ce = Dt({}, ce), fe = fe.defaultProps;
      for (var Ee in fe)
        ce[Ee] === void 0 && (ce[Ee] = fe[Ee]);
      return ce;
    }
    return ce;
  }
  var Uo = Qr(null), Wc = null, Us = null, jh = null;
  function Gh() {
    jh = Us = Wc = null;
  }
  function js(fe) {
    var ce = Uo.current;
    pn(Uo), fe._currentValue = ce;
  }
  function Ii(fe, ce, Ee) {
    for (; fe !== null; ) {
      var Te = fe.alternate;
      if ((fe.childLanes & ce) !== ce ? (fe.childLanes |= ce, Te !== null && (Te.childLanes |= ce)) : Te !== null && (Te.childLanes & ce) !== ce && (Te.childLanes |= ce), fe === Ee)
        break;
      fe = fe.return;
    }
  }
  function hr(fe, ce) {
    Wc = fe, jh = Us = null, fe = fe.dependencies, fe !== null && fe.firstContext !== null && (fe.lanes & ce && (yi = !0), fe.firstContext = null);
  }
  function ci(fe) {
    var ce = fe._currentValue;
    if (jh !== fe)
      if (fe = { context: fe, memoizedValue: ce, next: null }, Us === null) {
        if (Wc === null)
          throw Error(oe(308));
        Us = fe, Wc.dependencies = { lanes: 0, firstContext: fe };
      } else
        Us = Us.next = fe;
    return ce;
  }
  var ji = null;
  function Wh(fe) {
    ji === null ? ji = [fe] : ji.push(fe);
  }
  function ov(fe, ce, Ee, Te) {
    var nt = ce.interleaved;
    return nt === null ? (Ee.next = Ee, Wh(ce)) : (Ee.next = nt.next, nt.next = Ee), ce.interleaved = Ee, ds(fe, Te);
  }
  function ds(fe, ce) {
    fe.lanes |= ce;
    var Ee = fe.alternate;
    for (Ee !== null && (Ee.lanes |= ce), Ee = fe, fe = fe.return; fe !== null; )
      fe.childLanes |= ce, Ee = fe.alternate, Ee !== null && (Ee.childLanes |= ce), Ee = fe, fe = fe.return;
    return Ee.tag === 3 ? Ee.stateNode : null;
  }
  var Gs = !1;
  function qh(fe) {
    fe.updateQueue = { baseState: fe.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Ti(fe, ce) {
    fe = fe.updateQueue, ce.updateQueue === fe && (ce.updateQueue = { baseState: fe.baseState, firstBaseUpdate: fe.firstBaseUpdate, lastBaseUpdate: fe.lastBaseUpdate, shared: fe.shared, effects: fe.effects });
  }
  function hs(fe, ce) {
    return { eventTime: fe, lane: ce, tag: 0, payload: null, callback: null, next: null };
  }
  function Ws(fe, ce, Ee) {
    var Te = fe.updateQueue;
    if (Te === null)
      return null;
    if (Te = Te.shared, rn & 2) {
      var nt = Te.pending;
      return nt === null ? ce.next = ce : (ce.next = nt.next, nt.next = ce), Te.pending = ce, ds(fe, Ee);
    }
    return nt = Te.interleaved, nt === null ? (ce.next = ce, Wh(Te)) : (ce.next = nt.next, nt.next = ce), Te.interleaved = ce, ds(fe, Ee);
  }
  function qc(fe, ce, Ee) {
    if (ce = ce.updateQueue, ce !== null && (ce = ce.shared, (Ee & 4194240) !== 0)) {
      var Te = ce.lanes;
      Te &= fe.pendingLanes, Ee |= Te, ce.lanes = Ee, Ls(fe, Ee);
    }
  }
  function Yh(fe, ce) {
    var Ee = fe.updateQueue, Te = fe.alternate;
    if (Te !== null && (Te = Te.updateQueue, Ee === Te)) {
      var nt = null, ct = null;
      if (Ee = Ee.firstBaseUpdate, Ee !== null) {
        do {
          var bt = { eventTime: Ee.eventTime, lane: Ee.lane, tag: Ee.tag, payload: Ee.payload, callback: Ee.callback, next: null };
          ct === null ? nt = ct = bt : ct = ct.next = bt, Ee = Ee.next;
        } while (Ee !== null);
        ct === null ? nt = ct = ce : ct = ct.next = ce;
      } else
        nt = ct = ce;
      Ee = { baseState: Te.baseState, firstBaseUpdate: nt, lastBaseUpdate: ct, shared: Te.shared, effects: Te.effects }, fe.updateQueue = Ee;
      return;
    }
    fe = Ee.lastBaseUpdate, fe === null ? Ee.firstBaseUpdate = ce : fe.next = ce, Ee.lastBaseUpdate = ce;
  }
  function qs(fe, ce, Ee, Te) {
    var nt = fe.updateQueue;
    Gs = !1;
    var ct = nt.firstBaseUpdate, bt = nt.lastBaseUpdate, Mt = nt.shared.pending;
    if (Mt !== null) {
      nt.shared.pending = null;
      var Lt = Mt, qt = Lt.next;
      Lt.next = null, bt === null ? ct = qt : bt.next = qt, bt = Lt;
      var sr = fe.alternate;
      sr !== null && (sr = sr.updateQueue, Mt = sr.lastBaseUpdate, Mt !== bt && (Mt === null ? sr.firstBaseUpdate = qt : Mt.next = qt, sr.lastBaseUpdate = Lt));
    }
    if (ct !== null) {
      var lr = nt.baseState;
      bt = 0, sr = qt = Lt = null, Mt = ct;
      do {
        var or = Mt.lane, Er = Mt.eventTime;
        if ((Te & or) === or) {
          sr !== null && (sr = sr.next = {
            eventTime: Er,
            lane: 0,
            tag: Mt.tag,
            payload: Mt.payload,
            callback: Mt.callback,
            next: null
          });
          e: {
            var _r = fe, Rr = Mt;
            switch (or = ce, Er = Ee, Rr.tag) {
              case 1:
                if (_r = Rr.payload, typeof _r == "function") {
                  lr = _r.call(Er, lr, or);
                  break e;
                }
                lr = _r;
                break e;
              case 3:
                _r.flags = _r.flags & -65537 | 128;
              case 0:
                if (_r = Rr.payload, or = typeof _r == "function" ? _r.call(Er, lr, or) : _r, or == null)
                  break e;
                lr = Dt({}, lr, or);
                break e;
              case 2:
                Gs = !0;
            }
          }
          Mt.callback !== null && Mt.lane !== 0 && (fe.flags |= 64, or = nt.effects, or === null ? nt.effects = [Mt] : or.push(Mt));
        } else
          Er = { eventTime: Er, lane: or, tag: Mt.tag, payload: Mt.payload, callback: Mt.callback, next: null }, sr === null ? (qt = sr = Er, Lt = lr) : sr = sr.next = Er, bt |= or;
        if (Mt = Mt.next, Mt === null) {
          if (Mt = nt.shared.pending, Mt === null)
            break;
          or = Mt, Mt = or.next, or.next = null, nt.lastBaseUpdate = or, nt.shared.pending = null;
        }
      } while (!0);
      if (sr === null && (Lt = lr), nt.baseState = Lt, nt.firstBaseUpdate = qt, nt.lastBaseUpdate = sr, ce = nt.shared.interleaved, ce !== null) {
        nt = ce;
        do
          bt |= nt.lane, nt = nt.next;
        while (nt !== ce);
      } else
        ct === null && (nt.shared.lanes = 0);
      ys |= bt, fe.lanes = bt, fe.memoizedState = lr;
    }
  }
  function Rl(fe, ce, Ee) {
    if (fe = ce.effects, ce.effects = null, fe !== null)
      for (ce = 0; ce < fe.length; ce++) {
        var Te = fe[ce], nt = Te.callback;
        if (nt !== null) {
          if (Te.callback = null, Te = Ee, typeof nt != "function")
            throw Error(oe(191, nt));
          nt.call(Te);
        }
      }
  }
  var sv = new L.Component().refs;
  function Qh(fe, ce, Ee, Te) {
    ce = fe.memoizedState, Ee = Ee(Te, ce), Ee = Ee == null ? ce : Dt({}, ce, Ee), fe.memoizedState = Ee, fe.lanes === 0 && (fe.updateQueue.baseState = Ee);
  }
  var Yc = { isMounted: function(fe) {
    return (fe = fe._reactInternals) ? ro(fe) === fe : !1;
  }, enqueueSetState: function(fe, ce, Ee) {
    fe = fe._reactInternals;
    var Te = ia(), nt = gi(fe), ct = hs(Te, nt);
    ct.payload = ce, Ee != null && (ct.callback = Ee), ce = Ws(fe, ct, nt), ce !== null && (aa(ce, fe, nt, Te), qc(ce, fe, nt));
  }, enqueueReplaceState: function(fe, ce, Ee) {
    fe = fe._reactInternals;
    var Te = ia(), nt = gi(fe), ct = hs(Te, nt);
    ct.tag = 1, ct.payload = ce, Ee != null && (ct.callback = Ee), ce = Ws(fe, ct, nt), ce !== null && (aa(ce, fe, nt, Te), qc(ce, fe, nt));
  }, enqueueForceUpdate: function(fe, ce) {
    fe = fe._reactInternals;
    var Ee = ia(), Te = gi(fe), nt = hs(Ee, Te);
    nt.tag = 2, ce != null && (nt.callback = ce), ce = Ws(fe, nt, Te), ce !== null && (aa(ce, fe, Te, Ee), qc(ce, fe, Te));
  } };
  function lv(fe, ce, Ee, Te, nt, ct, bt) {
    return fe = fe.stateNode, typeof fe.shouldComponentUpdate == "function" ? fe.shouldComponentUpdate(Te, ct, bt) : ce.prototype && ce.prototype.isPureReactComponent ? !Cf(Ee, Te) || !Cf(nt, ct) : !0;
  }
  function uv(fe, ce, Ee) {
    var Te = !1, nt = Ho, ct = ce.contextType;
    return typeof ct == "object" && ct !== null ? ct = ci(ct) : (nt = jn(ce) ? Aa : Ur.current, Te = ce.contextTypes, ct = (Te = Te != null) ? uo(fe, nt) : Ho), ce = new ce(Ee, ct), fe.memoizedState = ce.state !== null && ce.state !== void 0 ? ce.state : null, ce.updater = Yc, fe.stateNode = ce, ce._reactInternals = fe, Te && (fe = fe.stateNode, fe.__reactInternalMemoizedUnmaskedChildContext = nt, fe.__reactInternalMemoizedMaskedChildContext = ct), ce;
  }
  function fv(fe, ce, Ee, Te) {
    fe = ce.state, typeof ce.componentWillReceiveProps == "function" && ce.componentWillReceiveProps(Ee, Te), typeof ce.UNSAFE_componentWillReceiveProps == "function" && ce.UNSAFE_componentWillReceiveProps(Ee, Te), ce.state !== fe && Yc.enqueueReplaceState(ce, ce.state, null);
  }
  function Qc(fe, ce, Ee, Te) {
    var nt = fe.stateNode;
    nt.props = Ee, nt.state = fe.memoizedState, nt.refs = sv, qh(fe);
    var ct = ce.contextType;
    typeof ct == "object" && ct !== null ? nt.context = ci(ct) : (ct = jn(ce) ? Aa : Ur.current, nt.context = uo(fe, ct)), nt.state = fe.memoizedState, ct = ce.getDerivedStateFromProps, typeof ct == "function" && (Qh(fe, ce, ct, Ee), nt.state = fe.memoizedState), typeof ce.getDerivedStateFromProps == "function" || typeof nt.getSnapshotBeforeUpdate == "function" || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || (ce = nt.state, typeof nt.componentWillMount == "function" && nt.componentWillMount(), typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount(), ce !== nt.state && Yc.enqueueReplaceState(nt, nt.state, null), qs(fe, Ee, nt, Te), nt.state = fe.memoizedState), typeof nt.componentDidMount == "function" && (fe.flags |= 4194308);
  }
  function _u(fe, ce, Ee) {
    if (fe = Ee.ref, fe !== null && typeof fe != "function" && typeof fe != "object") {
      if (Ee._owner) {
        if (Ee = Ee._owner, Ee) {
          if (Ee.tag !== 1)
            throw Error(oe(309));
          var Te = Ee.stateNode;
        }
        if (!Te)
          throw Error(oe(147, fe));
        var nt = Te, ct = "" + fe;
        return ce !== null && ce.ref !== null && typeof ce.ref == "function" && ce.ref._stringRef === ct ? ce.ref : (ce = function(bt) {
          var Mt = nt.refs;
          Mt === sv && (Mt = nt.refs = {}), bt === null ? delete Mt[ct] : Mt[ct] = bt;
        }, ce._stringRef = ct, ce);
      }
      if (typeof fe != "string")
        throw Error(oe(284));
      if (!Ee._owner)
        throw Error(oe(290, fe));
    }
    return fe;
  }
  function Xc(fe, ce) {
    throw fe = Object.prototype.toString.call(ce), Error(oe(31, fe === "[object Object]" ? "object with keys {" + Object.keys(ce).join(", ") + "}" : fe));
  }
  function cv(fe) {
    var ce = fe._init;
    return ce(fe._payload);
  }
  function dv(fe) {
    function ce(Bt, It) {
      if (fe) {
        var jt = Bt.deletions;
        jt === null ? (Bt.deletions = [It], Bt.flags |= 16) : jt.push(It);
      }
    }
    function Ee(Bt, It) {
      if (!fe)
        return null;
      for (; It !== null; )
        ce(Bt, It), It = It.sibling;
      return null;
    }
    function Te(Bt, It) {
      for (Bt = /* @__PURE__ */ new Map(); It !== null; )
        It.key !== null ? Bt.set(It.key, It) : Bt.set(It.index, It), It = It.sibling;
      return Bt;
    }
    function nt(Bt, It) {
      return Bt = tl(Bt, It), Bt.index = 0, Bt.sibling = null, Bt;
    }
    function ct(Bt, It, jt) {
      return Bt.index = jt, fe ? (jt = Bt.alternate, jt !== null ? (jt = jt.index, jt < It ? (Bt.flags |= 2, It) : jt) : (Bt.flags |= 2, It)) : (Bt.flags |= 1048576, It);
    }
    function bt(Bt) {
      return fe && Bt.alternate === null && (Bt.flags |= 2), Bt;
    }
    function Mt(Bt, It, jt, cr) {
      return It === null || It.tag !== 6 ? (It = Zf(jt, Bt.mode, cr), It.return = Bt, It) : (It = nt(It, jt), It.return = Bt, It);
    }
    function Lt(Bt, It, jt, cr) {
      var Mr = jt.type;
      return Mr === At ? sr(Bt, It, jt.props.children, cr, jt.key) : It !== null && (It.elementType === Mr || typeof Mr == "object" && Mr !== null && Mr.$$typeof === wt && cv(Mr) === It.type) ? (cr = nt(It, jt.props), cr.ref = _u(Bt, It, jt), cr.return = Bt, cr) : (cr = Pd(jt.type, jt.key, jt.props, null, Bt.mode, cr), cr.ref = _u(Bt, It, jt), cr.return = Bt, cr);
    }
    function qt(Bt, It, jt, cr) {
      return It === null || It.tag !== 4 || It.stateNode.containerInfo !== jt.containerInfo || It.stateNode.implementation !== jt.implementation ? (It = Yl(jt, Bt.mode, cr), It.return = Bt, It) : (It = nt(It, jt.children || []), It.return = Bt, It);
    }
    function sr(Bt, It, jt, cr, Mr) {
      return It === null || It.tag !== 7 ? (It = ql(jt, Bt.mode, cr, Mr), It.return = Bt, It) : (It = nt(It, jt), It.return = Bt, It);
    }
    function lr(Bt, It, jt) {
      if (typeof It == "string" && It !== "" || typeof It == "number")
        return It = Zf("" + It, Bt.mode, jt), It.return = Bt, It;
      if (typeof It == "object" && It !== null) {
        switch (It.$$typeof) {
          case xt:
            return jt = Pd(It.type, It.key, It.props, null, Bt.mode, jt), jt.ref = _u(Bt, null, It), jt.return = Bt, jt;
          case Ct:
            return It = Yl(It, Bt.mode, jt), It.return = Bt, It;
          case wt:
            var cr = It._init;
            return lr(Bt, cr(It._payload), jt);
        }
        if (Ei(It) || Et(It))
          return It = ql(It, Bt.mode, jt, null), It.return = Bt, It;
        Xc(Bt, It);
      }
      return null;
    }
    function or(Bt, It, jt, cr) {
      var Mr = It !== null ? It.key : null;
      if (typeof jt == "string" && jt !== "" || typeof jt == "number")
        return Mr !== null ? null : Mt(Bt, It, "" + jt, cr);
      if (typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case xt:
            return jt.key === Mr ? Lt(Bt, It, jt, cr) : null;
          case Ct:
            return jt.key === Mr ? qt(Bt, It, jt, cr) : null;
          case wt:
            return Mr = jt._init, or(
              Bt,
              It,
              Mr(jt._payload),
              cr
            );
        }
        if (Ei(jt) || Et(jt))
          return Mr !== null ? null : sr(Bt, It, jt, cr, null);
        Xc(Bt, jt);
      }
      return null;
    }
    function Er(Bt, It, jt, cr, Mr) {
      if (typeof cr == "string" && cr !== "" || typeof cr == "number")
        return Bt = Bt.get(jt) || null, Mt(It, Bt, "" + cr, Mr);
      if (typeof cr == "object" && cr !== null) {
        switch (cr.$$typeof) {
          case xt:
            return Bt = Bt.get(cr.key === null ? jt : cr.key) || null, Lt(It, Bt, cr, Mr);
          case Ct:
            return Bt = Bt.get(cr.key === null ? jt : cr.key) || null, qt(It, Bt, cr, Mr);
          case wt:
            var Ar = cr._init;
            return Er(Bt, It, jt, Ar(cr._payload), Mr);
        }
        if (Ei(cr) || Et(cr))
          return Bt = Bt.get(jt) || null, sr(It, Bt, cr, Mr, null);
        Xc(It, cr);
      }
      return null;
    }
    function _r(Bt, It, jt, cr) {
      for (var Mr = null, Ar = null, Or = It, jr = It = 0, Vi = null; Or !== null && jr < jt.length; jr++) {
        Or.index > jr ? (Vi = Or, Or = null) : Vi = Or.sibling;
        var fn = or(Bt, Or, jt[jr], cr);
        if (fn === null) {
          Or === null && (Or = Vi);
          break;
        }
        fe && Or && fn.alternate === null && ce(Bt, Or), It = ct(fn, It, jr), Ar === null ? Mr = fn : Ar.sibling = fn, Ar = fn, Or = Vi;
      }
      if (jr === jt.length)
        return Ee(Bt, Or), Ln && Wa(Bt, jr), Mr;
      if (Or === null) {
        for (; jr < jt.length; jr++)
          Or = lr(Bt, jt[jr], cr), Or !== null && (It = ct(Or, It, jr), Ar === null ? Mr = Or : Ar.sibling = Or, Ar = Or);
        return Ln && Wa(Bt, jr), Mr;
      }
      for (Or = Te(Bt, Or); jr < jt.length; jr++)
        Vi = Er(Or, Bt, jr, jt[jr], cr), Vi !== null && (fe && Vi.alternate !== null && Or.delete(Vi.key === null ? jr : Vi.key), It = ct(Vi, It, jr), Ar === null ? Mr = Vi : Ar.sibling = Vi, Ar = Vi);
      return fe && Or.forEach(function(rl) {
        return ce(Bt, rl);
      }), Ln && Wa(Bt, jr), Mr;
    }
    function Rr(Bt, It, jt, cr) {
      var Mr = Et(jt);
      if (typeof Mr != "function")
        throw Error(oe(150));
      if (jt = Mr.call(jt), jt == null)
        throw Error(oe(151));
      for (var Ar = Mr = null, Or = It, jr = It = 0, Vi = null, fn = jt.next(); Or !== null && !fn.done; jr++, fn = jt.next()) {
        Or.index > jr ? (Vi = Or, Or = null) : Vi = Or.sibling;
        var rl = or(Bt, Or, fn.value, cr);
        if (rl === null) {
          Or === null && (Or = Vi);
          break;
        }
        fe && Or && rl.alternate === null && ce(Bt, Or), It = ct(rl, It, jr), Ar === null ? Mr = rl : Ar.sibling = rl, Ar = rl, Or = Vi;
      }
      if (fn.done)
        return Ee(
          Bt,
          Or
        ), Ln && Wa(Bt, jr), Mr;
      if (Or === null) {
        for (; !fn.done; jr++, fn = jt.next())
          fn = lr(Bt, fn.value, cr), fn !== null && (It = ct(fn, It, jr), Ar === null ? Mr = fn : Ar.sibling = fn, Ar = fn);
        return Ln && Wa(Bt, jr), Mr;
      }
      for (Or = Te(Bt, Or); !fn.done; jr++, fn = jt.next())
        fn = Er(Or, Bt, jr, fn.value, cr), fn !== null && (fe && fn.alternate !== null && Or.delete(fn.key === null ? jr : fn.key), It = ct(fn, It, jr), Ar === null ? Mr = fn : Ar.sibling = fn, Ar = fn);
      return fe && Or.forEach(function(Qg) {
        return ce(Bt, Qg);
      }), Ln && Wa(Bt, jr), Mr;
    }
    function di(Bt, It, jt, cr) {
      if (typeof jt == "object" && jt !== null && jt.type === At && jt.key === null && (jt = jt.props.children), typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case xt:
            e: {
              for (var Mr = jt.key, Ar = It; Ar !== null; ) {
                if (Ar.key === Mr) {
                  if (Mr = jt.type, Mr === At) {
                    if (Ar.tag === 7) {
                      Ee(Bt, Ar.sibling), It = nt(Ar, jt.props.children), It.return = Bt, Bt = It;
                      break e;
                    }
                  } else if (Ar.elementType === Mr || typeof Mr == "object" && Mr !== null && Mr.$$typeof === wt && cv(Mr) === Ar.type) {
                    Ee(Bt, Ar.sibling), It = nt(Ar, jt.props), It.ref = _u(Bt, Ar, jt), It.return = Bt, Bt = It;
                    break e;
                  }
                  Ee(Bt, Ar);
                  break;
                } else
                  ce(Bt, Ar);
                Ar = Ar.sibling;
              }
              jt.type === At ? (It = ql(jt.props.children, Bt.mode, cr, jt.key), It.return = Bt, Bt = It) : (cr = Pd(jt.type, jt.key, jt.props, null, Bt.mode, cr), cr.ref = _u(Bt, It, jt), cr.return = Bt, Bt = cr);
            }
            return bt(Bt);
          case Ct:
            e: {
              for (Ar = jt.key; It !== null; ) {
                if (It.key === Ar)
                  if (It.tag === 4 && It.stateNode.containerInfo === jt.containerInfo && It.stateNode.implementation === jt.implementation) {
                    Ee(Bt, It.sibling), It = nt(It, jt.children || []), It.return = Bt, Bt = It;
                    break e;
                  } else {
                    Ee(Bt, It);
                    break;
                  }
                else
                  ce(Bt, It);
                It = It.sibling;
              }
              It = Yl(jt, Bt.mode, cr), It.return = Bt, Bt = It;
            }
            return bt(Bt);
          case wt:
            return Ar = jt._init, di(Bt, It, Ar(jt._payload), cr);
        }
        if (Ei(jt))
          return _r(Bt, It, jt, cr);
        if (Et(jt))
          return Rr(Bt, It, jt, cr);
        Xc(Bt, jt);
      }
      return typeof jt == "string" && jt !== "" || typeof jt == "number" ? (jt = "" + jt, It !== null && It.tag === 6 ? (Ee(Bt, It.sibling), It = nt(It, jt), It.return = Bt, Bt = It) : (Ee(Bt, It), It = Zf(jt, Bt.mode, cr), It.return = Bt, Bt = It), bt(Bt)) : Ee(Bt, It);
    }
    return di;
  }
  var Au = dv(!0), hv = dv(!1), Lf = {}, ko = Qr(Lf), $f = Qr(Lf), Pu = Qr(Lf);
  function kl(fe) {
    if (fe === Lf)
      throw Error(oe(174));
    return fe;
  }
  function Xh(fe, ce) {
    switch (Sn(Pu, ce), Sn($f, fe), Sn(ko, Lf), fe = ce.nodeType, fe) {
      case 9:
      case 11:
        ce = (ce = ce.documentElement) ? ce.namespaceURI : wn(null, "");
        break;
      default:
        fe = fe === 8 ? ce.parentNode : ce, ce = fe.namespaceURI || null, fe = fe.tagName, ce = wn(ce, fe);
    }
    pn(ko), Sn(ko, ce);
  }
  function Ys() {
    pn(ko), pn($f), pn(Pu);
  }
  function zr(fe) {
    kl(Pu.current);
    var ce = kl(ko.current), Ee = wn(ce, fe.type);
    ce !== Ee && (Sn($f, fe), Sn(ko, Ee));
  }
  function Zr(fe) {
    $f.current === fe && (pn(ko), pn($f));
  }
  var Vr = Qr(0);
  function Yn(fe) {
    for (var ce = fe; ce !== null; ) {
      if (ce.tag === 13) {
        var Ee = ce.memoizedState;
        if (Ee !== null && (Ee = Ee.dehydrated, Ee === null || Ee.data === "$?" || Ee.data === "$!"))
          return ce;
      } else if (ce.tag === 19 && ce.memoizedProps.revealOrder !== void 0) {
        if (ce.flags & 128)
          return ce;
      } else if (ce.child !== null) {
        ce.child.return = ce, ce = ce.child;
        continue;
      }
      if (ce === fe)
        break;
      for (; ce.sibling === null; ) {
        if (ce.return === null || ce.return === fe)
          return null;
        ce = ce.return;
      }
      ce.sibling.return = ce.return, ce = ce.sibling;
    }
    return null;
  }
  var po = [];
  function Kc() {
    for (var fe = 0; fe < po.length; fe++)
      po[fe]._workInProgressVersionPrimary = null;
    po.length = 0;
  }
  var Jc = vt.ReactCurrentDispatcher, Kh = vt.ReactCurrentBatchConfig, Ml = 0, $n = null, Zt = null, on = null, Br = !1, jo = !1, Qa = 0, Fl = 0;
  function In() {
    throw Error(oe(321));
  }
  function Dl(fe, ce) {
    if (ce === null)
      return !1;
    for (var Ee = 0; Ee < ce.length && Ee < fe.length; Ee++)
      if (!so(fe[Ee], ce[Ee]))
        return !1;
    return !0;
  }
  function Qs(fe, ce, Ee, Te, nt, ct) {
    if (Ml = ct, $n = ce, ce.memoizedState = null, ce.updateQueue = null, ce.lanes = 0, Jc.current = fe === null || fe.memoizedState === null ? Mg : Fg, fe = Ee(Te, nt), jo) {
      ct = 0;
      do {
        if (jo = !1, Qa = 0, 25 <= ct)
          throw Error(oe(301));
        ct += 1, on = Zt = null, ce.updateQueue = null, Jc.current = Zh, fe = Ee(Te, nt);
      } while (jo);
    }
    if (Jc.current = pd, ce = Zt !== null && Zt.next !== null, Ml = 0, on = Zt = $n = null, Br = !1, ce)
      throw Error(oe(300));
    return fe;
  }
  function Ol() {
    var fe = Qa !== 0;
    return Qa = 0, fe;
  }
  function mo() {
    var fe = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return on === null ? $n.memoizedState = on = fe : on = on.next = fe, on;
  }
  function Fa() {
    if (Zt === null) {
      var fe = $n.alternate;
      fe = fe !== null ? fe.memoizedState : null;
    } else
      fe = Zt.next;
    var ce = on === null ? $n.memoizedState : on.next;
    if (ce !== null)
      on = ce, Zt = fe;
    else {
      if (fe === null)
        throw Error(oe(310));
      Zt = fe, fe = { memoizedState: Zt.memoizedState, baseState: Zt.baseState, baseQueue: Zt.baseQueue, queue: Zt.queue, next: null }, on === null ? $n.memoizedState = on = fe : on = on.next = fe;
    }
    return on;
  }
  function Ll(fe, ce) {
    return typeof ce == "function" ? ce(fe) : ce;
  }
  function If(fe) {
    var ce = Fa(), Ee = ce.queue;
    if (Ee === null)
      throw Error(oe(311));
    Ee.lastRenderedReducer = fe;
    var Te = Zt, nt = Te.baseQueue, ct = Ee.pending;
    if (ct !== null) {
      if (nt !== null) {
        var bt = nt.next;
        nt.next = ct.next, ct.next = bt;
      }
      Te.baseQueue = nt = ct, Ee.pending = null;
    }
    if (nt !== null) {
      ct = nt.next, Te = Te.baseState;
      var Mt = bt = null, Lt = null, qt = ct;
      do {
        var sr = qt.lane;
        if ((Ml & sr) === sr)
          Lt !== null && (Lt = Lt.next = { lane: 0, action: qt.action, hasEagerState: qt.hasEagerState, eagerState: qt.eagerState, next: null }), Te = qt.hasEagerState ? qt.eagerState : fe(Te, qt.action);
        else {
          var lr = {
            lane: sr,
            action: qt.action,
            hasEagerState: qt.hasEagerState,
            eagerState: qt.eagerState,
            next: null
          };
          Lt === null ? (Mt = Lt = lr, bt = Te) : Lt = Lt.next = lr, $n.lanes |= sr, ys |= sr;
        }
        qt = qt.next;
      } while (qt !== null && qt !== ct);
      Lt === null ? bt = Te : Lt.next = Mt, so(Te, ce.memoizedState) || (yi = !0), ce.memoizedState = Te, ce.baseState = bt, ce.baseQueue = Lt, Ee.lastRenderedState = Te;
    }
    if (fe = Ee.interleaved, fe !== null) {
      nt = fe;
      do
        ct = nt.lane, $n.lanes |= ct, ys |= ct, nt = nt.next;
      while (nt !== fe);
    } else
      nt === null && (Ee.lanes = 0);
    return [ce.memoizedState, Ee.dispatch];
  }
  function Nf(fe) {
    var ce = Fa(), Ee = ce.queue;
    if (Ee === null)
      throw Error(oe(311));
    Ee.lastRenderedReducer = fe;
    var Te = Ee.dispatch, nt = Ee.pending, ct = ce.memoizedState;
    if (nt !== null) {
      Ee.pending = null;
      var bt = nt = nt.next;
      do
        ct = fe(ct, bt.action), bt = bt.next;
      while (bt !== nt);
      so(ct, ce.memoizedState) || (yi = !0), ce.memoizedState = ct, ce.baseQueue === null && (ce.baseState = ct), Ee.lastRenderedState = ct;
    }
    return [ct, Te];
  }
  function Zc() {
  }
  function ed(fe, ce) {
    var Ee = $n, Te = Fa(), nt = ce(), ct = !so(Te.memoizedState, nt);
    if (ct && (Te.memoizedState = nt, yi = !0), Te = Te.queue, zf(nd.bind(null, Ee, Te, fe), [fe]), Te.getSnapshot !== ce || ct || on !== null && on.memoizedState.tag & 1) {
      if (Ee.flags |= 2048, $l(9, rd.bind(null, Ee, Te, nt, ce), void 0, null), Qn === null)
        throw Error(oe(349));
      Ml & 30 || td(Ee, ce, nt);
    }
    return nt;
  }
  function td(fe, ce, Ee) {
    fe.flags |= 16384, fe = { getSnapshot: ce, value: Ee }, ce = $n.updateQueue, ce === null ? (ce = { lastEffect: null, stores: null }, $n.updateQueue = ce, ce.stores = [fe]) : (Ee = ce.stores, Ee === null ? ce.stores = [fe] : Ee.push(fe));
  }
  function rd(fe, ce, Ee, Te) {
    ce.value = Ee, ce.getSnapshot = Te, id(ce) && ad(fe);
  }
  function nd(fe, ce, Ee) {
    return Ee(function() {
      id(ce) && ad(fe);
    });
  }
  function id(fe) {
    var ce = fe.getSnapshot;
    fe = fe.value;
    try {
      var Ee = ce();
      return !so(fe, Ee);
    } catch {
      return !0;
    }
  }
  function ad(fe) {
    var ce = ds(fe, 1);
    ce !== null && aa(ce, fe, 1, -1);
  }
  function od(fe) {
    var ce = mo();
    return typeof fe == "function" && (fe = fe()), ce.memoizedState = ce.baseState = fe, fe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ll, lastRenderedState: fe }, ce.queue = fe, fe = fe.dispatch = hd.bind(null, $n, fe), [ce.memoizedState, fe];
  }
  function $l(fe, ce, Ee, Te) {
    return fe = { tag: fe, create: ce, destroy: Ee, deps: Te, next: null }, ce = $n.updateQueue, ce === null ? (ce = { lastEffect: null, stores: null }, $n.updateQueue = ce, ce.lastEffect = fe.next = fe) : (Ee = ce.lastEffect, Ee === null ? ce.lastEffect = fe.next = fe : (Te = Ee.next, Ee.next = fe, fe.next = Te, ce.lastEffect = fe)), fe;
  }
  function sd() {
    return Fa().memoizedState;
  }
  function Il(fe, ce, Ee, Te) {
    var nt = mo();
    $n.flags |= fe, nt.memoizedState = $l(1 | ce, Ee, void 0, Te === void 0 ? null : Te);
  }
  function ps(fe, ce, Ee, Te) {
    var nt = Fa();
    Te = Te === void 0 ? null : Te;
    var ct = void 0;
    if (Zt !== null) {
      var bt = Zt.memoizedState;
      if (ct = bt.destroy, Te !== null && Dl(Te, bt.deps)) {
        nt.memoizedState = $l(ce, Ee, ct, Te);
        return;
      }
    }
    $n.flags |= fe, nt.memoizedState = $l(1 | ce, Ee, ct, Te);
  }
  function ld(fe, ce) {
    return Il(8390656, 8, fe, ce);
  }
  function zf(fe, ce) {
    return ps(2048, 8, fe, ce);
  }
  function ud(fe, ce) {
    return ps(4, 2, fe, ce);
  }
  function fd(fe, ce) {
    return ps(4, 4, fe, ce);
  }
  function Jh(fe, ce) {
    if (typeof ce == "function")
      return fe = fe(), ce(fe), function() {
        ce(null);
      };
    if (ce != null)
      return fe = fe(), ce.current = fe, function() {
        ce.current = null;
      };
  }
  function Ru(fe, ce, Ee) {
    return Ee = Ee != null ? Ee.concat([fe]) : null, ps(4, 4, Jh.bind(null, ce, fe), Ee);
  }
  function cd() {
  }
  function ku(fe, ce) {
    var Ee = Fa();
    ce = ce === void 0 ? null : ce;
    var Te = Ee.memoizedState;
    return Te !== null && ce !== null && Dl(ce, Te[1]) ? Te[0] : (Ee.memoizedState = [fe, ce], fe);
  }
  function Xs(fe, ce) {
    var Ee = Fa();
    ce = ce === void 0 ? null : ce;
    var Te = Ee.memoizedState;
    return Te !== null && ce !== null && Dl(ce, Te[1]) ? Te[0] : (fe = fe(), Ee.memoizedState = [fe, ce], fe);
  }
  function Da(fe, ce, Ee) {
    return Ml & 21 ? (so(Ee, ce) || (Ee = pu(), $n.lanes |= Ee, ys |= Ee, fe.baseState = !0), ce) : (fe.baseState && (fe.baseState = !1, yi = !0), fe.memoizedState = Ee);
  }
  function kg(fe, ce) {
    var Ee = un;
    un = Ee !== 0 && 4 > Ee ? Ee : 4, fe(!0);
    var Te = Kh.transition;
    Kh.transition = {};
    try {
      fe(!1), ce();
    } finally {
      un = Ee, Kh.transition = Te;
    }
  }
  function Rn() {
    return Fa().memoizedState;
  }
  function dd(fe, ce, Ee) {
    var Te = gi(fe);
    if (Ee = { lane: Te, action: Ee, hasEagerState: !1, eagerState: null, next: null }, Mu(fe))
      Vf(ce, Ee);
    else if (Ee = ov(fe, ce, Ee, Te), Ee !== null) {
      var nt = ia();
      aa(Ee, fe, Te, nt), pv(Ee, ce, Te);
    }
  }
  function hd(fe, ce, Ee) {
    var Te = gi(fe), nt = { lane: Te, action: Ee, hasEagerState: !1, eagerState: null, next: null };
    if (Mu(fe))
      Vf(ce, nt);
    else {
      var ct = fe.alternate;
      if (fe.lanes === 0 && (ct === null || ct.lanes === 0) && (ct = ce.lastRenderedReducer, ct !== null))
        try {
          var bt = ce.lastRenderedState, Mt = ct(bt, Ee);
          if (nt.hasEagerState = !0, nt.eagerState = Mt, so(Mt, bt)) {
            var Lt = ce.interleaved;
            Lt === null ? (nt.next = nt, Wh(ce)) : (nt.next = Lt.next, Lt.next = nt), ce.interleaved = nt;
            return;
          }
        } catch {
        } finally {
        }
      Ee = ov(fe, ce, nt, Te), Ee !== null && (nt = ia(), aa(Ee, fe, Te, nt), pv(Ee, ce, Te));
    }
  }
  function Mu(fe) {
    var ce = fe.alternate;
    return fe === $n || ce !== null && ce === $n;
  }
  function Vf(fe, ce) {
    jo = Br = !0;
    var Ee = fe.pending;
    Ee === null ? ce.next = ce : (ce.next = Ee.next, Ee.next = ce), fe.pending = ce;
  }
  function pv(fe, ce, Ee) {
    if (Ee & 4194240) {
      var Te = ce.lanes;
      Te &= fe.pendingLanes, Ee |= Te, ce.lanes = Ee, Ls(fe, Ee);
    }
  }
  var pd = { readContext: ci, useCallback: In, useContext: In, useEffect: In, useImperativeHandle: In, useInsertionEffect: In, useLayoutEffect: In, useMemo: In, useReducer: In, useRef: In, useState: In, useDebugValue: In, useDeferredValue: In, useTransition: In, useMutableSource: In, useSyncExternalStore: In, useId: In, unstable_isNewReconciler: !1 }, Mg = { readContext: ci, useCallback: function(fe, ce) {
    return mo().memoizedState = [fe, ce === void 0 ? null : ce], fe;
  }, useContext: ci, useEffect: ld, useImperativeHandle: function(fe, ce, Ee) {
    return Ee = Ee != null ? Ee.concat([fe]) : null, Il(
      4194308,
      4,
      Jh.bind(null, ce, fe),
      Ee
    );
  }, useLayoutEffect: function(fe, ce) {
    return Il(4194308, 4, fe, ce);
  }, useInsertionEffect: function(fe, ce) {
    return Il(4, 2, fe, ce);
  }, useMemo: function(fe, ce) {
    var Ee = mo();
    return ce = ce === void 0 ? null : ce, fe = fe(), Ee.memoizedState = [fe, ce], fe;
  }, useReducer: function(fe, ce, Ee) {
    var Te = mo();
    return ce = Ee !== void 0 ? Ee(ce) : ce, Te.memoizedState = Te.baseState = ce, fe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: fe, lastRenderedState: ce }, Te.queue = fe, fe = fe.dispatch = dd.bind(null, $n, fe), [Te.memoizedState, fe];
  }, useRef: function(fe) {
    var ce = mo();
    return fe = { current: fe }, ce.memoizedState = fe;
  }, useState: od, useDebugValue: cd, useDeferredValue: function(fe) {
    return mo().memoizedState = fe;
  }, useTransition: function() {
    var fe = od(!1), ce = fe[0];
    return fe = kg.bind(null, fe[1]), mo().memoizedState = fe, [ce, fe];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(fe, ce, Ee) {
    var Te = $n, nt = mo();
    if (Ln) {
      if (Ee === void 0)
        throw Error(oe(407));
      Ee = Ee();
    } else {
      if (Ee = ce(), Qn === null)
        throw Error(oe(349));
      Ml & 30 || td(Te, ce, Ee);
    }
    nt.memoizedState = Ee;
    var ct = { value: Ee, getSnapshot: ce };
    return nt.queue = ct, ld(nd.bind(
      null,
      Te,
      ct,
      fe
    ), [fe]), Te.flags |= 2048, $l(9, rd.bind(null, Te, ct, Ee, ce), void 0, null), Ee;
  }, useId: function() {
    var fe = mo(), ce = Qn.identifierPrefix;
    if (Ln) {
      var Ee = cs, Te = Ui;
      Ee = (Te & ~(1 << 32 - Ta(Te) - 1)).toString(32) + Ee, ce = ":" + ce + "R" + Ee, Ee = Qa++, 0 < Ee && (ce += "H" + Ee.toString(32)), ce += ":";
    } else
      Ee = Fl++, ce = ":" + ce + "r" + Ee.toString(32) + ":";
    return fe.memoizedState = ce;
  }, unstable_isNewReconciler: !1 }, Fg = {
    readContext: ci,
    useCallback: ku,
    useContext: ci,
    useEffect: zf,
    useImperativeHandle: Ru,
    useInsertionEffect: ud,
    useLayoutEffect: fd,
    useMemo: Xs,
    useReducer: If,
    useRef: sd,
    useState: function() {
      return If(Ll);
    },
    useDebugValue: cd,
    useDeferredValue: function(fe) {
      var ce = Fa();
      return Da(ce, Zt.memoizedState, fe);
    },
    useTransition: function() {
      var fe = If(Ll)[0], ce = Fa().memoizedState;
      return [fe, ce];
    },
    useMutableSource: Zc,
    useSyncExternalStore: ed,
    useId: Rn,
    unstable_isNewReconciler: !1
  }, Zh = { readContext: ci, useCallback: ku, useContext: ci, useEffect: zf, useImperativeHandle: Ru, useInsertionEffect: ud, useLayoutEffect: fd, useMemo: Xs, useReducer: Nf, useRef: sd, useState: function() {
    return Nf(Ll);
  }, useDebugValue: cd, useDeferredValue: function(fe) {
    var ce = Fa();
    return Zt === null ? ce.memoizedState = fe : Da(ce, Zt.memoizedState, fe);
  }, useTransition: function() {
    var fe = Nf(Ll)[0], ce = Fa().memoizedState;
    return [fe, ce];
  }, useMutableSource: Zc, useSyncExternalStore: ed, useId: Rn, unstable_isNewReconciler: !1 };
  function Fu(fe, ce) {
    try {
      var Ee = "", Te = ce;
      do
        Ee += Tr(Te), Te = Te.return;
      while (Te);
      var nt = Ee;
    } catch (ct) {
      nt = `
Error generating stack: ` + ct.message + `
` + ct.stack;
    }
    return { value: fe, source: ce, stack: nt, digest: null };
  }
  function Bf(fe, ce, Ee) {
    return { value: fe, source: null, stack: Ee ?? null, digest: ce ?? null };
  }
  function md(fe, ce) {
    try {
      console.error(ce.value);
    } catch (Ee) {
      setTimeout(function() {
        throw Ee;
      });
    }
  }
  var Dg = typeof WeakMap == "function" ? WeakMap : Map;
  function mv(fe, ce, Ee) {
    Ee = hs(-1, Ee), Ee.tag = 3, Ee.payload = { element: null };
    var Te = ce.value;
    return Ee.callback = function() {
      xd || (xd = !0, Hl = Te), md(fe, ce);
    }, Ee;
  }
  function Hf(fe, ce, Ee) {
    Ee = hs(-1, Ee), Ee.tag = 3;
    var Te = fe.type.getDerivedStateFromError;
    if (typeof Te == "function") {
      var nt = ce.value;
      Ee.payload = function() {
        return Te(nt);
      }, Ee.callback = function() {
        md(fe, ce);
      };
    }
    var ct = fe.stateNode;
    return ct !== null && typeof ct.componentDidCatch == "function" && (Ee.callback = function() {
      md(fe, ce), typeof Te != "function" && (qo === null ? qo = /* @__PURE__ */ new Set([this]) : qo.add(this));
      var bt = ce.stack;
      this.componentDidCatch(ce.value, { componentStack: bt !== null ? bt : "" });
    }), Ee;
  }
  function vv(fe, ce, Ee) {
    var Te = fe.pingCache;
    if (Te === null) {
      Te = fe.pingCache = new Dg();
      var nt = /* @__PURE__ */ new Set();
      Te.set(ce, nt);
    } else
      nt = Te.get(ce), nt === void 0 && (nt = /* @__PURE__ */ new Set(), Te.set(ce, nt));
    nt.has(Ee) || (nt.add(Ee), fe = Vg.bind(null, fe, ce, Ee), ce.then(fe, fe));
  }
  function ep(fe) {
    do {
      var ce;
      if ((ce = fe.tag === 13) && (ce = fe.memoizedState, ce = ce !== null ? ce.dehydrated !== null : !0), ce)
        return fe;
      fe = fe.return;
    } while (fe !== null);
    return null;
  }
  function tp(fe, ce, Ee, Te, nt) {
    return fe.mode & 1 ? (fe.flags |= 65536, fe.lanes = nt, fe) : (fe === ce ? fe.flags |= 65536 : (fe.flags |= 128, Ee.flags |= 131072, Ee.flags &= -52805, Ee.tag === 1 && (Ee.alternate === null ? Ee.tag = 17 : (ce = hs(-1, 1), ce.tag = 2, Ws(Ee, ce, 1))), Ee.lanes |= 1), fe);
  }
  var Og = vt.ReactCurrentOwner, yi = !1;
  function wi(fe, ce, Ee, Te) {
    ce.child = fe === null ? hv(ce, null, Ee, Te) : Au(ce, fe.child, Ee, Te);
  }
  function Ks(fe, ce, Ee, Te, nt) {
    Ee = Ee.render;
    var ct = ce.ref;
    return hr(ce, nt), Te = Qs(fe, ce, Ee, Te, ct, nt), Ee = Ol(), fe !== null && !yi ? (ce.updateQueue = fe.updateQueue, ce.flags &= -2053, fe.lanes &= ~nt, Gi(fe, ce, nt)) : (Ln && Ee && Bc(ce), ce.flags |= 1, wi(fe, ce, Te, nt), ce.child);
  }
  function vd(fe, ce, Ee, Te, nt) {
    if (fe === null) {
      var ct = Ee.type;
      return typeof ct == "function" && !xp(ct) && ct.defaultProps === void 0 && Ee.compare === null && Ee.defaultProps === void 0 ? (ce.tag = 15, ce.type = ct, Oa(fe, ce, ct, Te, nt)) : (fe = Pd(Ee.type, null, Te, ce, ce.mode, nt), fe.ref = ce.ref, fe.return = ce, ce.child = fe);
    }
    if (ct = fe.child, !(fe.lanes & nt)) {
      var bt = ct.memoizedProps;
      if (Ee = Ee.compare, Ee = Ee !== null ? Ee : Cf, Ee(bt, Te) && fe.ref === ce.ref)
        return Gi(fe, ce, nt);
    }
    return ce.flags |= 1, fe = tl(ct, Te), fe.ref = ce.ref, fe.return = ce, ce.child = fe;
  }
  function Oa(fe, ce, Ee, Te, nt) {
    if (fe !== null) {
      var ct = fe.memoizedProps;
      if (Cf(ct, Te) && fe.ref === ce.ref)
        if (yi = !1, ce.pendingProps = Te = ct, (fe.lanes & nt) !== 0)
          fe.flags & 131072 && (yi = !0);
        else
          return ce.lanes = fe.lanes, Gi(fe, ce, nt);
    }
    return Du(fe, ce, Ee, Te, nt);
  }
  function Nl(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = Te.children, ct = fe !== null ? fe.memoizedState : null;
    if (Te.mode === "hidden")
      if (!(ce.mode & 1))
        ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Sn(zu, Xa), Xa |= Ee;
      else {
        if (!(Ee & 1073741824))
          return fe = ct !== null ? ct.baseLanes | Ee : Ee, ce.lanes = ce.childLanes = 1073741824, ce.memoizedState = { baseLanes: fe, cachePool: null, transitions: null }, ce.updateQueue = null, Sn(zu, Xa), Xa |= fe, null;
        ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Te = ct !== null ? ct.baseLanes : Ee, Sn(zu, Xa), Xa |= Te;
      }
    else
      ct !== null ? (Te = ct.baseLanes | Ee, ce.memoizedState = null) : Te = Ee, Sn(zu, Xa), Xa |= Te;
    return wi(fe, ce, nt, Ee), ce.child;
  }
  function Xr(fe, ce) {
    var Ee = ce.ref;
    (fe === null && Ee !== null || fe !== null && fe.ref !== Ee) && (ce.flags |= 512, ce.flags |= 2097152);
  }
  function Du(fe, ce, Ee, Te, nt) {
    var ct = jn(Ee) ? Aa : Ur.current;
    return ct = uo(ce, ct), hr(ce, nt), Ee = Qs(fe, ce, Ee, Te, ct, nt), Te = Ol(), fe !== null && !yi ? (ce.updateQueue = fe.updateQueue, ce.flags &= -2053, fe.lanes &= ~nt, Gi(fe, ce, nt)) : (Ln && Te && Bc(ce), ce.flags |= 1, wi(fe, ce, Ee, nt), ce.child);
  }
  function rp(fe, ce, Ee, Te, nt) {
    if (jn(Ee)) {
      var ct = !0;
      Vc(ce);
    } else
      ct = !1;
    if (hr(ce, nt), ce.stateNode === null)
      ta(fe, ce), uv(ce, Ee, Te), Qc(ce, Ee, Te, nt), Te = !0;
    else if (fe === null) {
      var bt = ce.stateNode, Mt = ce.memoizedProps;
      bt.props = Mt;
      var Lt = bt.context, qt = Ee.contextType;
      typeof qt == "object" && qt !== null ? qt = ci(qt) : (qt = jn(Ee) ? Aa : Ur.current, qt = uo(ce, qt));
      var sr = Ee.getDerivedStateFromProps, lr = typeof sr == "function" || typeof bt.getSnapshotBeforeUpdate == "function";
      lr || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (Mt !== Te || Lt !== qt) && fv(ce, bt, Te, qt), Gs = !1;
      var or = ce.memoizedState;
      bt.state = or, qs(ce, Te, bt, nt), Lt = ce.memoizedState, Mt !== Te || or !== Lt || si.current || Gs ? (typeof sr == "function" && (Qh(ce, Ee, sr, Te), Lt = ce.memoizedState), (Mt = Gs || lv(ce, Ee, Mt, Te, or, Lt, qt)) ? (lr || typeof bt.UNSAFE_componentWillMount != "function" && typeof bt.componentWillMount != "function" || (typeof bt.componentWillMount == "function" && bt.componentWillMount(), typeof bt.UNSAFE_componentWillMount == "function" && bt.UNSAFE_componentWillMount()), typeof bt.componentDidMount == "function" && (ce.flags |= 4194308)) : (typeof bt.componentDidMount == "function" && (ce.flags |= 4194308), ce.memoizedProps = Te, ce.memoizedState = Lt), bt.props = Te, bt.state = Lt, bt.context = qt, Te = Mt) : (typeof bt.componentDidMount == "function" && (ce.flags |= 4194308), Te = !1);
    } else {
      bt = ce.stateNode, Ti(fe, ce), Mt = ce.memoizedProps, qt = ce.type === ce.elementType ? Mt : Ya(ce.type, Mt), bt.props = qt, lr = ce.pendingProps, or = bt.context, Lt = Ee.contextType, typeof Lt == "object" && Lt !== null ? Lt = ci(Lt) : (Lt = jn(Ee) ? Aa : Ur.current, Lt = uo(ce, Lt));
      var Er = Ee.getDerivedStateFromProps;
      (sr = typeof Er == "function" || typeof bt.getSnapshotBeforeUpdate == "function") || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (Mt !== lr || or !== Lt) && fv(ce, bt, Te, Lt), Gs = !1, or = ce.memoizedState, bt.state = or, qs(ce, Te, bt, nt);
      var _r = ce.memoizedState;
      Mt !== lr || or !== _r || si.current || Gs ? (typeof Er == "function" && (Qh(ce, Ee, Er, Te), _r = ce.memoizedState), (qt = Gs || lv(ce, Ee, qt, Te, or, _r, Lt) || !1) ? (sr || typeof bt.UNSAFE_componentWillUpdate != "function" && typeof bt.componentWillUpdate != "function" || (typeof bt.componentWillUpdate == "function" && bt.componentWillUpdate(Te, _r, Lt), typeof bt.UNSAFE_componentWillUpdate == "function" && bt.UNSAFE_componentWillUpdate(Te, _r, Lt)), typeof bt.componentDidUpdate == "function" && (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate == "function" && (ce.flags |= 1024)) : (typeof bt.componentDidUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 1024), ce.memoizedProps = Te, ce.memoizedState = _r), bt.props = Te, bt.state = _r, bt.context = Lt, Te = qt) : (typeof bt.componentDidUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 1024), Te = !1);
    }
    return yv(fe, ce, Ee, Te, ct, nt);
  }
  function yv(fe, ce, Ee, Te, nt, ct) {
    Xr(fe, ce);
    var bt = (ce.flags & 128) !== 0;
    if (!Te && !bt)
      return nt && rv(ce, Ee, !1), Gi(fe, ce, ct);
    Te = ce.stateNode, Og.current = ce;
    var Mt = bt && typeof Ee.getDerivedStateFromError != "function" ? null : Te.render();
    return ce.flags |= 1, fe !== null && bt ? (ce.child = Au(ce, fe.child, null, ct), ce.child = Au(ce, null, Mt, ct)) : wi(fe, ce, Mt, ct), ce.memoizedState = Te.state, nt && rv(ce, Ee, !0), ce.child;
  }
  function gv(fe) {
    var ce = fe.stateNode;
    ce.pendingContext ? Bs(fe, ce.pendingContext, ce.pendingContext !== ce.context) : ce.context && Bs(fe, ce.context, !1), Xh(fe, ce.containerInfo);
  }
  function yd(fe, ce, Ee, Te, nt) {
    return qn(), Uh(nt), ce.flags |= 256, wi(fe, ce, Ee, Te), ce.child;
  }
  var zl = { dehydrated: null, treeContext: null, retryLane: 0 };
  function np(fe) {
    return { baseLanes: fe, cachePool: null, transitions: null };
  }
  function ap(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = Vr.current, ct = !1, bt = (ce.flags & 128) !== 0, Mt;
    if ((Mt = bt) || (Mt = fe !== null && fe.memoizedState === null ? !1 : (nt & 2) !== 0), Mt ? (ct = !0, ce.flags &= -129) : (fe === null || fe.memoizedState !== null) && (nt |= 1), Sn(Vr, nt & 1), fe === null)
      return Uc(ce), fe = ce.memoizedState, fe !== null && (fe = fe.dehydrated, fe !== null) ? (ce.mode & 1 ? fe.data === "$!" ? ce.lanes = 8 : ce.lanes = 1073741824 : ce.lanes = 1, null) : (bt = Te.children, fe = Te.fallback, ct ? (Te = ce.mode, ct = ce.child, bt = { mode: "hidden", children: bt }, !(Te & 1) && ct !== null ? (ct.childLanes = 0, ct.pendingProps = bt) : ct = Jf(bt, Te, 0, null), fe = ql(fe, Te, Ee, null), ct.return = ce, fe.return = ce, ct.sibling = fe, ce.child = ct, ce.child.memoizedState = np(Ee), ce.memoizedState = zl, fe) : sp(ce, bt));
    if (nt = fe.memoizedState, nt !== null && (Mt = nt.dehydrated, Mt !== null))
      return Lg(fe, ce, bt, Te, Mt, nt, Ee);
    if (ct) {
      ct = Te.fallback, bt = ce.mode, nt = fe.child, Mt = nt.sibling;
      var Lt = { mode: "hidden", children: Te.children };
      return !(bt & 1) && ce.child !== nt ? (Te = ce.child, Te.childLanes = 0, Te.pendingProps = Lt, ce.deletions = null) : (Te = tl(nt, Lt), Te.subtreeFlags = nt.subtreeFlags & 14680064), Mt !== null ? ct = tl(Mt, ct) : (ct = ql(ct, bt, Ee, null), ct.flags |= 2), ct.return = ce, Te.return = ce, Te.sibling = ct, ce.child = Te, Te = ct, ct = ce.child, bt = fe.child.memoizedState, bt = bt === null ? np(Ee) : { baseLanes: bt.baseLanes | Ee, cachePool: null, transitions: bt.transitions }, ct.memoizedState = bt, ct.childLanes = fe.childLanes & ~Ee, ce.memoizedState = zl, Te;
    }
    return ct = fe.child, fe = ct.sibling, Te = tl(ct, { mode: "visible", children: Te.children }), !(ce.mode & 1) && (Te.lanes = Ee), Te.return = ce, Te.sibling = null, fe !== null && (Ee = ce.deletions, Ee === null ? (ce.deletions = [fe], ce.flags |= 16) : Ee.push(fe)), ce.child = Te, ce.memoizedState = null, Te;
  }
  function sp(fe, ce) {
    return ce = Jf({ mode: "visible", children: ce }, fe.mode, 0, null), ce.return = fe, fe.child = ce;
  }
  function Ou(fe, ce, Ee, Te) {
    return Te !== null && Uh(Te), Au(ce, fe.child, null, Ee), fe = sp(ce, ce.pendingProps.children), fe.flags |= 2, ce.memoizedState = null, fe;
  }
  function Lg(fe, ce, Ee, Te, nt, ct, bt) {
    if (Ee)
      return ce.flags & 256 ? (ce.flags &= -257, Te = Bf(Error(oe(422))), Ou(fe, ce, bt, Te)) : ce.memoizedState !== null ? (ce.child = fe.child, ce.flags |= 128, null) : (ct = Te.fallback, nt = ce.mode, Te = Jf({ mode: "visible", children: Te.children }, nt, 0, null), ct = ql(ct, nt, bt, null), ct.flags |= 2, Te.return = ce, ct.return = ce, Te.sibling = ct, ce.child = Te, ce.mode & 1 && Au(ce, fe.child, null, bt), ce.child.memoizedState = np(bt), ce.memoizedState = zl, ct);
    if (!(ce.mode & 1))
      return Ou(fe, ce, bt, null);
    if (nt.data === "$!") {
      if (Te = nt.nextSibling && nt.nextSibling.dataset, Te)
        var Mt = Te.dgst;
      return Te = Mt, ct = Error(oe(419)), Te = Bf(ct, Te, void 0), Ou(fe, ce, bt, Te);
    }
    if (Mt = (bt & fe.childLanes) !== 0, yi || Mt) {
      if (Te = Qn, Te !== null) {
        switch (bt & -bt) {
          case 4:
            nt = 2;
            break;
          case 16:
            nt = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            nt = 32;
            break;
          case 536870912:
            nt = 268435456;
            break;
          default:
            nt = 0;
        }
        nt = nt & (Te.suspendedLanes | bt) ? 0 : nt, nt !== 0 && nt !== ct.retryLane && (ct.retryLane = nt, ds(fe, nt), aa(Te, fe, nt, -1));
      }
      return Sp(), Te = Bf(Error(oe(421))), Ou(fe, ce, bt, Te);
    }
    return nt.data === "$?" ? (ce.flags |= 128, ce.child = fe.child, ce = Bg.bind(null, fe), nt._reactRetry = ce, null) : (fe = ct.treeContext, Ma = Ro(nt.nextSibling), qa = ce, Ln = !0, ho = null, fe !== null && (ka[ea++] = Ui, ka[ea++] = cs, ka[ea++] = co, Ui = fe.id, cs = fe.overflow, co = ce), ce = sp(ce, Te.children), ce.flags |= 4096, ce);
  }
  function lp(fe, ce, Ee) {
    fe.lanes |= ce;
    var Te = fe.alternate;
    Te !== null && (Te.lanes |= ce), Ii(fe.return, ce, Ee);
  }
  function gd(fe, ce, Ee, Te, nt) {
    var ct = fe.memoizedState;
    ct === null ? fe.memoizedState = { isBackwards: ce, rendering: null, renderingStartTime: 0, last: Te, tail: Ee, tailMode: nt } : (ct.isBackwards = ce, ct.rendering = null, ct.renderingStartTime = 0, ct.last = Te, ct.tail = Ee, ct.tailMode = nt);
  }
  function up(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = Te.revealOrder, ct = Te.tail;
    if (wi(fe, ce, Te.children, Ee), Te = Vr.current, Te & 2)
      Te = Te & 1 | 2, ce.flags |= 128;
    else {
      if (fe !== null && fe.flags & 128)
        e:
          for (fe = ce.child; fe !== null; ) {
            if (fe.tag === 13)
              fe.memoizedState !== null && lp(fe, Ee, ce);
            else if (fe.tag === 19)
              lp(fe, Ee, ce);
            else if (fe.child !== null) {
              fe.child.return = fe, fe = fe.child;
              continue;
            }
            if (fe === ce)
              break e;
            for (; fe.sibling === null; ) {
              if (fe.return === null || fe.return === ce)
                break e;
              fe = fe.return;
            }
            fe.sibling.return = fe.return, fe = fe.sibling;
          }
      Te &= 1;
    }
    if (Sn(Vr, Te), !(ce.mode & 1))
      ce.memoizedState = null;
    else
      switch (nt) {
        case "forwards":
          for (Ee = ce.child, nt = null; Ee !== null; )
            fe = Ee.alternate, fe !== null && Yn(fe) === null && (nt = Ee), Ee = Ee.sibling;
          Ee = nt, Ee === null ? (nt = ce.child, ce.child = null) : (nt = Ee.sibling, Ee.sibling = null), gd(ce, !1, nt, Ee, ct);
          break;
        case "backwards":
          for (Ee = null, nt = ce.child, ce.child = null; nt !== null; ) {
            if (fe = nt.alternate, fe !== null && Yn(fe) === null) {
              ce.child = nt;
              break;
            }
            fe = nt.sibling, nt.sibling = Ee, Ee = nt, nt = fe;
          }
          gd(ce, !0, Ee, null, ct);
          break;
        case "together":
          gd(ce, !1, null, null, void 0);
          break;
        default:
          ce.memoizedState = null;
      }
    return ce.child;
  }
  function ta(fe, ce) {
    !(ce.mode & 1) && fe !== null && (fe.alternate = null, ce.alternate = null, ce.flags |= 2);
  }
  function Gi(fe, ce, Ee) {
    if (fe !== null && (ce.dependencies = fe.dependencies), ys |= ce.lanes, !(Ee & ce.childLanes))
      return null;
    if (fe !== null && ce.child !== fe.child)
      throw Error(oe(153));
    if (ce.child !== null) {
      for (fe = ce.child, Ee = tl(fe, fe.pendingProps), ce.child = Ee, Ee.return = ce; fe.sibling !== null; )
        fe = fe.sibling, Ee = Ee.sibling = tl(fe, fe.pendingProps), Ee.return = ce;
      Ee.sibling = null;
    }
    return ce.child;
  }
  function ms(fe, ce, Ee) {
    switch (ce.tag) {
      case 3:
        gv(ce), qn();
        break;
      case 5:
        zr(ce);
        break;
      case 1:
        jn(ce.type) && Vc(ce);
        break;
      case 4:
        Xh(ce, ce.stateNode.containerInfo);
        break;
      case 10:
        var Te = ce.type._context, nt = ce.memoizedProps.value;
        Sn(Uo, Te._currentValue), Te._currentValue = nt;
        break;
      case 13:
        if (Te = ce.memoizedState, Te !== null)
          return Te.dehydrated !== null ? (Sn(Vr, Vr.current & 1), ce.flags |= 128, null) : Ee & ce.child.childLanes ? ap(fe, ce, Ee) : (Sn(Vr, Vr.current & 1), fe = Gi(fe, ce, Ee), fe !== null ? fe.sibling : null);
        Sn(Vr, Vr.current & 1);
        break;
      case 19:
        if (Te = (Ee & ce.childLanes) !== 0, fe.flags & 128) {
          if (Te)
            return up(fe, ce, Ee);
          ce.flags |= 128;
        }
        if (nt = ce.memoizedState, nt !== null && (nt.rendering = null, nt.tail = null, nt.lastEffect = null), Sn(Vr, Vr.current), Te)
          break;
        return null;
      case 22:
      case 23:
        return ce.lanes = 0, Nl(fe, ce, Ee);
    }
    return Gi(fe, ce, Ee);
  }
  var Uf, Vl, vo, _i;
  Uf = function(fe, ce) {
    for (var Ee = ce.child; Ee !== null; ) {
      if (Ee.tag === 5 || Ee.tag === 6)
        fe.appendChild(Ee.stateNode);
      else if (Ee.tag !== 4 && Ee.child !== null) {
        Ee.child.return = Ee, Ee = Ee.child;
        continue;
      }
      if (Ee === ce)
        break;
      for (; Ee.sibling === null; ) {
        if (Ee.return === null || Ee.return === ce)
          return;
        Ee = Ee.return;
      }
      Ee.sibling.return = Ee.return, Ee = Ee.sibling;
    }
  }, Vl = function() {
  }, vo = function(fe, ce, Ee, Te) {
    var nt = fe.memoizedProps;
    if (nt !== Te) {
      fe = ce.stateNode, kl(ko.current);
      var ct = null;
      switch (Ee) {
        case "input":
          nt = dr(fe, nt), Te = dr(fe, Te), ct = [];
          break;
        case "select":
          nt = Dt({}, nt, { value: void 0 }), Te = Dt({}, Te, { value: void 0 }), ct = [];
          break;
        case "textarea":
          nt = Mi(fe, nt), Te = Mi(fe, Te), ct = [];
          break;
        default:
          typeof nt.onClick != "function" && typeof Te.onClick == "function" && (fe.onclick = zc);
      }
      bi(Ee, Te);
      var bt;
      Ee = null;
      for (qt in nt)
        if (!Te.hasOwnProperty(qt) && nt.hasOwnProperty(qt) && nt[qt] != null)
          if (qt === "style") {
            var Mt = nt[qt];
            for (bt in Mt)
              Mt.hasOwnProperty(bt) && (Ee || (Ee = {}), Ee[bt] = "");
          } else
            qt !== "dangerouslySetInnerHTML" && qt !== "children" && qt !== "suppressContentEditableWarning" && qt !== "suppressHydrationWarning" && qt !== "autoFocus" && (me.hasOwnProperty(qt) ? ct || (ct = []) : (ct = ct || []).push(qt, null));
      for (qt in Te) {
        var Lt = Te[qt];
        if (Mt = nt != null ? nt[qt] : void 0, Te.hasOwnProperty(qt) && Lt !== Mt && (Lt != null || Mt != null))
          if (qt === "style")
            if (Mt) {
              for (bt in Mt)
                !Mt.hasOwnProperty(bt) || Lt && Lt.hasOwnProperty(bt) || (Ee || (Ee = {}), Ee[bt] = "");
              for (bt in Lt)
                Lt.hasOwnProperty(bt) && Mt[bt] !== Lt[bt] && (Ee || (Ee = {}), Ee[bt] = Lt[bt]);
            } else
              Ee || (ct || (ct = []), ct.push(
                qt,
                Ee
              )), Ee = Lt;
          else
            qt === "dangerouslySetInnerHTML" ? (Lt = Lt ? Lt.__html : void 0, Mt = Mt ? Mt.__html : void 0, Lt != null && Mt !== Lt && (ct = ct || []).push(qt, Lt)) : qt === "children" ? typeof Lt != "string" && typeof Lt != "number" || (ct = ct || []).push(qt, "" + Lt) : qt !== "suppressContentEditableWarning" && qt !== "suppressHydrationWarning" && (me.hasOwnProperty(qt) ? (Lt != null && qt === "onScroll" && Pn("scroll", fe), ct || Mt === Lt || (ct = [])) : (ct = ct || []).push(qt, Lt));
      }
      Ee && (ct = ct || []).push("style", Ee);
      var qt = ct;
      (ce.updateQueue = qt) && (ce.flags |= 4);
    }
  }, _i = function(fe, ce, Ee, Te) {
    Ee !== Te && (ce.flags |= 4);
  };
  function jf(fe, ce) {
    if (!Ln)
      switch (fe.tailMode) {
        case "hidden":
          ce = fe.tail;
          for (var Ee = null; ce !== null; )
            ce.alternate !== null && (Ee = ce), ce = ce.sibling;
          Ee === null ? fe.tail = null : Ee.sibling = null;
          break;
        case "collapsed":
          Ee = fe.tail;
          for (var Te = null; Ee !== null; )
            Ee.alternate !== null && (Te = Ee), Ee = Ee.sibling;
          Te === null ? ce || fe.tail === null ? fe.tail = null : fe.tail.sibling = null : Te.sibling = null;
      }
  }
  function ra(fe) {
    var ce = fe.alternate !== null && fe.alternate.child === fe.child, Ee = 0, Te = 0;
    if (ce)
      for (var nt = fe.child; nt !== null; )
        Ee |= nt.lanes | nt.childLanes, Te |= nt.subtreeFlags & 14680064, Te |= nt.flags & 14680064, nt.return = fe, nt = nt.sibling;
    else
      for (nt = fe.child; nt !== null; )
        Ee |= nt.lanes | nt.childLanes, Te |= nt.subtreeFlags, Te |= nt.flags, nt.return = fe, nt = nt.sibling;
    return fe.subtreeFlags |= Te, fe.childLanes = Ee, ce;
  }
  function $g(fe, ce, Ee) {
    var Te = ce.pendingProps;
    switch (Bh(ce), ce.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ra(ce), null;
      case 1:
        return jn(ce.type) && fo(), ra(ce), null;
      case 3:
        return Te = ce.stateNode, Ys(), pn(si), pn(Ur), Kc(), Te.pendingContext && (Te.context = Te.pendingContext, Te.pendingContext = null), (fe === null || fe.child === null) && (jc(ce) ? ce.flags |= 4 : fe === null || fe.memoizedState.isDehydrated && !(ce.flags & 256) || (ce.flags |= 1024, ho !== null && (Kf(ho), ho = null))), Vl(fe, ce), ra(ce), null;
      case 5:
        Zr(ce);
        var nt = kl(Pu.current);
        if (Ee = ce.type, fe !== null && ce.stateNode != null)
          vo(fe, ce, Ee, Te, nt), fe.ref !== ce.ref && (ce.flags |= 512, ce.flags |= 2097152);
        else {
          if (!Te) {
            if (ce.stateNode === null)
              throw Error(oe(166));
            return ra(ce), null;
          }
          if (fe = kl(ko.current), jc(ce)) {
            Te = ce.stateNode, Ee = ce.type;
            var ct = ce.memoizedProps;
            switch (Te[Bo] = ce, Te[Al] = ct, fe = (ce.mode & 1) !== 0, Ee) {
              case "dialog":
                Pn("cancel", Te), Pn("close", Te);
                break;
              case "iframe":
              case "object":
              case "embed":
                Pn("load", Te);
                break;
              case "video":
              case "audio":
                for (nt = 0; nt < Af.length; nt++)
                  Pn(Af[nt], Te);
                break;
              case "source":
                Pn("error", Te);
                break;
              case "img":
              case "image":
              case "link":
                Pn(
                  "error",
                  Te
                ), Pn("load", Te);
                break;
              case "details":
                Pn("toggle", Te);
                break;
              case "input":
                zn(Te, ct), Pn("invalid", Te);
                break;
              case "select":
                Te._wrapperState = { wasMultiple: !!ct.multiple }, Pn("invalid", Te);
                break;
              case "textarea":
                Zn(Te, ct), Pn("invalid", Te);
            }
            bi(Ee, ct), nt = null;
            for (var bt in ct)
              if (ct.hasOwnProperty(bt)) {
                var Mt = ct[bt];
                bt === "children" ? typeof Mt == "string" ? Te.textContent !== Mt && (ct.suppressHydrationWarning !== !0 && Nc(Te.textContent, Mt, fe), nt = ["children", Mt]) : typeof Mt == "number" && Te.textContent !== "" + Mt && (ct.suppressHydrationWarning !== !0 && Nc(
                  Te.textContent,
                  Mt,
                  fe
                ), nt = ["children", "" + Mt]) : me.hasOwnProperty(bt) && Mt != null && bt === "onScroll" && Pn("scroll", Te);
              }
            switch (Ee) {
              case "input":
                $r(Te), Jn(Te, ct, !0);
                break;
              case "textarea":
                $r(Te), fi(Te);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof ct.onClick == "function" && (Te.onclick = zc);
            }
            Te = nt, ce.updateQueue = Te, Te !== null && (ce.flags |= 4);
          } else {
            bt = nt.nodeType === 9 ? nt : nt.ownerDocument, fe === "http://www.w3.org/1999/xhtml" && (fe = ti(Ee)), fe === "http://www.w3.org/1999/xhtml" ? Ee === "script" ? (fe = bt.createElement("div"), fe.innerHTML = "<script><\/script>", fe = fe.removeChild(fe.firstChild)) : typeof Te.is == "string" ? fe = bt.createElement(Ee, { is: Te.is }) : (fe = bt.createElement(Ee), Ee === "select" && (bt = fe, Te.multiple ? bt.multiple = !0 : Te.size && (bt.size = Te.size))) : fe = bt.createElementNS(fe, Ee), fe[Bo] = ce, fe[Al] = Te, Uf(fe, ce, !1, !1), ce.stateNode = fe;
            e: {
              switch (bt = ri(Ee, Te), Ee) {
                case "dialog":
                  Pn("cancel", fe), Pn("close", fe), nt = Te;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Pn("load", fe), nt = Te;
                  break;
                case "video":
                case "audio":
                  for (nt = 0; nt < Af.length; nt++)
                    Pn(Af[nt], fe);
                  nt = Te;
                  break;
                case "source":
                  Pn("error", fe), nt = Te;
                  break;
                case "img":
                case "image":
                case "link":
                  Pn(
                    "error",
                    fe
                  ), Pn("load", fe), nt = Te;
                  break;
                case "details":
                  Pn("toggle", fe), nt = Te;
                  break;
                case "input":
                  zn(fe, Te), nt = dr(fe, Te), Pn("invalid", fe);
                  break;
                case "option":
                  nt = Te;
                  break;
                case "select":
                  fe._wrapperState = { wasMultiple: !!Te.multiple }, nt = Dt({}, Te, { value: void 0 }), Pn("invalid", fe);
                  break;
                case "textarea":
                  Zn(fe, Te), nt = Mi(fe, Te), Pn("invalid", fe);
                  break;
                default:
                  nt = Te;
              }
              bi(Ee, nt), Mt = nt;
              for (ct in Mt)
                if (Mt.hasOwnProperty(ct)) {
                  var Lt = Mt[ct];
                  ct === "style" ? mn(fe, Lt) : ct === "dangerouslySetInnerHTML" ? (Lt = Lt ? Lt.__html : void 0, Lt != null && Va(fe, Lt)) : ct === "children" ? typeof Lt == "string" ? (Ee !== "textarea" || Lt !== "") && Vn(fe, Lt) : typeof Lt == "number" && Vn(fe, "" + Lt) : ct !== "suppressContentEditableWarning" && ct !== "suppressHydrationWarning" && ct !== "autoFocus" && (me.hasOwnProperty(ct) ? Lt != null && ct === "onScroll" && Pn("scroll", fe) : Lt != null && ft(fe, ct, Lt, bt));
                }
              switch (Ee) {
                case "input":
                  $r(fe), Jn(fe, Te, !1);
                  break;
                case "textarea":
                  $r(fe), fi(fe);
                  break;
                case "option":
                  Te.value != null && fe.setAttribute("value", "" + en(Te.value));
                  break;
                case "select":
                  fe.multiple = !!Te.multiple, ct = Te.value, ct != null ? Dn(fe, !!Te.multiple, ct, !1) : Te.defaultValue != null && Dn(
                    fe,
                    !!Te.multiple,
                    Te.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof nt.onClick == "function" && (fe.onclick = zc);
              }
              switch (Ee) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  Te = !!Te.autoFocus;
                  break e;
                case "img":
                  Te = !0;
                  break e;
                default:
                  Te = !1;
              }
            }
            Te && (ce.flags |= 4);
          }
          ce.ref !== null && (ce.flags |= 512, ce.flags |= 2097152);
        }
        return ra(ce), null;
      case 6:
        if (fe && ce.stateNode != null)
          _i(fe, ce, fe.memoizedProps, Te);
        else {
          if (typeof Te != "string" && ce.stateNode === null)
            throw Error(oe(166));
          if (Ee = kl(Pu.current), kl(ko.current), jc(ce)) {
            if (Te = ce.stateNode, Ee = ce.memoizedProps, Te[Bo] = ce, (ct = Te.nodeValue !== Ee) && (fe = qa, fe !== null))
              switch (fe.tag) {
                case 3:
                  Nc(Te.nodeValue, Ee, (fe.mode & 1) !== 0);
                  break;
                case 5:
                  fe.memoizedProps.suppressHydrationWarning !== !0 && Nc(Te.nodeValue, Ee, (fe.mode & 1) !== 0);
              }
            ct && (ce.flags |= 4);
          } else
            Te = (Ee.nodeType === 9 ? Ee : Ee.ownerDocument).createTextNode(Te), Te[Bo] = ce, ce.stateNode = Te;
        }
        return ra(ce), null;
      case 13:
        if (pn(Vr), Te = ce.memoizedState, fe === null || fe.memoizedState !== null && fe.memoizedState.dehydrated !== null) {
          if (Ln && Ma !== null && ce.mode & 1 && !(ce.flags & 128))
            av(), qn(), ce.flags |= 98560, ct = !1;
          else if (ct = jc(ce), Te !== null && Te.dehydrated !== null) {
            if (fe === null) {
              if (!ct)
                throw Error(oe(318));
              if (ct = ce.memoizedState, ct = ct !== null ? ct.dehydrated : null, !ct)
                throw Error(oe(317));
              ct[Bo] = ce;
            } else
              qn(), !(ce.flags & 128) && (ce.memoizedState = null), ce.flags |= 4;
            ra(ce), ct = !1;
          } else
            ho !== null && (Kf(ho), ho = null), ct = !0;
          if (!ct)
            return ce.flags & 65536 ? ce : null;
        }
        return ce.flags & 128 ? (ce.lanes = Ee, ce) : (Te = Te !== null, Te !== (fe !== null && fe.memoizedState !== null) && Te && (ce.child.flags |= 8192, ce.mode & 1 && (fe === null || Vr.current & 1 ? Pi === 0 && (Pi = 3) : Sp())), ce.updateQueue !== null && (ce.flags |= 4), ra(ce), null);
      case 4:
        return Ys(), Vl(fe, ce), fe === null && Cu(ce.stateNode.containerInfo), ra(ce), null;
      case 10:
        return js(ce.type._context), ra(ce), null;
      case 17:
        return jn(ce.type) && fo(), ra(ce), null;
      case 19:
        if (pn(Vr), ct = ce.memoizedState, ct === null)
          return ra(ce), null;
        if (Te = (ce.flags & 128) !== 0, bt = ct.rendering, bt === null)
          if (Te)
            jf(ct, !1);
          else {
            if (Pi !== 0 || fe !== null && fe.flags & 128)
              for (fe = ce.child; fe !== null; ) {
                if (bt = Yn(fe), bt !== null) {
                  for (ce.flags |= 128, jf(ct, !1), Te = bt.updateQueue, Te !== null && (ce.updateQueue = Te, ce.flags |= 4), ce.subtreeFlags = 0, Te = Ee, Ee = ce.child; Ee !== null; )
                    ct = Ee, fe = Te, ct.flags &= 14680066, bt = ct.alternate, bt === null ? (ct.childLanes = 0, ct.lanes = fe, ct.child = null, ct.subtreeFlags = 0, ct.memoizedProps = null, ct.memoizedState = null, ct.updateQueue = null, ct.dependencies = null, ct.stateNode = null) : (ct.childLanes = bt.childLanes, ct.lanes = bt.lanes, ct.child = bt.child, ct.subtreeFlags = 0, ct.deletions = null, ct.memoizedProps = bt.memoizedProps, ct.memoizedState = bt.memoizedState, ct.updateQueue = bt.updateQueue, ct.type = bt.type, fe = bt.dependencies, ct.dependencies = fe === null ? null : { lanes: fe.lanes, firstContext: fe.firstContext }), Ee = Ee.sibling;
                  return Sn(Vr, Vr.current & 1 | 2), ce.child;
                }
                fe = fe.sibling;
              }
            ct.tail !== null && Hn() > Bu && (ce.flags |= 128, Te = !0, jf(ct, !1), ce.lanes = 4194304);
          }
        else {
          if (!Te)
            if (fe = Yn(bt), fe !== null) {
              if (ce.flags |= 128, Te = !0, Ee = fe.updateQueue, Ee !== null && (ce.updateQueue = Ee, ce.flags |= 4), jf(ct, !0), ct.tail === null && ct.tailMode === "hidden" && !bt.alternate && !Ln)
                return ra(ce), null;
            } else
              2 * Hn() - ct.renderingStartTime > Bu && Ee !== 1073741824 && (ce.flags |= 128, Te = !0, jf(ct, !1), ce.lanes = 4194304);
          ct.isBackwards ? (bt.sibling = ce.child, ce.child = bt) : (Ee = ct.last, Ee !== null ? Ee.sibling = bt : ce.child = bt, ct.last = bt);
        }
        return ct.tail !== null ? (ce = ct.tail, ct.rendering = ce, ct.tail = ce.sibling, ct.renderingStartTime = Hn(), ce.sibling = null, Ee = Vr.current, Sn(Vr, Te ? Ee & 1 | 2 : Ee & 1), ce) : (ra(ce), null);
      case 22:
      case 23:
        return gp(), Te = ce.memoizedState !== null, fe !== null && fe.memoizedState !== null !== Te && (ce.flags |= 8192), Te && ce.mode & 1 ? Xa & 1073741824 && (ra(ce), ce.subtreeFlags & 6 && (ce.flags |= 8192)) : ra(ce), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(oe(156, ce.tag));
  }
  function fp(fe, ce) {
    switch (Bh(ce), ce.tag) {
      case 1:
        return jn(ce.type) && fo(), fe = ce.flags, fe & 65536 ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 3:
        return Ys(), pn(si), pn(Ur), Kc(), fe = ce.flags, fe & 65536 && !(fe & 128) ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 5:
        return Zr(ce), null;
      case 13:
        if (pn(Vr), fe = ce.memoizedState, fe !== null && fe.dehydrated !== null) {
          if (ce.alternate === null)
            throw Error(oe(340));
          qn();
        }
        return fe = ce.flags, fe & 65536 ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 19:
        return pn(Vr), null;
      case 4:
        return Ys(), null;
      case 10:
        return js(ce.type._context), null;
      case 22:
      case 23:
        return gp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Gf = !1, Ai = !1, Sv = typeof WeakSet == "function" ? WeakSet : Set, wr = null;
  function Lu(fe, ce) {
    var Ee = fe.ref;
    if (Ee !== null)
      if (typeof Ee == "function")
        try {
          Ee(null);
        } catch (Te) {
          ui(fe, ce, Te);
        }
      else
        Ee.current = null;
  }
  function Wf(fe, ce, Ee) {
    try {
      Ee();
    } catch (Te) {
      ui(fe, ce, Te);
    }
  }
  var Ev = !1;
  function bv(fe, ce) {
    if (Dh = zt, fe = Dc(), ss(fe)) {
      if ("selectionStart" in fe)
        var Ee = { start: fe.selectionStart, end: fe.selectionEnd };
      else
        e: {
          Ee = (Ee = fe.ownerDocument) && Ee.defaultView || window;
          var Te = Ee.getSelection && Ee.getSelection();
          if (Te && Te.rangeCount !== 0) {
            Ee = Te.anchorNode;
            var nt = Te.anchorOffset, ct = Te.focusNode;
            Te = Te.focusOffset;
            try {
              Ee.nodeType, ct.nodeType;
            } catch {
              Ee = null;
              break e;
            }
            var bt = 0, Mt = -1, Lt = -1, qt = 0, sr = 0, lr = fe, or = null;
            t:
              for (; ; ) {
                for (var Er; lr !== Ee || nt !== 0 && lr.nodeType !== 3 || (Mt = bt + nt), lr !== ct || Te !== 0 && lr.nodeType !== 3 || (Lt = bt + Te), lr.nodeType === 3 && (bt += lr.nodeValue.length), (Er = lr.firstChild) !== null; )
                  or = lr, lr = Er;
                for (; ; ) {
                  if (lr === fe)
                    break t;
                  if (or === Ee && ++qt === nt && (Mt = bt), or === ct && ++sr === Te && (Lt = bt), (Er = lr.nextSibling) !== null)
                    break;
                  lr = or, or = lr.parentNode;
                }
                lr = Er;
              }
            Ee = Mt === -1 || Lt === -1 ? null : { start: Mt, end: Lt };
          } else
            Ee = null;
        }
      Ee = Ee || { start: 0, end: 0 };
    } else
      Ee = null;
    for (wl = { focusedElem: fe, selectionRange: Ee }, zt = !1, wr = ce; wr !== null; )
      if (ce = wr, fe = ce.child, (ce.subtreeFlags & 1028) !== 0 && fe !== null)
        fe.return = ce, wr = fe;
      else
        for (; wr !== null; ) {
          ce = wr;
          try {
            var _r = ce.alternate;
            if (ce.flags & 1024)
              switch (ce.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (_r !== null) {
                    var Rr = _r.memoizedProps, di = _r.memoizedState, Bt = ce.stateNode, It = Bt.getSnapshotBeforeUpdate(ce.elementType === ce.type ? Rr : Ya(ce.type, Rr), di);
                    Bt.__reactInternalSnapshotBeforeUpdate = It;
                  }
                  break;
                case 3:
                  var jt = ce.stateNode.containerInfo;
                  jt.nodeType === 1 ? jt.textContent = "" : jt.nodeType === 9 && jt.documentElement && jt.removeChild(jt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(oe(163));
              }
          } catch (cr) {
            ui(ce, ce.return, cr);
          }
          if (fe = ce.sibling, fe !== null) {
            fe.return = ce.return, wr = fe;
            break;
          }
          wr = ce.return;
        }
    return _r = Ev, Ev = !1, _r;
  }
  function qf(fe, ce, Ee) {
    var Te = ce.updateQueue;
    if (Te = Te !== null ? Te.lastEffect : null, Te !== null) {
      var nt = Te = Te.next;
      do {
        if ((nt.tag & fe) === fe) {
          var ct = nt.destroy;
          nt.destroy = void 0, ct !== void 0 && Wf(ce, Ee, ct);
        }
        nt = nt.next;
      } while (nt !== Te);
    }
  }
  function Yf(fe, ce) {
    if (ce = ce.updateQueue, ce = ce !== null ? ce.lastEffect : null, ce !== null) {
      var Ee = ce = ce.next;
      do {
        if ((Ee.tag & fe) === fe) {
          var Te = Ee.create;
          Ee.destroy = Te();
        }
        Ee = Ee.next;
      } while (Ee !== ce);
    }
  }
  function cp(fe) {
    var ce = fe.ref;
    if (ce !== null) {
      var Ee = fe.stateNode;
      switch (fe.tag) {
        case 5:
          fe = Ee;
          break;
        default:
          fe = Ee;
      }
      typeof ce == "function" ? ce(fe) : ce.current = fe;
    }
  }
  function dp(fe) {
    var ce = fe.alternate;
    ce !== null && (fe.alternate = null, dp(ce)), fe.child = null, fe.deletions = null, fe.sibling = null, fe.tag === 5 && (ce = fe.stateNode, ce !== null && (delete ce[Bo], delete ce[Al], delete ce[$h], delete ce[Rg], delete ce[Ih])), fe.stateNode = null, fe.return = null, fe.dependencies = null, fe.memoizedProps = null, fe.memoizedState = null, fe.pendingProps = null, fe.stateNode = null, fe.updateQueue = null;
  }
  function xv(fe) {
    return fe.tag === 5 || fe.tag === 3 || fe.tag === 4;
  }
  function Sd(fe) {
    e:
      for (; ; ) {
        for (; fe.sibling === null; ) {
          if (fe.return === null || xv(fe.return))
            return null;
          fe = fe.return;
        }
        for (fe.sibling.return = fe.return, fe = fe.sibling; fe.tag !== 5 && fe.tag !== 6 && fe.tag !== 18; ) {
          if (fe.flags & 2 || fe.child === null || fe.tag === 4)
            continue e;
          fe.child.return = fe, fe = fe.child;
        }
        if (!(fe.flags & 2))
          return fe.stateNode;
      }
  }
  function $u(fe, ce, Ee) {
    var Te = fe.tag;
    if (Te === 5 || Te === 6)
      fe = fe.stateNode, ce ? Ee.nodeType === 8 ? Ee.parentNode.insertBefore(fe, ce) : Ee.insertBefore(fe, ce) : (Ee.nodeType === 8 ? (ce = Ee.parentNode, ce.insertBefore(fe, Ee)) : (ce = Ee, ce.appendChild(fe)), Ee = Ee._reactRootContainer, Ee != null || ce.onclick !== null || (ce.onclick = zc));
    else if (Te !== 4 && (fe = fe.child, fe !== null))
      for ($u(fe, ce, Ee), fe = fe.sibling; fe !== null; )
        $u(fe, ce, Ee), fe = fe.sibling;
  }
  function Go(fe, ce, Ee) {
    var Te = fe.tag;
    if (Te === 5 || Te === 6)
      fe = fe.stateNode, ce ? Ee.insertBefore(fe, ce) : Ee.appendChild(fe);
    else if (Te !== 4 && (fe = fe.child, fe !== null))
      for (Go(fe, ce, Ee), fe = fe.sibling; fe !== null; )
        Go(fe, ce, Ee), fe = fe.sibling;
  }
  var Gn = null, Ni = !1;
  function yo(fe, ce, Ee) {
    for (Ee = Ee.child; Ee !== null; )
      Iu(fe, ce, Ee), Ee = Ee.sibling;
  }
  function Iu(fe, ce, Ee) {
    if (Ua && typeof Ua.onCommitFiberUnmount == "function")
      try {
        Ua.onCommitFiberUnmount(ml, Ee);
      } catch {
      }
    switch (Ee.tag) {
      case 5:
        Ai || Lu(Ee, ce);
      case 6:
        var Te = Gn, nt = Ni;
        Gn = null, yo(fe, ce, Ee), Gn = Te, Ni = nt, Gn !== null && (Ni ? (fe = Gn, Ee = Ee.stateNode, fe.nodeType === 8 ? fe.parentNode.removeChild(Ee) : fe.removeChild(Ee)) : Gn.removeChild(Ee.stateNode));
        break;
      case 18:
        Gn !== null && (Ni ? (fe = Gn, Ee = Ee.stateNode, fe.nodeType === 8 ? Ns(fe.parentNode, Ee) : fe.nodeType === 1 && Ns(fe, Ee), Sl(fe)) : Ns(Gn, Ee.stateNode));
        break;
      case 4:
        Te = Gn, nt = Ni, Gn = Ee.stateNode.containerInfo, Ni = !0, yo(fe, ce, Ee), Gn = Te, Ni = nt;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Ai && (Te = Ee.updateQueue, Te !== null && (Te = Te.lastEffect, Te !== null))) {
          nt = Te = Te.next;
          do {
            var ct = nt, bt = ct.destroy;
            ct = ct.tag, bt !== void 0 && (ct & 2 || ct & 4) && Wf(Ee, ce, bt), nt = nt.next;
          } while (nt !== Te);
        }
        yo(fe, ce, Ee);
        break;
      case 1:
        if (!Ai && (Lu(Ee, ce), Te = Ee.stateNode, typeof Te.componentWillUnmount == "function"))
          try {
            Te.props = Ee.memoizedProps, Te.state = Ee.memoizedState, Te.componentWillUnmount();
          } catch (Mt) {
            ui(Ee, ce, Mt);
          }
        yo(fe, ce, Ee);
        break;
      case 21:
        yo(fe, ce, Ee);
        break;
      case 22:
        Ee.mode & 1 ? (Ai = (Te = Ai) || Ee.memoizedState !== null, yo(fe, ce, Ee), Ai = Te) : yo(fe, ce, Ee);
        break;
      default:
        yo(fe, ce, Ee);
    }
  }
  function vs(fe) {
    var ce = fe.updateQueue;
    if (ce !== null) {
      fe.updateQueue = null;
      var Ee = fe.stateNode;
      Ee === null && (Ee = fe.stateNode = new Sv()), ce.forEach(function(Te) {
        var nt = Hg.bind(null, fe, Te);
        Ee.has(Te) || (Ee.add(Te), Te.then(nt, nt));
      });
    }
  }
  function Mo(fe, ce) {
    var Ee = ce.deletions;
    if (Ee !== null)
      for (var Te = 0; Te < Ee.length; Te++) {
        var nt = Ee[Te];
        try {
          var ct = fe, bt = ce, Mt = bt;
          e:
            for (; Mt !== null; ) {
              switch (Mt.tag) {
                case 5:
                  Gn = Mt.stateNode, Ni = !1;
                  break e;
                case 3:
                  Gn = Mt.stateNode.containerInfo, Ni = !0;
                  break e;
                case 4:
                  Gn = Mt.stateNode.containerInfo, Ni = !0;
                  break e;
              }
              Mt = Mt.return;
            }
          if (Gn === null)
            throw Error(oe(160));
          Iu(ct, bt, nt), Gn = null, Ni = !1;
          var Lt = nt.alternate;
          Lt !== null && (Lt.return = null), nt.return = null;
        } catch (qt) {
          ui(nt, ce, qt);
        }
      }
    if (ce.subtreeFlags & 12854)
      for (ce = ce.child; ce !== null; )
        Cv(ce, fe), ce = ce.sibling;
  }
  function Cv(fe, ce) {
    var Ee = fe.alternate, Te = fe.flags;
    switch (fe.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Mo(ce, fe), Wo(fe), Te & 4) {
          try {
            qf(3, fe, fe.return), Yf(3, fe);
          } catch (Rr) {
            ui(fe, fe.return, Rr);
          }
          try {
            qf(5, fe, fe.return);
          } catch (Rr) {
            ui(fe, fe.return, Rr);
          }
        }
        break;
      case 1:
        Mo(ce, fe), Wo(fe), Te & 512 && Ee !== null && Lu(Ee, Ee.return);
        break;
      case 5:
        if (Mo(ce, fe), Wo(fe), Te & 512 && Ee !== null && Lu(Ee, Ee.return), fe.flags & 32) {
          var nt = fe.stateNode;
          try {
            Vn(nt, "");
          } catch (Rr) {
            ui(fe, fe.return, Rr);
          }
        }
        if (Te & 4 && (nt = fe.stateNode, nt != null)) {
          var ct = fe.memoizedProps, bt = Ee !== null ? Ee.memoizedProps : ct, Mt = fe.type, Lt = fe.updateQueue;
          if (fe.updateQueue = null, Lt !== null)
            try {
              Mt === "input" && ct.type === "radio" && ct.name != null && Kn(nt, ct), ri(Mt, bt);
              var qt = ri(Mt, ct);
              for (bt = 0; bt < Lt.length; bt += 2) {
                var sr = Lt[bt], lr = Lt[bt + 1];
                sr === "style" ? mn(nt, lr) : sr === "dangerouslySetInnerHTML" ? Va(nt, lr) : sr === "children" ? Vn(nt, lr) : ft(nt, sr, lr, qt);
              }
              switch (Mt) {
                case "input":
                  Fn(nt, ct);
                  break;
                case "textarea":
                  ei(nt, ct);
                  break;
                case "select":
                  var or = nt._wrapperState.wasMultiple;
                  nt._wrapperState.wasMultiple = !!ct.multiple;
                  var Er = ct.value;
                  Er != null ? Dn(nt, !!ct.multiple, Er, !1) : or !== !!ct.multiple && (ct.defaultValue != null ? Dn(
                    nt,
                    !!ct.multiple,
                    ct.defaultValue,
                    !0
                  ) : Dn(nt, !!ct.multiple, ct.multiple ? [] : "", !1));
              }
              nt[Al] = ct;
            } catch (Rr) {
              ui(fe, fe.return, Rr);
            }
        }
        break;
      case 6:
        if (Mo(ce, fe), Wo(fe), Te & 4) {
          if (fe.stateNode === null)
            throw Error(oe(162));
          nt = fe.stateNode, ct = fe.memoizedProps;
          try {
            nt.nodeValue = ct;
          } catch (Rr) {
            ui(fe, fe.return, Rr);
          }
        }
        break;
      case 3:
        if (Mo(ce, fe), Wo(fe), Te & 4 && Ee !== null && Ee.memoizedState.isDehydrated)
          try {
            Sl(ce.containerInfo);
          } catch (Rr) {
            ui(fe, fe.return, Rr);
          }
        break;
      case 4:
        Mo(ce, fe), Wo(fe);
        break;
      case 13:
        Mo(ce, fe), Wo(fe), nt = fe.child, nt.flags & 8192 && (ct = nt.memoizedState !== null, nt.stateNode.isHidden = ct, !ct || nt.alternate !== null && nt.alternate.memoizedState !== null || (mp = Hn())), Te & 4 && vs(fe);
        break;
      case 22:
        if (sr = Ee !== null && Ee.memoizedState !== null, fe.mode & 1 ? (Ai = (qt = Ai) || sr, Mo(ce, fe), Ai = qt) : Mo(ce, fe), Wo(fe), Te & 8192) {
          if (qt = fe.memoizedState !== null, (fe.stateNode.isHidden = qt) && !sr && fe.mode & 1)
            for (wr = fe, sr = fe.child; sr !== null; ) {
              for (lr = wr = sr; wr !== null; ) {
                switch (or = wr, Er = or.child, or.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    qf(4, or, or.return);
                    break;
                  case 1:
                    Lu(or, or.return);
                    var _r = or.stateNode;
                    if (typeof _r.componentWillUnmount == "function") {
                      Te = or, Ee = or.return;
                      try {
                        ce = Te, _r.props = ce.memoizedProps, _r.state = ce.memoizedState, _r.componentWillUnmount();
                      } catch (Rr) {
                        ui(Te, Ee, Rr);
                      }
                    }
                    break;
                  case 5:
                    Lu(or, or.return);
                    break;
                  case 22:
                    if (or.memoizedState !== null) {
                      hp(lr);
                      continue;
                    }
                }
                Er !== null ? (Er.return = or, wr = Er) : hp(lr);
              }
              sr = sr.sibling;
            }
          e:
            for (sr = null, lr = fe; ; ) {
              if (lr.tag === 5) {
                if (sr === null) {
                  sr = lr;
                  try {
                    nt = lr.stateNode, qt ? (ct = nt.style, typeof ct.setProperty == "function" ? ct.setProperty("display", "none", "important") : ct.display = "none") : (Mt = lr.stateNode, Lt = lr.memoizedProps.style, bt = Lt != null && Lt.hasOwnProperty("display") ? Lt.display : null, Mt.style.display = Jr("display", bt));
                  } catch (Rr) {
                    ui(fe, fe.return, Rr);
                  }
                }
              } else if (lr.tag === 6) {
                if (sr === null)
                  try {
                    lr.stateNode.nodeValue = qt ? "" : lr.memoizedProps;
                  } catch (Rr) {
                    ui(fe, fe.return, Rr);
                  }
              } else if ((lr.tag !== 22 && lr.tag !== 23 || lr.memoizedState === null || lr === fe) && lr.child !== null) {
                lr.child.return = lr, lr = lr.child;
                continue;
              }
              if (lr === fe)
                break e;
              for (; lr.sibling === null; ) {
                if (lr.return === null || lr.return === fe)
                  break e;
                sr === lr && (sr = null), lr = lr.return;
              }
              sr === lr && (sr = null), lr.sibling.return = lr.return, lr = lr.sibling;
            }
        }
        break;
      case 19:
        Mo(ce, fe), Wo(fe), Te & 4 && vs(fe);
        break;
      case 21:
        break;
      default:
        Mo(
          ce,
          fe
        ), Wo(fe);
    }
  }
  function Wo(fe) {
    var ce = fe.flags;
    if (ce & 2) {
      try {
        e: {
          for (var Ee = fe.return; Ee !== null; ) {
            if (xv(Ee)) {
              var Te = Ee;
              break e;
            }
            Ee = Ee.return;
          }
          throw Error(oe(160));
        }
        switch (Te.tag) {
          case 5:
            var nt = Te.stateNode;
            Te.flags & 32 && (Vn(nt, ""), Te.flags &= -33);
            var ct = Sd(fe);
            Go(fe, ct, nt);
            break;
          case 3:
          case 4:
            var bt = Te.stateNode.containerInfo, Mt = Sd(fe);
            $u(fe, Mt, bt);
            break;
          default:
            throw Error(oe(161));
        }
      } catch (Lt) {
        ui(fe, fe.return, Lt);
      }
      fe.flags &= -3;
    }
    ce & 4096 && (fe.flags &= -4097);
  }
  function Tv(fe, ce, Ee) {
    wr = fe, Nu(fe);
  }
  function Nu(fe, ce, Ee) {
    for (var Te = (fe.mode & 1) !== 0; wr !== null; ) {
      var nt = wr, ct = nt.child;
      if (nt.tag === 22 && Te) {
        var bt = nt.memoizedState !== null || Gf;
        if (!bt) {
          var Mt = nt.alternate, Lt = Mt !== null && Mt.memoizedState !== null || Ai;
          Mt = Gf;
          var qt = Ai;
          if (Gf = bt, (Ai = Lt) && !qt)
            for (wr = nt; wr !== null; )
              bt = wr, Lt = bt.child, bt.tag === 22 && bt.memoizedState !== null ? _v(nt) : Lt !== null ? (Lt.return = bt, wr = Lt) : _v(nt);
          for (; ct !== null; )
            wr = ct, Nu(ct), ct = ct.sibling;
          wr = nt, Gf = Mt, Ai = qt;
        }
        wv(fe);
      } else
        nt.subtreeFlags & 8772 && ct !== null ? (ct.return = nt, wr = ct) : wv(fe);
    }
  }
  function wv(fe) {
    for (; wr !== null; ) {
      var ce = wr;
      if (ce.flags & 8772) {
        var Ee = ce.alternate;
        try {
          if (ce.flags & 8772)
            switch (ce.tag) {
              case 0:
              case 11:
              case 15:
                Ai || Yf(5, ce);
                break;
              case 1:
                var Te = ce.stateNode;
                if (ce.flags & 4 && !Ai)
                  if (Ee === null)
                    Te.componentDidMount();
                  else {
                    var nt = ce.elementType === ce.type ? Ee.memoizedProps : Ya(ce.type, Ee.memoizedProps);
                    Te.componentDidUpdate(nt, Ee.memoizedState, Te.__reactInternalSnapshotBeforeUpdate);
                  }
                var ct = ce.updateQueue;
                ct !== null && Rl(ce, ct, Te);
                break;
              case 3:
                var bt = ce.updateQueue;
                if (bt !== null) {
                  if (Ee = null, ce.child !== null)
                    switch (ce.child.tag) {
                      case 5:
                        Ee = ce.child.stateNode;
                        break;
                      case 1:
                        Ee = ce.child.stateNode;
                    }
                  Rl(ce, bt, Ee);
                }
                break;
              case 5:
                var Mt = ce.stateNode;
                if (Ee === null && ce.flags & 4) {
                  Ee = Mt;
                  var Lt = ce.memoizedProps;
                  switch (ce.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Lt.autoFocus && Ee.focus();
                      break;
                    case "img":
                      Lt.src && (Ee.src = Lt.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ce.memoizedState === null) {
                  var qt = ce.alternate;
                  if (qt !== null) {
                    var sr = qt.memoizedState;
                    if (sr !== null) {
                      var lr = sr.dehydrated;
                      lr !== null && Sl(lr);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(oe(163));
            }
          Ai || ce.flags & 512 && cp(ce);
        } catch (or) {
          ui(ce, ce.return, or);
        }
      }
      if (ce === fe) {
        wr = null;
        break;
      }
      if (Ee = ce.sibling, Ee !== null) {
        Ee.return = ce.return, wr = Ee;
        break;
      }
      wr = ce.return;
    }
  }
  function hp(fe) {
    for (; wr !== null; ) {
      var ce = wr;
      if (ce === fe) {
        wr = null;
        break;
      }
      var Ee = ce.sibling;
      if (Ee !== null) {
        Ee.return = ce.return, wr = Ee;
        break;
      }
      wr = ce.return;
    }
  }
  function _v(fe) {
    for (; wr !== null; ) {
      var ce = wr;
      try {
        switch (ce.tag) {
          case 0:
          case 11:
          case 15:
            var Ee = ce.return;
            try {
              Yf(4, ce);
            } catch (Lt) {
              ui(ce, Ee, Lt);
            }
            break;
          case 1:
            var Te = ce.stateNode;
            if (typeof Te.componentDidMount == "function") {
              var nt = ce.return;
              try {
                Te.componentDidMount();
              } catch (Lt) {
                ui(ce, nt, Lt);
              }
            }
            var ct = ce.return;
            try {
              cp(ce);
            } catch (Lt) {
              ui(ce, ct, Lt);
            }
            break;
          case 5:
            var bt = ce.return;
            try {
              cp(ce);
            } catch (Lt) {
              ui(ce, bt, Lt);
            }
        }
      } catch (Lt) {
        ui(ce, ce.return, Lt);
      }
      if (ce === fe) {
        wr = null;
        break;
      }
      var Mt = ce.sibling;
      if (Mt !== null) {
        Mt.return = ce.return, wr = Mt;
        break;
      }
      wr = ce.return;
    }
  }
  var Ed = Math.ceil, Qf = vt.ReactCurrentDispatcher, pp = vt.ReactCurrentOwner, na = vt.ReactCurrentBatchConfig, rn = 0, Qn = null, li = null, zi = 0, Xa = 0, zu = Qr(0), Pi = 0, Xf = null, ys = 0, bd = 0, Vu = 0, Bl = null, ca = null, mp = 0, Bu = 1 / 0, gs = null, xd = !1, Hl = null, qo = null, Js = !1, Zs = null, Cd = 0, Hu = 0, Td = null, Ul = -1, jl = 0;
  function ia() {
    return rn & 6 ? Hn() : Ul !== -1 ? Ul : Ul = Hn();
  }
  function gi(fe) {
    return fe.mode & 1 ? rn & 2 && zi !== 0 ? zi & -zi : Gc.transition !== null ? (jl === 0 && (jl = pu()), jl) : (fe = un, fe !== 0 || (fe = window.event, fe = fe === void 0 ? 16 : ai(fe.type)), fe) : 1;
  }
  function aa(fe, ce, Ee, Te) {
    if (50 < Hu)
      throw Hu = 0, Td = null, Error(oe(185));
    rs(fe, Ee, Te), (!(rn & 2) || fe !== Qn) && (fe === Qn && (!(rn & 2) && (bd |= Ee), Pi === 4 && go(fe, zi)), oa(fe, Te), Ee === 1 && rn === 0 && !(ce.mode & 1) && (Bu = Hn() + 500, $i && Pa()));
  }
  function oa(fe, ce) {
    var Ee = fe.callbackNode;
    hu(fe, ce);
    var Te = wa(fe, fe === Qn ? zi : 0);
    if (Te === 0)
      Ee !== null && Io(Ee), fe.callbackNode = null, fe.callbackPriority = 0;
    else if (ce = Te & -Te, fe.callbackPriority !== ce) {
      if (Ee != null && Io(Ee), ce === 1)
        fe.tag === 0 ? zh(Av.bind(null, fe)) : Nh(Av.bind(null, fe)), Lh(function() {
          !(rn & 6) && Pa();
        }), Ee = null;
      else {
        switch (Vo(Te)) {
          case 1:
            Ee = wo;
            break;
          case 4:
            Ee = Kr;
            break;
          case 16:
            Ee = No;
            break;
          case 536870912:
            Ee = no;
            break;
          default:
            Ee = No;
        }
        Ee = bp(Ee, Uu.bind(null, fe));
      }
      fe.callbackPriority = ce, fe.callbackNode = Ee;
    }
  }
  function Uu(fe, ce) {
    if (Ul = -1, jl = 0, rn & 6)
      throw Error(oe(327));
    var Ee = fe.callbackNode;
    if (Gu() && fe.callbackNode !== Ee)
      return null;
    var Te = wa(fe, fe === Qn ? zi : 0);
    if (Te === 0)
      return null;
    if (Te & 30 || Te & fe.expiredLanes || ce)
      ce = _d(fe, Te);
    else {
      ce = Te;
      var nt = rn;
      rn |= 2;
      var ct = wd();
      (Qn !== fe || zi !== ce) && (gs = null, Bu = Hn() + 500, Gl(fe, ce));
      do
        try {
          Ng();
          break;
        } catch (Mt) {
          Pv(fe, Mt);
        }
      while (!0);
      Gh(), Qf.current = ct, rn = nt, li !== null ? ce = 0 : (Qn = null, zi = 0, ce = Pi);
    }
    if (ce !== 0) {
      if (ce === 2 && (nt = yf(fe), nt !== 0 && (Te = nt, ce = vp(fe, nt))), ce === 1)
        throw Ee = Xf, Gl(fe, 0), go(fe, Te), oa(fe, Hn()), Ee;
      if (ce === 6)
        go(fe, Te);
      else {
        if (nt = fe.current.alternate, !(Te & 30) && !yp(nt) && (ce = _d(fe, Te), ce === 2 && (ct = yf(fe), ct !== 0 && (Te = ct, ce = vp(fe, ct))), ce === 1))
          throw Ee = Xf, Gl(fe, 0), go(fe, Te), oa(fe, Hn()), Ee;
        switch (fe.finishedWork = nt, fe.finishedLanes = Te, ce) {
          case 0:
          case 1:
            throw Error(oe(345));
          case 2:
            Wl(fe, ca, gs);
            break;
          case 3:
            if (go(fe, Te), (Te & 130023424) === Te && (ce = mp + 500 - Hn(), 10 < ce)) {
              if (wa(fe, 0) !== 0)
                break;
              if (nt = fe.suspendedLanes, (nt & Te) !== Te) {
                ia(), fe.pingedLanes |= fe.suspendedLanes & nt;
                break;
              }
              fe.timeoutHandle = _l(Wl.bind(null, fe, ca, gs), ce);
              break;
            }
            Wl(fe, ca, gs);
            break;
          case 4:
            if (go(fe, Te), (Te & 4194240) === Te)
              break;
            for (ce = fe.eventTimes, nt = -1; 0 < Te; ) {
              var bt = 31 - Ta(Te);
              ct = 1 << bt, bt = ce[bt], bt > nt && (nt = bt), Te &= ~ct;
            }
            if (Te = nt, Te = Hn() - Te, Te = (120 > Te ? 120 : 480 > Te ? 480 : 1080 > Te ? 1080 : 1920 > Te ? 1920 : 3e3 > Te ? 3e3 : 4320 > Te ? 4320 : 1960 * Ed(Te / 1960)) - Te, 10 < Te) {
              fe.timeoutHandle = _l(Wl.bind(null, fe, ca, gs), Te);
              break;
            }
            Wl(fe, ca, gs);
            break;
          case 5:
            Wl(fe, ca, gs);
            break;
          default:
            throw Error(oe(329));
        }
      }
    }
    return oa(fe, Hn()), fe.callbackNode === Ee ? Uu.bind(null, fe) : null;
  }
  function vp(fe, ce) {
    var Ee = Bl;
    return fe.current.memoizedState.isDehydrated && (Gl(fe, ce).flags |= 256), fe = _d(fe, ce), fe !== 2 && (ce = ca, ca = Ee, ce !== null && Kf(ce)), fe;
  }
  function Kf(fe) {
    ca === null ? ca = fe : ca.push.apply(ca, fe);
  }
  function yp(fe) {
    for (var ce = fe; ; ) {
      if (ce.flags & 16384) {
        var Ee = ce.updateQueue;
        if (Ee !== null && (Ee = Ee.stores, Ee !== null))
          for (var Te = 0; Te < Ee.length; Te++) {
            var nt = Ee[Te], ct = nt.getSnapshot;
            nt = nt.value;
            try {
              if (!so(ct(), nt))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (Ee = ce.child, ce.subtreeFlags & 16384 && Ee !== null)
        Ee.return = ce, ce = Ee;
      else {
        if (ce === fe)
          break;
        for (; ce.sibling === null; ) {
          if (ce.return === null || ce.return === fe)
            return !0;
          ce = ce.return;
        }
        ce.sibling.return = ce.return, ce = ce.sibling;
      }
    }
    return !0;
  }
  function go(fe, ce) {
    for (ce &= ~Vu, ce &= ~bd, fe.suspendedLanes |= ce, fe.pingedLanes &= ~ce, fe = fe.expirationTimes; 0 < ce; ) {
      var Ee = 31 - Ta(ce), Te = 1 << Ee;
      fe[Ee] = -1, ce &= ~Te;
    }
  }
  function Av(fe) {
    if (rn & 6)
      throw Error(oe(327));
    Gu();
    var ce = wa(fe, 0);
    if (!(ce & 1))
      return oa(fe, Hn()), null;
    var Ee = _d(fe, ce);
    if (fe.tag !== 0 && Ee === 2) {
      var Te = yf(fe);
      Te !== 0 && (ce = Te, Ee = vp(fe, Te));
    }
    if (Ee === 1)
      throw Ee = Xf, Gl(fe, 0), go(fe, ce), oa(fe, Hn()), Ee;
    if (Ee === 6)
      throw Error(oe(345));
    return fe.finishedWork = fe.current.alternate, fe.finishedLanes = ce, Wl(fe, ca, gs), oa(fe, Hn()), null;
  }
  function ju(fe, ce) {
    var Ee = rn;
    rn |= 1;
    try {
      return fe(ce);
    } finally {
      rn = Ee, rn === 0 && (Bu = Hn() + 500, $i && Pa());
    }
  }
  function el(fe) {
    Zs !== null && Zs.tag === 0 && !(rn & 6) && Gu();
    var ce = rn;
    rn |= 1;
    var Ee = na.transition, Te = un;
    try {
      if (na.transition = null, un = 1, fe)
        return fe();
    } finally {
      un = Te, na.transition = Ee, rn = ce, !(rn & 6) && Pa();
    }
  }
  function gp() {
    Xa = zu.current, pn(zu);
  }
  function Gl(fe, ce) {
    fe.finishedWork = null, fe.finishedLanes = 0;
    var Ee = fe.timeoutHandle;
    if (Ee !== -1 && (fe.timeoutHandle = -1, tv(Ee)), li !== null)
      for (Ee = li.return; Ee !== null; ) {
        var Te = Ee;
        switch (Bh(Te), Te.tag) {
          case 1:
            Te = Te.type.childContextTypes, Te != null && fo();
            break;
          case 3:
            Ys(), pn(si), pn(Ur), Kc();
            break;
          case 5:
            Zr(Te);
            break;
          case 4:
            Ys();
            break;
          case 13:
            pn(Vr);
            break;
          case 19:
            pn(Vr);
            break;
          case 10:
            js(Te.type._context);
            break;
          case 22:
          case 23:
            gp();
        }
        Ee = Ee.return;
      }
    if (Qn = fe, li = fe = tl(fe.current, null), zi = Xa = ce, Pi = 0, Xf = null, Vu = bd = ys = 0, ca = Bl = null, ji !== null) {
      for (ce = 0; ce < ji.length; ce++)
        if (Ee = ji[ce], Te = Ee.interleaved, Te !== null) {
          Ee.interleaved = null;
          var nt = Te.next, ct = Ee.pending;
          if (ct !== null) {
            var bt = ct.next;
            ct.next = nt, Te.next = bt;
          }
          Ee.pending = Te;
        }
      ji = null;
    }
    return fe;
  }
  function Pv(fe, ce) {
    do {
      var Ee = li;
      try {
        if (Gh(), Jc.current = pd, Br) {
          for (var Te = $n.memoizedState; Te !== null; ) {
            var nt = Te.queue;
            nt !== null && (nt.pending = null), Te = Te.next;
          }
          Br = !1;
        }
        if (Ml = 0, on = Zt = $n = null, jo = !1, Qa = 0, pp.current = null, Ee === null || Ee.return === null) {
          Pi = 1, Xf = ce, li = null;
          break;
        }
        e: {
          var ct = fe, bt = Ee.return, Mt = Ee, Lt = ce;
          if (ce = zi, Mt.flags |= 32768, Lt !== null && typeof Lt == "object" && typeof Lt.then == "function") {
            var qt = Lt, sr = Mt, lr = sr.tag;
            if (!(sr.mode & 1) && (lr === 0 || lr === 11 || lr === 15)) {
              var or = sr.alternate;
              or ? (sr.updateQueue = or.updateQueue, sr.memoizedState = or.memoizedState, sr.lanes = or.lanes) : (sr.updateQueue = null, sr.memoizedState = null);
            }
            var Er = ep(bt);
            if (Er !== null) {
              Er.flags &= -257, tp(Er, bt, Mt, ct, ce), Er.mode & 1 && vv(ct, qt, ce), ce = Er, Lt = qt;
              var _r = ce.updateQueue;
              if (_r === null) {
                var Rr = /* @__PURE__ */ new Set();
                Rr.add(Lt), ce.updateQueue = Rr;
              } else
                _r.add(Lt);
              break e;
            } else {
              if (!(ce & 1)) {
                vv(ct, qt, ce), Sp();
                break e;
              }
              Lt = Error(oe(426));
            }
          } else if (Ln && Mt.mode & 1) {
            var di = ep(bt);
            if (di !== null) {
              !(di.flags & 65536) && (di.flags |= 256), tp(di, bt, Mt, ct, ce), Uh(Fu(Lt, Mt));
              break e;
            }
          }
          ct = Lt = Fu(Lt, Mt), Pi !== 4 && (Pi = 2), Bl === null ? Bl = [ct] : Bl.push(ct), ct = bt;
          do {
            switch (ct.tag) {
              case 3:
                ct.flags |= 65536, ce &= -ce, ct.lanes |= ce;
                var Bt = mv(ct, Lt, ce);
                Yh(ct, Bt);
                break e;
              case 1:
                Mt = Lt;
                var It = ct.type, jt = ct.stateNode;
                if (!(ct.flags & 128) && (typeof It.getDerivedStateFromError == "function" || jt !== null && typeof jt.componentDidCatch == "function" && (qo === null || !qo.has(jt)))) {
                  ct.flags |= 65536, ce &= -ce, ct.lanes |= ce;
                  var cr = Hf(ct, Mt, ce);
                  Yh(ct, cr);
                  break e;
                }
            }
            ct = ct.return;
          } while (ct !== null);
        }
        Ep(Ee);
      } catch (Mr) {
        ce = Mr, li === Ee && Ee !== null && (li = Ee = Ee.return);
        continue;
      }
      break;
    } while (!0);
  }
  function wd() {
    var fe = Qf.current;
    return Qf.current = pd, fe === null ? pd : fe;
  }
  function Sp() {
    (Pi === 0 || Pi === 3 || Pi === 2) && (Pi = 4), Qn === null || !(ys & 268435455) && !(bd & 268435455) || go(Qn, zi);
  }
  function _d(fe, ce) {
    var Ee = rn;
    rn |= 2;
    var Te = wd();
    (Qn !== fe || zi !== ce) && (gs = null, Gl(fe, ce));
    do
      try {
        Ig();
        break;
      } catch (nt) {
        Pv(fe, nt);
      }
    while (!0);
    if (Gh(), rn = Ee, Qf.current = Te, li !== null)
      throw Error(oe(261));
    return Qn = null, zi = 0, Pi;
  }
  function Ig() {
    for (; li !== null; )
      Rv(li);
  }
  function Ng() {
    for (; li !== null && !ch(); )
      Rv(li);
  }
  function Rv(fe) {
    var ce = Mv(fe.alternate, fe, Xa);
    fe.memoizedProps = fe.pendingProps, ce === null ? Ep(fe) : li = ce, pp.current = null;
  }
  function Ep(fe) {
    var ce = fe;
    do {
      var Ee = ce.alternate;
      if (fe = ce.return, ce.flags & 32768) {
        if (Ee = fp(Ee, ce), Ee !== null) {
          Ee.flags &= 32767, li = Ee;
          return;
        }
        if (fe !== null)
          fe.flags |= 32768, fe.subtreeFlags = 0, fe.deletions = null;
        else {
          Pi = 6, li = null;
          return;
        }
      } else if (Ee = $g(Ee, ce, Xa), Ee !== null) {
        li = Ee;
        return;
      }
      if (ce = ce.sibling, ce !== null) {
        li = ce;
        return;
      }
      li = ce = fe;
    } while (ce !== null);
    Pi === 0 && (Pi = 5);
  }
  function Wl(fe, ce, Ee) {
    var Te = un, nt = na.transition;
    try {
      na.transition = null, un = 1, zg(fe, ce, Ee, Te);
    } finally {
      na.transition = nt, un = Te;
    }
    return null;
  }
  function zg(fe, ce, Ee, Te) {
    do
      Gu();
    while (Zs !== null);
    if (rn & 6)
      throw Error(oe(327));
    Ee = fe.finishedWork;
    var nt = fe.finishedLanes;
    if (Ee === null)
      return null;
    if (fe.finishedWork = null, fe.finishedLanes = 0, Ee === fe.current)
      throw Error(oe(177));
    fe.callbackNode = null, fe.callbackPriority = 0;
    var ct = Ee.lanes | Ee.childLanes;
    if (ph(fe, ct), fe === Qn && (li = Qn = null, zi = 0), !(Ee.subtreeFlags & 2064) && !(Ee.flags & 2064) || Js || (Js = !0, bp(No, function() {
      return Gu(), null;
    })), ct = (Ee.flags & 15990) !== 0, Ee.subtreeFlags & 15990 || ct) {
      ct = na.transition, na.transition = null;
      var bt = un;
      un = 1;
      var Mt = rn;
      rn |= 4, pp.current = null, bv(fe, Ee), Cv(Ee, fe), Oc(wl), zt = !!Dh, wl = Dh = null, fe.current = Ee, Tv(Ee), dh(), rn = Mt, un = bt, na.transition = ct;
    } else
      fe.current = Ee;
    if (Js && (Js = !1, Zs = fe, Cd = nt), ct = fe.pendingLanes, ct === 0 && (qo = null), xc(Ee.stateNode), oa(fe, Hn()), ce !== null)
      for (Te = fe.onRecoverableError, Ee = 0; Ee < ce.length; Ee++)
        nt = ce[Ee], Te(nt.value, { componentStack: nt.stack, digest: nt.digest });
    if (xd)
      throw xd = !1, fe = Hl, Hl = null, fe;
    return Cd & 1 && fe.tag !== 0 && Gu(), ct = fe.pendingLanes, ct & 1 ? fe === Td ? Hu++ : (Hu = 0, Td = fe) : Hu = 0, Pa(), null;
  }
  function Gu() {
    if (Zs !== null) {
      var fe = Vo(Cd), ce = na.transition, Ee = un;
      try {
        if (na.transition = null, un = 16 > fe ? 16 : fe, Zs === null)
          var Te = !1;
        else {
          if (fe = Zs, Zs = null, Cd = 0, rn & 6)
            throw Error(oe(331));
          var nt = rn;
          for (rn |= 4, wr = fe.current; wr !== null; ) {
            var ct = wr, bt = ct.child;
            if (wr.flags & 16) {
              var Mt = ct.deletions;
              if (Mt !== null) {
                for (var Lt = 0; Lt < Mt.length; Lt++) {
                  var qt = Mt[Lt];
                  for (wr = qt; wr !== null; ) {
                    var sr = wr;
                    switch (sr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        qf(8, sr, ct);
                    }
                    var lr = sr.child;
                    if (lr !== null)
                      lr.return = sr, wr = lr;
                    else
                      for (; wr !== null; ) {
                        sr = wr;
                        var or = sr.sibling, Er = sr.return;
                        if (dp(sr), sr === qt) {
                          wr = null;
                          break;
                        }
                        if (or !== null) {
                          or.return = Er, wr = or;
                          break;
                        }
                        wr = Er;
                      }
                  }
                }
                var _r = ct.alternate;
                if (_r !== null) {
                  var Rr = _r.child;
                  if (Rr !== null) {
                    _r.child = null;
                    do {
                      var di = Rr.sibling;
                      Rr.sibling = null, Rr = di;
                    } while (Rr !== null);
                  }
                }
                wr = ct;
              }
            }
            if (ct.subtreeFlags & 2064 && bt !== null)
              bt.return = ct, wr = bt;
            else
              e:
                for (; wr !== null; ) {
                  if (ct = wr, ct.flags & 2048)
                    switch (ct.tag) {
                      case 0:
                      case 11:
                      case 15:
                        qf(9, ct, ct.return);
                    }
                  var Bt = ct.sibling;
                  if (Bt !== null) {
                    Bt.return = ct.return, wr = Bt;
                    break e;
                  }
                  wr = ct.return;
                }
          }
          var It = fe.current;
          for (wr = It; wr !== null; ) {
            bt = wr;
            var jt = bt.child;
            if (bt.subtreeFlags & 2064 && jt !== null)
              jt.return = bt, wr = jt;
            else
              e:
                for (bt = It; wr !== null; ) {
                  if (Mt = wr, Mt.flags & 2048)
                    try {
                      switch (Mt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Yf(9, Mt);
                      }
                    } catch (Mr) {
                      ui(Mt, Mt.return, Mr);
                    }
                  if (Mt === bt) {
                    wr = null;
                    break e;
                  }
                  var cr = Mt.sibling;
                  if (cr !== null) {
                    cr.return = Mt.return, wr = cr;
                    break e;
                  }
                  wr = Mt.return;
                }
          }
          if (rn = nt, Pa(), Ua && typeof Ua.onPostCommitFiberRoot == "function")
            try {
              Ua.onPostCommitFiberRoot(ml, fe);
            } catch {
            }
          Te = !0;
        }
        return Te;
      } finally {
        un = Ee, na.transition = ce;
      }
    }
    return !1;
  }
  function kv(fe, ce, Ee) {
    ce = Fu(Ee, ce), ce = mv(fe, ce, 1), fe = Ws(fe, ce, 1), ce = ia(), fe !== null && (rs(fe, 1, ce), oa(fe, ce));
  }
  function ui(fe, ce, Ee) {
    if (fe.tag === 3)
      kv(fe, fe, Ee);
    else
      for (; ce !== null; ) {
        if (ce.tag === 3) {
          kv(ce, fe, Ee);
          break;
        } else if (ce.tag === 1) {
          var Te = ce.stateNode;
          if (typeof ce.type.getDerivedStateFromError == "function" || typeof Te.componentDidCatch == "function" && (qo === null || !qo.has(Te))) {
            fe = Fu(Ee, fe), fe = Hf(ce, fe, 1), ce = Ws(ce, fe, 1), fe = ia(), ce !== null && (rs(ce, 1, fe), oa(ce, fe));
            break;
          }
        }
        ce = ce.return;
      }
  }
  function Vg(fe, ce, Ee) {
    var Te = fe.pingCache;
    Te !== null && Te.delete(ce), ce = ia(), fe.pingedLanes |= fe.suspendedLanes & Ee, Qn === fe && (zi & Ee) === Ee && (Pi === 4 || Pi === 3 && (zi & 130023424) === zi && 500 > Hn() - mp ? Gl(fe, 0) : Vu |= Ee), oa(fe, ce);
  }
  function Ad(fe, ce) {
    ce === 0 && (fe.mode & 1 ? (ce = io, io <<= 1, !(io & 130023424) && (io = 4194304)) : ce = 1);
    var Ee = ia();
    fe = ds(fe, ce), fe !== null && (rs(fe, ce, Ee), oa(fe, Ee));
  }
  function Bg(fe) {
    var ce = fe.memoizedState, Ee = 0;
    ce !== null && (Ee = ce.retryLane), Ad(fe, Ee);
  }
  function Hg(fe, ce) {
    var Ee = 0;
    switch (fe.tag) {
      case 13:
        var Te = fe.stateNode, nt = fe.memoizedState;
        nt !== null && (Ee = nt.retryLane);
        break;
      case 19:
        Te = fe.stateNode;
        break;
      default:
        throw Error(oe(314));
    }
    Te !== null && Te.delete(ce), Ad(fe, Ee);
  }
  var Mv;
  Mv = function(fe, ce, Ee) {
    if (fe !== null)
      if (fe.memoizedProps !== ce.pendingProps || si.current)
        yi = !0;
      else {
        if (!(fe.lanes & Ee) && !(ce.flags & 128))
          return yi = !1, ms(fe, ce, Ee);
        yi = !!(fe.flags & 131072);
      }
    else
      yi = !1, Ln && ce.flags & 1048576 && Vh(ce, wu, ce.index);
    switch (ce.lanes = 0, ce.tag) {
      case 2:
        var Te = ce.type;
        ta(fe, ce), fe = ce.pendingProps;
        var nt = uo(ce, Ur.current);
        hr(ce, Ee), nt = Qs(null, ce, Te, fe, nt, Ee);
        var ct = Ol();
        return ce.flags |= 1, typeof nt == "object" && nt !== null && typeof nt.render == "function" && nt.$$typeof === void 0 ? (ce.tag = 1, ce.memoizedState = null, ce.updateQueue = null, jn(Te) ? (ct = !0, Vc(ce)) : ct = !1, ce.memoizedState = nt.state !== null && nt.state !== void 0 ? nt.state : null, qh(ce), nt.updater = Yc, ce.stateNode = nt, nt._reactInternals = ce, Qc(ce, Te, fe, Ee), ce = yv(null, ce, Te, !0, ct, Ee)) : (ce.tag = 0, Ln && ct && Bc(ce), wi(null, ce, nt, Ee), ce = ce.child), ce;
      case 16:
        Te = ce.elementType;
        e: {
          switch (ta(fe, ce), fe = ce.pendingProps, nt = Te._init, Te = nt(Te._payload), ce.type = Te, nt = ce.tag = jg(Te), fe = Ya(Te, fe), nt) {
            case 0:
              ce = Du(null, ce, Te, fe, Ee);
              break e;
            case 1:
              ce = rp(null, ce, Te, fe, Ee);
              break e;
            case 11:
              ce = Ks(null, ce, Te, fe, Ee);
              break e;
            case 14:
              ce = vd(null, ce, Te, Ya(Te.type, fe), Ee);
              break e;
          }
          throw Error(oe(
            306,
            Te,
            ""
          ));
        }
        return ce;
      case 0:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : Ya(Te, nt), Du(fe, ce, Te, nt, Ee);
      case 1:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : Ya(Te, nt), rp(fe, ce, Te, nt, Ee);
      case 3:
        e: {
          if (gv(ce), fe === null)
            throw Error(oe(387));
          Te = ce.pendingProps, ct = ce.memoizedState, nt = ct.element, Ti(fe, ce), qs(ce, Te, null, Ee);
          var bt = ce.memoizedState;
          if (Te = bt.element, ct.isDehydrated)
            if (ct = { element: Te, isDehydrated: !1, cache: bt.cache, pendingSuspenseBoundaries: bt.pendingSuspenseBoundaries, transitions: bt.transitions }, ce.updateQueue.baseState = ct, ce.memoizedState = ct, ce.flags & 256) {
              nt = Fu(Error(oe(423)), ce), ce = yd(fe, ce, Te, Ee, nt);
              break e;
            } else if (Te !== nt) {
              nt = Fu(Error(oe(424)), ce), ce = yd(fe, ce, Te, Ee, nt);
              break e;
            } else
              for (Ma = Ro(ce.stateNode.containerInfo.firstChild), qa = ce, Ln = !0, ho = null, Ee = hv(ce, null, Te, Ee), ce.child = Ee; Ee; )
                Ee.flags = Ee.flags & -3 | 4096, Ee = Ee.sibling;
          else {
            if (qn(), Te === nt) {
              ce = Gi(fe, ce, Ee);
              break e;
            }
            wi(fe, ce, Te, Ee);
          }
          ce = ce.child;
        }
        return ce;
      case 5:
        return zr(ce), fe === null && Uc(ce), Te = ce.type, nt = ce.pendingProps, ct = fe !== null ? fe.memoizedProps : null, bt = nt.children, kf(Te, nt) ? bt = null : ct !== null && kf(Te, ct) && (ce.flags |= 32), Xr(fe, ce), wi(fe, ce, bt, Ee), ce.child;
      case 6:
        return fe === null && Uc(ce), null;
      case 13:
        return ap(fe, ce, Ee);
      case 4:
        return Xh(ce, ce.stateNode.containerInfo), Te = ce.pendingProps, fe === null ? ce.child = Au(ce, null, Te, Ee) : wi(fe, ce, Te, Ee), ce.child;
      case 11:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : Ya(Te, nt), Ks(fe, ce, Te, nt, Ee);
      case 7:
        return wi(fe, ce, ce.pendingProps, Ee), ce.child;
      case 8:
        return wi(fe, ce, ce.pendingProps.children, Ee), ce.child;
      case 12:
        return wi(fe, ce, ce.pendingProps.children, Ee), ce.child;
      case 10:
        e: {
          if (Te = ce.type._context, nt = ce.pendingProps, ct = ce.memoizedProps, bt = nt.value, Sn(Uo, Te._currentValue), Te._currentValue = bt, ct !== null)
            if (so(ct.value, bt)) {
              if (ct.children === nt.children && !si.current) {
                ce = Gi(fe, ce, Ee);
                break e;
              }
            } else
              for (ct = ce.child, ct !== null && (ct.return = ce); ct !== null; ) {
                var Mt = ct.dependencies;
                if (Mt !== null) {
                  bt = ct.child;
                  for (var Lt = Mt.firstContext; Lt !== null; ) {
                    if (Lt.context === Te) {
                      if (ct.tag === 1) {
                        Lt = hs(-1, Ee & -Ee), Lt.tag = 2;
                        var qt = ct.updateQueue;
                        if (qt !== null) {
                          qt = qt.shared;
                          var sr = qt.pending;
                          sr === null ? Lt.next = Lt : (Lt.next = sr.next, sr.next = Lt), qt.pending = Lt;
                        }
                      }
                      ct.lanes |= Ee, Lt = ct.alternate, Lt !== null && (Lt.lanes |= Ee), Ii(
                        ct.return,
                        Ee,
                        ce
                      ), Mt.lanes |= Ee;
                      break;
                    }
                    Lt = Lt.next;
                  }
                } else if (ct.tag === 10)
                  bt = ct.type === ce.type ? null : ct.child;
                else if (ct.tag === 18) {
                  if (bt = ct.return, bt === null)
                    throw Error(oe(341));
                  bt.lanes |= Ee, Mt = bt.alternate, Mt !== null && (Mt.lanes |= Ee), Ii(bt, Ee, ce), bt = ct.sibling;
                } else
                  bt = ct.child;
                if (bt !== null)
                  bt.return = ct;
                else
                  for (bt = ct; bt !== null; ) {
                    if (bt === ce) {
                      bt = null;
                      break;
                    }
                    if (ct = bt.sibling, ct !== null) {
                      ct.return = bt.return, bt = ct;
                      break;
                    }
                    bt = bt.return;
                  }
                ct = bt;
              }
          wi(fe, ce, nt.children, Ee), ce = ce.child;
        }
        return ce;
      case 9:
        return nt = ce.type, Te = ce.pendingProps.children, hr(ce, Ee), nt = ci(nt), Te = Te(nt), ce.flags |= 1, wi(fe, ce, Te, Ee), ce.child;
      case 14:
        return Te = ce.type, nt = Ya(Te, ce.pendingProps), nt = Ya(Te.type, nt), vd(fe, ce, Te, nt, Ee);
      case 15:
        return Oa(fe, ce, ce.type, ce.pendingProps, Ee);
      case 17:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : Ya(Te, nt), ta(fe, ce), ce.tag = 1, jn(Te) ? (fe = !0, Vc(ce)) : fe = !1, hr(ce, Ee), uv(ce, Te, nt), Qc(ce, Te, nt, Ee), yv(null, ce, Te, !0, fe, Ee);
      case 19:
        return up(fe, ce, Ee);
      case 22:
        return Nl(fe, ce, Ee);
    }
    throw Error(oe(156, ce.tag));
  };
  function bp(fe, ce) {
    return mf(fe, ce);
  }
  function Ug(fe, ce, Ee, Te) {
    this.tag = fe, this.key = Ee, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = ce, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Te, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function So(fe, ce, Ee, Te) {
    return new Ug(fe, ce, Ee, Te);
  }
  function xp(fe) {
    return fe = fe.prototype, !(!fe || !fe.isReactComponent);
  }
  function jg(fe) {
    if (typeof fe == "function")
      return xp(fe) ? 1 : 0;
    if (fe != null) {
      if (fe = fe.$$typeof, fe === Yt)
        return 11;
      if (fe === Qt)
        return 14;
    }
    return 2;
  }
  function tl(fe, ce) {
    var Ee = fe.alternate;
    return Ee === null ? (Ee = So(fe.tag, ce, fe.key, fe.mode), Ee.elementType = fe.elementType, Ee.type = fe.type, Ee.stateNode = fe.stateNode, Ee.alternate = fe, fe.alternate = Ee) : (Ee.pendingProps = ce, Ee.type = fe.type, Ee.flags = 0, Ee.subtreeFlags = 0, Ee.deletions = null), Ee.flags = fe.flags & 14680064, Ee.childLanes = fe.childLanes, Ee.lanes = fe.lanes, Ee.child = fe.child, Ee.memoizedProps = fe.memoizedProps, Ee.memoizedState = fe.memoizedState, Ee.updateQueue = fe.updateQueue, ce = fe.dependencies, Ee.dependencies = ce === null ? null : { lanes: ce.lanes, firstContext: ce.firstContext }, Ee.sibling = fe.sibling, Ee.index = fe.index, Ee.ref = fe.ref, Ee;
  }
  function Pd(fe, ce, Ee, Te, nt, ct) {
    var bt = 2;
    if (Te = fe, typeof fe == "function")
      xp(fe) && (bt = 1);
    else if (typeof fe == "string")
      bt = 5;
    else
      e:
        switch (fe) {
          case At:
            return ql(Ee.children, nt, ct, ce);
          case kt:
            bt = 8, nt |= 8;
            break;
          case Vt:
            return fe = So(12, Ee, ce, nt | 2), fe.elementType = Vt, fe.lanes = ct, fe;
          case Jt:
            return fe = So(13, Ee, ce, nt), fe.elementType = Jt, fe.lanes = ct, fe;
          case rr:
            return fe = So(19, Ee, ce, nt), fe.elementType = rr, fe.lanes = ct, fe;
          case Ft:
            return Jf(Ee, nt, ct, ce);
          default:
            if (typeof fe == "object" && fe !== null)
              switch (fe.$$typeof) {
                case ir:
                  bt = 10;
                  break e;
                case er:
                  bt = 9;
                  break e;
                case Yt:
                  bt = 11;
                  break e;
                case Qt:
                  bt = 14;
                  break e;
                case wt:
                  bt = 16, Te = null;
                  break e;
              }
            throw Error(oe(130, fe == null ? fe : typeof fe, ""));
        }
    return ce = So(bt, Ee, ce, nt), ce.elementType = fe, ce.type = Te, ce.lanes = ct, ce;
  }
  function ql(fe, ce, Ee, Te) {
    return fe = So(7, fe, Te, ce), fe.lanes = Ee, fe;
  }
  function Jf(fe, ce, Ee, Te) {
    return fe = So(22, fe, Te, ce), fe.elementType = Ft, fe.lanes = Ee, fe.stateNode = { isHidden: !1 }, fe;
  }
  function Zf(fe, ce, Ee) {
    return fe = So(6, fe, null, ce), fe.lanes = Ee, fe;
  }
  function Yl(fe, ce, Ee) {
    return ce = So(4, fe.children !== null ? fe.children : [], fe.key, ce), ce.lanes = Ee, ce.stateNode = { containerInfo: fe.containerInfo, pendingChildren: null, implementation: fe.implementation }, ce;
  }
  function Gg(fe, ce, Ee, Te, nt) {
    this.tag = ce, this.containerInfo = fe, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = mu(0), this.expirationTimes = mu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = mu(0), this.identifierPrefix = Te, this.onRecoverableError = nt, this.mutableSourceEagerHydrationData = null;
  }
  function Rd(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    return fe = new Gg(fe, ce, Ee, Mt, Lt), ce === 1 ? (ce = 1, ct === !0 && (ce |= 8)) : ce = 0, ct = So(3, null, null, ce), fe.current = ct, ct.stateNode = fe, ct.memoizedState = { element: Te, isDehydrated: Ee, cache: null, transitions: null, pendingSuspenseBoundaries: null }, qh(ct), fe;
  }
  function Fv(fe, ce, Ee) {
    var Te = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: Ct, key: Te == null ? null : "" + Te, children: fe, containerInfo: ce, implementation: Ee };
  }
  function Cp(fe) {
    if (!fe)
      return Ho;
    fe = fe._reactInternals;
    e: {
      if (ro(fe) !== fe || fe.tag !== 1)
        throw Error(oe(170));
      var ce = fe;
      do {
        switch (ce.tag) {
          case 3:
            ce = ce.stateNode.context;
            break e;
          case 1:
            if (jn(ce.type)) {
              ce = ce.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        ce = ce.return;
      } while (ce !== null);
      throw Error(oe(171));
    }
    if (fe.tag === 1) {
      var Ee = fe.type;
      if (jn(Ee))
        return Df(fe, Ee, ce);
    }
    return ce;
  }
  function Dv(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    return fe = Rd(Ee, Te, !0, fe, nt, ct, bt, Mt, Lt), fe.context = Cp(null), Ee = fe.current, Te = ia(), nt = gi(Ee), ct = hs(Te, nt), ct.callback = ce ?? null, Ws(Ee, ct, nt), fe.current.lanes = nt, rs(fe, nt, Te), oa(fe, Te), fe;
  }
  function ec(fe, ce, Ee, Te) {
    var nt = ce.current, ct = ia(), bt = gi(nt);
    return Ee = Cp(Ee), ce.context === null ? ce.context = Ee : ce.pendingContext = Ee, ce = hs(ct, bt), ce.payload = { element: fe }, Te = Te === void 0 ? null : Te, Te !== null && (ce.callback = Te), fe = Ws(nt, ce, bt), fe !== null && (aa(fe, nt, bt, ct), qc(fe, nt, bt)), bt;
  }
  function kd(fe) {
    if (fe = fe.current, !fe.child)
      return null;
    switch (fe.child.tag) {
      case 5:
        return fe.child.stateNode;
      default:
        return fe.child.stateNode;
    }
  }
  function Ov(fe, ce) {
    if (fe = fe.memoizedState, fe !== null && fe.dehydrated !== null) {
      var Ee = fe.retryLane;
      fe.retryLane = Ee !== 0 && Ee < ce ? Ee : ce;
    }
  }
  function Tp(fe, ce) {
    Ov(fe, ce), (fe = fe.alternate) && Ov(fe, ce);
  }
  function Lv() {
    return null;
  }
  var wp = typeof reportError == "function" ? reportError : function(fe) {
    console.error(fe);
  };
  function Md(fe) {
    this._internalRoot = fe;
  }
  Ss.prototype.render = Md.prototype.render = function(fe) {
    var ce = this._internalRoot;
    if (ce === null)
      throw Error(oe(409));
    ec(fe, ce, null, null);
  }, Ss.prototype.unmount = Md.prototype.unmount = function() {
    var fe = this._internalRoot;
    if (fe !== null) {
      this._internalRoot = null;
      var ce = fe.containerInfo;
      el(function() {
        ec(null, fe, null, null);
      }), ce[fs] = null;
    }
  };
  function Ss(fe) {
    this._internalRoot = fe;
  }
  Ss.prototype.unstable_scheduleHydration = function(fe) {
    if (fe) {
      var ce = _c();
      fe = { blockedOn: null, target: fe, priority: ce };
      for (var Ee = 0; Ee < yn.length && ce !== 0 && ce < yn[Ee].priority; Ee++)
        ;
      yn.splice(Ee, 0, fe), Ee === 0 && Ef(fe);
    }
  };
  function _p(fe) {
    return !(!fe || fe.nodeType !== 1 && fe.nodeType !== 9 && fe.nodeType !== 11);
  }
  function Fd(fe) {
    return !(!fe || fe.nodeType !== 1 && fe.nodeType !== 9 && fe.nodeType !== 11 && (fe.nodeType !== 8 || fe.nodeValue !== " react-mount-point-unstable "));
  }
  function $v() {
  }
  function Wg(fe, ce, Ee, Te, nt) {
    if (nt) {
      if (typeof Te == "function") {
        var ct = Te;
        Te = function() {
          var qt = kd(bt);
          ct.call(qt);
        };
      }
      var bt = Dv(ce, Te, fe, 0, null, !1, !1, "", $v);
      return fe._reactRootContainer = bt, fe[fs] = bt.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), el(), bt;
    }
    for (; nt = fe.lastChild; )
      fe.removeChild(nt);
    if (typeof Te == "function") {
      var Mt = Te;
      Te = function() {
        var qt = kd(Lt);
        Mt.call(qt);
      };
    }
    var Lt = Rd(fe, 0, !1, null, null, !1, !1, "", $v);
    return fe._reactRootContainer = Lt, fe[fs] = Lt.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), el(function() {
      ec(ce, Lt, Ee, Te);
    }), Lt;
  }
  function Dd(fe, ce, Ee, Te, nt) {
    var ct = Ee._reactRootContainer;
    if (ct) {
      var bt = ct;
      if (typeof nt == "function") {
        var Mt = nt;
        nt = function() {
          var Lt = kd(bt);
          Mt.call(Lt);
        };
      }
      ec(ce, bt, fe, nt);
    } else
      bt = Wg(Ee, ce, fe, nt, Te);
    return kd(bt);
  }
  wc = function(fe) {
    switch (fe.tag) {
      case 3:
        var ce = fe.stateNode;
        if (ce.current.memoizedState.isDehydrated) {
          var Ee = zo(ce.pendingLanes);
          Ee !== 0 && (Ls(ce, Ee | 1), oa(ce, Hn()), !(rn & 6) && (Bu = Hn() + 500, Pa()));
        }
        break;
      case 13:
        el(function() {
          var Te = ds(fe, 1);
          if (Te !== null) {
            var nt = ia();
            aa(Te, fe, 1, nt);
          }
        }), Tp(fe, 1);
    }
  }, vu = function(fe) {
    if (fe.tag === 13) {
      var ce = ds(fe, 134217728);
      if (ce !== null) {
        var Ee = ia();
        aa(ce, fe, 134217728, Ee);
      }
      Tp(fe, 134217728);
    }
  }, an = function(fe) {
    if (fe.tag === 13) {
      var ce = gi(fe), Ee = ds(fe, ce);
      if (Ee !== null) {
        var Te = ia();
        aa(Ee, fe, ce, Te);
      }
      Tp(fe, ce);
    }
  }, _c = function() {
    return un;
  }, gf = function(fe, ce) {
    var Ee = un;
    try {
      return un = fe, ce();
    } finally {
      un = Ee;
    }
  }, Ba = function(fe, ce, Ee) {
    switch (ce) {
      case "input":
        if (Fn(fe, Ee), ce = Ee.name, Ee.type === "radio" && ce != null) {
          for (Ee = fe; Ee.parentNode; )
            Ee = Ee.parentNode;
          for (Ee = Ee.querySelectorAll("input[name=" + JSON.stringify("" + ce) + '][type="radio"]'), ce = 0; ce < Ee.length; ce++) {
            var Te = Ee[ce];
            if (Te !== fe && Te.form === fe.form) {
              var nt = Lr(Te);
              if (!nt)
                throw Error(oe(90));
              tn(Te), Fn(Te, nt);
            }
          }
        }
        break;
      case "textarea":
        ei(fe, Ee);
        break;
      case "select":
        ce = Ee.value, ce != null && Dn(fe, !!Ee.multiple, ce, !1);
    }
  }, lu = ju, uu = el;
  var qg = { usingClientEntryPoint: !1, Events: [Ff, Tu, Lr, Lo, Ms, ju] }, Wu = { findFiberByHostInstance: lo, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Yg = { bundleType: Wu.bundleType, version: Wu.version, rendererPackageName: Wu.rendererPackageName, rendererConfig: Wu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: vt.ReactCurrentDispatcher, findHostInstanceByFiber: function(fe) {
    return fe = Sc(fe), fe === null ? null : fe.stateNode;
  }, findFiberByHostInstance: Wu.findFiberByHostInstance || Lv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Od = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Od.isDisabled && Od.supportsFiber)
      try {
        ml = Od.inject(Yg), Ua = Od;
      } catch {
      }
  }
  return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qg, reactDom_production_min.createPortal = function(fe, ce) {
    var Ee = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!_p(ce))
      throw Error(oe(200));
    return Fv(fe, ce, null, Ee);
  }, reactDom_production_min.createRoot = function(fe, ce) {
    if (!_p(fe))
      throw Error(oe(299));
    var Ee = !1, Te = "", nt = wp;
    return ce != null && (ce.unstable_strictMode === !0 && (Ee = !0), ce.identifierPrefix !== void 0 && (Te = ce.identifierPrefix), ce.onRecoverableError !== void 0 && (nt = ce.onRecoverableError)), ce = Rd(fe, 1, !1, null, null, Ee, !1, Te, nt), fe[fs] = ce.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), new Md(ce);
  }, reactDom_production_min.findDOMNode = function(fe) {
    if (fe == null)
      return null;
    if (fe.nodeType === 1)
      return fe;
    var ce = fe._reactInternals;
    if (ce === void 0)
      throw typeof fe.render == "function" ? Error(oe(188)) : (fe = Object.keys(fe).join(","), Error(oe(268, fe)));
    return fe = Sc(ce), fe = fe === null ? null : fe.stateNode, fe;
  }, reactDom_production_min.flushSync = function(fe) {
    return el(fe);
  }, reactDom_production_min.hydrate = function(fe, ce, Ee) {
    if (!Fd(ce))
      throw Error(oe(200));
    return Dd(null, fe, ce, !0, Ee);
  }, reactDom_production_min.hydrateRoot = function(fe, ce, Ee) {
    if (!_p(fe))
      throw Error(oe(405));
    var Te = Ee != null && Ee.hydratedSources || null, nt = !1, ct = "", bt = wp;
    if (Ee != null && (Ee.unstable_strictMode === !0 && (nt = !0), Ee.identifierPrefix !== void 0 && (ct = Ee.identifierPrefix), Ee.onRecoverableError !== void 0 && (bt = Ee.onRecoverableError)), ce = Dv(ce, null, fe, 1, Ee ?? null, nt, !1, ct, bt), fe[fs] = ce.current, Cu(fe), Te)
      for (fe = 0; fe < Te.length; fe++)
        Ee = Te[fe], nt = Ee._getVersion, nt = nt(Ee._source), ce.mutableSourceEagerHydrationData == null ? ce.mutableSourceEagerHydrationData = [Ee, nt] : ce.mutableSourceEagerHydrationData.push(
          Ee,
          nt
        );
    return new Ss(ce);
  }, reactDom_production_min.render = function(fe, ce, Ee) {
    if (!Fd(ce))
      throw Error(oe(200));
    return Dd(null, fe, ce, !1, Ee);
  }, reactDom_production_min.unmountComponentAtNode = function(fe) {
    if (!Fd(fe))
      throw Error(oe(40));
    return fe._reactRootContainer ? (el(function() {
      Dd(null, null, fe, !1, function() {
        fe._reactRootContainer = null, fe[fs] = null;
      });
    }), !0) : !1;
  }, reactDom_production_min.unstable_batchedUpdates = ju, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(fe, ce, Ee, Te) {
    if (!Fd(Ee))
      throw Error(oe(200));
    if (fe == null || fe._reactInternals === void 0)
      throw Error(oe(38));
    return Dd(fe, ce, Ee, !1, Te);
  }, reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608", reactDom_production_min;
}
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (L) {
      console.error(L);
    }
  }
}
process.env.NODE_ENV === "production" ? (checkDCE(), reactDom.exports = requireReactDom_production_min()) : reactDom.exports = requireReactDom_development();
var reactDomExports = reactDom.exports, i$3 = Object.defineProperty, d$5 = (L, ne, oe) => ne in L ? i$3(L, ne, { enumerable: !0, configurable: !0, writable: !0, value: oe }) : L[ne] = oe, r$3 = (L, ne, oe) => (d$5(L, typeof ne != "symbol" ? ne + "" : ne, oe), oe);
let o$5 = class {
  constructor() {
    r$3(this, "current", this.detect()), r$3(this, "handoffState", "pending"), r$3(this, "currentId", 0);
  }
  set(ne) {
    this.current !== ne && (this.handoffState = "pending", this.currentId = 0, this.current = ne);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$8 = new o$5(), l$5 = (L, ne) => {
  s$8.isServer ? useEffect(L, ne) : useLayoutEffect(L, ne);
};
function s$7(L) {
  let ne = useRef(L);
  return l$5(() => {
    ne.current = L;
  }, [L]), ne;
}
let o$4 = function(L) {
  let ne = s$7(L);
  return React__default.useCallback((...oe) => ne.current(...oe), [ne]);
};
function t$6(L) {
  typeof queueMicrotask == "function" ? queueMicrotask(L) : Promise.resolve().then(L).catch((ne) => setTimeout(() => {
    throw ne;
  }));
}
function o$3() {
  let L = [], ne = { addEventListener(oe, pe, me, ge) {
    return oe.addEventListener(pe, me, ge), ne.add(() => oe.removeEventListener(pe, me, ge));
  }, requestAnimationFrame(...oe) {
    let pe = requestAnimationFrame(...oe);
    return ne.add(() => cancelAnimationFrame(pe));
  }, nextFrame(...oe) {
    return ne.requestAnimationFrame(() => ne.requestAnimationFrame(...oe));
  }, setTimeout(...oe) {
    let pe = setTimeout(...oe);
    return ne.add(() => clearTimeout(pe));
  }, microTask(...oe) {
    let pe = { current: !0 };
    return t$6(() => {
      pe.current && oe[0]();
    }), ne.add(() => {
      pe.current = !1;
    });
  }, style(oe, pe, me) {
    let ge = oe.style.getPropertyValue(pe);
    return Object.assign(oe.style, { [pe]: me }), this.add(() => {
      Object.assign(oe.style, { [pe]: ge });
    });
  }, group(oe) {
    let pe = o$3();
    return oe(pe), this.add(() => pe.dispose());
  }, add(oe) {
    return L.push(oe), () => {
      let pe = L.indexOf(oe);
      if (pe >= 0)
        for (let me of L.splice(pe, 1))
          me();
    };
  }, dispose() {
    for (let oe of L.splice(0))
      oe();
  } };
  return ne;
}
function p$3() {
  let [L] = useState(o$3);
  return useEffect(() => () => L.dispose(), [L]), L;
}
function s$6() {
  let L = typeof document > "u";
  return "useSyncExternalStore" in React ? ((ne) => ne.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !L) : !1;
}
function l$4() {
  let L = s$6(), [ne, oe] = React.useState(s$8.isHandoffComplete);
  return ne && s$8.isHandoffComplete === !1 && oe(!1), React.useEffect(() => {
    ne !== !0 && oe(!0);
  }, [ne]), React.useEffect(() => s$8.handoff(), []), L ? !1 : ne;
}
var o$2;
let I$6 = (o$2 = React__default.useId) != null ? o$2 : function() {
  let L = l$4(), [ne, oe] = React__default.useState(L ? () => s$8.nextId() : null);
  return l$5(() => {
    ne === null && oe(s$8.nextId());
  }, [ne]), ne != null ? "" + ne : void 0;
};
function u$4(L, ne, ...oe) {
  if (L in ne) {
    let me = ne[L];
    return typeof me == "function" ? me(...oe) : me;
  }
  let pe = new Error(`Tried to handle "${L}" but there is no handler defined. Only defined handlers are: ${Object.keys(ne).map((me) => `"${me}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(pe, u$4), pe;
}
function o$1(L) {
  return s$8.isServer ? null : L instanceof Node ? L.ownerDocument : L != null && L.hasOwnProperty("current") && L.current instanceof Node ? L.current.ownerDocument : document;
}
let c$4 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((L) => `${L}:not([tabindex='-1'])`).join(",");
var M$3 = ((L) => (L[L.First = 1] = "First", L[L.Previous = 2] = "Previous", L[L.Next = 4] = "Next", L[L.Last = 8] = "Last", L[L.WrapAround = 16] = "WrapAround", L[L.NoScroll = 32] = "NoScroll", L))(M$3 || {}), N$4 = ((L) => (L[L.Error = 0] = "Error", L[L.Overflow = 1] = "Overflow", L[L.Success = 2] = "Success", L[L.Underflow = 3] = "Underflow", L))(N$4 || {}), F$3 = ((L) => (L[L.Previous = -1] = "Previous", L[L.Next = 1] = "Next", L))(F$3 || {});
function f$6(L = document.body) {
  return L == null ? [] : Array.from(L.querySelectorAll(c$4)).sort((ne, oe) => Math.sign((ne.tabIndex || Number.MAX_SAFE_INTEGER) - (oe.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$1 = ((L) => (L[L.Strict = 0] = "Strict", L[L.Loose = 1] = "Loose", L))(T$1 || {});
function h$2(L, ne = 0) {
  var oe;
  return L === ((oe = o$1(L)) == null ? void 0 : oe.body) ? !1 : u$4(ne, { 0() {
    return L.matches(c$4);
  }, 1() {
    let pe = L;
    for (; pe !== null; ) {
      if (pe.matches(c$4))
        return !0;
      pe = pe.parentElement;
    }
    return !1;
  } });
}
var w$2 = ((L) => (L[L.Keyboard = 0] = "Keyboard", L[L.Mouse = 1] = "Mouse", L))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (L) => {
  L.metaKey || L.altKey || L.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (L) => {
  L.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : L.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(L) {
  L == null || L.focus({ preventScroll: !0 });
}
let S$6 = ["textarea", "input"].join(",");
function H$1(L) {
  var ne, oe;
  return (oe = (ne = L == null ? void 0 : L.matches) == null ? void 0 : ne.call(L, S$6)) != null ? oe : !1;
}
function I$5(L, ne = (oe) => oe) {
  return L.slice().sort((oe, pe) => {
    let me = ne(oe), ge = ne(pe);
    if (me === null || ge === null)
      return 0;
    let be = me.compareDocumentPosition(ge);
    return be & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : be & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function O$1(L, ne, { sorted: oe = !0, relativeTo: pe = null, skipElements: me = [] } = {}) {
  let ge = Array.isArray(L) ? L.length > 0 ? L[0].ownerDocument : document : L.ownerDocument, be = Array.isArray(L) ? oe ? I$5(L) : L : f$6(L);
  me.length > 0 && be.length > 1 && (be = be.filter((ht) => !me.includes(ht))), pe = pe ?? ge.activeElement;
  let Ie = (() => {
    if (ne & 5)
      return 1;
    if (ne & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ae = (() => {
    if (ne & 1)
      return 0;
    if (ne & 2)
      return Math.max(0, be.indexOf(pe)) - 1;
    if (ne & 4)
      return Math.max(0, be.indexOf(pe)) + 1;
    if (ne & 8)
      return be.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), rt = ne & 32 ? { preventScroll: !0 } : {}, st = 0, dt = be.length, ut;
  do {
    if (st >= dt || st + dt <= 0)
      return 0;
    let ht = Ae + st;
    if (ne & 16)
      ht = (ht + dt) % dt;
    else {
      if (ht < 0)
        return 3;
      if (ht >= dt)
        return 1;
    }
    ut = be[ht], ut == null || ut.focus(rt), st += Ie;
  } while (ut !== ge.activeElement);
  return ne & 6 && H$1(ut) && ut.select(), 2;
}
function t$5() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$2() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$5() || i$2();
}
function d$4(L, ne, oe) {
  let pe = s$7(ne);
  useEffect(() => {
    function me(ge) {
      pe.current(ge);
    }
    return document.addEventListener(L, me, oe), () => document.removeEventListener(L, me, oe);
  }, [L, oe]);
}
function s$5(L, ne, oe) {
  let pe = s$7(ne);
  useEffect(() => {
    function me(ge) {
      pe.current(ge);
    }
    return window.addEventListener(L, me, oe), () => window.removeEventListener(L, me, oe);
  }, [L, oe]);
}
function y$2(L, ne, oe = !0) {
  let pe = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      pe.current = oe;
    });
  }, [oe]);
  function me(be, Ie) {
    if (!pe.current || be.defaultPrevented)
      return;
    let Ae = Ie(be);
    if (Ae === null || !Ae.getRootNode().contains(Ae) || !Ae.isConnected)
      return;
    let rt = function st(dt) {
      return typeof dt == "function" ? st(dt()) : Array.isArray(dt) || dt instanceof Set ? dt : [dt];
    }(L);
    for (let st of rt) {
      if (st === null)
        continue;
      let dt = st instanceof HTMLElement ? st : st.current;
      if (dt != null && dt.contains(Ae) || be.composed && be.composedPath().includes(dt))
        return;
    }
    return !h$2(Ae, T$1.Loose) && Ae.tabIndex !== -1 && be.preventDefault(), ne(be, Ae);
  }
  let ge = useRef(null);
  d$4("pointerdown", (be) => {
    var Ie, Ae;
    pe.current && (ge.current = ((Ae = (Ie = be.composedPath) == null ? void 0 : Ie.call(be)) == null ? void 0 : Ae[0]) || be.target);
  }, !0), d$4("mousedown", (be) => {
    var Ie, Ae;
    pe.current && (ge.current = ((Ae = (Ie = be.composedPath) == null ? void 0 : Ie.call(be)) == null ? void 0 : Ae[0]) || be.target);
  }, !0), d$4("click", (be) => {
    n$3() || ge.current && (me(be, () => ge.current), ge.current = null);
  }, !0), d$4("touchend", (be) => me(be, () => be.target instanceof HTMLElement ? be.target : null), !0), s$5("blur", (be) => me(be, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...L) {
  return useMemo(() => o$1(...L), [...L]);
}
let u$3 = Symbol();
function T(L, ne = !0) {
  return Object.assign(L, { [u$3]: ne });
}
function y$1(...L) {
  let ne = useRef(L);
  useEffect(() => {
    ne.current = L;
  }, [L]);
  let oe = o$4((pe) => {
    for (let me of ne.current)
      me != null && (typeof me == "function" ? me(pe) : me.current = pe);
  });
  return L.every((pe) => pe == null || (pe == null ? void 0 : pe[u$3])) ? void 0 : oe;
}
function m$2(L, ne) {
  let oe = useRef([]), pe = o$4(L);
  useEffect(() => {
    let me = [...oe.current];
    for (let [ge, be] of ne.entries())
      if (oe.current[ge] !== be) {
        let Ie = pe(ne, me);
        return oe.current = ne, Ie;
      }
  }, [pe, ...ne]);
}
function t$4(...L) {
  return Array.from(new Set(L.flatMap((ne) => typeof ne == "string" ? ne.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((L) => (L[L.None = 0] = "None", L[L.RenderStrategy = 1] = "RenderStrategy", L[L.Static = 2] = "Static", L))(O || {}), v$2 = ((L) => (L[L.Unmount = 0] = "Unmount", L[L.Hidden = 1] = "Hidden", L))(v$2 || {});
function C$1({ ourProps: L, theirProps: ne, slot: oe, defaultTag: pe, features: me, visible: ge = !0, name: be, mergeRefs: Ie }) {
  Ie = Ie ?? k$1;
  let Ae = R$1(ne, L);
  if (ge)
    return m$1(Ae, oe, pe, be, Ie);
  let rt = me ?? 0;
  if (rt & 2) {
    let { static: st = !1, ...dt } = Ae;
    if (st)
      return m$1(dt, oe, pe, be, Ie);
  }
  if (rt & 1) {
    let { unmount: st = !0, ...dt } = Ae;
    return u$4(st ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...dt, hidden: !0, style: { display: "none" } }, oe, pe, be, Ie);
    } });
  }
  return m$1(Ae, oe, pe, be, Ie);
}
function m$1(L, ne = {}, oe, pe, me) {
  let { as: ge = oe, children: be, refName: Ie = "ref", ...Ae } = F$2(L, ["unmount", "static"]), rt = L.ref !== void 0 ? { [Ie]: L.ref } : {}, st = typeof be == "function" ? be(ne) : be;
  "className" in Ae && Ae.className && typeof Ae.className == "function" && (Ae.className = Ae.className(ne));
  let dt = {};
  if (ne) {
    let ut = !1, ht = [];
    for (let [it, lt] of Object.entries(ne))
      typeof lt == "boolean" && (ut = !0), lt === !0 && ht.push(it);
    ut && (dt["data-headlessui-state"] = ht.join(" "));
  }
  if (ge === Fragment && Object.keys(x$1(Ae)).length > 0) {
    if (!isValidElement(st) || Array.isArray(st) && st.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${pe} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(Ae).map((lt) => `  - ${lt}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((lt) => `  - ${lt}`).join(`
`)].join(`
`));
    let ut = st.props, ht = typeof (ut == null ? void 0 : ut.className) == "function" ? (...lt) => t$4(ut == null ? void 0 : ut.className(...lt), Ae.className) : t$4(ut == null ? void 0 : ut.className, Ae.className), it = ht ? { className: ht } : {};
    return cloneElement(st, Object.assign({}, R$1(st.props, x$1(F$2(Ae, ["ref"]))), dt, rt, { ref: me(st.ref, rt.ref) }, it));
  }
  return createElement(ge, Object.assign({}, F$2(Ae, ["ref"]), ge !== Fragment && rt, ge !== Fragment && dt), st);
}
function k$1(...L) {
  return L.every((ne) => ne == null) ? void 0 : (ne) => {
    for (let oe of L)
      oe != null && (typeof oe == "function" ? oe(ne) : oe.current = ne);
  };
}
function R$1(...L) {
  if (L.length === 0)
    return {};
  if (L.length === 1)
    return L[0];
  let ne = {}, oe = {};
  for (let pe of L)
    for (let me in pe)
      me.startsWith("on") && typeof pe[me] == "function" ? (oe[me] != null || (oe[me] = []), oe[me].push(pe[me])) : ne[me] = pe[me];
  if (ne.disabled || ne["aria-disabled"])
    return Object.assign(ne, Object.fromEntries(Object.keys(oe).map((pe) => [pe, void 0])));
  for (let pe in oe)
    Object.assign(ne, { [pe](me, ...ge) {
      let be = oe[pe];
      for (let Ie of be) {
        if ((me instanceof Event || (me == null ? void 0 : me.nativeEvent) instanceof Event) && me.defaultPrevented)
          return;
        Ie(me, ...ge);
      }
    } });
  return ne;
}
function U$2(L) {
  var ne;
  return Object.assign(forwardRef(L), { displayName: (ne = L.displayName) != null ? ne : L.name });
}
function x$1(L) {
  let ne = Object.assign({}, L);
  for (let oe in ne)
    ne[oe] === void 0 && delete ne[oe];
  return ne;
}
function F$2(L, ne = []) {
  let oe = Object.assign({}, L);
  for (let pe of ne)
    pe in oe && delete oe[pe];
  return oe;
}
let p$2 = "div";
var s$4 = ((L) => (L[L.None = 1] = "None", L[L.Focusable = 2] = "Focusable", L[L.Hidden = 4] = "Hidden", L))(s$4 || {});
function l$3(L, ne) {
  var oe;
  let { features: pe = 1, ...me } = L, ge = { ref: ne, "aria-hidden": (pe & 2) === 2 ? !0 : (oe = me["aria-hidden"]) != null ? oe : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(pe & 4) === 4 && (pe & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: ge, theirProps: me, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let f$5 = U$2(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((L) => (L[L.Open = 1] = "Open", L[L.Closed = 2] = "Closed", L[L.Closing = 4] = "Closing", L[L.Opening = 8] = "Opening", L))(d$3 || {});
function u$2() {
  return useContext(n$1);
}
function s$3({ value: L, children: ne }) {
  return React__default.createElement(n$1.Provider, { value: L }, ne);
}
function t$3(L) {
  function ne() {
    document.readyState !== "loading" && (L(), document.removeEventListener("DOMContentLoaded", ne));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", ne), ne());
}
let t$2 = [];
t$3(() => {
  function L(ne) {
    ne.target instanceof HTMLElement && ne.target !== document.body && t$2[0] !== ne.target && (t$2.unshift(ne.target), t$2 = t$2.filter((oe) => oe != null && oe.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", L, { capture: !0 }), window.addEventListener("mousedown", L, { capture: !0 }), window.addEventListener("focus", L, { capture: !0 }), document.body.addEventListener("click", L, { capture: !0 }), document.body.addEventListener("mousedown", L, { capture: !0 }), document.body.addEventListener("focus", L, { capture: !0 });
});
function r$2(L) {
  let ne = L.parentElement, oe = null;
  for (; ne && !(ne instanceof HTMLFieldSetElement); )
    ne instanceof HTMLLegendElement && (oe = ne), ne = ne.parentElement;
  let pe = (ne == null ? void 0 : ne.getAttribute("disabled")) === "";
  return pe && i$1(oe) ? !1 : pe;
}
function i$1(L) {
  if (!L)
    return !1;
  let ne = L.previousElementSibling;
  for (; ne !== null; ) {
    if (ne instanceof HTMLLegendElement)
      return !1;
    ne = ne.previousElementSibling;
  }
  return !0;
}
var o = ((L) => (L.Space = " ", L.Enter = "Enter", L.Escape = "Escape", L.Backspace = "Backspace", L.Delete = "Delete", L.ArrowLeft = "ArrowLeft", L.ArrowUp = "ArrowUp", L.ArrowRight = "ArrowRight", L.ArrowDown = "ArrowDown", L.Home = "Home", L.End = "End", L.PageUp = "PageUp", L.PageDown = "PageDown", L.Tab = "Tab", L))(o || {});
function E(L, ne, oe, pe) {
  let me = s$7(oe);
  useEffect(() => {
    L = L ?? window;
    function ge(be) {
      me.current(be);
    }
    return L.addEventListener(ne, ge, pe), () => L.removeEventListener(ne, ge, pe);
  }, [L, ne, pe]);
}
function f$4() {
  let L = useRef(!1);
  return l$5(() => (L.current = !0, () => {
    L.current = !1;
  }), []), L;
}
function c$3(L) {
  let ne = o$4(L), oe = useRef(!1);
  useEffect(() => (oe.current = !1, () => {
    oe.current = !0, t$6(() => {
      oe.current && ne();
    });
  }), [ne]);
}
var s$2 = ((L) => (L[L.Forwards = 0] = "Forwards", L[L.Backwards = 1] = "Backwards", L))(s$2 || {});
function n() {
  let L = useRef(0);
  return s$5("keydown", (ne) => {
    ne.key === "Tab" && (L.current = ne.shiftKey ? 1 : 0);
  }, !0), L;
}
function P(L) {
  if (!L)
    return /* @__PURE__ */ new Set();
  if (typeof L == "function")
    return new Set(L());
  let ne = /* @__PURE__ */ new Set();
  for (let oe of L.current)
    oe.current instanceof HTMLElement && ne.add(oe.current);
  return ne;
}
let X$1 = "div";
var _$2 = ((L) => (L[L.None = 1] = "None", L[L.InitialFocus = 2] = "InitialFocus", L[L.TabLock = 4] = "TabLock", L[L.FocusLock = 8] = "FocusLock", L[L.RestoreFocus = 16] = "RestoreFocus", L[L.All = 30] = "All", L))(_$2 || {});
function z$1(L, ne) {
  let oe = useRef(null), pe = y$1(oe, ne), { initialFocus: me, containers: ge, features: be = 30, ...Ie } = L;
  l$4() || (be = 1);
  let Ae = n$2(oe);
  Y({ ownerDocument: Ae }, !!(be & 16));
  let rt = Z({ ownerDocument: Ae, container: oe, initialFocus: me }, !!(be & 2));
  $$1({ ownerDocument: Ae, container: oe, containers: ge, previousActiveElement: rt }, !!(be & 8));
  let st = n(), dt = o$4((lt) => {
    let St = oe.current;
    St && ((ot) => ot())(() => {
      u$4(st.current, { [s$2.Forwards]: () => {
        O$1(St, M$3.First, { skipElements: [lt.relatedTarget] });
      }, [s$2.Backwards]: () => {
        O$1(St, M$3.Last, { skipElements: [lt.relatedTarget] });
      } });
    });
  }), ut = p$3(), ht = useRef(!1), it = { ref: pe, onKeyDown(lt) {
    lt.key == "Tab" && (ht.current = !0, ut.requestAnimationFrame(() => {
      ht.current = !1;
    }));
  }, onBlur(lt) {
    let St = P(ge);
    oe.current instanceof HTMLElement && St.add(oe.current);
    let ot = lt.relatedTarget;
    ot instanceof HTMLElement && ot.dataset.headlessuiFocusGuard !== "true" && (S$5(St, ot) || (ht.current ? O$1(oe.current, u$4(st.current, { [s$2.Forwards]: () => M$3.Next, [s$2.Backwards]: () => M$3.Previous }) | M$3.WrapAround, { relativeTo: lt.target }) : lt.target instanceof HTMLElement && y$3(lt.target)));
  } };
  return React__default.createElement(React__default.Fragment, null, !!(be & 4) && React__default.createElement(f$5, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: dt, features: s$4.Focusable }), C$1({ ourProps: it, theirProps: Ie, defaultTag: X$1, name: "FocusTrap" }), !!(be & 4) && React__default.createElement(f$5, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: dt, features: s$4.Focusable }));
}
let D$2 = U$2(z$1), de$1 = Object.assign(D$2, { features: _$2 });
function Q(L = !0) {
  let ne = useRef(t$2.slice());
  return m$2(([oe], [pe]) => {
    pe === !0 && oe === !1 && t$6(() => {
      ne.current.splice(0);
    }), pe === !1 && oe === !0 && (ne.current = t$2.slice());
  }, [L, t$2, ne]), o$4(() => {
    var oe;
    return (oe = ne.current.find((pe) => pe != null && pe.isConnected)) != null ? oe : null;
  });
}
function Y({ ownerDocument: L }, ne) {
  let oe = Q(ne);
  m$2(() => {
    ne || (L == null ? void 0 : L.activeElement) === (L == null ? void 0 : L.body) && y$3(oe());
  }, [ne]), c$3(() => {
    ne && y$3(oe());
  });
}
function Z({ ownerDocument: L, container: ne, initialFocus: oe }, pe) {
  let me = useRef(null), ge = f$4();
  return m$2(() => {
    if (!pe)
      return;
    let be = ne.current;
    be && t$6(() => {
      if (!ge.current)
        return;
      let Ie = L == null ? void 0 : L.activeElement;
      if (oe != null && oe.current) {
        if ((oe == null ? void 0 : oe.current) === Ie) {
          me.current = Ie;
          return;
        }
      } else if (be.contains(Ie)) {
        me.current = Ie;
        return;
      }
      oe != null && oe.current ? y$3(oe.current) : O$1(be, M$3.First) === N$4.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), me.current = L == null ? void 0 : L.activeElement;
    });
  }, [pe]), me;
}
function $$1({ ownerDocument: L, container: ne, containers: oe, previousActiveElement: pe }, me) {
  let ge = f$4();
  E(L == null ? void 0 : L.defaultView, "focus", (be) => {
    if (!me || !ge.current)
      return;
    let Ie = P(oe);
    ne.current instanceof HTMLElement && Ie.add(ne.current);
    let Ae = pe.current;
    if (!Ae)
      return;
    let rt = be.target;
    rt && rt instanceof HTMLElement ? S$5(Ie, rt) ? (pe.current = rt, y$3(rt)) : (be.preventDefault(), be.stopPropagation(), y$3(Ae)) : y$3(pe.current);
  }, !0);
}
function S$5(L, ne) {
  for (let oe of L)
    if (oe.contains(ne))
      return !0;
  return !1;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l$2(L) {
  return React__default.createElement(e.Provider, { value: L.force }, L.children);
}
function F$1(L) {
  let ne = a$4(), oe = useContext(_$1), pe = n$2(L), [me, ge] = useState(() => {
    if (!ne && oe !== null || s$8.isServer)
      return null;
    let be = pe == null ? void 0 : pe.getElementById("headlessui-portal-root");
    if (be)
      return be;
    if (pe === null)
      return null;
    let Ie = pe.createElement("div");
    return Ie.setAttribute("id", "headlessui-portal-root"), pe.body.appendChild(Ie);
  });
  return useEffect(() => {
    me !== null && (pe != null && pe.body.contains(me) || pe == null || pe.body.appendChild(me));
  }, [me, pe]), useEffect(() => {
    ne || oe !== null && ge(oe.current);
  }, [oe, ge, ne]), me;
}
let U$1 = Fragment;
function N$3(L, ne) {
  let oe = L, pe = useRef(null), me = y$1(T((st) => {
    pe.current = st;
  }), ne), ge = n$2(pe), be = F$1(pe), [Ie] = useState(() => {
    var st;
    return s$8.isServer ? null : (st = ge == null ? void 0 : ge.createElement("div")) != null ? st : null;
  }), Ae = useContext(f$3), rt = l$4();
  return l$5(() => {
    !be || !Ie || be.contains(Ie) || (Ie.setAttribute("data-headlessui-portal", ""), be.appendChild(Ie));
  }, [be, Ie]), l$5(() => {
    if (Ie && Ae)
      return Ae.register(Ie);
  }, [Ae, Ie]), c$3(() => {
    var st;
    !be || !Ie || (Ie instanceof Node && be.contains(Ie) && be.removeChild(Ie), be.childNodes.length <= 0 && ((st = be.parentElement) == null || st.removeChild(be)));
  }), rt ? !be || !Ie ? null : reactDomExports.createPortal(C$1({ ourProps: { ref: me }, theirProps: oe, defaultTag: U$1, name: "Portal" }), Ie) : null;
}
let S$4 = Fragment, _$1 = createContext(null);
function j$1(L, ne) {
  let { target: oe, ...pe } = L, me = { ref: y$1(ne) };
  return React__default.createElement(_$1.Provider, { value: oe }, C$1({ ourProps: me, theirProps: pe, defaultTag: S$4, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee$1() {
  let L = useContext(f$3), ne = useRef([]), oe = o$4((ge) => (ne.current.push(ge), L && L.register(ge), () => pe(ge))), pe = o$4((ge) => {
    let be = ne.current.indexOf(ge);
    be !== -1 && ne.current.splice(be, 1), L && L.unregister(ge);
  }), me = useMemo(() => ({ register: oe, unregister: pe, portals: ne }), [oe, pe, ne]);
  return [ne, useMemo(() => function({ children: ge }) {
    return React__default.createElement(f$3.Provider, { value: me }, ge);
  }, [me])];
}
let D$1 = U$2(N$3), I$4 = U$2(j$1), te$1 = Object.assign(D$1, { Group: I$4 });
function i(L, ne) {
  return L === ne && (L !== 0 || 1 / L === 1 / ne) || L !== L && ne !== ne;
}
const d$2 = typeof Object.is == "function" ? Object.is : i, { useState: u$1, useEffect: h$1, useLayoutEffect: f$2, useDebugValue: p$1 } = React;
function y(L, ne, oe) {
  const pe = ne(), [{ inst: me }, ge] = u$1({ inst: { value: pe, getSnapshot: ne } });
  return f$2(() => {
    me.value = pe, me.getSnapshot = ne, r$1(me) && ge({ inst: me });
  }, [L, pe, ne]), h$1(() => (r$1(me) && ge({ inst: me }), L(() => {
    r$1(me) && ge({ inst: me });
  })), [L]), p$1(pe), pe;
}
function r$1(L) {
  const ne = L.getSnapshot, oe = L.value;
  try {
    const pe = ne();
    return !d$2(oe, pe);
  } catch {
    return !0;
  }
}
function t$1(L, ne, oe) {
  return ne();
}
const r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$1 = !r, c$2 = s$1 ? t$1 : y, a$3 = "useSyncExternalStore" in React ? ((L) => L.useSyncExternalStore)(React) : c$2;
function S$3(L) {
  return a$3(L.subscribe, L.getSnapshot, L.getSnapshot);
}
function a$2(L, ne) {
  let oe = L(), pe = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return oe;
  }, subscribe(me) {
    return pe.add(me), () => pe.delete(me);
  }, dispatch(me, ...ge) {
    let be = ne[me].call(oe, ...ge);
    be && (oe = be, pe.forEach((Ie) => Ie()));
  } };
}
function c$1() {
  let L;
  return { before({ doc: ne }) {
    var oe;
    let pe = ne.documentElement;
    L = ((oe = ne.defaultView) != null ? oe : window).innerWidth - pe.clientWidth;
  }, after({ doc: ne, d: oe }) {
    let pe = ne.documentElement, me = pe.clientWidth - pe.offsetWidth, ge = L - me;
    oe.style(pe, "paddingRight", `${ge}px`);
  } };
}
function d$1() {
  return t$5() ? { before({ doc: L, d: ne, meta: oe }) {
    function pe(me) {
      return oe.containers.flatMap((ge) => ge()).some((ge) => ge.contains(me));
    }
    ne.microTask(() => {
      var me;
      if (window.getComputedStyle(L.documentElement).scrollBehavior !== "auto") {
        let Ie = o$3();
        Ie.style(L.documentElement, "scrollBehavior", "auto"), ne.add(() => ne.microTask(() => Ie.dispose()));
      }
      let ge = (me = window.scrollY) != null ? me : window.pageYOffset, be = null;
      ne.addEventListener(L, "click", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          try {
            let Ae = Ie.target.closest("a");
            if (!Ae)
              return;
            let { hash: rt } = new URL(Ae.href), st = L.querySelector(rt);
            st && !pe(st) && (be = st);
          } catch {
          }
      }, !0), ne.addEventListener(L, "touchstart", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          if (pe(Ie.target)) {
            let Ae = Ie.target;
            for (; Ae.parentElement && pe(Ae.parentElement); )
              Ae = Ae.parentElement;
            ne.style(Ae, "overscrollBehavior", "contain");
          } else
            ne.style(Ie.target, "touchAction", "none");
      }), ne.addEventListener(L, "touchmove", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          if (pe(Ie.target)) {
            let Ae = Ie.target;
            for (; Ae.parentElement && Ae.dataset.headlessuiPortal !== "" && !(Ae.scrollHeight > Ae.clientHeight || Ae.scrollWidth > Ae.clientWidth); )
              Ae = Ae.parentElement;
            Ae.dataset.headlessuiPortal === "" && Ie.preventDefault();
          } else
            Ie.preventDefault();
      }, { passive: !1 }), ne.add(() => {
        var Ie;
        let Ae = (Ie = window.scrollY) != null ? Ie : window.pageYOffset;
        ge !== Ae && window.scrollTo(0, ge), be && be.isConnected && (be.scrollIntoView({ block: "nearest" }), be = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: L, d: ne }) {
    ne.style(L.documentElement, "overflow", "hidden");
  } };
}
function m(L) {
  let ne = {};
  for (let oe of L)
    Object.assign(ne, oe(ne));
  return ne;
}
let a$1 = a$2(() => /* @__PURE__ */ new Map(), { PUSH(L, ne) {
  var oe;
  let pe = (oe = this.get(L)) != null ? oe : { doc: L, count: 0, d: o$3(), meta: /* @__PURE__ */ new Set() };
  return pe.count++, pe.meta.add(ne), this.set(L, pe), this;
}, POP(L, ne) {
  let oe = this.get(L);
  return oe && (oe.count--, oe.meta.delete(ne)), this;
}, SCROLL_PREVENT({ doc: L, d: ne, meta: oe }) {
  let pe = { doc: L, d: ne, meta: m(oe) }, me = [d$1(), c$1(), l$1()];
  me.forEach(({ before: ge }) => ge == null ? void 0 : ge(pe)), me.forEach(({ after: ge }) => ge == null ? void 0 : ge(pe));
}, SCROLL_ALLOW({ d: L }) {
  L.dispose();
}, TEARDOWN({ doc: L }) {
  this.delete(L);
} });
a$1.subscribe(() => {
  let L = a$1.getSnapshot(), ne = /* @__PURE__ */ new Map();
  for (let [oe] of L)
    ne.set(oe, oe.documentElement.style.overflow);
  for (let oe of L.values()) {
    let pe = ne.get(oe.doc) === "hidden", me = oe.count !== 0;
    (me && !pe || !me && pe) && a$1.dispatch(oe.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", oe), oe.count === 0 && a$1.dispatch("TEARDOWN", oe);
  }
});
function p(L, ne, oe) {
  let pe = S$3(a$1), me = L ? pe.get(L) : void 0, ge = me ? me.count > 0 : !1;
  return l$5(() => {
    if (!(!L || !ne))
      return a$1.dispatch("PUSH", L, oe), () => a$1.dispatch("POP", L, oe);
  }, [ne, L]), ge;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(L, ne = !0) {
  l$5(() => {
    var oe;
    if (!ne)
      return;
    let pe = typeof L == "function" ? L() : L.current;
    if (!pe)
      return;
    function me() {
      var be;
      if (!pe)
        return;
      let Ie = (be = t.get(pe)) != null ? be : 1;
      if (Ie === 1 ? t.delete(pe) : t.set(pe, Ie - 1), Ie !== 1)
        return;
      let Ae = u.get(pe);
      Ae && (Ae["aria-hidden"] === null ? pe.removeAttribute("aria-hidden") : pe.setAttribute("aria-hidden", Ae["aria-hidden"]), pe.inert = Ae.inert, u.delete(pe));
    }
    let ge = (oe = t.get(pe)) != null ? oe : 0;
    return t.set(pe, ge + 1), ge !== 0 || (u.set(pe, { "aria-hidden": pe.getAttribute("aria-hidden"), inert: pe.inert }), pe.setAttribute("aria-hidden", "true"), pe.inert = !0), me;
  }, [L, ne]);
}
function N$2({ defaultContainers: L = [], portals: ne, mainTreeNodeRef: oe } = {}) {
  var pe;
  let me = useRef((pe = oe == null ? void 0 : oe.current) != null ? pe : null), ge = n$2(me), be = o$4(() => {
    var Ie, Ae, rt;
    let st = [];
    for (let dt of L)
      dt !== null && (dt instanceof HTMLElement ? st.push(dt) : "current" in dt && dt.current instanceof HTMLElement && st.push(dt.current));
    if (ne != null && ne.current)
      for (let dt of ne.current)
        st.push(dt);
    for (let dt of (Ie = ge == null ? void 0 : ge.querySelectorAll("html > *, body > *")) != null ? Ie : [])
      dt !== document.body && dt !== document.head && dt instanceof HTMLElement && dt.id !== "headlessui-portal-root" && (dt.contains(me.current) || dt.contains((rt = (Ae = me.current) == null ? void 0 : Ae.getRootNode()) == null ? void 0 : rt.host) || st.some((ut) => dt.contains(ut)) || st.push(dt));
    return st;
  });
  return { resolveContainers: be, contains: o$4((Ie) => be().some((Ae) => Ae.contains(Ie))), mainTreeNodeRef: me, MainTreeNode: useMemo(() => function() {
    return oe != null ? null : React__default.createElement(f$5, { features: s$4.Hidden, ref: me });
  }, [me, oe]) };
}
let a = createContext(() => {
});
a.displayName = "StackContext";
var s = ((L) => (L[L.Add = 0] = "Add", L[L.Remove = 1] = "Remove", L))(s || {});
function x() {
  return useContext(a);
}
function b$2({ children: L, onUpdate: ne, type: oe, element: pe, enabled: me }) {
  let ge = x(), be = o$4((...Ie) => {
    ne == null || ne(...Ie), ge(...Ie);
  });
  return l$5(() => {
    let Ie = me === void 0 || me === !0;
    return Ie && be(0, oe, pe), () => {
      Ie && be(1, oe, pe);
    };
  }, [be, oe, pe, me]), React__default.createElement(a.Provider, { value: be }, L);
}
let d = createContext(null);
function f$1() {
  let L = useContext(d);
  if (L === null) {
    let ne = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(ne, f$1), ne;
  }
  return L;
}
function w$1() {
  let [L, ne] = useState([]);
  return [L.length > 0 ? L.join(" ") : void 0, useMemo(() => function(oe) {
    let pe = o$4((ge) => (ne((be) => [...be, ge]), () => ne((be) => {
      let Ie = be.slice(), Ae = Ie.indexOf(ge);
      return Ae !== -1 && Ie.splice(Ae, 1), Ie;
    }))), me = useMemo(() => ({ register: pe, slot: oe.slot, name: oe.name, props: oe.props }), [pe, oe.slot, oe.name, oe.props]);
    return React__default.createElement(d.Provider, { value: me }, oe.children);
  }, [ne])];
}
let I$3 = "p";
function S$2(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-description-${oe}`, ...me } = L, ge = f$1(), be = y$1(ne);
  l$5(() => ge.register(pe), [pe, ge.register]);
  let Ie = { ref: be, ...ge.props, id: pe };
  return C$1({ ourProps: Ie, theirProps: me, slot: ge.slot || {}, defaultTag: I$3, name: ge.name || "Description" });
}
let h = U$2(S$2), G = Object.assign(h, {});
var Me = ((L) => (L[L.Open = 0] = "Open", L[L.Closed = 1] = "Closed", L))(Me || {}), we = ((L) => (L[L.SetTitleId = 0] = "SetTitleId", L))(we || {});
let He$1 = { 0(L, ne) {
  return L.titleId === ne.id ? L : { ...L, titleId: ne.id };
} }, I$2 = createContext(null);
I$2.displayName = "DialogContext";
function b$1(L) {
  let ne = useContext(I$2);
  if (ne === null) {
    let oe = new Error(`<${L} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(oe, b$1), oe;
  }
  return ne;
}
function Be(L, ne, oe = () => [document.body]) {
  p(L, ne, (pe) => {
    var me;
    return { containers: [...(me = pe.containers) != null ? me : [], oe] };
  });
}
function Ge(L, ne) {
  return u$4(ne.type, He$1, L, ne);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-${oe}`, open: me, onClose: ge, initialFocus: be, role: Ie = "dialog", __demoMode: Ae = !1, ...rt } = L, [st, dt] = useState(0), ut = useRef(!1);
  Ie = function() {
    return Ie === "dialog" || Ie === "alertdialog" ? Ie : (ut.current || (ut.current = !0, console.warn(`Invalid role [${Ie}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let ht = u$2();
  me === void 0 && ht !== null && (me = (ht & d$3.Open) === d$3.Open);
  let it = useRef(null), lt = y$1(it, ne), St = n$2(it), ot = L.hasOwnProperty("open") || ht !== null, pt = L.hasOwnProperty("onClose");
  if (!ot && !pt)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ot)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!pt)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof me != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${me}`);
  if (typeof ge != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${ge}`);
  let ft = me ? 0 : 1, [vt, xt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), Ct = o$4(() => ge(!1)), At = o$4(($r) => xt({ type: 0, id: $r })), kt = l$4() ? Ae ? !1 : ft === 0 : !1, Vt = st > 1, ir = useContext(I$2) !== null, [er, Yt] = ee$1(), Jt = { get current() {
    var $r;
    return ($r = vt.panelRef.current) != null ? $r : it.current;
  } }, { resolveContainers: rr, mainTreeNodeRef: Qt, MainTreeNode: wt } = N$2({ portals: er, defaultContainers: [Jt] }), Ft = Vt ? "parent" : "leaf", yt = ht !== null ? (ht & d$3.Closing) === d$3.Closing : !1, Et = ir || yt ? !1 : kt, Dt = useCallback(() => {
    var $r, tn;
    return (tn = Array.from(($r = St == null ? void 0 : St.querySelectorAll("body > *")) != null ? $r : []).find((kr) => kr.id === "headlessui-portal-root" ? !1 : kr.contains(Qt.current) && kr instanceof HTMLElement)) != null ? tn : null;
  }, [Qt]);
  b$3(Dt, Et);
  let Ot = Vt ? !0 : kt, nr = useCallback(() => {
    var $r, tn;
    return (tn = Array.from(($r = St == null ? void 0 : St.querySelectorAll("[data-headlessui-portal]")) != null ? $r : []).find((kr) => kr.contains(Qt.current) && kr instanceof HTMLElement)) != null ? tn : null;
  }, [Qt]);
  b$3(nr, Ot), y$2(rr, Ct, !(!kt || Vt));
  let mr = !(Vt || ft !== 0);
  E(St == null ? void 0 : St.defaultView, "keydown", ($r) => {
    mr && ($r.defaultPrevented || $r.key === o.Escape && ($r.preventDefault(), $r.stopPropagation(), Ct()));
  }), Be(St, !(yt || ft !== 0 || ir), rr), useEffect(() => {
    if (ft !== 0 || !it.current)
      return;
    let $r = new ResizeObserver((tn) => {
      for (let kr of tn) {
        let dr = kr.target.getBoundingClientRect();
        dr.x === 0 && dr.y === 0 && dr.width === 0 && dr.height === 0 && Ct();
      }
    });
    return $r.observe(it.current), () => $r.disconnect();
  }, [ft, it, Ct]);
  let [Nr, cn] = w$1(), en = useMemo(() => [{ dialogState: ft, close: Ct, setTitleId: At }, vt], [ft, vt, Ct, At]), Tn = useMemo(() => ({ open: ft === 0 }), [ft]), Mn = { ref: lt, id: pe, role: Ie, "aria-modal": ft === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": Nr };
  return React__default.createElement(b$2, { type: "Dialog", enabled: ft === 0, element: it, onUpdate: o$4(($r, tn) => {
    tn === "Dialog" && u$4($r, { [s.Add]: () => dt((kr) => kr + 1), [s.Remove]: () => dt((kr) => kr - 1) });
  }) }, React__default.createElement(l$2, { force: !0 }, React__default.createElement(te$1, null, React__default.createElement(I$2.Provider, { value: en }, React__default.createElement(te$1.Group, { target: it }, React__default.createElement(l$2, { force: !1 }, React__default.createElement(cn, { slot: Tn, name: "Dialog.Description" }, React__default.createElement(de$1, { initialFocus: be, containers: rr, features: kt ? u$4(Ft, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, React__default.createElement(Yt, null, C$1({ ourProps: Mn, theirProps: rt, slot: Tn, defaultTag: Ne$1, features: Ue, visible: ft === 0, name: "Dialog" }))))))))), React__default.createElement(wt, null));
}
let $e = "div";
function Ye(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-overlay-${oe}`, ...me } = L, [{ dialogState: ge, close: be }] = b$1("Dialog.Overlay"), Ie = y$1(ne), Ae = o$4((st) => {
    if (st.target === st.currentTarget) {
      if (r$2(st.currentTarget))
        return st.preventDefault();
      st.preventDefault(), st.stopPropagation(), be();
    }
  }), rt = useMemo(() => ({ open: ge === 0 }), [ge]);
  return C$1({ ourProps: { ref: Ie, id: pe, "aria-hidden": !0, onClick: Ae }, theirProps: me, slot: rt, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-backdrop-${oe}`, ...me } = L, [{ dialogState: ge }, be] = b$1("Dialog.Backdrop"), Ie = y$1(ne);
  useEffect(() => {
    if (be.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [be.panelRef]);
  let Ae = useMemo(() => ({ open: ge === 0 }), [ge]);
  return React__default.createElement(l$2, { force: !0 }, React__default.createElement(te$1, null, C$1({ ourProps: { ref: Ie, id: pe, "aria-hidden": !0 }, theirProps: me, slot: Ae, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-panel-${oe}`, ...me } = L, [{ dialogState: ge }, be] = b$1("Dialog.Panel"), Ie = y$1(ne, be.panelRef), Ae = useMemo(() => ({ open: ge === 0 }), [ge]), rt = o$4((st) => {
    st.stopPropagation();
  });
  return C$1({ ourProps: { ref: Ie, id: pe, onClick: rt }, theirProps: me, slot: Ae, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$1(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-title-${oe}`, ...me } = L, [{ dialogState: ge, setTitleId: be }] = b$1("Dialog.Title"), Ie = y$1(ne);
  useEffect(() => (be(pe), () => be(null)), [pe, be]);
  let Ae = useMemo(() => ({ open: ge === 0 }), [ge]);
  return C$1({ ourProps: { ref: Ie, id: pe }, theirProps: me, slot: Ae, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$2(We), Qe = U$2(Je), Ze = U$2(Ke), et = U$2(Ye), tt = U$2(qe$1), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G });
function c(L = 0) {
  let [ne, oe] = useState(L), pe = f$4(), me = useCallback((Ae) => {
    pe.current && oe((rt) => rt | Ae);
  }, [ne, pe]), ge = useCallback((Ae) => !!(ne & Ae), [ne]), be = useCallback((Ae) => {
    pe.current && oe((rt) => rt & ~Ae);
  }, [oe, pe]), Ie = useCallback((Ae) => {
    pe.current && oe((rt) => rt ^ Ae);
  }, [oe]);
  return { flags: ne, addFlag: me, hasFlag: ge, removeFlag: be, toggleFlag: Ie };
}
function l(L) {
  let ne = { called: !1 };
  return (...oe) => {
    if (!ne.called)
      return ne.called = !0, L(...oe);
  };
}
function g(L, ...ne) {
  L && ne.length > 0 && L.classList.add(...ne);
}
function v$1(L, ...ne) {
  L && ne.length > 0 && L.classList.remove(...ne);
}
function b(L, ne) {
  let oe = o$3();
  if (!L)
    return oe.dispose;
  let { transitionDuration: pe, transitionDelay: me } = getComputedStyle(L), [ge, be] = [pe, me].map((Ae) => {
    let [rt = 0] = Ae.split(",").filter(Boolean).map((st) => st.includes("ms") ? parseFloat(st) : parseFloat(st) * 1e3).sort((st, dt) => dt - st);
    return rt;
  }), Ie = ge + be;
  if (Ie !== 0) {
    oe.group((rt) => {
      rt.setTimeout(() => {
        ne(), rt.dispose();
      }, Ie), rt.addEventListener(L, "transitionrun", (st) => {
        st.target === st.currentTarget && rt.dispose();
      });
    });
    let Ae = oe.addEventListener(L, "transitionend", (rt) => {
      rt.target === rt.currentTarget && (ne(), Ae());
    });
  } else
    ne();
  return oe.add(() => ne()), oe.dispose;
}
function M$2(L, ne, oe, pe) {
  let me = oe ? "enter" : "leave", ge = o$3(), be = pe !== void 0 ? l(pe) : () => {
  };
  me === "enter" && (L.removeAttribute("hidden"), L.style.display = "");
  let Ie = u$4(me, { enter: () => ne.enter, leave: () => ne.leave }), Ae = u$4(me, { enter: () => ne.enterTo, leave: () => ne.leaveTo }), rt = u$4(me, { enter: () => ne.enterFrom, leave: () => ne.leaveFrom });
  return v$1(L, ...ne.base, ...ne.enter, ...ne.enterTo, ...ne.enterFrom, ...ne.leave, ...ne.leaveFrom, ...ne.leaveTo, ...ne.entered), g(L, ...ne.base, ...Ie, ...rt), ge.nextFrame(() => {
    v$1(L, ...ne.base, ...Ie, ...rt), g(L, ...ne.base, ...Ie, ...Ae), b(L, () => (v$1(L, ...ne.base, ...Ie), g(L, ...ne.base, ...ne.entered), be()));
  }), ge.dispose;
}
function D({ immediate: L, container: ne, direction: oe, classes: pe, onStart: me, onStop: ge }) {
  let be = f$4(), Ie = p$3(), Ae = s$7(oe);
  l$5(() => {
    L && (Ae.current = "enter");
  }, [L]), l$5(() => {
    let rt = o$3();
    Ie.add(rt.dispose);
    let st = ne.current;
    if (st && Ae.current !== "idle" && be.current)
      return rt.dispose(), me.current(Ae.current), rt.add(M$2(st, pe.current, Ae.current === "enter", () => {
        rt.dispose(), ge.current(Ae.current);
      })), rt.dispose;
  }, [oe]);
}
function S$1(L = "") {
  return L.split(/\s+/).filter((ne) => ne.length > 1);
}
let I$1 = createContext(null);
I$1.displayName = "TransitionContext";
var Se = ((L) => (L.Visible = "visible", L.Hidden = "hidden", L))(Se || {});
function ye() {
  let L = useContext(I$1);
  if (L === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return L;
}
function xe() {
  let L = useContext(M$1);
  if (L === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return L;
}
let M$1 = createContext(null);
M$1.displayName = "NestingContext";
function U(L) {
  return "children" in L ? U(L.children) : L.current.filter(({ el: ne }) => ne.current !== null).filter(({ state: ne }) => ne === "visible").length > 0;
}
function se(L, ne) {
  let oe = s$7(L), pe = useRef([]), me = f$4(), ge = p$3(), be = o$4((ht, it = v$2.Hidden) => {
    let lt = pe.current.findIndex(({ el: St }) => St === ht);
    lt !== -1 && (u$4(it, { [v$2.Unmount]() {
      pe.current.splice(lt, 1);
    }, [v$2.Hidden]() {
      pe.current[lt].state = "hidden";
    } }), ge.microTask(() => {
      var St;
      !U(pe) && me.current && ((St = oe.current) == null || St.call(oe));
    }));
  }), Ie = o$4((ht) => {
    let it = pe.current.find(({ el: lt }) => lt === ht);
    return it ? it.state !== "visible" && (it.state = "visible") : pe.current.push({ el: ht, state: "visible" }), () => be(ht, v$2.Unmount);
  }), Ae = useRef([]), rt = useRef(Promise.resolve()), st = useRef({ enter: [], leave: [], idle: [] }), dt = o$4((ht, it, lt) => {
    Ae.current.splice(0), ne && (ne.chains.current[it] = ne.chains.current[it].filter(([St]) => St !== ht)), ne == null || ne.chains.current[it].push([ht, new Promise((St) => {
      Ae.current.push(St);
    })]), ne == null || ne.chains.current[it].push([ht, new Promise((St) => {
      Promise.all(st.current[it].map(([ot, pt]) => pt)).then(() => St());
    })]), it === "enter" ? rt.current = rt.current.then(() => ne == null ? void 0 : ne.wait.current).then(() => lt(it)) : lt(it);
  }), ut = o$4((ht, it, lt) => {
    Promise.all(st.current[it].splice(0).map(([St, ot]) => ot)).then(() => {
      var St;
      (St = Ae.current.shift()) == null || St();
    }).then(() => lt(it));
  });
  return useMemo(() => ({ children: pe, register: Ie, unregister: be, onStart: dt, onStop: ut, wait: rt, chains: st }), [Ie, be, pe, dt, ut, st, rt]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(L) {
  var ne;
  let oe = {};
  for (let pe of Pe)
    oe[pe] = (ne = L[pe]) != null ? ne : Ne;
  return oe;
}
function Re(L) {
  let ne = useRef(ae(L));
  return useEffect(() => {
    ne.current = ae(L);
  }, [L]), ne;
}
let De = "div", le = O.RenderStrategy;
function He(L, ne) {
  var oe, pe;
  let { beforeEnter: me, afterEnter: ge, beforeLeave: be, afterLeave: Ie, enter: Ae, enterFrom: rt, enterTo: st, entered: dt, leave: ut, leaveFrom: ht, leaveTo: it, ...lt } = L, St = useRef(null), ot = y$1(St, ne), pt = (oe = lt.unmount) == null || oe ? v$2.Unmount : v$2.Hidden, { show: ft, appear: vt, initial: xt } = ye(), [Ct, At] = useState(ft ? "visible" : "hidden"), kt = xe(), { register: Vt, unregister: ir } = kt;
  useEffect(() => Vt(St), [Vt, St]), useEffect(() => {
    if (pt === v$2.Hidden && St.current) {
      if (ft && Ct !== "visible") {
        At("visible");
        return;
      }
      return u$4(Ct, { hidden: () => ir(St), visible: () => Vt(St) });
    }
  }, [Ct, St, Vt, ir, ft, pt]);
  let er = s$7({ base: S$1(lt.className), enter: S$1(Ae), enterFrom: S$1(rt), enterTo: S$1(st), entered: S$1(dt), leave: S$1(ut), leaveFrom: S$1(ht), leaveTo: S$1(it) }), Yt = Re({ beforeEnter: me, afterEnter: ge, beforeLeave: be, afterLeave: Ie }), Jt = l$4();
  useEffect(() => {
    if (Jt && Ct === "visible" && St.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [St, Ct, Jt]);
  let rr = xt && !vt, Qt = vt && ft && xt, wt = !Jt || rr ? "idle" : ft ? "enter" : "leave", Ft = c(0), yt = o$4((mr) => u$4(mr, { enter: () => {
    Ft.addFlag(d$3.Opening), Yt.current.beforeEnter();
  }, leave: () => {
    Ft.addFlag(d$3.Closing), Yt.current.beforeLeave();
  }, idle: () => {
  } })), Et = o$4((mr) => u$4(mr, { enter: () => {
    Ft.removeFlag(d$3.Opening), Yt.current.afterEnter();
  }, leave: () => {
    Ft.removeFlag(d$3.Closing), Yt.current.afterLeave();
  }, idle: () => {
  } })), Dt = se(() => {
    At("hidden"), ir(St);
  }, kt), Ot = useRef(!1);
  D({ immediate: Qt, container: St, classes: er, direction: wt, onStart: s$7((mr) => {
    Ot.current = !0, Dt.onStart(St, mr, yt);
  }), onStop: s$7((mr) => {
    Ot.current = !1, Dt.onStop(St, mr, Et), mr === "leave" && !U(Dt) && (At("hidden"), ir(St));
  }) });
  let nr = lt, yr = { ref: ot };
  return Qt ? nr = { ...nr, className: t$4(lt.className, ...er.current.enter, ...er.current.enterFrom) } : Ot.current && (nr.className = t$4(lt.className, (pe = St.current) == null ? void 0 : pe.className), nr.className === "" && delete nr.className), React__default.createElement(M$1.Provider, { value: Dt }, React__default.createElement(s$3, { value: u$4(Ct, { visible: d$3.Open, hidden: d$3.Closed }) | Ft.flags }, C$1({ ourProps: yr, theirProps: nr, defaultTag: De, features: le, visible: Ct === "visible", name: "Transition.Child" })));
}
function Fe(L, ne) {
  let { show: oe, appear: pe = !1, unmount: me = !0, ...ge } = L, be = useRef(null), Ie = y$1(be, ne);
  l$4();
  let Ae = u$2();
  if (oe === void 0 && Ae !== null && (oe = (Ae & d$3.Open) === d$3.Open), ![!0, !1].includes(oe))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [rt, st] = useState(oe ? "visible" : "hidden"), dt = se(() => {
    st("hidden");
  }), [ut, ht] = useState(!0), it = useRef([oe]);
  l$5(() => {
    ut !== !1 && it.current[it.current.length - 1] !== oe && (it.current.push(oe), ht(!1));
  }, [it, oe]);
  let lt = useMemo(() => ({ show: oe, appear: pe, initial: ut }), [oe, pe, ut]);
  useEffect(() => {
    if (oe)
      st("visible");
    else if (!U(dt))
      st("hidden");
    else {
      let ft = be.current;
      if (!ft)
        return;
      let vt = ft.getBoundingClientRect();
      vt.x === 0 && vt.y === 0 && vt.width === 0 && vt.height === 0 && st("hidden");
    }
  }, [oe, dt]);
  let St = { unmount: me }, ot = o$4(() => {
    var ft;
    ut && ht(!1), (ft = L.beforeEnter) == null || ft.call(L);
  }), pt = o$4(() => {
    var ft;
    ut && ht(!1), (ft = L.beforeLeave) == null || ft.call(L);
  });
  return React__default.createElement(M$1.Provider, { value: dt }, React__default.createElement(I$1.Provider, { value: lt }, C$1({ ourProps: { ...St, as: Fragment, children: React__default.createElement(ue, { ref: Ie, ...St, ...ge, beforeEnter: ot, beforeLeave: pt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: rt === "visible", name: "Transition" })));
}
function _e(L, ne) {
  let oe = useContext(I$1) !== null, pe = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !oe && pe ? React__default.createElement(q$1, { ref: ne, ...L }) : React__default.createElement(ue, { ref: ne, ...L }));
}
let q$1 = U$2(Fe), ue = U$2(He), Le = U$2(_e), qe = Object.assign(q$1, { Child: Le, Root: q$1 });
const MainSidebar = ({ gtlsLogo: L, mobileMenuOpen: ne, XMarkIcon: oe, ChevronDownIcon: pe, handleClick: me, handleMenuSide: ge, handleClickSide: be, ResponsiveNavLink: Ie, setMobileMenuOpen: Ae, currentAppId: rt, allowedApplications: st, sidebarElements: dt, LogoutIcon: ut, SupportIcon: ht, handleLogout: it, SupportModal: lt }) => {
  function St(...ot) {
    return ot.filter(Boolean).join(" ");
  }
  return /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement("div", { className: "hidden md:flex md:flex-shrink-0 h-full fixed top-0 left-0 z-50 w-auto" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex w-20 flex-col" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex min-h-0 flex-1 flex-col overflow-y-auto bg-gray-800 containerscroll" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex-1" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex items-center justify-center bg-gray-800 py-4" }, /* @__PURE__ */ React__default.createElement("a", { href: "/" }, typeof L == "string" ? /* @__PURE__ */ React__default.createElement("img", { src: L, alt: "tiger" }) : /* @__PURE__ */ React__default.createElement("div", null, L))), /* @__PURE__ */ React__default.createElement(
    "nav",
    {
      "aria-label": "Sidebar",
      className: "flex flex-col items-center space-y-3 pt-6"
    },
    st == null ? void 0 : st.map((ot) => /* @__PURE__ */ React__default.createElement(
      "a",
      {
        href: ot == null ? void 0 : ot.AppURL,
        key: ot == null ? void 0 : ot.AppId,
        target: (ot == null ? void 0 : ot.id) === 0 ? void 0 : "_blank"
      },
      " ",
      /* @__PURE__ */ React__default.createElement(
        "button",
        {
          key: ot == null ? void 0 : ot.AppAbv,
          className: St(
            (ot == null ? void 0 : ot.AppId) == rt ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
            "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
          )
        },
        ot.icon ? /* @__PURE__ */ React__default.createElement(
          ot.icon,
          {
            className: St(
              ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
              "h-6 w-6"
            ),
            "aria-hidden": "true"
          }
        ) : /* @__PURE__ */ React__default.createElement(
          "img",
          {
            src: `AppLogo/${ot == null ? void 0 : ot.AppIcon}`,
            className: St(
              (ot == null ? void 0 : ot.AppId) == rt ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
              "h-6 w-8"
            ),
            "aria-hidden": "true"
          }
        ),
        /* @__PURE__ */ React__default.createElement("span", null, ot == null ? void 0 : ot.AppAbv)
      )
    ))
  )), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-col flex-shrink-0 pb-5" }, /* @__PURE__ */ React__default.createElement(
    "a",
    {
      href: "https://support.gtls.com.au/help/2703577665",
      target: "_blank",
      className: "flex justify-center"
    },
    " ",
    /* @__PURE__ */ React__default.createElement(
      "button",
      {
        className: St(
          "text-gray-400 hover:bg-gray-700 hover:text-white",
          "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
        )
      },
      typeof ht == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: St(
        "text-gray-400 group-hover:text-white",
        "h-6 w-6"
      ), src: ht }) : ht,
      /* @__PURE__ */ React__default.createElement("span", { className: "mt-2" }, "Support")
    )
  ), /* @__PURE__ */ React__default.createElement("button", { onClick: it }, typeof Ie == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-6 w-6", src: Ie }) : Ie))))), /* @__PURE__ */ React__default.createElement(qe.Root, { show: ne, as: Fragment }, /* @__PURE__ */ React__default.createElement(
    _t,
    {
      as: "div",
      className: "relative z-20 lg:hidden",
      onClose: Ae
    },
    /* @__PURE__ */ React__default.createElement(
      qe.Child,
      {
        as: Fragment,
        enter: "transition-opacity ease-linear duration-300",
        enterFrom: "opacity-0",
        enterTo: "opacity-100",
        leave: "transition-opacity ease-linear duration-300",
        leaveFrom: "opacity-100",
        leaveTo: "opacity-0"
      },
      /* @__PURE__ */ React__default.createElement("div", { className: "fixed inset-0 bg-gray-600 bg-opacity-75" })
    ),
    /* @__PURE__ */ React__default.createElement("div", { className: "fixed inset-0 z-40 flex" }, /* @__PURE__ */ React__default.createElement(
      qe.Child,
      {
        as: Fragment,
        enter: "transition ease-in-out duration-300 transform",
        enterFrom: "-translate-x-full",
        enterTo: "translate-x-0",
        leave: "transition ease-in-out duration-300 transform",
        leaveFrom: "translate-x-0",
        leaveTo: "-translate-x-full"
      },
      /* @__PURE__ */ React__default.createElement(_t.Panel, { className: "relative flex w-full max-w-xs flex-1 flex-col bg-gray-800 pt-5 pb-4" }, /* @__PURE__ */ React__default.createElement(
        qe.Child,
        {
          as: Fragment,
          enter: "ease-in-out duration-300",
          enterFrom: "opacity-0",
          enterTo: "opacity-100",
          leave: "ease-in-out duration-300",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0"
        },
        /* @__PURE__ */ React__default.createElement("div", { className: "absolute top-1 right-0 -mr-14 p-1" }, /* @__PURE__ */ React__default.createElement(
          "button",
          {
            type: "button",
            className: "flex h-12 w-12 items-center justify-center rounded-full focus:outline-none ",
            onClick: Ae
          },
          typeof oe == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-6 w-6 text-white", src: oe }) : oe,
          /* @__PURE__ */ React__default.createElement("span", { className: "sr-only" }, "Close sidebar")
        ))
      ), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-shrink-0 items-center px-4" }, typeof L == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-8 w-auto", src: L, alt: "tiger" }) : /* @__PURE__ */ React__default.createElement("div", { className: "h-8 w-auto" }, L)), /* @__PURE__ */ React__default.createElement("div", { className: "mt-5 h-0 flex-1 overflow-y-auto px-2" }, /* @__PURE__ */ React__default.createElement("nav", { className: "flex h-full flex-col" }, /* @__PURE__ */ React__default.createElement("div", { className: "space-y-1 " }, dt.map((ot) => /* @__PURE__ */ React__default.createElement(
        Accordion,
        {
          key: ot == null ? void 0 : ot.id,
          transition: {
            duration: "300ms",
            timingFunction: "cubic-bezier(0, 0, 0.2, 1)"
          }
        },
        ot != null && ot.options ? /* @__PURE__ */ React__default.createElement(AccordionItem, null, ({}) => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(
          AccordionHeader,
          {
            onClick: ge,
            className: St(
              ot != null && ot.current ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
              "group py-2 px-3 rounded-md gap-x-2 text-sm font-medium w-full flex justify- items-center text-gray-600  p-4"
            )
          },
          ot != null && ot.icon ? /* @__PURE__ */ React__default.createElement(
            ot.icon,
            {
              className: St(
                ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                "h-6 w-6"
              ),
              "aria-hidden": "true"
            }
          ) : /* @__PURE__ */ React__default.createElement(
            "img",
            {
              src: ot == null ? void 0 : ot.img,
              className: St(
                ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                "h-6 w-6"
              ),
              "aria-hidden": "true"
            }
          ),
          /* @__PURE__ */ React__default.createElement(
            "span",
            {
              id: ot == null ? void 0 : ot.name
            },
            ot == null ? void 0 : ot.name
          ),
          (ot == null ? void 0 : ot.options.length) > 0 ? typeof pe == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-3", src: pe, alt: "" }) : pe : /* @__PURE__ */ React__default.createElement(React__default.Fragment, null)
        ), ot.options ? /* @__PURE__ */ React__default.createElement(AccordionBody, { className: "pl-8 flex flex-col" }, ot.options.map(
          (pt) => /* @__PURE__ */ React__default.createElement(
            "button",
            {
              id: pt.name ? pt == null ? void 0 : pt.name.toString() : "",
              onClick: be,
              className: "p-5 font-light text-left text-white"
            },
            pt == null ? void 0 : pt.name
          )
        )) : "")) : /* @__PURE__ */ React__default.createElement(
          "a",
          {
            href: ot.href,
            onClick: me
          },
          /* @__PURE__ */ React__default.createElement(
            AccordionItem,
            {
              key: ot.name ? ot == null ? void 0 : ot.name.toString() : ""
            },
            ({}) => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(
              AccordionHeader,
              {
                className: St(
                  ot != null && ot.current ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
                  "group py-2 px-3 rounded-md flex gap-x-2 items-center text-sm font-medium w-full text-gray-600  p-4"
                )
              },
              ot.icon ? /* @__PURE__ */ React__default.createElement(
                ot.icon,
                {
                  className: St(
                    ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                    "h-6 w-6"
                  ),
                  "aria-hidden": "true"
                }
              ) : /* @__PURE__ */ React__default.createElement(
                "img",
                {
                  src: ot == null ? void 0 : ot.img,
                  className: St(
                    ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                    "h-6 w-6"
                  ),
                  "aria-hidden": "true"
                }
              ),
              /* @__PURE__ */ React__default.createElement("span", null, ot == null ? void 0 : ot.name)
            ), ot.options ? /* @__PURE__ */ React__default.createElement(AccordionBody, { className: "pl-8 flex flex-col" }, ot.options.map(
              (pt) => /* @__PURE__ */ React__default.createElement(
                "button",
                {
                  onClick: be,
                  className: "p-5 font-light text-left text-white"
                },
                pt == null ? void 0 : pt.name
              )
            )) : "")
          )
        )
      ))))), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-col flex-shrink-0 pb-5" }, /* @__PURE__ */ React__default.createElement(
        "a",
        {
          href: "https://support.gtls.com.au/help/2703577665",
          target: "_blank",
          className: "flex"
        },
        " ",
        /* @__PURE__ */ React__default.createElement(
          "button",
          {
            className: St(
              "text-gray-400 hover:bg-gray-700 hover:text-white",
              "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
            )
          },
          typeof ht == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: St(
            "text-gray-400 group-hover:text-white",
            "h-6 w-6"
          ), src: ht }) : ht,
          /* @__PURE__ */ React__default.createElement("span", { className: "mt-2" }, "Support")
        )
      ), /* @__PURE__ */ React__default.createElement("button", { onClick: it }, typeof Ie == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-6 w-6", src: Ie }) : Ie)))
    ), /* @__PURE__ */ React__default.createElement("div", { className: "w-14 flex-shrink-0", "aria-hidden": "true" }))
  )), typeof lt == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: St(
    "text-gray-400 group-hover:text-white",
    "h-6 w-6"
  ), src: lt }) : lt);
};
function bind$2(L, ne) {
  return function() {
    return L.apply(ne, arguments);
  };
}
const { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = /* @__PURE__ */ ((L) => (ne) => {
  const oe = toString.call(ne);
  return L[oe] || (L[oe] = oe.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (L) => (L = L.toLowerCase(), (ne) => kindOf(ne) === L), typeOfTest = (L) => (ne) => typeof ne === L, { isArray: isArray$4 } = Array, isUndefined = typeOfTest("undefined");
function isBuffer$1(L) {
  return L !== null && !isUndefined(L) && L.constructor !== null && !isUndefined(L.constructor) && isFunction(L.constructor.isBuffer) && L.constructor.isBuffer(L);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(L) {
  let ne;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ne = ArrayBuffer.isView(L) : ne = L && L.buffer && isArrayBuffer(L.buffer), ne;
}
const isString$1 = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber$1 = typeOfTest("number"), isObject = (L) => L !== null && typeof L == "object", isBoolean$1 = (L) => L === !0 || L === !1, isPlainObject = (L) => {
  if (kindOf(L) !== "object")
    return !1;
  const ne = getPrototypeOf(L);
  return (ne === null || ne === Object.prototype || Object.getPrototypeOf(ne) === null) && !(Symbol.toStringTag in L) && !(Symbol.iterator in L);
}, isDate$1 = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (L) => isObject(L) && isFunction(L.pipe), isFormData = (L) => {
  let ne;
  return L && (typeof FormData == "function" && L instanceof FormData || isFunction(L.append) && ((ne = kindOf(L)) === "formdata" || // detect form-data instance
  ne === "object" && isFunction(L.toString) && L.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (L) => L.trim ? L.trim() : L.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(L, ne, { allOwnKeys: oe = !1 } = {}) {
  if (L === null || typeof L > "u")
    return;
  let pe, me;
  if (typeof L != "object" && (L = [L]), isArray$4(L))
    for (pe = 0, me = L.length; pe < me; pe++)
      ne.call(null, L[pe], pe, L);
  else {
    const ge = oe ? Object.getOwnPropertyNames(L) : Object.keys(L), be = ge.length;
    let Ie;
    for (pe = 0; pe < be; pe++)
      Ie = ge[pe], ne.call(null, L[Ie], Ie, L);
  }
}
function findKey(L, ne) {
  ne = ne.toLowerCase();
  const oe = Object.keys(L);
  let pe = oe.length, me;
  for (; pe-- > 0; )
    if (me = oe[pe], ne === me.toLowerCase())
      return me;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = (L) => !isUndefined(L) && L !== _global;
function merge$1() {
  const { caseless: L } = isContextDefined(this) && this || {}, ne = {}, oe = (pe, me) => {
    const ge = L && findKey(ne, me) || me;
    isPlainObject(ne[ge]) && isPlainObject(pe) ? ne[ge] = merge$1(ne[ge], pe) : isPlainObject(pe) ? ne[ge] = merge$1({}, pe) : isArray$4(pe) ? ne[ge] = pe.slice() : ne[ge] = pe;
  };
  for (let pe = 0, me = arguments.length; pe < me; pe++)
    arguments[pe] && forEach(arguments[pe], oe);
  return ne;
}
const extend = (L, ne, oe, { allOwnKeys: pe } = {}) => (forEach(ne, (me, ge) => {
  oe && isFunction(me) ? L[ge] = bind$2(me, oe) : L[ge] = me;
}, { allOwnKeys: pe }), L), stripBOM = (L) => (L.charCodeAt(0) === 65279 && (L = L.slice(1)), L), inherits = (L, ne, oe, pe) => {
  L.prototype = Object.create(ne.prototype, pe), L.prototype.constructor = L, Object.defineProperty(L, "super", {
    value: ne.prototype
  }), oe && Object.assign(L.prototype, oe);
}, toFlatObject = (L, ne, oe, pe) => {
  let me, ge, be;
  const Ie = {};
  if (ne = ne || {}, L == null)
    return ne;
  do {
    for (me = Object.getOwnPropertyNames(L), ge = me.length; ge-- > 0; )
      be = me[ge], (!pe || pe(be, L, ne)) && !Ie[be] && (ne[be] = L[be], Ie[be] = !0);
    L = oe !== !1 && getPrototypeOf(L);
  } while (L && (!oe || oe(L, ne)) && L !== Object.prototype);
  return ne;
}, endsWith = (L, ne, oe) => {
  L = String(L), (oe === void 0 || oe > L.length) && (oe = L.length), oe -= ne.length;
  const pe = L.indexOf(ne, oe);
  return pe !== -1 && pe === oe;
}, toArray = (L) => {
  if (!L)
    return null;
  if (isArray$4(L))
    return L;
  let ne = L.length;
  if (!isNumber$1(ne))
    return null;
  const oe = new Array(ne);
  for (; ne-- > 0; )
    oe[ne] = L[ne];
  return oe;
}, isTypedArray = /* @__PURE__ */ ((L) => (ne) => L && ne instanceof L)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (L, ne) => {
  const pe = (L && L[Symbol.iterator]).call(L);
  let me;
  for (; (me = pe.next()) && !me.done; ) {
    const ge = me.value;
    ne.call(L, ge[0], ge[1]);
  }
}, matchAll = (L, ne) => {
  let oe;
  const pe = [];
  for (; (oe = L.exec(ne)) !== null; )
    pe.push(oe);
  return pe;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (L) => L.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(oe, pe, me) {
    return pe.toUpperCase() + me;
  }
), hasOwnProperty = (({ hasOwnProperty: L }) => (ne, oe) => L.call(ne, oe))(Object.prototype), isRegExp$2 = kindOfTest("RegExp"), reduceDescriptors = (L, ne) => {
  const oe = Object.getOwnPropertyDescriptors(L), pe = {};
  forEach(oe, (me, ge) => {
    let be;
    (be = ne(me, ge, L)) !== !1 && (pe[ge] = be || me);
  }), Object.defineProperties(L, pe);
}, freezeMethods = (L) => {
  reduceDescriptors(L, (ne, oe) => {
    if (isFunction(L) && ["arguments", "caller", "callee"].indexOf(oe) !== -1)
      return !1;
    const pe = L[oe];
    if (isFunction(pe)) {
      if (ne.enumerable = !1, "writable" in ne) {
        ne.writable = !1;
        return;
      }
      ne.set || (ne.set = () => {
        throw Error("Can not rewrite read-only method '" + oe + "'");
      });
    }
  });
}, toObjectSet = (L, ne) => {
  const oe = {}, pe = (me) => {
    me.forEach((ge) => {
      oe[ge] = !0;
    });
  };
  return isArray$4(L) ? pe(L) : pe(String(L).split(ne)), oe;
}, noop = () => {
}, toFiniteNumber = (L, ne) => (L = +L, Number.isFinite(L) ? L : ne), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (L = 16, ne = ALPHABET.ALPHA_DIGIT) => {
  let oe = "";
  const { length: pe } = ne;
  for (; L--; )
    oe += ne[Math.random() * pe | 0];
  return oe;
};
function isSpecCompliantForm(L) {
  return !!(L && isFunction(L.append) && L[Symbol.toStringTag] === "FormData" && L[Symbol.iterator]);
}
const toJSONObject = (L) => {
  const ne = new Array(10), oe = (pe, me) => {
    if (isObject(pe)) {
      if (ne.indexOf(pe) >= 0)
        return;
      if (!("toJSON" in pe)) {
        ne[me] = pe;
        const ge = isArray$4(pe) ? [] : {};
        return forEach(pe, (be, Ie) => {
          const Ae = oe(be, me + 1);
          !isUndefined(Ae) && (ge[Ie] = Ae);
        }), ne[me] = void 0, ge;
      }
    }
    return pe;
  };
  return oe(L, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (L) => L && (isObject(L) || isFunction(L)) && isFunction(L.then) && isFunction(L.catch), utils$4 = {
  isArray: isArray$4,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isBoolean: isBoolean$1,
  isObject,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp: isRegExp$2,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(L, ne, oe, pe, me) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = L, this.name = "AxiosError", ne && (this.code = ne), oe && (this.config = oe), pe && (this.request = pe), me && (this.response = me);
}
utils$4.inherits(AxiosError, Error, {
  toJSON: function L() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((L) => {
  descriptors[L] = { value: L };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (L, ne, oe, pe, me, ge) => {
  const be = Object.create(prototype$1);
  return utils$4.toFlatObject(L, be, function(Ae) {
    return Ae !== Error.prototype;
  }, (Ie) => Ie !== "isAxiosError"), AxiosError.call(be, L.message, ne, oe, pe, me), be.cause = L, be.name = L.name, ge && Object.assign(be, ge), be;
};
const httpAdapter = null;
function isVisitable(L) {
  return utils$4.isPlainObject(L) || utils$4.isArray(L);
}
function removeBrackets(L) {
  return utils$4.endsWith(L, "[]") ? L.slice(0, -2) : L;
}
function renderKey(L, ne, oe) {
  return L ? L.concat(ne).map(function(me, ge) {
    return me = removeBrackets(me), !oe && ge ? "[" + me + "]" : me;
  }).join(oe ? "." : "") : ne;
}
function isFlatArray(L) {
  return utils$4.isArray(L) && !L.some(isVisitable);
}
const predicates = utils$4.toFlatObject(utils$4, {}, null, function L(ne) {
  return /^is[A-Z]/.test(ne);
});
function toFormData(L, ne, oe) {
  if (!utils$4.isObject(L))
    throw new TypeError("target must be an object");
  ne = ne || new FormData(), oe = utils$4.toFlatObject(oe, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(lt, St) {
    return !utils$4.isUndefined(St[lt]);
  });
  const pe = oe.metaTokens, me = oe.visitor || st, ge = oe.dots, be = oe.indexes, Ae = (oe.Blob || typeof Blob < "u" && Blob) && utils$4.isSpecCompliantForm(ne);
  if (!utils$4.isFunction(me))
    throw new TypeError("visitor must be a function");
  function rt(it) {
    if (it === null)
      return "";
    if (utils$4.isDate(it))
      return it.toISOString();
    if (!Ae && utils$4.isBlob(it))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$4.isArrayBuffer(it) || utils$4.isTypedArray(it) ? Ae && typeof Blob == "function" ? new Blob([it]) : Buffer.from(it) : it;
  }
  function st(it, lt, St) {
    let ot = it;
    if (it && !St && typeof it == "object") {
      if (utils$4.endsWith(lt, "{}"))
        lt = pe ? lt : lt.slice(0, -2), it = JSON.stringify(it);
      else if (utils$4.isArray(it) && isFlatArray(it) || (utils$4.isFileList(it) || utils$4.endsWith(lt, "[]")) && (ot = utils$4.toArray(it)))
        return lt = removeBrackets(lt), ot.forEach(function(ft, vt) {
          !(utils$4.isUndefined(ft) || ft === null) && ne.append(
            // eslint-disable-next-line no-nested-ternary
            be === !0 ? renderKey([lt], vt, ge) : be === null ? lt : lt + "[]",
            rt(ft)
          );
        }), !1;
    }
    return isVisitable(it) ? !0 : (ne.append(renderKey(St, lt, ge), rt(it)), !1);
  }
  const dt = [], ut = Object.assign(predicates, {
    defaultVisitor: st,
    convertValue: rt,
    isVisitable
  });
  function ht(it, lt) {
    if (!utils$4.isUndefined(it)) {
      if (dt.indexOf(it) !== -1)
        throw Error("Circular reference detected in " + lt.join("."));
      dt.push(it), utils$4.forEach(it, function(ot, pt) {
        (!(utils$4.isUndefined(ot) || ot === null) && me.call(
          ne,
          ot,
          utils$4.isString(pt) ? pt.trim() : pt,
          lt,
          ut
        )) === !0 && ht(ot, lt ? lt.concat(pt) : [pt]);
      }), dt.pop();
    }
  }
  if (!utils$4.isObject(L))
    throw new TypeError("data must be an object");
  return ht(L), ne;
}
function encode$2(L) {
  const ne = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(L).replace(/[!'()~]|%20|%00/g, function(pe) {
    return ne[pe];
  });
}
function AxiosURLSearchParams(L, ne) {
  this._pairs = [], L && toFormData(L, this, ne);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function L(ne, oe) {
  this._pairs.push([ne, oe]);
};
prototype.toString = function L(ne) {
  const oe = ne ? function(pe) {
    return ne.call(this, pe, encode$2);
  } : encode$2;
  return this._pairs.map(function(me) {
    return oe(me[0]) + "=" + oe(me[1]);
  }, "").join("&");
};
function encode$1(L) {
  return encodeURIComponent(L).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(L, ne, oe) {
  if (!ne)
    return L;
  const pe = oe && oe.encode || encode$1, me = oe && oe.serialize;
  let ge;
  if (me ? ge = me(ne, oe) : ge = utils$4.isURLSearchParams(ne) ? ne.toString() : new AxiosURLSearchParams(ne, oe).toString(pe), ge) {
    const be = L.indexOf("#");
    be !== -1 && (L = L.slice(0, be)), L += (L.indexOf("?") === -1 ? "?" : "&") + ge;
  }
  return L;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(ne, oe, pe) {
    return this.handlers.push({
      fulfilled: ne,
      rejected: oe,
      synchronous: pe ? pe.synchronous : !1,
      runWhen: pe ? pe.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(ne) {
    this.handlers[ne] && (this.handlers[ne] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(ne) {
    utils$4.forEach(this.handlers, function(pe) {
      pe !== null && ne(pe);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = ((L) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(L) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", utils$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" })), platform = {
  ...utils$3,
  ...platform$1
};
function toURLEncodedForm(L, ne) {
  return toFormData(L, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(oe, pe, me, ge) {
      return platform.isNode && utils$4.isBuffer(oe) ? (this.append(pe, oe.toString("base64")), !1) : ge.defaultVisitor.apply(this, arguments);
    }
  }, ne));
}
function parsePropPath(L) {
  return utils$4.matchAll(/\w+|\[(\w*)]/g, L).map((ne) => ne[0] === "[]" ? "" : ne[1] || ne[0]);
}
function arrayToObject$1(L) {
  const ne = {}, oe = Object.keys(L);
  let pe;
  const me = oe.length;
  let ge;
  for (pe = 0; pe < me; pe++)
    ge = oe[pe], ne[ge] = L[ge];
  return ne;
}
function formDataToJSON(L) {
  function ne(oe, pe, me, ge) {
    let be = oe[ge++];
    if (be === "__proto__")
      return !0;
    const Ie = Number.isFinite(+be), Ae = ge >= oe.length;
    return be = !be && utils$4.isArray(me) ? me.length : be, Ae ? (utils$4.hasOwnProp(me, be) ? me[be] = [me[be], pe] : me[be] = pe, !Ie) : ((!me[be] || !utils$4.isObject(me[be])) && (me[be] = []), ne(oe, pe, me[be], ge) && utils$4.isArray(me[be]) && (me[be] = arrayToObject$1(me[be])), !Ie);
  }
  if (utils$4.isFormData(L) && utils$4.isFunction(L.entries)) {
    const oe = {};
    return utils$4.forEachEntry(L, (pe, me) => {
      ne(parsePropPath(pe), me, oe, 0);
    }), oe;
  }
  return null;
}
function stringifySafely(L, ne, oe) {
  if (utils$4.isString(L))
    try {
      return (ne || JSON.parse)(L), utils$4.trim(L);
    } catch (pe) {
      if (pe.name !== "SyntaxError")
        throw pe;
    }
  return (oe || JSON.stringify)(L);
}
const defaults$2 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function L(ne, oe) {
    const pe = oe.getContentType() || "", me = pe.indexOf("application/json") > -1, ge = utils$4.isObject(ne);
    if (ge && utils$4.isHTMLForm(ne) && (ne = new FormData(ne)), utils$4.isFormData(ne))
      return me && me ? JSON.stringify(formDataToJSON(ne)) : ne;
    if (utils$4.isArrayBuffer(ne) || utils$4.isBuffer(ne) || utils$4.isStream(ne) || utils$4.isFile(ne) || utils$4.isBlob(ne))
      return ne;
    if (utils$4.isArrayBufferView(ne))
      return ne.buffer;
    if (utils$4.isURLSearchParams(ne))
      return oe.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), ne.toString();
    let Ie;
    if (ge) {
      if (pe.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(ne, this.formSerializer).toString();
      if ((Ie = utils$4.isFileList(ne)) || pe.indexOf("multipart/form-data") > -1) {
        const Ae = this.env && this.env.FormData;
        return toFormData(
          Ie ? { "files[]": ne } : ne,
          Ae && new Ae(),
          this.formSerializer
        );
      }
    }
    return ge || me ? (oe.setContentType("application/json", !1), stringifySafely(ne)) : ne;
  }],
  transformResponse: [function L(ne) {
    const oe = this.transitional || defaults$2.transitional, pe = oe && oe.forcedJSONParsing, me = this.responseType === "json";
    if (ne && utils$4.isString(ne) && (pe && !this.responseType || me)) {
      const be = !(oe && oe.silentJSONParsing) && me;
      try {
        return JSON.parse(ne);
      } catch (Ie) {
        if (be)
          throw Ie.name === "SyntaxError" ? AxiosError.from(Ie, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : Ie;
      }
    }
    return ne;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function L(ne) {
    return ne >= 200 && ne < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$4.forEach(["delete", "get", "head", "post", "put", "patch"], (L) => {
  defaults$2.headers[L] = {};
});
const defaults$3 = defaults$2, ignoreDuplicateOf = utils$4.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (L) => {
  const ne = {};
  let oe, pe, me;
  return L && L.split(`
`).forEach(function(be) {
    me = be.indexOf(":"), oe = be.substring(0, me).trim().toLowerCase(), pe = be.substring(me + 1).trim(), !(!oe || ne[oe] && ignoreDuplicateOf[oe]) && (oe === "set-cookie" ? ne[oe] ? ne[oe].push(pe) : ne[oe] = [pe] : ne[oe] = ne[oe] ? ne[oe] + ", " + pe : pe);
  }), ne;
}, $internals = Symbol("internals");
function normalizeHeader(L) {
  return L && String(L).trim().toLowerCase();
}
function normalizeValue(L) {
  return L === !1 || L == null ? L : utils$4.isArray(L) ? L.map(normalizeValue) : String(L);
}
function parseTokens(L) {
  const ne = /* @__PURE__ */ Object.create(null), oe = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let pe;
  for (; pe = oe.exec(L); )
    ne[pe[1]] = pe[2];
  return ne;
}
const isValidHeaderName = (L) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(L.trim());
function matchHeaderValue(L, ne, oe, pe, me) {
  if (utils$4.isFunction(pe))
    return pe.call(this, ne, oe);
  if (me && (ne = oe), !!utils$4.isString(ne)) {
    if (utils$4.isString(pe))
      return ne.indexOf(pe) !== -1;
    if (utils$4.isRegExp(pe))
      return pe.test(ne);
  }
}
function formatHeader(L) {
  return L.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (ne, oe, pe) => oe.toUpperCase() + pe);
}
function buildAccessors(L, ne) {
  const oe = utils$4.toCamelCase(" " + ne);
  ["get", "set", "has"].forEach((pe) => {
    Object.defineProperty(L, pe + oe, {
      value: function(me, ge, be) {
        return this[pe].call(this, ne, me, ge, be);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(ne) {
    ne && this.set(ne);
  }
  set(ne, oe, pe) {
    const me = this;
    function ge(Ie, Ae, rt) {
      const st = normalizeHeader(Ae);
      if (!st)
        throw new Error("header name must be a non-empty string");
      const dt = utils$4.findKey(me, st);
      (!dt || me[dt] === void 0 || rt === !0 || rt === void 0 && me[dt] !== !1) && (me[dt || Ae] = normalizeValue(Ie));
    }
    const be = (Ie, Ae) => utils$4.forEach(Ie, (rt, st) => ge(rt, st, Ae));
    return utils$4.isPlainObject(ne) || ne instanceof this.constructor ? be(ne, oe) : utils$4.isString(ne) && (ne = ne.trim()) && !isValidHeaderName(ne) ? be(parseHeaders(ne), oe) : ne != null && ge(oe, ne, pe), this;
  }
  get(ne, oe) {
    if (ne = normalizeHeader(ne), ne) {
      const pe = utils$4.findKey(this, ne);
      if (pe) {
        const me = this[pe];
        if (!oe)
          return me;
        if (oe === !0)
          return parseTokens(me);
        if (utils$4.isFunction(oe))
          return oe.call(this, me, pe);
        if (utils$4.isRegExp(oe))
          return oe.exec(me);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(ne, oe) {
    if (ne = normalizeHeader(ne), ne) {
      const pe = utils$4.findKey(this, ne);
      return !!(pe && this[pe] !== void 0 && (!oe || matchHeaderValue(this, this[pe], pe, oe)));
    }
    return !1;
  }
  delete(ne, oe) {
    const pe = this;
    let me = !1;
    function ge(be) {
      if (be = normalizeHeader(be), be) {
        const Ie = utils$4.findKey(pe, be);
        Ie && (!oe || matchHeaderValue(pe, pe[Ie], Ie, oe)) && (delete pe[Ie], me = !0);
      }
    }
    return utils$4.isArray(ne) ? ne.forEach(ge) : ge(ne), me;
  }
  clear(ne) {
    const oe = Object.keys(this);
    let pe = oe.length, me = !1;
    for (; pe--; ) {
      const ge = oe[pe];
      (!ne || matchHeaderValue(this, this[ge], ge, ne, !0)) && (delete this[ge], me = !0);
    }
    return me;
  }
  normalize(ne) {
    const oe = this, pe = {};
    return utils$4.forEach(this, (me, ge) => {
      const be = utils$4.findKey(pe, ge);
      if (be) {
        oe[be] = normalizeValue(me), delete oe[ge];
        return;
      }
      const Ie = ne ? formatHeader(ge) : String(ge).trim();
      Ie !== ge && delete oe[ge], oe[Ie] = normalizeValue(me), pe[Ie] = !0;
    }), this;
  }
  concat(...ne) {
    return this.constructor.concat(this, ...ne);
  }
  toJSON(ne) {
    const oe = /* @__PURE__ */ Object.create(null);
    return utils$4.forEach(this, (pe, me) => {
      pe != null && pe !== !1 && (oe[me] = ne && utils$4.isArray(pe) ? pe.join(", ") : pe);
    }), oe;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([ne, oe]) => ne + ": " + oe).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(ne) {
    return ne instanceof this ? ne : new this(ne);
  }
  static concat(ne, ...oe) {
    const pe = new this(ne);
    return oe.forEach((me) => pe.set(me)), pe;
  }
  static accessor(ne) {
    const pe = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, me = this.prototype;
    function ge(be) {
      const Ie = normalizeHeader(be);
      pe[Ie] || (buildAccessors(me, be), pe[Ie] = !0);
    }
    return utils$4.isArray(ne) ? ne.forEach(ge) : ge(ne), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$4.reduceDescriptors(AxiosHeaders.prototype, ({ value: L }, ne) => {
  let oe = ne[0].toUpperCase() + ne.slice(1);
  return {
    get: () => L,
    set(pe) {
      this[oe] = pe;
    }
  };
});
utils$4.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(L, ne) {
  const oe = this || defaults$3, pe = ne || oe, me = AxiosHeaders$1.from(pe.headers);
  let ge = pe.data;
  return utils$4.forEach(L, function(Ie) {
    ge = Ie.call(oe, ge, me.normalize(), ne ? ne.status : void 0);
  }), me.normalize(), ge;
}
function isCancel(L) {
  return !!(L && L.__CANCEL__);
}
function CanceledError(L, ne, oe) {
  AxiosError.call(this, L ?? "canceled", AxiosError.ERR_CANCELED, ne, oe), this.name = "CanceledError";
}
utils$4.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(L, ne, oe) {
  const pe = oe.config.validateStatus;
  !oe.status || !pe || pe(oe.status) ? L(oe) : ne(new AxiosError(
    "Request failed with status code " + oe.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(oe.status / 100) - 4],
    oe.config,
    oe.request,
    oe
  ));
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(L, ne, oe, pe, me, ge) {
      const be = [L + "=" + encodeURIComponent(ne)];
      utils$4.isNumber(oe) && be.push("expires=" + new Date(oe).toGMTString()), utils$4.isString(pe) && be.push("path=" + pe), utils$4.isString(me) && be.push("domain=" + me), ge === !0 && be.push("secure"), document.cookie = be.join("; ");
    },
    read(L) {
      const ne = document.cookie.match(new RegExp("(^|;\\s*)(" + L + ")=([^;]*)"));
      return ne ? decodeURIComponent(ne[3]) : null;
    },
    remove(L) {
      this.write(L, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(L) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(L);
}
function combineURLs(L, ne) {
  return ne ? L.replace(/\/?\/$/, "") + "/" + ne.replace(/^\/+/, "") : L;
}
function buildFullPath(L, ne) {
  return L && !isAbsoluteURL(ne) ? combineURLs(L, ne) : ne;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function L() {
    const ne = /(msie|trident)/i.test(navigator.userAgent), oe = document.createElement("a");
    let pe;
    function me(ge) {
      let be = ge;
      return ne && (oe.setAttribute("href", be), be = oe.href), oe.setAttribute("href", be), {
        href: oe.href,
        protocol: oe.protocol ? oe.protocol.replace(/:$/, "") : "",
        host: oe.host,
        search: oe.search ? oe.search.replace(/^\?/, "") : "",
        hash: oe.hash ? oe.hash.replace(/^#/, "") : "",
        hostname: oe.hostname,
        port: oe.port,
        pathname: oe.pathname.charAt(0) === "/" ? oe.pathname : "/" + oe.pathname
      };
    }
    return pe = me(window.location.href), function(be) {
      const Ie = utils$4.isString(be) ? me(be) : be;
      return Ie.protocol === pe.protocol && Ie.host === pe.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function L() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol(L) {
  const ne = /^([-+\w]{1,25})(:?\/\/|:)/.exec(L);
  return ne && ne[1] || "";
}
function speedometer(L, ne) {
  L = L || 10;
  const oe = new Array(L), pe = new Array(L);
  let me = 0, ge = 0, be;
  return ne = ne !== void 0 ? ne : 1e3, function(Ae) {
    const rt = Date.now(), st = pe[ge];
    be || (be = rt), oe[me] = Ae, pe[me] = rt;
    let dt = ge, ut = 0;
    for (; dt !== me; )
      ut += oe[dt++], dt = dt % L;
    if (me = (me + 1) % L, me === ge && (ge = (ge + 1) % L), rt - be < ne)
      return;
    const ht = st && rt - st;
    return ht ? Math.round(ut * 1e3 / ht) : void 0;
  };
}
function progressEventReducer(L, ne) {
  let oe = 0;
  const pe = speedometer(50, 250);
  return (me) => {
    const ge = me.loaded, be = me.lengthComputable ? me.total : void 0, Ie = ge - oe, Ae = pe(Ie), rt = ge <= be;
    oe = ge;
    const st = {
      loaded: ge,
      total: be,
      progress: be ? ge / be : void 0,
      bytes: Ie,
      rate: Ae || void 0,
      estimated: Ae && be && rt ? (be - ge) / Ae : void 0,
      event: me
    };
    st[ne ? "download" : "upload"] = !0, L(st);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(L) {
  return new Promise(function(oe, pe) {
    let me = L.data;
    const ge = AxiosHeaders$1.from(L.headers).normalize();
    let { responseType: be, withXSRFToken: Ie } = L, Ae;
    function rt() {
      L.cancelToken && L.cancelToken.unsubscribe(Ae), L.signal && L.signal.removeEventListener("abort", Ae);
    }
    let st;
    if (utils$4.isFormData(me)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
        ge.setContentType(!1);
      else if ((st = ge.getContentType()) !== !1) {
        const [lt, ...St] = st ? st.split(";").map((ot) => ot.trim()).filter(Boolean) : [];
        ge.setContentType([lt || "multipart/form-data", ...St].join("; "));
      }
    }
    let dt = new XMLHttpRequest();
    if (L.auth) {
      const lt = L.auth.username || "", St = L.auth.password ? unescape(encodeURIComponent(L.auth.password)) : "";
      ge.set("Authorization", "Basic " + btoa(lt + ":" + St));
    }
    const ut = buildFullPath(L.baseURL, L.url);
    dt.open(L.method.toUpperCase(), buildURL(ut, L.params, L.paramsSerializer), !0), dt.timeout = L.timeout;
    function ht() {
      if (!dt)
        return;
      const lt = AxiosHeaders$1.from(
        "getAllResponseHeaders" in dt && dt.getAllResponseHeaders()
      ), ot = {
        data: !be || be === "text" || be === "json" ? dt.responseText : dt.response,
        status: dt.status,
        statusText: dt.statusText,
        headers: lt,
        config: L,
        request: dt
      };
      settle(function(ft) {
        oe(ft), rt();
      }, function(ft) {
        pe(ft), rt();
      }, ot), dt = null;
    }
    if ("onloadend" in dt ? dt.onloadend = ht : dt.onreadystatechange = function() {
      !dt || dt.readyState !== 4 || dt.status === 0 && !(dt.responseURL && dt.responseURL.indexOf("file:") === 0) || setTimeout(ht);
    }, dt.onabort = function() {
      dt && (pe(new AxiosError("Request aborted", AxiosError.ECONNABORTED, L, dt)), dt = null);
    }, dt.onerror = function() {
      pe(new AxiosError("Network Error", AxiosError.ERR_NETWORK, L, dt)), dt = null;
    }, dt.ontimeout = function() {
      let St = L.timeout ? "timeout of " + L.timeout + "ms exceeded" : "timeout exceeded";
      const ot = L.transitional || transitionalDefaults;
      L.timeoutErrorMessage && (St = L.timeoutErrorMessage), pe(new AxiosError(
        St,
        ot.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        L,
        dt
      )), dt = null;
    }, platform.hasStandardBrowserEnv && (Ie && utils$4.isFunction(Ie) && (Ie = Ie(L)), Ie || Ie !== !1 && isURLSameOrigin(ut))) {
      const lt = L.xsrfHeaderName && L.xsrfCookieName && cookies.read(L.xsrfCookieName);
      lt && ge.set(L.xsrfHeaderName, lt);
    }
    me === void 0 && ge.setContentType(null), "setRequestHeader" in dt && utils$4.forEach(ge.toJSON(), function(St, ot) {
      dt.setRequestHeader(ot, St);
    }), utils$4.isUndefined(L.withCredentials) || (dt.withCredentials = !!L.withCredentials), be && be !== "json" && (dt.responseType = L.responseType), typeof L.onDownloadProgress == "function" && dt.addEventListener("progress", progressEventReducer(L.onDownloadProgress, !0)), typeof L.onUploadProgress == "function" && dt.upload && dt.upload.addEventListener("progress", progressEventReducer(L.onUploadProgress)), (L.cancelToken || L.signal) && (Ae = (lt) => {
      dt && (pe(!lt || lt.type ? new CanceledError(null, L, dt) : lt), dt.abort(), dt = null);
    }, L.cancelToken && L.cancelToken.subscribe(Ae), L.signal && (L.signal.aborted ? Ae() : L.signal.addEventListener("abort", Ae)));
    const it = parseProtocol(ut);
    if (it && platform.protocols.indexOf(it) === -1) {
      pe(new AxiosError("Unsupported protocol " + it + ":", AxiosError.ERR_BAD_REQUEST, L));
      return;
    }
    dt.send(me || null);
  });
}, knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$4.forEach(knownAdapters, (L, ne) => {
  if (L) {
    try {
      Object.defineProperty(L, "name", { value: ne });
    } catch {
    }
    Object.defineProperty(L, "adapterName", { value: ne });
  }
});
const renderReason = (L) => `- ${L}`, isResolvedHandle = (L) => utils$4.isFunction(L) || L === null || L === !1, adapters = {
  getAdapter: (L) => {
    L = utils$4.isArray(L) ? L : [L];
    const { length: ne } = L;
    let oe, pe;
    const me = {};
    for (let ge = 0; ge < ne; ge++) {
      oe = L[ge];
      let be;
      if (pe = oe, !isResolvedHandle(oe) && (pe = knownAdapters[(be = String(oe)).toLowerCase()], pe === void 0))
        throw new AxiosError(`Unknown adapter '${be}'`);
      if (pe)
        break;
      me[be || "#" + ge] = pe;
    }
    if (!pe) {
      const ge = Object.entries(me).map(
        ([Ie, Ae]) => `adapter ${Ie} ` + (Ae === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let be = ne ? ge.length > 1 ? `since :
` + ge.map(renderReason).join(`
`) : " " + renderReason(ge[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + be,
        "ERR_NOT_SUPPORT"
      );
    }
    return pe;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(L) {
  if (L.cancelToken && L.cancelToken.throwIfRequested(), L.signal && L.signal.aborted)
    throw new CanceledError(null, L);
}
function dispatchRequest(L) {
  return throwIfCancellationRequested(L), L.headers = AxiosHeaders$1.from(L.headers), L.data = transformData.call(
    L,
    L.transformRequest
  ), ["post", "put", "patch"].indexOf(L.method) !== -1 && L.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(L.adapter || defaults$3.adapter)(L).then(function(pe) {
    return throwIfCancellationRequested(L), pe.data = transformData.call(
      L,
      L.transformResponse,
      pe
    ), pe.headers = AxiosHeaders$1.from(pe.headers), pe;
  }, function(pe) {
    return isCancel(pe) || (throwIfCancellationRequested(L), pe && pe.response && (pe.response.data = transformData.call(
      L,
      L.transformResponse,
      pe.response
    ), pe.response.headers = AxiosHeaders$1.from(pe.response.headers))), Promise.reject(pe);
  });
}
const headersToObject = (L) => L instanceof AxiosHeaders$1 ? L.toJSON() : L;
function mergeConfig(L, ne) {
  ne = ne || {};
  const oe = {};
  function pe(rt, st, dt) {
    return utils$4.isPlainObject(rt) && utils$4.isPlainObject(st) ? utils$4.merge.call({ caseless: dt }, rt, st) : utils$4.isPlainObject(st) ? utils$4.merge({}, st) : utils$4.isArray(st) ? st.slice() : st;
  }
  function me(rt, st, dt) {
    if (utils$4.isUndefined(st)) {
      if (!utils$4.isUndefined(rt))
        return pe(void 0, rt, dt);
    } else
      return pe(rt, st, dt);
  }
  function ge(rt, st) {
    if (!utils$4.isUndefined(st))
      return pe(void 0, st);
  }
  function be(rt, st) {
    if (utils$4.isUndefined(st)) {
      if (!utils$4.isUndefined(rt))
        return pe(void 0, rt);
    } else
      return pe(void 0, st);
  }
  function Ie(rt, st, dt) {
    if (dt in ne)
      return pe(rt, st);
    if (dt in L)
      return pe(void 0, rt);
  }
  const Ae = {
    url: ge,
    method: ge,
    data: ge,
    baseURL: be,
    transformRequest: be,
    transformResponse: be,
    paramsSerializer: be,
    timeout: be,
    timeoutMessage: be,
    withCredentials: be,
    withXSRFToken: be,
    adapter: be,
    responseType: be,
    xsrfCookieName: be,
    xsrfHeaderName: be,
    onUploadProgress: be,
    onDownloadProgress: be,
    decompress: be,
    maxContentLength: be,
    maxBodyLength: be,
    beforeRedirect: be,
    transport: be,
    httpAgent: be,
    httpsAgent: be,
    cancelToken: be,
    socketPath: be,
    responseEncoding: be,
    validateStatus: Ie,
    headers: (rt, st) => me(headersToObject(rt), headersToObject(st), !0)
  };
  return utils$4.forEach(Object.keys(Object.assign({}, L, ne)), function(st) {
    const dt = Ae[st] || me, ut = dt(L[st], ne[st], st);
    utils$4.isUndefined(ut) && dt !== Ie || (oe[st] = ut);
  }), oe;
}
const VERSION = "1.6.5", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((L, ne) => {
  validators$1[L] = function(pe) {
    return typeof pe === L || "a" + (ne < 1 ? "n " : " ") + L;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function L(ne, oe, pe) {
  function me(ge, be) {
    return "[Axios v" + VERSION + "] Transitional option '" + ge + "'" + be + (pe ? ". " + pe : "");
  }
  return (ge, be, Ie) => {
    if (ne === !1)
      throw new AxiosError(
        me(be, " has been removed" + (oe ? " in " + oe : "")),
        AxiosError.ERR_DEPRECATED
      );
    return oe && !deprecatedWarnings[be] && (deprecatedWarnings[be] = !0, console.warn(
      me(
        be,
        " has been deprecated since v" + oe + " and will be removed in the near future"
      )
    )), ne ? ne(ge, be, Ie) : !0;
  };
};
function assertOptions(L, ne, oe) {
  if (typeof L != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const pe = Object.keys(L);
  let me = pe.length;
  for (; me-- > 0; ) {
    const ge = pe[me], be = ne[ge];
    if (be) {
      const Ie = L[ge], Ae = Ie === void 0 || be(Ie, ge, L);
      if (Ae !== !0)
        throw new AxiosError("option " + ge + " must be " + Ae, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (oe !== !0)
      throw new AxiosError("Unknown option " + ge, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(ne) {
    this.defaults = ne, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(ne, oe) {
    typeof ne == "string" ? (oe = oe || {}, oe.url = ne) : oe = ne || {}, oe = mergeConfig(this.defaults, oe);
    const { transitional: pe, paramsSerializer: me, headers: ge } = oe;
    pe !== void 0 && validator.assertOptions(pe, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), me != null && (utils$4.isFunction(me) ? oe.paramsSerializer = {
      serialize: me
    } : validator.assertOptions(me, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), oe.method = (oe.method || this.defaults.method || "get").toLowerCase();
    let be = ge && utils$4.merge(
      ge.common,
      ge[oe.method]
    );
    ge && utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (it) => {
        delete ge[it];
      }
    ), oe.headers = AxiosHeaders$1.concat(be, ge);
    const Ie = [];
    let Ae = !0;
    this.interceptors.request.forEach(function(lt) {
      typeof lt.runWhen == "function" && lt.runWhen(oe) === !1 || (Ae = Ae && lt.synchronous, Ie.unshift(lt.fulfilled, lt.rejected));
    });
    const rt = [];
    this.interceptors.response.forEach(function(lt) {
      rt.push(lt.fulfilled, lt.rejected);
    });
    let st, dt = 0, ut;
    if (!Ae) {
      const it = [dispatchRequest.bind(this), void 0];
      for (it.unshift.apply(it, Ie), it.push.apply(it, rt), ut = it.length, st = Promise.resolve(oe); dt < ut; )
        st = st.then(it[dt++], it[dt++]);
      return st;
    }
    ut = Ie.length;
    let ht = oe;
    for (dt = 0; dt < ut; ) {
      const it = Ie[dt++], lt = Ie[dt++];
      try {
        ht = it(ht);
      } catch (St) {
        lt.call(this, St);
        break;
      }
    }
    try {
      st = dispatchRequest.call(this, ht);
    } catch (it) {
      return Promise.reject(it);
    }
    for (dt = 0, ut = rt.length; dt < ut; )
      st = st.then(rt[dt++], rt[dt++]);
    return st;
  }
  getUri(ne) {
    ne = mergeConfig(this.defaults, ne);
    const oe = buildFullPath(ne.baseURL, ne.url);
    return buildURL(oe, ne.params, ne.paramsSerializer);
  }
}
utils$4.forEach(["delete", "get", "head", "options"], function L(ne) {
  Axios.prototype[ne] = function(oe, pe) {
    return this.request(mergeConfig(pe || {}, {
      method: ne,
      url: oe,
      data: (pe || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function L(ne) {
  function oe(pe) {
    return function(ge, be, Ie) {
      return this.request(mergeConfig(Ie || {}, {
        method: ne,
        headers: pe ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: ge,
        data: be
      }));
    };
  }
  Axios.prototype[ne] = oe(), Axios.prototype[ne + "Form"] = oe(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(ne) {
    if (typeof ne != "function")
      throw new TypeError("executor must be a function.");
    let oe;
    this.promise = new Promise(function(ge) {
      oe = ge;
    });
    const pe = this;
    this.promise.then((me) => {
      if (!pe._listeners)
        return;
      let ge = pe._listeners.length;
      for (; ge-- > 0; )
        pe._listeners[ge](me);
      pe._listeners = null;
    }), this.promise.then = (me) => {
      let ge;
      const be = new Promise((Ie) => {
        pe.subscribe(Ie), ge = Ie;
      }).then(me);
      return be.cancel = function() {
        pe.unsubscribe(ge);
      }, be;
    }, ne(function(ge, be, Ie) {
      pe.reason || (pe.reason = new CanceledError(ge, be, Ie), oe(pe.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(ne) {
    if (this.reason) {
      ne(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(ne) : this._listeners = [ne];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(ne) {
    if (!this._listeners)
      return;
    const oe = this._listeners.indexOf(ne);
    oe !== -1 && this._listeners.splice(oe, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let ne;
    return {
      token: new CancelToken(function(me) {
        ne = me;
      }),
      cancel: ne
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(L) {
  return function(oe) {
    return L.apply(null, oe);
  };
}
function isAxiosError(L) {
  return utils$4.isObject(L) && L.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([L, ne]) => {
  HttpStatusCode[ne] = L;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(L) {
  const ne = new Axios$1(L), oe = bind$2(Axios$1.prototype.request, ne);
  return utils$4.extend(oe, Axios$1.prototype, ne, { allOwnKeys: !0 }), utils$4.extend(oe, ne, null, { allOwnKeys: !0 }), oe.create = function(me) {
    return createInstance(mergeConfig(L, me));
  }, oe;
}
const axios = createInstance(defaults$3);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function L(ne) {
  return Promise.all(ne);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (L) => formDataToJSON(utils$4.isHTMLForm(L) ? new FormData(L) : L);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var isMergeableObject = function L(ne) {
  return isNonNullObject(ne) && !isSpecial(ne);
};
function isNonNullObject(L) {
  return !!L && typeof L == "object";
}
function isSpecial(L) {
  var ne = Object.prototype.toString.call(L);
  return ne === "[object RegExp]" || ne === "[object Date]" || isReactElement(L);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(L) {
  return L.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(L) {
  return Array.isArray(L) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(L, ne) {
  return ne.clone !== !1 && ne.isMergeableObject(L) ? deepmerge(emptyTarget(L), L, ne) : L;
}
function defaultArrayMerge(L, ne, oe) {
  return L.concat(ne).map(function(pe) {
    return cloneUnlessOtherwiseSpecified(pe, oe);
  });
}
function getMergeFunction(L, ne) {
  if (!ne.customMerge)
    return deepmerge;
  var oe = ne.customMerge(L);
  return typeof oe == "function" ? oe : deepmerge;
}
function getEnumerableOwnPropertySymbols(L) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(L).filter(function(ne) {
    return Object.propertyIsEnumerable.call(L, ne);
  }) : [];
}
function getKeys(L) {
  return Object.keys(L).concat(getEnumerableOwnPropertySymbols(L));
}
function propertyIsOnObject(L, ne) {
  try {
    return ne in L;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(L, ne) {
  return propertyIsOnObject(L, ne) && !(Object.hasOwnProperty.call(L, ne) && Object.propertyIsEnumerable.call(L, ne));
}
function mergeObject(L, ne, oe) {
  var pe = {};
  return oe.isMergeableObject(L) && getKeys(L).forEach(function(me) {
    pe[me] = cloneUnlessOtherwiseSpecified(L[me], oe);
  }), getKeys(ne).forEach(function(me) {
    propertyIsUnsafe(L, me) || (propertyIsOnObject(L, me) && oe.isMergeableObject(ne[me]) ? pe[me] = getMergeFunction(me, oe)(L[me], ne[me], oe) : pe[me] = cloneUnlessOtherwiseSpecified(ne[me], oe));
  }), pe;
}
function deepmerge(L, ne, oe) {
  oe = oe || {}, oe.arrayMerge = oe.arrayMerge || defaultArrayMerge, oe.isMergeableObject = oe.isMergeableObject || isMergeableObject, oe.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var pe = Array.isArray(ne), me = Array.isArray(L), ge = pe === me;
  return ge ? pe ? oe.arrayMerge(L, ne, oe) : mergeObject(L, ne, oe) : cloneUnlessOtherwiseSpecified(ne, oe);
}
deepmerge.all = function L(ne, oe) {
  if (!Array.isArray(ne))
    throw new Error("first argument should be an array");
  return ne.reduce(function(pe, me) {
    return deepmerge(pe, me, oe);
  }, {});
};
var deepmerge_1 = deepmerge, cjs = deepmerge_1;
const te = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
var shams = function L() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var ne = {}, oe = Symbol("test"), pe = Object(oe);
  if (typeof oe == "string" || Object.prototype.toString.call(oe) !== "[object Symbol]" || Object.prototype.toString.call(pe) !== "[object Symbol]")
    return !1;
  var me = 42;
  ne[oe] = me;
  for (oe in ne)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(ne).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(ne).length !== 0)
    return !1;
  var ge = Object.getOwnPropertySymbols(ne);
  if (ge.length !== 1 || ge[0] !== oe || !Object.prototype.propertyIsEnumerable.call(ne, oe))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var be = Object.getOwnPropertyDescriptor(ne, oe);
    if (be.value !== me || be.enumerable !== !0)
      return !1;
  }
  return !0;
}, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams, hasSymbols$1 = function L() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function L() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$1 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function L(ne, oe) {
  for (var pe = [], me = 0; me < ne.length; me += 1)
    pe[me] = ne[me];
  for (var ge = 0; ge < oe.length; ge += 1)
    pe[ge + ne.length] = oe[ge];
  return pe;
}, slicy = function L(ne, oe) {
  for (var pe = [], me = oe || 0, ge = 0; me < ne.length; me += 1, ge += 1)
    pe[ge] = ne[me];
  return pe;
}, joiny = function(L, ne) {
  for (var oe = "", pe = 0; pe < L.length; pe += 1)
    oe += L[pe], pe + 1 < L.length && (oe += ne);
  return oe;
}, implementation$1 = function L(ne) {
  var oe = this;
  if (typeof oe != "function" || toStr$1.apply(oe) !== funcType)
    throw new TypeError(ERROR_MESSAGE + oe);
  for (var pe = slicy(arguments, 1), me, ge = function() {
    if (this instanceof me) {
      var st = oe.apply(
        this,
        concatty(pe, arguments)
      );
      return Object(st) === st ? st : this;
    }
    return oe.apply(
      ne,
      concatty(pe, arguments)
    );
  }, be = max(0, oe.length - pe.length), Ie = [], Ae = 0; Ae < be; Ae++)
    Ie[Ae] = "$" + Ae;
  if (me = Function("binder", "return function (" + joiny(Ie, ",") + "){ return binder.apply(this,arguments); }")(ge), oe.prototype) {
    var rt = function() {
    };
    rt.prototype = oe.prototype, me.prototype = new rt(), rt.prototype = null;
  }
  return me;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call, $hasOwn), undefined$1, $SyntaxError$1 = SyntaxError, $Function = Function, $TypeError$3 = TypeError, getEvalledConstructor = function(L) {
  try {
    return $Function('"use strict"; return (' + L + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto = Object.getPrototypeOf || (hasProto ? function(L) {
  return L.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto ? undefined$1 : getProto(Uint8Array), INTRINSICS = {
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto)
  try {
    null.error;
  } catch (L) {
    var errorProto = getProto(getProto(L));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function L(ne) {
  var oe;
  if (ne === "%AsyncFunction%")
    oe = getEvalledConstructor("async function () {}");
  else if (ne === "%GeneratorFunction%")
    oe = getEvalledConstructor("function* () {}");
  else if (ne === "%AsyncGeneratorFunction%")
    oe = getEvalledConstructor("async function* () {}");
  else if (ne === "%AsyncGenerator%") {
    var pe = L("%AsyncGeneratorFunction%");
    pe && (oe = pe.prototype);
  } else if (ne === "%AsyncIteratorPrototype%") {
    var me = L("%AsyncGenerator%");
    me && getProto && (oe = getProto(me.prototype));
  }
  return INTRINSICS[ne] = oe, oe;
}, LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn$1 = hasown, $concat$1 = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace$1 = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function L(ne) {
  var oe = $strSlice(ne, 0, 1), pe = $strSlice(ne, -1);
  if (oe === "%" && pe !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (pe === "%" && oe !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var me = [];
  return $replace$1(ne, rePropName, function(ge, be, Ie, Ae) {
    me[me.length] = Ie ? $replace$1(Ae, reEscapeChar, "$1") : be || ge;
  }), me;
}, getBaseIntrinsic = function L(ne, oe) {
  var pe = ne, me;
  if (hasOwn$1(LEGACY_ALIASES, pe) && (me = LEGACY_ALIASES[pe], pe = "%" + me[0] + "%"), hasOwn$1(INTRINSICS, pe)) {
    var ge = INTRINSICS[pe];
    if (ge === needsEval && (ge = doEval(pe)), typeof ge > "u" && !oe)
      throw new $TypeError$3("intrinsic " + ne + " exists, but is not available. Please file an issue!");
    return {
      alias: me,
      name: pe,
      value: ge
    };
  }
  throw new $SyntaxError$1("intrinsic " + ne + " does not exist!");
}, getIntrinsic = function L(ne, oe) {
  if (typeof ne != "string" || ne.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof oe != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, ne) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var pe = stringToPath(ne), me = pe.length > 0 ? pe[0] : "", ge = getBaseIntrinsic("%" + me + "%", oe), be = ge.name, Ie = ge.value, Ae = !1, rt = ge.alias;
  rt && (me = rt[0], $spliceApply(pe, $concat$1([0, 1], rt)));
  for (var st = 1, dt = !0; st < pe.length; st += 1) {
    var ut = pe[st], ht = $strSlice(ut, 0, 1), it = $strSlice(ut, -1);
    if ((ht === '"' || ht === "'" || ht === "`" || it === '"' || it === "'" || it === "`") && ht !== it)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((ut === "constructor" || !dt) && (Ae = !0), me += "." + ut, be = "%" + me + "%", hasOwn$1(INTRINSICS, be))
      Ie = INTRINSICS[be];
    else if (Ie != null) {
      if (!(ut in Ie)) {
        if (!oe)
          throw new $TypeError$3("base intrinsic for " + ne + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && st + 1 >= pe.length) {
        var lt = $gOPD$1(Ie, ut);
        dt = !!lt, dt && "get" in lt && !("originalValue" in lt.get) ? Ie = lt.get : Ie = Ie[ut];
      } else
        dt = hasOwn$1(Ie, ut), Ie = Ie[ut];
      dt && !Ae && (INTRINSICS[be] = Ie);
    }
  }
  return Ie;
}, callBind$1 = { exports: {} }, GetIntrinsic$5 = getIntrinsic, $defineProperty$1 = GetIntrinsic$5("%Object.defineProperty%", !0), hasPropertyDescriptors$1 = function L() {
  if ($defineProperty$1)
    try {
      return $defineProperty$1({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function L() {
  if (!hasPropertyDescriptors$1())
    return null;
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1, GetIntrinsic$4 = getIntrinsic, $gOPD = GetIntrinsic$4("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, hasPropertyDescriptors = hasPropertyDescriptors_1(), GetIntrinsic$3 = getIntrinsic, $defineProperty = hasPropertyDescriptors && GetIntrinsic$3("%Object.defineProperty%", !0);
if ($defineProperty)
  try {
    $defineProperty({}, "a", { value: 1 });
  } catch {
    $defineProperty = !1;
  }
var $SyntaxError = GetIntrinsic$3("%SyntaxError%"), $TypeError$2 = GetIntrinsic$3("%TypeError%"), gopd = gopd$1, defineDataProperty = function L(ne, oe, pe) {
  if (!ne || typeof ne != "object" && typeof ne != "function")
    throw new $TypeError$2("`obj` must be an object or a function`");
  if (typeof oe != "string" && typeof oe != "symbol")
    throw new $TypeError$2("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  var me = arguments.length > 3 ? arguments[3] : null, ge = arguments.length > 4 ? arguments[4] : null, be = arguments.length > 5 ? arguments[5] : null, Ie = arguments.length > 6 ? arguments[6] : !1, Ae = !!gopd && gopd(ne, oe);
  if ($defineProperty)
    $defineProperty(ne, oe, {
      configurable: be === null && Ae ? Ae.configurable : !be,
      enumerable: me === null && Ae ? Ae.enumerable : !me,
      value: pe,
      writable: ge === null && Ae ? Ae.writable : !ge
    });
  else if (Ie || !me && !ge && !be)
    ne[oe] = pe;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, GetIntrinsic$2 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD = gopd$1, $TypeError$1 = GetIntrinsic$2("%TypeError%"), $floor$1 = GetIntrinsic$2("%Math.floor%"), setFunctionLength = function L(ne, oe) {
  if (typeof ne != "function")
    throw new $TypeError$1("`fn` is not a function");
  if (typeof oe != "number" || oe < 0 || oe > 4294967295 || $floor$1(oe) !== oe)
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  var pe = arguments.length > 2 && !!arguments[2], me = !0, ge = !0;
  if ("length" in ne && gOPD) {
    var be = gOPD(ne, "length");
    be && !be.configurable && (me = !1), be && !be.writable && (ge = !1);
  }
  return (me || ge || !pe) && (hasDescriptors ? define(ne, "length", oe, !0, !0) : define(ne, "length", oe)), ne;
};
(function(L) {
  var ne = functionBind, oe = getIntrinsic, pe = setFunctionLength, me = oe("%TypeError%"), ge = oe("%Function.prototype.apply%"), be = oe("%Function.prototype.call%"), Ie = oe("%Reflect.apply%", !0) || ne.call(be, ge), Ae = oe("%Object.defineProperty%", !0), rt = oe("%Math.max%");
  if (Ae)
    try {
      Ae({}, "a", { value: 1 });
    } catch {
      Ae = null;
    }
  L.exports = function(ut) {
    if (typeof ut != "function")
      throw new me("a function is required");
    var ht = Ie(ne, be, arguments);
    return pe(
      ht,
      1 + rt(0, ut.length - (arguments.length - 1)),
      !0
    );
  };
  var st = function() {
    return Ie(ne, ge, arguments);
  };
  Ae ? Ae(L.exports, "apply", { value: st }) : L.exports.apply = st;
})(callBind$1);
var callBindExports = callBind$1.exports, GetIntrinsic$1 = getIntrinsic, callBind = callBindExports, $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf")), callBound$1 = function L(ne, oe) {
  var pe = GetIntrinsic$1(ne, !!oe);
  return typeof pe == "function" && $indexOf(ne, ".prototype.") > -1 ? callBind(pe) : pe;
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map == "function" && Map.prototype, mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get == "function" ? mapSizeDescriptor.get : null, mapForEach = hasMap && Map.prototype.forEach, hasSet = typeof Set == "function" && Set.prototype, setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get == "function" ? setSizeDescriptor.get : null, setForEach = hasSet && Set.prototype.forEach, hasWeakMap = typeof WeakMap == "function" && WeakMap.prototype, weakMapHas = hasWeakMap ? WeakMap.prototype.has : null, hasWeakSet = typeof WeakSet == "function" && WeakSet.prototype, weakSetHas = hasWeakSet ? WeakSet.prototype.has : null, hasWeakRef = typeof WeakRef == "function" && WeakRef.prototype, weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null, booleanValueOf = Boolean.prototype.valueOf, objectToString = Object.prototype.toString, functionToString = Function.prototype.toString, $match = String.prototype.match, $slice = String.prototype.slice, $replace = String.prototype.replace, $toUpperCase = String.prototype.toUpperCase, $toLowerCase = String.prototype.toLowerCase, $test = RegExp.prototype.test, $concat = Array.prototype.concat, $join = Array.prototype.join, $arrSlice = Array.prototype.slice, $floor = Math.floor, bigIntValueOf = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, gOPS = Object.getOwnPropertySymbols, symToString = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, hasShammedSymbols = typeof Symbol == "function" && typeof Symbol.iterator == "object", toStringTag = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols || !0) ? Symbol.toStringTag : null, isEnumerable = Object.prototype.propertyIsEnumerable, gPO = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(L) {
  return L.__proto__;
} : null);
function addNumericSeparator(L, ne) {
  if (L === 1 / 0 || L === -1 / 0 || L !== L || L && L > -1e3 && L < 1e3 || $test.call(/e/, ne))
    return ne;
  var oe = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof L == "number") {
    var pe = L < 0 ? -$floor(-L) : $floor(L);
    if (pe !== L) {
      var me = String(pe), ge = $slice.call(ne, me.length + 1);
      return $replace.call(me, oe, "$&_") + "." + $replace.call($replace.call(ge, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(ne, oe, "$&_");
}
var utilInspect = require$$0, inspectCustom = utilInspect.custom, inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null, objectInspect = function L(ne, oe, pe, me) {
  var ge = oe || {};
  if (has$3(ge, "quoteStyle") && ge.quoteStyle !== "single" && ge.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (has$3(ge, "maxStringLength") && (typeof ge.maxStringLength == "number" ? ge.maxStringLength < 0 && ge.maxStringLength !== 1 / 0 : ge.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var be = has$3(ge, "customInspect") ? ge.customInspect : !0;
  if (typeof be != "boolean" && be !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (has$3(ge, "indent") && ge.indent !== null && ge.indent !== "	" && !(parseInt(ge.indent, 10) === ge.indent && ge.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (has$3(ge, "numericSeparator") && typeof ge.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var Ie = ge.numericSeparator;
  if (typeof ne > "u")
    return "undefined";
  if (ne === null)
    return "null";
  if (typeof ne == "boolean")
    return ne ? "true" : "false";
  if (typeof ne == "string")
    return inspectString(ne, ge);
  if (typeof ne == "number") {
    if (ne === 0)
      return 1 / 0 / ne > 0 ? "0" : "-0";
    var Ae = String(ne);
    return Ie ? addNumericSeparator(ne, Ae) : Ae;
  }
  if (typeof ne == "bigint") {
    var rt = String(ne) + "n";
    return Ie ? addNumericSeparator(ne, rt) : rt;
  }
  var st = typeof ge.depth > "u" ? 5 : ge.depth;
  if (typeof pe > "u" && (pe = 0), pe >= st && st > 0 && typeof ne == "object")
    return isArray$3(ne) ? "[Array]" : "[Object]";
  var dt = getIndent(ge, pe);
  if (typeof me > "u")
    me = [];
  else if (indexOf(me, ne) >= 0)
    return "[Circular]";
  function ut(Jt, rr, Qt) {
    if (rr && (me = $arrSlice.call(me), me.push(rr)), Qt) {
      var wt = {
        depth: ge.depth
      };
      return has$3(ge, "quoteStyle") && (wt.quoteStyle = ge.quoteStyle), L(Jt, wt, pe + 1, me);
    }
    return L(Jt, ge, pe + 1, me);
  }
  if (typeof ne == "function" && !isRegExp$1(ne)) {
    var ht = nameOf(ne), it = arrObjKeys(ne, ut);
    return "[Function" + (ht ? ": " + ht : " (anonymous)") + "]" + (it.length > 0 ? " { " + $join.call(it, ", ") + " }" : "");
  }
  if (isSymbol(ne)) {
    var lt = hasShammedSymbols ? $replace.call(String(ne), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(ne);
    return typeof ne == "object" && !hasShammedSymbols ? markBoxed(lt) : lt;
  }
  if (isElement(ne)) {
    for (var St = "<" + $toLowerCase.call(String(ne.nodeName)), ot = ne.attributes || [], pt = 0; pt < ot.length; pt++)
      St += " " + ot[pt].name + "=" + wrapQuotes(quote(ot[pt].value), "double", ge);
    return St += ">", ne.childNodes && ne.childNodes.length && (St += "..."), St += "</" + $toLowerCase.call(String(ne.nodeName)) + ">", St;
  }
  if (isArray$3(ne)) {
    if (ne.length === 0)
      return "[]";
    var ft = arrObjKeys(ne, ut);
    return dt && !singleLineValues(ft) ? "[" + indentedJoin(ft, dt) + "]" : "[ " + $join.call(ft, ", ") + " ]";
  }
  if (isError(ne)) {
    var vt = arrObjKeys(ne, ut);
    return !("cause" in Error.prototype) && "cause" in ne && !isEnumerable.call(ne, "cause") ? "{ [" + String(ne) + "] " + $join.call($concat.call("[cause]: " + ut(ne.cause), vt), ", ") + " }" : vt.length === 0 ? "[" + String(ne) + "]" : "{ [" + String(ne) + "] " + $join.call(vt, ", ") + " }";
  }
  if (typeof ne == "object" && be) {
    if (inspectSymbol && typeof ne[inspectSymbol] == "function" && utilInspect)
      return utilInspect(ne, { depth: st - pe });
    if (be !== "symbol" && typeof ne.inspect == "function")
      return ne.inspect();
  }
  if (isMap(ne)) {
    var xt = [];
    return mapForEach && mapForEach.call(ne, function(Jt, rr) {
      xt.push(ut(rr, ne, !0) + " => " + ut(Jt, ne));
    }), collectionOf("Map", mapSize.call(ne), xt, dt);
  }
  if (isSet(ne)) {
    var Ct = [];
    return setForEach && setForEach.call(ne, function(Jt) {
      Ct.push(ut(Jt, ne));
    }), collectionOf("Set", setSize.call(ne), Ct, dt);
  }
  if (isWeakMap(ne))
    return weakCollectionOf("WeakMap");
  if (isWeakSet(ne))
    return weakCollectionOf("WeakSet");
  if (isWeakRef(ne))
    return weakCollectionOf("WeakRef");
  if (isNumber(ne))
    return markBoxed(ut(Number(ne)));
  if (isBigInt(ne))
    return markBoxed(ut(bigIntValueOf.call(ne)));
  if (isBoolean(ne))
    return markBoxed(booleanValueOf.call(ne));
  if (isString(ne))
    return markBoxed(ut(String(ne)));
  if (typeof window < "u" && ne === window)
    return "{ [object Window] }";
  if (ne === commonjsGlobal)
    return "{ [object globalThis] }";
  if (!isDate(ne) && !isRegExp$1(ne)) {
    var At = arrObjKeys(ne, ut), kt = gPO ? gPO(ne) === Object.prototype : ne instanceof Object || ne.constructor === Object, Vt = ne instanceof Object ? "" : "null prototype", ir = !kt && toStringTag && Object(ne) === ne && toStringTag in ne ? $slice.call(toStr(ne), 8, -1) : Vt ? "Object" : "", er = kt || typeof ne.constructor != "function" ? "" : ne.constructor.name ? ne.constructor.name + " " : "", Yt = er + (ir || Vt ? "[" + $join.call($concat.call([], ir || [], Vt || []), ": ") + "] " : "");
    return At.length === 0 ? Yt + "{}" : dt ? Yt + "{" + indentedJoin(At, dt) + "}" : Yt + "{ " + $join.call(At, ", ") + " }";
  }
  return String(ne);
};
function wrapQuotes(L, ne, oe) {
  var pe = (oe.quoteStyle || ne) === "double" ? '"' : "'";
  return pe + L + pe;
}
function quote(L) {
  return $replace.call(String(L), /"/g, "&quot;");
}
function isArray$3(L) {
  return toStr(L) === "[object Array]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isDate(L) {
  return toStr(L) === "[object Date]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isRegExp$1(L) {
  return toStr(L) === "[object RegExp]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isError(L) {
  return toStr(L) === "[object Error]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isString(L) {
  return toStr(L) === "[object String]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isNumber(L) {
  return toStr(L) === "[object Number]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isBoolean(L) {
  return toStr(L) === "[object Boolean]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isSymbol(L) {
  if (hasShammedSymbols)
    return L && typeof L == "object" && L instanceof Symbol;
  if (typeof L == "symbol")
    return !0;
  if (!L || typeof L != "object" || !symToString)
    return !1;
  try {
    return symToString.call(L), !0;
  } catch {
  }
  return !1;
}
function isBigInt(L) {
  if (!L || typeof L != "object" || !bigIntValueOf)
    return !1;
  try {
    return bigIntValueOf.call(L), !0;
  } catch {
  }
  return !1;
}
var hasOwn = Object.prototype.hasOwnProperty || function(L) {
  return L in this;
};
function has$3(L, ne) {
  return hasOwn.call(L, ne);
}
function toStr(L) {
  return objectToString.call(L);
}
function nameOf(L) {
  if (L.name)
    return L.name;
  var ne = $match.call(functionToString.call(L), /^function\s*([\w$]+)/);
  return ne ? ne[1] : null;
}
function indexOf(L, ne) {
  if (L.indexOf)
    return L.indexOf(ne);
  for (var oe = 0, pe = L.length; oe < pe; oe++)
    if (L[oe] === ne)
      return oe;
  return -1;
}
function isMap(L) {
  if (!mapSize || !L || typeof L != "object")
    return !1;
  try {
    mapSize.call(L);
    try {
      setSize.call(L);
    } catch {
      return !0;
    }
    return L instanceof Map;
  } catch {
  }
  return !1;
}
function isWeakMap(L) {
  if (!weakMapHas || !L || typeof L != "object")
    return !1;
  try {
    weakMapHas.call(L, weakMapHas);
    try {
      weakSetHas.call(L, weakSetHas);
    } catch {
      return !0;
    }
    return L instanceof WeakMap;
  } catch {
  }
  return !1;
}
function isWeakRef(L) {
  if (!weakRefDeref || !L || typeof L != "object")
    return !1;
  try {
    return weakRefDeref.call(L), !0;
  } catch {
  }
  return !1;
}
function isSet(L) {
  if (!setSize || !L || typeof L != "object")
    return !1;
  try {
    setSize.call(L);
    try {
      mapSize.call(L);
    } catch {
      return !0;
    }
    return L instanceof Set;
  } catch {
  }
  return !1;
}
function isWeakSet(L) {
  if (!weakSetHas || !L || typeof L != "object")
    return !1;
  try {
    weakSetHas.call(L, weakSetHas);
    try {
      weakMapHas.call(L, weakMapHas);
    } catch {
      return !0;
    }
    return L instanceof WeakSet;
  } catch {
  }
  return !1;
}
function isElement(L) {
  return !L || typeof L != "object" ? !1 : typeof HTMLElement < "u" && L instanceof HTMLElement ? !0 : typeof L.nodeName == "string" && typeof L.getAttribute == "function";
}
function inspectString(L, ne) {
  if (L.length > ne.maxStringLength) {
    var oe = L.length - ne.maxStringLength, pe = "... " + oe + " more character" + (oe > 1 ? "s" : "");
    return inspectString($slice.call(L, 0, ne.maxStringLength), ne) + pe;
  }
  var me = $replace.call($replace.call(L, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(me, "single", ne);
}
function lowbyte(L) {
  var ne = L.charCodeAt(0), oe = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[ne];
  return oe ? "\\" + oe : "\\x" + (ne < 16 ? "0" : "") + $toUpperCase.call(ne.toString(16));
}
function markBoxed(L) {
  return "Object(" + L + ")";
}
function weakCollectionOf(L) {
  return L + " { ? }";
}
function collectionOf(L, ne, oe, pe) {
  var me = pe ? indentedJoin(oe, pe) : $join.call(oe, ", ");
  return L + " (" + ne + ") {" + me + "}";
}
function singleLineValues(L) {
  for (var ne = 0; ne < L.length; ne++)
    if (indexOf(L[ne], `
`) >= 0)
      return !1;
  return !0;
}
function getIndent(L, ne) {
  var oe;
  if (L.indent === "	")
    oe = "	";
  else if (typeof L.indent == "number" && L.indent > 0)
    oe = $join.call(Array(L.indent + 1), " ");
  else
    return null;
  return {
    base: oe,
    prev: $join.call(Array(ne + 1), oe)
  };
}
function indentedJoin(L, ne) {
  if (L.length === 0)
    return "";
  var oe = `
` + ne.prev + ne.base;
  return oe + $join.call(L, "," + oe) + `
` + ne.prev;
}
function arrObjKeys(L, ne) {
  var oe = isArray$3(L), pe = [];
  if (oe) {
    pe.length = L.length;
    for (var me = 0; me < L.length; me++)
      pe[me] = has$3(L, me) ? ne(L[me], L) : "";
  }
  var ge = typeof gOPS == "function" ? gOPS(L) : [], be;
  if (hasShammedSymbols) {
    be = {};
    for (var Ie = 0; Ie < ge.length; Ie++)
      be["$" + ge[Ie]] = ge[Ie];
  }
  for (var Ae in L)
    has$3(L, Ae) && (oe && String(Number(Ae)) === Ae && Ae < L.length || hasShammedSymbols && be["$" + Ae] instanceof Symbol || ($test.call(/[^\w$]/, Ae) ? pe.push(ne(Ae, L) + ": " + ne(L[Ae], L)) : pe.push(Ae + ": " + ne(L[Ae], L))));
  if (typeof gOPS == "function")
    for (var rt = 0; rt < ge.length; rt++)
      isEnumerable.call(L, ge[rt]) && pe.push("[" + ne(ge[rt]) + "]: " + ne(L[ge[rt]], L));
  return pe;
}
var GetIntrinsic = getIntrinsic, callBound = callBound$1, inspect = objectInspect, $TypeError = GetIntrinsic("%TypeError%"), $WeakMap = GetIntrinsic("%WeakMap%", !0), $Map = GetIntrinsic("%Map%", !0), $weakMapGet = callBound("WeakMap.prototype.get", !0), $weakMapSet = callBound("WeakMap.prototype.set", !0), $weakMapHas = callBound("WeakMap.prototype.has", !0), $mapGet = callBound("Map.prototype.get", !0), $mapSet = callBound("Map.prototype.set", !0), $mapHas = callBound("Map.prototype.has", !0), listGetNode = function(L, ne) {
  for (var oe = L, pe; (pe = oe.next) !== null; oe = pe)
    if (pe.key === ne)
      return oe.next = pe.next, pe.next = L.next, L.next = pe, pe;
}, listGet = function(L, ne) {
  var oe = listGetNode(L, ne);
  return oe && oe.value;
}, listSet = function(L, ne, oe) {
  var pe = listGetNode(L, ne);
  pe ? pe.value = oe : L.next = {
    // eslint-disable-line no-param-reassign
    key: ne,
    next: L.next,
    value: oe
  };
}, listHas = function(L, ne) {
  return !!listGetNode(L, ne);
}, sideChannel = function L() {
  var ne, oe, pe, me = {
    assert: function(ge) {
      if (!me.has(ge))
        throw new $TypeError("Side channel does not contain " + inspect(ge));
    },
    get: function(ge) {
      if ($WeakMap && ge && (typeof ge == "object" || typeof ge == "function")) {
        if (ne)
          return $weakMapGet(ne, ge);
      } else if ($Map) {
        if (oe)
          return $mapGet(oe, ge);
      } else if (pe)
        return listGet(pe, ge);
    },
    has: function(ge) {
      if ($WeakMap && ge && (typeof ge == "object" || typeof ge == "function")) {
        if (ne)
          return $weakMapHas(ne, ge);
      } else if ($Map) {
        if (oe)
          return $mapHas(oe, ge);
      } else if (pe)
        return listHas(pe, ge);
      return !1;
    },
    set: function(ge, be) {
      $WeakMap && ge && (typeof ge == "object" || typeof ge == "function") ? (ne || (ne = new $WeakMap()), $weakMapSet(ne, ge, be)) : $Map ? (oe || (oe = new $Map()), $mapSet(oe, ge, be)) : (pe || (pe = { key: {}, next: null }), listSet(pe, ge, be));
    }
  };
  return me;
}, replace = String.prototype.replace, percentTwenties = /%20/g, Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, formats$3 = {
  default: Format.RFC3986,
  formatters: {
    RFC1738: function(L) {
      return replace.call(L, percentTwenties, "+");
    },
    RFC3986: function(L) {
      return String(L);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
}, formats$2 = formats$3, has$2 = Object.prototype.hasOwnProperty, isArray$2 = Array.isArray, hexTable = function() {
  for (var L = [], ne = 0; ne < 256; ++ne)
    L.push("%" + ((ne < 16 ? "0" : "") + ne.toString(16)).toUpperCase());
  return L;
}(), compactQueue = function L(ne) {
  for (; ne.length > 1; ) {
    var oe = ne.pop(), pe = oe.obj[oe.prop];
    if (isArray$2(pe)) {
      for (var me = [], ge = 0; ge < pe.length; ++ge)
        typeof pe[ge] < "u" && me.push(pe[ge]);
      oe.obj[oe.prop] = me;
    }
  }
}, arrayToObject = function L(ne, oe) {
  for (var pe = oe && oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, me = 0; me < ne.length; ++me)
    typeof ne[me] < "u" && (pe[me] = ne[me]);
  return pe;
}, merge = function L(ne, oe, pe) {
  if (!oe)
    return ne;
  if (typeof oe != "object") {
    if (isArray$2(ne))
      ne.push(oe);
    else if (ne && typeof ne == "object")
      (pe && (pe.plainObjects || pe.allowPrototypes) || !has$2.call(Object.prototype, oe)) && (ne[oe] = !0);
    else
      return [ne, oe];
    return ne;
  }
  if (!ne || typeof ne != "object")
    return [ne].concat(oe);
  var me = ne;
  return isArray$2(ne) && !isArray$2(oe) && (me = arrayToObject(ne, pe)), isArray$2(ne) && isArray$2(oe) ? (oe.forEach(function(ge, be) {
    if (has$2.call(ne, be)) {
      var Ie = ne[be];
      Ie && typeof Ie == "object" && ge && typeof ge == "object" ? ne[be] = L(Ie, ge, pe) : ne.push(ge);
    } else
      ne[be] = ge;
  }), ne) : Object.keys(oe).reduce(function(ge, be) {
    var Ie = oe[be];
    return has$2.call(ge, be) ? ge[be] = L(ge[be], Ie, pe) : ge[be] = Ie, ge;
  }, me);
}, assign = function L(ne, oe) {
  return Object.keys(oe).reduce(function(pe, me) {
    return pe[me] = oe[me], pe;
  }, ne);
}, decode = function(L, ne, oe) {
  var pe = L.replace(/\+/g, " ");
  if (oe === "iso-8859-1")
    return pe.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(pe);
  } catch {
    return pe;
  }
}, encode = function L(ne, oe, pe, me, ge) {
  if (ne.length === 0)
    return ne;
  var be = ne;
  if (typeof ne == "symbol" ? be = Symbol.prototype.toString.call(ne) : typeof ne != "string" && (be = String(ne)), pe === "iso-8859-1")
    return escape(be).replace(/%u[0-9a-f]{4}/gi, function(st) {
      return "%26%23" + parseInt(st.slice(2), 16) + "%3B";
    });
  for (var Ie = "", Ae = 0; Ae < be.length; ++Ae) {
    var rt = be.charCodeAt(Ae);
    if (rt === 45 || rt === 46 || rt === 95 || rt === 126 || rt >= 48 && rt <= 57 || rt >= 65 && rt <= 90 || rt >= 97 && rt <= 122 || ge === formats$2.RFC1738 && (rt === 40 || rt === 41)) {
      Ie += be.charAt(Ae);
      continue;
    }
    if (rt < 128) {
      Ie = Ie + hexTable[rt];
      continue;
    }
    if (rt < 2048) {
      Ie = Ie + (hexTable[192 | rt >> 6] + hexTable[128 | rt & 63]);
      continue;
    }
    if (rt < 55296 || rt >= 57344) {
      Ie = Ie + (hexTable[224 | rt >> 12] + hexTable[128 | rt >> 6 & 63] + hexTable[128 | rt & 63]);
      continue;
    }
    Ae += 1, rt = 65536 + ((rt & 1023) << 10 | be.charCodeAt(Ae) & 1023), Ie += hexTable[240 | rt >> 18] + hexTable[128 | rt >> 12 & 63] + hexTable[128 | rt >> 6 & 63] + hexTable[128 | rt & 63];
  }
  return Ie;
}, compact = function L(ne) {
  for (var oe = [{ obj: { o: ne }, prop: "o" }], pe = [], me = 0; me < oe.length; ++me)
    for (var ge = oe[me], be = ge.obj[ge.prop], Ie = Object.keys(be), Ae = 0; Ae < Ie.length; ++Ae) {
      var rt = Ie[Ae], st = be[rt];
      typeof st == "object" && st !== null && pe.indexOf(st) === -1 && (oe.push({ obj: be, prop: rt }), pe.push(st));
    }
  return compactQueue(oe), ne;
}, isRegExp = function L(ne) {
  return Object.prototype.toString.call(ne) === "[object RegExp]";
}, isBuffer = function L(ne) {
  return !ne || typeof ne != "object" ? !1 : !!(ne.constructor && ne.constructor.isBuffer && ne.constructor.isBuffer(ne));
}, combine = function L(ne, oe) {
  return [].concat(ne, oe);
}, maybeMap = function L(ne, oe) {
  if (isArray$2(ne)) {
    for (var pe = [], me = 0; me < ne.length; me += 1)
      pe.push(oe(ne[me]));
    return pe;
  }
  return oe(ne);
}, utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
}, getSideChannel = sideChannel, utils$1 = utils$2, formats$1 = formats$3, has$1 = Object.prototype.hasOwnProperty, arrayPrefixGenerators = {
  brackets: function L(ne) {
    return ne + "[]";
  },
  comma: "comma",
  indices: function L(ne, oe) {
    return ne + "[" + oe + "]";
  },
  repeat: function L(ne) {
    return ne;
  }
}, isArray$1 = Array.isArray, push = Array.prototype.push, pushToArray = function(L, ne) {
  push.apply(L, isArray$1(ne) ? ne : [ne]);
}, toISO = Date.prototype.toISOString, defaultFormat = formats$1.default, defaults$1 = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: utils$1.encode,
  encodeValuesOnly: !1,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: !1,
  serializeDate: function L(ne) {
    return toISO.call(ne);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, isNonNullishPrimitive = function L(ne) {
  return typeof ne == "string" || typeof ne == "number" || typeof ne == "boolean" || typeof ne == "symbol" || typeof ne == "bigint";
}, sentinel = {}, stringify$1 = function L(ne, oe, pe, me, ge, be, Ie, Ae, rt, st, dt, ut, ht, it, lt, St) {
  for (var ot = ne, pt = St, ft = 0, vt = !1; (pt = pt.get(sentinel)) !== void 0 && !vt; ) {
    var xt = pt.get(ne);
    if (ft += 1, typeof xt < "u") {
      if (xt === ft)
        throw new RangeError("Cyclic object value");
      vt = !0;
    }
    typeof pt.get(sentinel) > "u" && (ft = 0);
  }
  if (typeof Ae == "function" ? ot = Ae(oe, ot) : ot instanceof Date ? ot = dt(ot) : pe === "comma" && isArray$1(ot) && (ot = utils$1.maybeMap(ot, function(wt) {
    return wt instanceof Date ? dt(wt) : wt;
  })), ot === null) {
    if (ge)
      return Ie && !it ? Ie(oe, defaults$1.encoder, lt, "key", ut) : oe;
    ot = "";
  }
  if (isNonNullishPrimitive(ot) || utils$1.isBuffer(ot)) {
    if (Ie) {
      var Ct = it ? oe : Ie(oe, defaults$1.encoder, lt, "key", ut);
      return [ht(Ct) + "=" + ht(Ie(ot, defaults$1.encoder, lt, "value", ut))];
    }
    return [ht(oe) + "=" + ht(String(ot))];
  }
  var At = [];
  if (typeof ot > "u")
    return At;
  var kt;
  if (pe === "comma" && isArray$1(ot))
    it && Ie && (ot = utils$1.maybeMap(ot, Ie)), kt = [{ value: ot.length > 0 ? ot.join(",") || null : void 0 }];
  else if (isArray$1(Ae))
    kt = Ae;
  else {
    var Vt = Object.keys(ot);
    kt = rt ? Vt.sort(rt) : Vt;
  }
  for (var ir = me && isArray$1(ot) && ot.length === 1 ? oe + "[]" : oe, er = 0; er < kt.length; ++er) {
    var Yt = kt[er], Jt = typeof Yt == "object" && typeof Yt.value < "u" ? Yt.value : ot[Yt];
    if (!(be && Jt === null)) {
      var rr = isArray$1(ot) ? typeof pe == "function" ? pe(ir, Yt) : ir : ir + (st ? "." + Yt : "[" + Yt + "]");
      St.set(ne, ft);
      var Qt = getSideChannel();
      Qt.set(sentinel, St), pushToArray(At, L(
        Jt,
        rr,
        pe,
        me,
        ge,
        be,
        pe === "comma" && it && isArray$1(ot) ? null : Ie,
        Ae,
        rt,
        st,
        dt,
        ut,
        ht,
        it,
        lt,
        Qt
      ));
    }
  }
  return At;
}, normalizeStringifyOptions = function L(ne) {
  if (!ne)
    return defaults$1;
  if (ne.encoder !== null && typeof ne.encoder < "u" && typeof ne.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var oe = ne.charset || defaults$1.charset;
  if (typeof ne.charset < "u" && ne.charset !== "utf-8" && ne.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var pe = formats$1.default;
  if (typeof ne.format < "u") {
    if (!has$1.call(formats$1.formatters, ne.format))
      throw new TypeError("Unknown format option provided.");
    pe = ne.format;
  }
  var me = formats$1.formatters[pe], ge = defaults$1.filter;
  return (typeof ne.filter == "function" || isArray$1(ne.filter)) && (ge = ne.filter), {
    addQueryPrefix: typeof ne.addQueryPrefix == "boolean" ? ne.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof ne.allowDots > "u" ? defaults$1.allowDots : !!ne.allowDots,
    charset: oe,
    charsetSentinel: typeof ne.charsetSentinel == "boolean" ? ne.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof ne.delimiter > "u" ? defaults$1.delimiter : ne.delimiter,
    encode: typeof ne.encode == "boolean" ? ne.encode : defaults$1.encode,
    encoder: typeof ne.encoder == "function" ? ne.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof ne.encodeValuesOnly == "boolean" ? ne.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: ge,
    format: pe,
    formatter: me,
    serializeDate: typeof ne.serializeDate == "function" ? ne.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof ne.skipNulls == "boolean" ? ne.skipNulls : defaults$1.skipNulls,
    sort: typeof ne.sort == "function" ? ne.sort : null,
    strictNullHandling: typeof ne.strictNullHandling == "boolean" ? ne.strictNullHandling : defaults$1.strictNullHandling
  };
}, stringify_1 = function(L, ne) {
  var oe = L, pe = normalizeStringifyOptions(ne), me, ge;
  typeof pe.filter == "function" ? (ge = pe.filter, oe = ge("", oe)) : isArray$1(pe.filter) && (ge = pe.filter, me = ge);
  var be = [];
  if (typeof oe != "object" || oe === null)
    return "";
  var Ie;
  ne && ne.arrayFormat in arrayPrefixGenerators ? Ie = ne.arrayFormat : ne && "indices" in ne ? Ie = ne.indices ? "indices" : "repeat" : Ie = "indices";
  var Ae = arrayPrefixGenerators[Ie];
  if (ne && "commaRoundTrip" in ne && typeof ne.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var rt = Ae === "comma" && ne && ne.commaRoundTrip;
  me || (me = Object.keys(oe)), pe.sort && me.sort(pe.sort);
  for (var st = getSideChannel(), dt = 0; dt < me.length; ++dt) {
    var ut = me[dt];
    pe.skipNulls && oe[ut] === null || pushToArray(be, stringify$1(
      oe[ut],
      ut,
      Ae,
      rt,
      pe.strictNullHandling,
      pe.skipNulls,
      pe.encode ? pe.encoder : null,
      pe.filter,
      pe.sort,
      pe.allowDots,
      pe.serializeDate,
      pe.format,
      pe.formatter,
      pe.encodeValuesOnly,
      pe.charset,
      st
    ));
  }
  var ht = be.join(pe.delimiter), it = pe.addQueryPrefix === !0 ? "?" : "";
  return pe.charsetSentinel && (pe.charset === "iso-8859-1" ? it += "utf8=%26%2310003%3B&" : it += "utf8=%E2%9C%93&"), ht.length > 0 ? it + ht : "";
}, utils = utils$2, has = Object.prototype.hasOwnProperty, isArray = Array.isArray, defaults = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, interpretNumericEntities = function(L) {
  return L.replace(/&#(\d+);/g, function(ne, oe) {
    return String.fromCharCode(parseInt(oe, 10));
  });
}, parseArrayValue = function(L, ne) {
  return L && typeof L == "string" && ne.comma && L.indexOf(",") > -1 ? L.split(",") : L;
}, isoSentinel = "utf8=%26%2310003%3B", charsetSentinel = "utf8=%E2%9C%93", parseValues = function L(ne, oe) {
  var pe = { __proto__: null }, me = oe.ignoreQueryPrefix ? ne.replace(/^\?/, "") : ne, ge = oe.parameterLimit === 1 / 0 ? void 0 : oe.parameterLimit, be = me.split(oe.delimiter, ge), Ie = -1, Ae, rt = oe.charset;
  if (oe.charsetSentinel)
    for (Ae = 0; Ae < be.length; ++Ae)
      be[Ae].indexOf("utf8=") === 0 && (be[Ae] === charsetSentinel ? rt = "utf-8" : be[Ae] === isoSentinel && (rt = "iso-8859-1"), Ie = Ae, Ae = be.length);
  for (Ae = 0; Ae < be.length; ++Ae)
    if (Ae !== Ie) {
      var st = be[Ae], dt = st.indexOf("]="), ut = dt === -1 ? st.indexOf("=") : dt + 1, ht, it;
      ut === -1 ? (ht = oe.decoder(st, defaults.decoder, rt, "key"), it = oe.strictNullHandling ? null : "") : (ht = oe.decoder(st.slice(0, ut), defaults.decoder, rt, "key"), it = utils.maybeMap(
        parseArrayValue(st.slice(ut + 1), oe),
        function(lt) {
          return oe.decoder(lt, defaults.decoder, rt, "value");
        }
      )), it && oe.interpretNumericEntities && rt === "iso-8859-1" && (it = interpretNumericEntities(it)), st.indexOf("[]=") > -1 && (it = isArray(it) ? [it] : it), has.call(pe, ht) ? pe[ht] = utils.combine(pe[ht], it) : pe[ht] = it;
    }
  return pe;
}, parseObject = function(L, ne, oe, pe) {
  for (var me = pe ? ne : parseArrayValue(ne, oe), ge = L.length - 1; ge >= 0; --ge) {
    var be, Ie = L[ge];
    if (Ie === "[]" && oe.parseArrays)
      be = [].concat(me);
    else {
      be = oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var Ae = Ie.charAt(0) === "[" && Ie.charAt(Ie.length - 1) === "]" ? Ie.slice(1, -1) : Ie, rt = parseInt(Ae, 10);
      !oe.parseArrays && Ae === "" ? be = { 0: me } : !isNaN(rt) && Ie !== Ae && String(rt) === Ae && rt >= 0 && oe.parseArrays && rt <= oe.arrayLimit ? (be = [], be[rt] = me) : Ae !== "__proto__" && (be[Ae] = me);
    }
    me = be;
  }
  return me;
}, parseKeys = function L(ne, oe, pe, me) {
  if (ne) {
    var ge = pe.allowDots ? ne.replace(/\.([^.[]+)/g, "[$1]") : ne, be = /(\[[^[\]]*])/, Ie = /(\[[^[\]]*])/g, Ae = pe.depth > 0 && be.exec(ge), rt = Ae ? ge.slice(0, Ae.index) : ge, st = [];
    if (rt) {
      if (!pe.plainObjects && has.call(Object.prototype, rt) && !pe.allowPrototypes)
        return;
      st.push(rt);
    }
    for (var dt = 0; pe.depth > 0 && (Ae = Ie.exec(ge)) !== null && dt < pe.depth; ) {
      if (dt += 1, !pe.plainObjects && has.call(Object.prototype, Ae[1].slice(1, -1)) && !pe.allowPrototypes)
        return;
      st.push(Ae[1]);
    }
    return Ae && st.push("[" + ge.slice(Ae.index) + "]"), parseObject(st, oe, pe, me);
  }
}, normalizeParseOptions = function L(ne) {
  if (!ne)
    return defaults;
  if (ne.decoder !== null && ne.decoder !== void 0 && typeof ne.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof ne.charset < "u" && ne.charset !== "utf-8" && ne.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var oe = typeof ne.charset > "u" ? defaults.charset : ne.charset;
  return {
    allowDots: typeof ne.allowDots > "u" ? defaults.allowDots : !!ne.allowDots,
    allowPrototypes: typeof ne.allowPrototypes == "boolean" ? ne.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof ne.allowSparse == "boolean" ? ne.allowSparse : defaults.allowSparse,
    arrayLimit: typeof ne.arrayLimit == "number" ? ne.arrayLimit : defaults.arrayLimit,
    charset: oe,
    charsetSentinel: typeof ne.charsetSentinel == "boolean" ? ne.charsetSentinel : defaults.charsetSentinel,
    comma: typeof ne.comma == "boolean" ? ne.comma : defaults.comma,
    decoder: typeof ne.decoder == "function" ? ne.decoder : defaults.decoder,
    delimiter: typeof ne.delimiter == "string" || utils.isRegExp(ne.delimiter) ? ne.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof ne.depth == "number" || ne.depth === !1 ? +ne.depth : defaults.depth,
    ignoreQueryPrefix: ne.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof ne.interpretNumericEntities == "boolean" ? ne.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof ne.parameterLimit == "number" ? ne.parameterLimit : defaults.parameterLimit,
    parseArrays: ne.parseArrays !== !1,
    plainObjects: typeof ne.plainObjects == "boolean" ? ne.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof ne.strictNullHandling == "boolean" ? ne.strictNullHandling : defaults.strictNullHandling
  };
}, parse$1 = function(L, ne) {
  var oe = normalizeParseOptions(ne);
  if (L === "" || L === null || typeof L > "u")
    return oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var pe = typeof L == "string" ? parseValues(L, oe) : L, me = oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, ge = Object.keys(pe), be = 0; be < ge.length; ++be) {
    var Ie = ge[be], Ae = parseKeys(Ie, pe[Ie], oe, typeof L == "string");
    me = utils.merge(me, Ae, oe);
  }
  return oe.allowSparse === !0 ? me : utils.compact(me);
}, stringify = stringify_1, parse = parse$1, formats = formats$3, lib = {
  formats,
  parse,
  stringify
}, nprogress = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(L, ne) {
  (function(oe, pe) {
    L.exports = pe();
  })(commonjsGlobal, function() {
    var oe = {};
    oe.version = "0.2.0";
    var pe = oe.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: !0,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: !0,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    oe.configure = function(it) {
      var lt, St;
      for (lt in it)
        St = it[lt], St !== void 0 && it.hasOwnProperty(lt) && (pe[lt] = St);
      return this;
    }, oe.status = null, oe.set = function(it) {
      var lt = oe.isStarted();
      it = me(it, pe.minimum, 1), oe.status = it === 1 ? null : it;
      var St = oe.render(!lt), ot = St.querySelector(pe.barSelector), pt = pe.speed, ft = pe.easing;
      return St.offsetWidth, Ie(function(vt) {
        pe.positionUsing === "" && (pe.positionUsing = oe.getPositioningCSS()), Ae(ot, be(it, pt, ft)), it === 1 ? (Ae(St, {
          transition: "none",
          opacity: 1
        }), St.offsetWidth, setTimeout(function() {
          Ae(St, {
            transition: "all " + pt + "ms linear",
            opacity: 0
          }), setTimeout(function() {
            oe.remove(), vt();
          }, pt);
        }, pt)) : setTimeout(vt, pt);
      }), this;
    }, oe.isStarted = function() {
      return typeof oe.status == "number";
    }, oe.start = function() {
      oe.status || oe.set(0);
      var it = function() {
        setTimeout(function() {
          oe.status && (oe.trickle(), it());
        }, pe.trickleSpeed);
      };
      return pe.trickle && it(), this;
    }, oe.done = function(it) {
      return !it && !oe.status ? this : oe.inc(0.3 + 0.5 * Math.random()).set(1);
    }, oe.inc = function(it) {
      var lt = oe.status;
      return lt ? (typeof it != "number" && (it = (1 - lt) * me(Math.random() * lt, 0.1, 0.95)), lt = me(lt + it, 0, 0.994), oe.set(lt)) : oe.start();
    }, oe.trickle = function() {
      return oe.inc(Math.random() * pe.trickleRate);
    }, function() {
      var it = 0, lt = 0;
      oe.promise = function(St) {
        return !St || St.state() === "resolved" ? this : (lt === 0 && oe.start(), it++, lt++, St.always(function() {
          lt--, lt === 0 ? (it = 0, oe.done()) : oe.set((it - lt) / it);
        }), this);
      };
    }(), oe.render = function(it) {
      if (oe.isRendered())
        return document.getElementById("nprogress");
      st(document.documentElement, "nprogress-busy");
      var lt = document.createElement("div");
      lt.id = "nprogress", lt.innerHTML = pe.template;
      var St = lt.querySelector(pe.barSelector), ot = it ? "-100" : ge(oe.status || 0), pt = document.querySelector(pe.parent), ft;
      return Ae(St, {
        transition: "all 0 linear",
        transform: "translate3d(" + ot + "%,0,0)"
      }), pe.showSpinner || (ft = lt.querySelector(pe.spinnerSelector), ft && ht(ft)), pt != document.body && st(pt, "nprogress-custom-parent"), pt.appendChild(lt), lt;
    }, oe.remove = function() {
      dt(document.documentElement, "nprogress-busy"), dt(document.querySelector(pe.parent), "nprogress-custom-parent");
      var it = document.getElementById("nprogress");
      it && ht(it);
    }, oe.isRendered = function() {
      return !!document.getElementById("nprogress");
    }, oe.getPositioningCSS = function() {
      var it = document.body.style, lt = "WebkitTransform" in it ? "Webkit" : "MozTransform" in it ? "Moz" : "msTransform" in it ? "ms" : "OTransform" in it ? "O" : "";
      return lt + "Perspective" in it ? "translate3d" : lt + "Transform" in it ? "translate" : "margin";
    };
    function me(it, lt, St) {
      return it < lt ? lt : it > St ? St : it;
    }
    function ge(it) {
      return (-1 + it) * 100;
    }
    function be(it, lt, St) {
      var ot;
      return pe.positionUsing === "translate3d" ? ot = { transform: "translate3d(" + ge(it) + "%,0,0)" } : pe.positionUsing === "translate" ? ot = { transform: "translate(" + ge(it) + "%,0)" } : ot = { "margin-left": ge(it) + "%" }, ot.transition = "all " + lt + "ms " + St, ot;
    }
    var Ie = /* @__PURE__ */ function() {
      var it = [];
      function lt() {
        var St = it.shift();
        St && St(lt);
      }
      return function(St) {
        it.push(St), it.length == 1 && lt();
      };
    }(), Ae = /* @__PURE__ */ function() {
      var it = ["Webkit", "O", "Moz", "ms"], lt = {};
      function St(vt) {
        return vt.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(xt, Ct) {
          return Ct.toUpperCase();
        });
      }
      function ot(vt) {
        var xt = document.body.style;
        if (vt in xt)
          return vt;
        for (var Ct = it.length, At = vt.charAt(0).toUpperCase() + vt.slice(1), kt; Ct--; )
          if (kt = it[Ct] + At, kt in xt)
            return kt;
        return vt;
      }
      function pt(vt) {
        return vt = St(vt), lt[vt] || (lt[vt] = ot(vt));
      }
      function ft(vt, xt, Ct) {
        xt = pt(xt), vt.style[xt] = Ct;
      }
      return function(vt, xt) {
        var Ct = arguments, At, kt;
        if (Ct.length == 2)
          for (At in xt)
            kt = xt[At], kt !== void 0 && xt.hasOwnProperty(At) && ft(vt, At, kt);
        else
          ft(vt, Ct[1], Ct[2]);
      };
    }();
    function rt(it, lt) {
      var St = typeof it == "string" ? it : ut(it);
      return St.indexOf(" " + lt + " ") >= 0;
    }
    function st(it, lt) {
      var St = ut(it), ot = St + lt;
      rt(St, lt) || (it.className = ot.substring(1));
    }
    function dt(it, lt) {
      var St = ut(it), ot;
      rt(it, lt) && (ot = St.replace(" " + lt + " ", " "), it.className = ot.substring(1, ot.length - 1));
    }
    function ut(it) {
      return (" " + (it.className || "") + " ").replace(/\s+/gi, " ");
    }
    function ht(it) {
      it && it.parentNode && it.parentNode.removeChild(it);
    }
    return oe;
  });
})(nprogress);
function R(L, ne) {
  let oe;
  return function(...pe) {
    clearTimeout(oe), oe = setTimeout(() => L.apply(this, pe), ne);
  };
}
function f(L, ne) {
  return document.dispatchEvent(new CustomEvent(`inertia:${L}`, ne));
}
var M = (L) => f("before", { cancelable: !0, detail: { visit: L } }), j = (L) => f("error", { detail: { errors: L } }), H = (L) => f("exception", { cancelable: !0, detail: { exception: L } }), N$1 = (L) => f("finish", { detail: { visit: L } }), $ = (L) => f("invalid", { cancelable: !0, detail: { response: L } }), S = (L) => f("navigate", { detail: { page: L } }), q = (L) => f("progress", { detail: { progress: L } }), W = (L) => f("start", { detail: { visit: L } }), K = (L) => f("success", { detail: { page: L } });
function I(L) {
  return L instanceof File || L instanceof Blob || L instanceof FileList && L.length > 0 || L instanceof FormData && Array.from(L.values()).some((ne) => I(ne)) || typeof L == "object" && L !== null && Object.values(L).some((ne) => I(ne));
}
function A(L, ne = new FormData(), oe = null) {
  L = L || {};
  for (let pe in L)
    Object.prototype.hasOwnProperty.call(L, pe) && J(ne, X(oe, pe), L[pe]);
  return ne;
}
function X(L, ne) {
  return L ? L + "[" + ne + "]" : ne;
}
function J(L, ne, oe) {
  if (Array.isArray(oe))
    return Array.from(oe.keys()).forEach((pe) => J(L, X(ne, pe.toString()), oe[pe]));
  if (oe instanceof Date)
    return L.append(ne, oe.toISOString());
  if (oe instanceof File)
    return L.append(ne, oe, oe.name);
  if (oe instanceof Blob)
    return L.append(ne, oe);
  if (typeof oe == "boolean")
    return L.append(ne, oe ? "1" : "0");
  if (typeof oe == "string")
    return L.append(ne, oe);
  if (typeof oe == "number")
    return L.append(ne, `${oe}`);
  if (oe == null)
    return L.append(ne, "");
  A(oe, L, ne);
}
var z = { modal: null, listener: null, show(L) {
  typeof L == "object" && (L = `All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>${JSON.stringify(L)}`);
  let ne = document.createElement("html");
  ne.innerHTML = L, ne.querySelectorAll("a").forEach((pe) => pe.setAttribute("target", "_top")), this.modal = document.createElement("div"), this.modal.style.position = "fixed", this.modal.style.width = "100vw", this.modal.style.height = "100vh", this.modal.style.padding = "50px", this.modal.style.boxSizing = "border-box", this.modal.style.backgroundColor = "rgba(0, 0, 0, .6)", this.modal.style.zIndex = 2e5, this.modal.addEventListener("click", () => this.hide());
  let oe = document.createElement("iframe");
  if (oe.style.backgroundColor = "white", oe.style.borderRadius = "5px", oe.style.width = "100%", oe.style.height = "100%", this.modal.appendChild(oe), document.body.prepend(this.modal), document.body.style.overflow = "hidden", !oe.contentWindow)
    throw new Error("iframe not yet ready.");
  oe.contentWindow.document.open(), oe.contentWindow.document.write(ne.outerHTML), oe.contentWindow.document.close(), this.listener = this.hideOnEscape.bind(this), document.addEventListener("keydown", this.listener);
}, hide() {
  this.modal.outerHTML = "", this.modal = null, document.body.style.overflow = "visible", document.removeEventListener("keydown", this.listener);
}, hideOnEscape(L) {
  L.keyCode === 27 && this.hide();
} };
function v(L) {
  return new URL(L.toString(), window.location.toString());
}
function k(L, ne, oe, pe = "brackets") {
  let me = /^https?:\/\//.test(ne.toString()), ge = me || ne.toString().startsWith("/"), be = !ge && !ne.toString().startsWith("#") && !ne.toString().startsWith("?"), Ie = ne.toString().includes("?") || L === "get" && Object.keys(oe).length, Ae = ne.toString().includes("#"), rt = new URL(ne.toString(), "http://localhost");
  return L === "get" && Object.keys(oe).length && (rt.search = lib.stringify(te(lib.parse(rt.search, { ignoreQueryPrefix: !0 }), oe), { encodeValuesOnly: !0, arrayFormat: pe }), oe = {}), [[me ? `${rt.protocol}//${rt.host}` : "", ge ? rt.pathname : "", be ? rt.pathname.substring(1) : "", Ie ? rt.search : "", Ae ? rt.hash : ""].join(""), oe];
}
function w(L) {
  return L = new URL(L.href), L.hash = "", L;
}
var _ = typeof window > "u", C = class {
  constructor() {
    this.visitId = null;
  }
  init({ initialPage: L, resolveComponent: ne, swapComponent: oe }) {
    this.page = L, this.resolveComponent = ne, this.swapComponent = oe, this.setNavigationType(), this.clearRememberedStateOnReload(), this.isBackForwardVisit() ? this.handleBackForwardVisit(this.page) : this.isLocationVisit() ? this.handleLocationVisit(this.page) : this.handleInitialPageVisit(this.page), this.setupEventListeners();
  }
  setNavigationType() {
    this.navigationType = window.performance && window.performance.getEntriesByType("navigation").length > 0 ? window.performance.getEntriesByType("navigation")[0].type : "navigate";
  }
  clearRememberedStateOnReload() {
    var L;
    this.navigationType === "reload" && ((L = window.history.state) != null && L.rememberedState) && delete window.history.state.rememberedState;
  }
  handleInitialPageVisit(L) {
    this.page.url += window.location.hash, this.setPage(L, { preserveState: !0 }).then(() => S(L));
  }
  setupEventListeners() {
    window.addEventListener("popstate", this.handlePopstateEvent.bind(this)), document.addEventListener("scroll", R(this.handleScrollEvent.bind(this), 100), !0);
  }
  scrollRegions() {
    return document.querySelectorAll("[scroll-region]");
  }
  handleScrollEvent(L) {
    typeof L.target.hasAttribute == "function" && L.target.hasAttribute("scroll-region") && this.saveScrollPositions();
  }
  saveScrollPositions() {
    this.replaceState({ ...this.page, scrollRegions: Array.from(this.scrollRegions()).map((L) => ({ top: L.scrollTop, left: L.scrollLeft })) });
  }
  resetScrollPositions() {
    window.scrollTo(0, 0), this.scrollRegions().forEach((L) => {
      typeof L.scrollTo == "function" ? L.scrollTo(0, 0) : (L.scrollTop = 0, L.scrollLeft = 0);
    }), this.saveScrollPositions(), window.location.hash && setTimeout(() => {
      var L;
      return (L = document.getElementById(window.location.hash.slice(1))) == null ? void 0 : L.scrollIntoView();
    });
  }
  restoreScrollPositions() {
    this.page.scrollRegions && this.scrollRegions().forEach((L, ne) => {
      let oe = this.page.scrollRegions[ne];
      if (oe)
        typeof L.scrollTo == "function" ? L.scrollTo(oe.left, oe.top) : (L.scrollTop = oe.top, L.scrollLeft = oe.left);
      else
        return;
    });
  }
  isBackForwardVisit() {
    return window.history.state && this.navigationType === "back_forward";
  }
  handleBackForwardVisit(L) {
    window.history.state.version = L.version, this.setPage(window.history.state, { preserveScroll: !0, preserveState: !0 }).then(() => {
      this.restoreScrollPositions(), S(L);
    });
  }
  locationVisit(L, ne) {
    try {
      let oe = { preserveScroll: ne };
      window.sessionStorage.setItem("inertiaLocationVisit", JSON.stringify(oe)), window.location.href = L.href, w(window.location).href === w(L).href && window.location.reload();
    } catch {
      return !1;
    }
  }
  isLocationVisit() {
    try {
      return window.sessionStorage.getItem("inertiaLocationVisit") !== null;
    } catch {
      return !1;
    }
  }
  handleLocationVisit(L) {
    var oe, pe;
    let ne = JSON.parse(window.sessionStorage.getItem("inertiaLocationVisit") || "");
    window.sessionStorage.removeItem("inertiaLocationVisit"), L.url += window.location.hash, L.rememberedState = ((oe = window.history.state) == null ? void 0 : oe.rememberedState) ?? {}, L.scrollRegions = ((pe = window.history.state) == null ? void 0 : pe.scrollRegions) ?? [], this.setPage(L, { preserveScroll: ne.preserveScroll, preserveState: !0 }).then(() => {
      ne.preserveScroll && this.restoreScrollPositions(), S(L);
    });
  }
  isLocationVisitResponse(L) {
    return !!(L && L.status === 409 && L.headers["x-inertia-location"]);
  }
  isInertiaResponse(L) {
    return !!(L != null && L.headers["x-inertia"]);
  }
  createVisitId() {
    return this.visitId = {}, this.visitId;
  }
  cancelVisit(L, { cancelled: ne = !1, interrupted: oe = !1 }) {
    L && !L.completed && !L.cancelled && !L.interrupted && (L.cancelToken.abort(), L.onCancel(), L.completed = !1, L.cancelled = ne, L.interrupted = oe, N$1(L), L.onFinish(L));
  }
  finishVisit(L) {
    !L.cancelled && !L.interrupted && (L.completed = !0, L.cancelled = !1, L.interrupted = !1, N$1(L), L.onFinish(L));
  }
  resolvePreserveOption(L, ne) {
    return typeof L == "function" ? L(ne) : L === "errors" ? Object.keys(ne.props.errors || {}).length > 0 : L;
  }
  cancel() {
    this.activeVisit && this.cancelVisit(this.activeVisit, { cancelled: !0 });
  }
  visit(L, { method: ne = "get", data: oe = {}, replace: pe = !1, preserveScroll: me = !1, preserveState: ge = !1, only: be = [], headers: Ie = {}, errorBag: Ae = "", forceFormData: rt = !1, onCancelToken: st = () => {
  }, onBefore: dt = () => {
  }, onStart: ut = () => {
  }, onProgress: ht = () => {
  }, onFinish: it = () => {
  }, onCancel: lt = () => {
  }, onSuccess: St = () => {
  }, onError: ot = () => {
  }, queryStringArrayFormat: pt = "brackets" } = {}) {
    let ft = typeof L == "string" ? v(L) : L;
    if ((I(oe) || rt) && !(oe instanceof FormData) && (oe = A(oe)), !(oe instanceof FormData)) {
      let [Ct, At] = k(ne, ft, oe, pt);
      ft = v(Ct), oe = At;
    }
    let vt = { url: ft, method: ne, data: oe, replace: pe, preserveScroll: me, preserveState: ge, only: be, headers: Ie, errorBag: Ae, forceFormData: rt, queryStringArrayFormat: pt, cancelled: !1, completed: !1, interrupted: !1 };
    if (dt(vt) === !1 || !M(vt))
      return;
    this.activeVisit && this.cancelVisit(this.activeVisit, { interrupted: !0 }), this.saveScrollPositions();
    let xt = this.createVisitId();
    this.activeVisit = { ...vt, onCancelToken: st, onBefore: dt, onStart: ut, onProgress: ht, onFinish: it, onCancel: lt, onSuccess: St, onError: ot, queryStringArrayFormat: pt, cancelToken: new AbortController() }, st({ cancel: () => {
      this.activeVisit && this.cancelVisit(this.activeVisit, { cancelled: !0 });
    } }), W(vt), ut(vt), axios({ method: ne, url: w(ft).href, data: ne === "get" ? {} : oe, params: ne === "get" ? oe : {}, signal: this.activeVisit.cancelToken.signal, headers: { ...Ie, Accept: "text/html, application/xhtml+xml", "X-Requested-With": "XMLHttpRequest", "X-Inertia": !0, ...be.length ? { "X-Inertia-Partial-Component": this.page.component, "X-Inertia-Partial-Data": be.join(",") } : {}, ...Ae && Ae.length ? { "X-Inertia-Error-Bag": Ae } : {}, ...this.page.version ? { "X-Inertia-Version": this.page.version } : {} }, onUploadProgress: (Ct) => {
      oe instanceof FormData && (Ct.percentage = Ct.progress ? Math.round(Ct.progress * 100) : 0, q(Ct), ht(Ct));
    } }).then((Ct) => {
      var ir;
      if (!this.isInertiaResponse(Ct))
        return Promise.reject({ response: Ct });
      let At = Ct.data;
      be.length && At.component === this.page.component && (At.props = { ...this.page.props, ...At.props }), me = this.resolvePreserveOption(me, At), ge = this.resolvePreserveOption(ge, At), ge && ((ir = window.history.state) != null && ir.rememberedState) && At.component === this.page.component && (At.rememberedState = window.history.state.rememberedState);
      let kt = ft, Vt = v(At.url);
      return kt.hash && !Vt.hash && w(kt).href === Vt.href && (Vt.hash = kt.hash, At.url = Vt.href), this.setPage(At, { visitId: xt, replace: pe, preserveScroll: me, preserveState: ge });
    }).then(() => {
      let Ct = this.page.props.errors || {};
      if (Object.keys(Ct).length > 0) {
        let At = Ae ? Ct[Ae] ? Ct[Ae] : {} : Ct;
        return j(At), ot(At);
      }
      return K(this.page), St(this.page);
    }).catch((Ct) => {
      if (this.isInertiaResponse(Ct.response))
        return this.setPage(Ct.response.data, { visitId: xt });
      if (this.isLocationVisitResponse(Ct.response)) {
        let At = v(Ct.response.headers["x-inertia-location"]), kt = ft;
        kt.hash && !At.hash && w(kt).href === At.href && (At.hash = kt.hash), this.locationVisit(At, me === !0);
      } else if (Ct.response)
        $(Ct.response) && z.show(Ct.response.data);
      else
        return Promise.reject(Ct);
    }).then(() => {
      this.activeVisit && this.finishVisit(this.activeVisit);
    }).catch((Ct) => {
      if (!axios.isCancel(Ct)) {
        let At = H(Ct);
        if (this.activeVisit && this.finishVisit(this.activeVisit), At)
          return Promise.reject(Ct);
      }
    });
  }
  setPage(L, { visitId: ne = this.createVisitId(), replace: oe = !1, preserveScroll: pe = !1, preserveState: me = !1 } = {}) {
    return Promise.resolve(this.resolveComponent(L.component)).then((ge) => {
      ne === this.visitId && (L.scrollRegions = L.scrollRegions || [], L.rememberedState = L.rememberedState || {}, oe = oe || v(L.url).href === window.location.href, oe ? this.replaceState(L) : this.pushState(L), this.swapComponent({ component: ge, page: L, preserveState: me }).then(() => {
        pe || this.resetScrollPositions(), oe || S(L);
      }));
    });
  }
  pushState(L) {
    this.page = L, window.history.pushState(L, "", L.url);
  }
  replaceState(L) {
    this.page = L, window.history.replaceState(L, "", L.url);
  }
  handlePopstateEvent(L) {
    if (L.state !== null) {
      let ne = L.state, oe = this.createVisitId();
      Promise.resolve(this.resolveComponent(ne.component)).then((pe) => {
        oe === this.visitId && (this.page = ne, this.swapComponent({ component: pe, page: ne, preserveState: !1 }).then(() => {
          this.restoreScrollPositions(), S(ne);
        }));
      });
    } else {
      let ne = v(this.page.url);
      ne.hash = window.location.hash, this.replaceState({ ...this.page, url: ne.href }), this.resetScrollPositions();
    }
  }
  get(L, ne = {}, oe = {}) {
    return this.visit(L, { ...oe, method: "get", data: ne });
  }
  reload(L = {}) {
    return this.visit(window.location.href, { ...L, preserveScroll: !0, preserveState: !0 });
  }
  replace(L, ne = {}) {
    return console.warn(`Inertia.replace() has been deprecated and will be removed in a future release. Please use Inertia.${ne.method ?? "get"}() instead.`), this.visit(L, { preserveState: !0, ...ne, replace: !0 });
  }
  post(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "post", data: ne });
  }
  put(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "put", data: ne });
  }
  patch(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "patch", data: ne });
  }
  delete(L, ne = {}) {
    return this.visit(L, { preserveState: !0, ...ne, method: "delete" });
  }
  remember(L, ne = "default") {
    var oe;
    _ || this.replaceState({ ...this.page, rememberedState: { ...(oe = this.page) == null ? void 0 : oe.rememberedState, [ne]: L } });
  }
  restore(L = "default") {
    var ne, oe;
    if (!_)
      return (oe = (ne = window.history.state) == null ? void 0 : ne.rememberedState) == null ? void 0 : oe[L];
  }
  on(L, ne) {
    let oe = (pe) => {
      let me = ne(pe);
      pe.cancelable && !pe.defaultPrevented && me === !1 && pe.preventDefault();
    };
    return document.addEventListener(`inertia:${L}`, oe), () => document.removeEventListener(`inertia:${L}`, oe);
  }
};
function ee(L) {
  let ne = L.currentTarget.tagName.toLowerCase() === "a";
  return !(L.target && (L == null ? void 0 : L.target).isContentEditable || L.defaultPrevented || ne && L.which > 1 || ne && L.altKey || ne && L.ctrlKey || ne && L.metaKey || ne && L.shiftKey);
}
var Oe = new C(), lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(L, ne) {
  var oe = 200, pe = "__lodash_hash_undefined__", me = 1, ge = 2, be = 9007199254740991, Ie = "[object Arguments]", Ae = "[object Array]", rt = "[object AsyncFunction]", st = "[object Boolean]", dt = "[object Date]", ut = "[object Error]", ht = "[object Function]", it = "[object GeneratorFunction]", lt = "[object Map]", St = "[object Number]", ot = "[object Null]", pt = "[object Object]", ft = "[object Promise]", vt = "[object Proxy]", xt = "[object RegExp]", Ct = "[object Set]", At = "[object String]", kt = "[object Symbol]", Vt = "[object Undefined]", ir = "[object WeakMap]", er = "[object ArrayBuffer]", Yt = "[object DataView]", Jt = "[object Float32Array]", rr = "[object Float64Array]", Qt = "[object Int8Array]", wt = "[object Int16Array]", Ft = "[object Int32Array]", yt = "[object Uint8Array]", Et = "[object Uint8ClampedArray]", Dt = "[object Uint16Array]", Ot = "[object Uint32Array]", nr = /[\\^$.*+?()[\]{}|]/g, yr = /^\[object .+?Constructor\]$/, mr = /^(?:0|[1-9]\d*)$/, Tr = {};
  Tr[Jt] = Tr[rr] = Tr[Qt] = Tr[wt] = Tr[Ft] = Tr[yt] = Tr[Et] = Tr[Dt] = Tr[Ot] = !0, Tr[Ie] = Tr[Ae] = Tr[er] = Tr[st] = Tr[Yt] = Tr[dt] = Tr[ut] = Tr[ht] = Tr[lt] = Tr[St] = Tr[pt] = Tr[xt] = Tr[Ct] = Tr[At] = Tr[ir] = !1;
  var Nr = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, cn = typeof self == "object" && self && self.Object === Object && self, en = Nr || cn || Function("return this")(), Tn = ne && !ne.nodeType && ne, Mn = Tn && !0 && L && !L.nodeType && L, $r = Mn && Mn.exports === Tn, tn = $r && Nr.process, kr = function() {
    try {
      return tn && tn.binding && tn.binding("util");
    } catch {
    }
  }(), dr = kr && kr.isTypedArray;
  function zn(Rt, zt) {
    for (var ar = -1, Sr = Rt == null ? 0 : Rt.length, gn = 0, Gr = []; ++ar < Sr; ) {
      var _n = Rt[ar];
      zt(_n, ar, Rt) && (Gr[gn++] = _n);
    }
    return Gr;
  }
  function Kn(Rt, zt) {
    for (var ar = -1, Sr = zt.length, gn = Rt.length; ++ar < Sr; )
      Rt[gn + ar] = zt[ar];
    return Rt;
  }
  function Fn(Rt, zt) {
    for (var ar = -1, Sr = Rt == null ? 0 : Rt.length; ++ar < Sr; )
      if (zt(Rt[ar], ar, Rt))
        return !0;
    return !1;
  }
  function Jn(Rt, zt) {
    for (var ar = -1, Sr = Array(Rt); ++ar < Rt; )
      Sr[ar] = zt(ar);
    return Sr;
  }
  function ki(Rt) {
    return function(zt) {
      return Rt(zt);
    };
  }
  function Ei(Rt, zt) {
    return Rt.has(zt);
  }
  function Dn(Rt, zt) {
    return Rt == null ? void 0 : Rt[zt];
  }
  function Mi(Rt) {
    var zt = -1, ar = Array(Rt.size);
    return Rt.forEach(function(Sr, gn) {
      ar[++zt] = [gn, Sr];
    }), ar;
  }
  function Zn(Rt, zt) {
    return function(ar) {
      return Rt(zt(ar));
    };
  }
  function ei(Rt) {
    var zt = -1, ar = Array(Rt.size);
    return Rt.forEach(function(Sr) {
      ar[++zt] = Sr;
    }), ar;
  }
  var fi = Array.prototype, ti = Function.prototype, wn = Object.prototype, pi = en["__core-js_shared__"], Va = ti.toString, Vn = wn.hasOwnProperty, vr = function() {
    var Rt = /[^.]+$/.exec(pi && pi.keys && pi.keys.IE_PROTO || "");
    return Rt ? "Symbol(src)_1." + Rt : "";
  }(), Dr = wn.toString, Jr = RegExp(
    "^" + Va.call(Vn).replace(nr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), mn = $r ? en.Buffer : void 0, kn = en.Symbol, bi = en.Uint8Array, ri = wn.propertyIsEnumerable, ba = fi.splice, vn = kn ? kn.toStringTag : void 0, Ba = Object.getOwnPropertySymbols, ni = mn ? mn.isBuffer : void 0, Bn = Zn(Object.keys, Object), su = Vo(en, "DataView"), Lo = Vo(en, "Map"), Ms = Vo(en, "Promise"), lu = Vo(en, "Set"), uu = Vo(en, "WeakMap"), $o = Vo(Object, "create"), df = mi(su), hl = mi(Lo), fu = mi(Ms), ts = mi(lu), Fs = mi(uu), xa = kn ? kn.prototype : void 0, Ha = xa ? xa.valueOf : void 0;
  function Ca(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var Sr = Rt[zt];
      this.set(Sr[0], Sr[1]);
    }
  }
  function pl() {
    this.__data__ = $o ? $o(null) : {}, this.size = 0;
  }
  function hf(Rt) {
    var zt = this.has(Rt) && delete this.__data__[Rt];
    return this.size -= zt ? 1 : 0, zt;
  }
  function pf(Rt) {
    var zt = this.__data__;
    if ($o) {
      var ar = zt[Rt];
      return ar === pe ? void 0 : ar;
    }
    return Vn.call(zt, Rt) ? zt[Rt] : void 0;
  }
  function Ds(Rt) {
    var zt = this.__data__;
    return $o ? zt[Rt] !== void 0 : Vn.call(zt, Rt);
  }
  function ro(Rt, zt) {
    var ar = this.__data__;
    return this.size += this.has(Rt) ? 0 : 1, ar[Rt] = $o && zt === void 0 ? pe : zt, this;
  }
  Ca.prototype.clear = pl, Ca.prototype.delete = hf, Ca.prototype.get = pf, Ca.prototype.has = Ds, Ca.prototype.set = ro;
  function sa(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var Sr = Rt[zt];
      this.set(Sr[0], Sr[1]);
    }
  }
  function Os() {
    this.__data__ = [], this.size = 0;
  }
  function Hi(Rt) {
    var zt = this.__data__, ar = cu(zt, Rt);
    if (ar < 0)
      return !1;
    var Sr = zt.length - 1;
    return ar == Sr ? zt.pop() : ba.call(zt, ar, 1), --this.size, !0;
  }
  function Sc(Rt) {
    var zt = this.__data__, ar = cu(zt, Rt);
    return ar < 0 ? void 0 : zt[ar][1];
  }
  function Ec(Rt) {
    return cu(this.__data__, Rt) > -1;
  }
  function mf(Rt, zt) {
    var ar = this.__data__, Sr = cu(ar, Rt);
    return Sr < 0 ? (++this.size, ar.push([Rt, zt])) : ar[Sr][1] = zt, this;
  }
  sa.prototype.clear = Os, sa.prototype.delete = Hi, sa.prototype.get = Sc, sa.prototype.has = Ec, sa.prototype.set = mf;
  function Io(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var Sr = Rt[zt];
      this.set(Sr[0], Sr[1]);
    }
  }
  function ch() {
    this.size = 0, this.__data__ = {
      hash: new Ca(),
      map: new (Lo || sa)(),
      string: new Ca()
    };
  }
  function dh(Rt) {
    var zt = un(this, Rt).delete(Rt);
    return this.size -= zt ? 1 : 0, zt;
  }
  function Hn(Rt) {
    return un(this, Rt).get(Rt);
  }
  function hh(Rt) {
    return un(this, Rt).has(Rt);
  }
  function wo(Rt, zt) {
    var ar = un(this, Rt), Sr = ar.size;
    return ar.set(Rt, zt), this.size += ar.size == Sr ? 0 : 1, this;
  }
  Io.prototype.clear = ch, Io.prototype.delete = dh, Io.prototype.get = Hn, Io.prototype.has = hh, Io.prototype.set = wo;
  function Kr(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.__data__ = new Io(); ++zt < ar; )
      this.add(Rt[zt]);
  }
  function No(Rt) {
    return this.__data__.set(Rt, pe), this;
  }
  function bc(Rt) {
    return this.__data__.has(Rt);
  }
  Kr.prototype.add = Kr.prototype.push = No, Kr.prototype.has = bc;
  function no(Rt) {
    var zt = this.__data__ = new sa(Rt);
    this.size = zt.size;
  }
  function ml() {
    this.__data__ = new sa(), this.size = 0;
  }
  function Ua(Rt) {
    var zt = this.__data__, ar = zt.delete(Rt);
    return this.size = zt.size, ar;
  }
  function xc(Rt) {
    return this.__data__.get(Rt);
  }
  function Ta(Rt) {
    return this.__data__.has(Rt);
  }
  function Cc(Rt, zt) {
    var ar = this.__data__;
    if (ar instanceof sa) {
      var Sr = ar.__data__;
      if (!Lo || Sr.length < oe - 1)
        return Sr.push([Rt, zt]), this.size = ++ar.size, this;
      ar = this.__data__ = new Io(Sr);
    }
    return ar.set(Rt, zt), this.size = ar.size, this;
  }
  no.prototype.clear = ml, no.prototype.delete = Ua, no.prototype.get = xc, no.prototype.has = Ta, no.prototype.set = Cc;
  function Tc(Rt, zt) {
    var ar = Un(Rt), Sr = !ar && yl(Rt), gn = !ar && !Sr && Sf(Rt), Gr = !ar && !Sr && !gn && yu(Rt), _n = ar || Sr || gn || Gr, ai = _n ? Jn(Rt.length, String) : [], An = ai.length;
    for (var bn in Rt)
      (zt || Vn.call(Rt, bn)) && !(_n && // Safari 9 has enumerable `arguments.length` in strict mode.
      (bn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      gn && (bn == "offset" || bn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Gr && (bn == "buffer" || bn == "byteLength" || bn == "byteOffset") || // Skip index properties.
      _c(bn, An))) && ai.push(bn);
    return ai;
  }
  function cu(Rt, zt) {
    for (var ar = Rt.length; ar--; )
      if (la(Rt[ar][0], zt))
        return ar;
    return -1;
  }
  function du(Rt, zt, ar) {
    var Sr = zt(Rt);
    return Un(Rt) ? Sr : Kn(Sr, ar(Rt));
  }
  function io(Rt) {
    return Rt == null ? Rt === void 0 ? Vt : ot : vn && vn in Object(Rt) ? wc(Rt) : ii(Rt);
  }
  function zo(Rt) {
    return ao(Rt) && io(Rt) == Ie;
  }
  function wa(Rt, zt, ar, Sr, gn) {
    return Rt === zt ? !0 : Rt == null || zt == null || !ao(Rt) && !ao(zt) ? Rt !== Rt && zt !== zt : vf(Rt, zt, ar, Sr, wa, gn);
  }
  function vf(Rt, zt, ar, Sr, gn, Gr) {
    var _n = Un(Rt), ai = Un(zt), An = _n ? Ae : an(Rt), bn = ai ? Ae : an(zt);
    An = An == Ie ? pt : An, bn = bn == Ie ? pt : bn;
    var Ci = An == pt, ua = bn == pt, Wn = An == bn;
    if (Wn && Sf(Rt)) {
      if (!Sf(zt))
        return !1;
      _n = !0, Ci = !1;
    }
    if (Wn && !Ci)
      return Gr || (Gr = new no()), _n || yu(Rt) ? mu(Rt, zt, ar, Sr, gn, Gr) : rs(Rt, zt, An, ar, Sr, gn, Gr);
    if (!(ar & me)) {
      var Fi = Ci && Vn.call(Rt, "__wrapped__"), fa = ua && Vn.call(zt, "__wrapped__");
      if (Fi || fa) {
        var oi = Fi ? Rt.value() : Rt, Di = fa ? zt.value() : zt;
        return Gr || (Gr = new no()), gn(oi, Di, ar, Sr, Gr);
      }
    }
    return Wn ? (Gr || (Gr = new no()), ph(Rt, zt, ar, Sr, gn, Gr)) : !1;
  }
  function hu(Rt) {
    if (!Ef(Rt) || Wr(Rt))
      return !1;
    var zt = xi(Rt) ? Jr : yr;
    return zt.test(mi(Rt));
  }
  function yf(Rt) {
    return ao(Rt) && _o(Rt.length) && !!Tr[io(Rt)];
  }
  function pu(Rt) {
    if (!vl(Rt))
      return Bn(Rt);
    var zt = [];
    for (var ar in Object(Rt))
      Vn.call(Rt, ar) && ar != "constructor" && zt.push(ar);
    return zt;
  }
  function mu(Rt, zt, ar, Sr, gn, Gr) {
    var _n = ar & me, ai = Rt.length, An = zt.length;
    if (ai != An && !(_n && An > ai))
      return !1;
    var bn = Gr.get(Rt);
    if (bn && Gr.get(zt))
      return bn == zt;
    var Ci = -1, ua = !0, Wn = ar & ge ? new Kr() : void 0;
    for (Gr.set(Rt, zt), Gr.set(zt, Rt); ++Ci < ai; ) {
      var Fi = Rt[Ci], fa = zt[Ci];
      if (Sr)
        var oi = _n ? Sr(fa, Fi, Ci, zt, Rt, Gr) : Sr(Fi, fa, Ci, Rt, zt, Gr);
      if (oi !== void 0) {
        if (oi)
          continue;
        ua = !1;
        break;
      }
      if (Wn) {
        if (!Fn(zt, function(Di, oo) {
          if (!Ei(Wn, oo) && (Fi === Di || gn(Fi, Di, ar, Sr, Gr)))
            return Wn.push(oo);
        })) {
          ua = !1;
          break;
        }
      } else if (!(Fi === fa || gn(Fi, fa, ar, Sr, Gr))) {
        ua = !1;
        break;
      }
    }
    return Gr.delete(Rt), Gr.delete(zt), ua;
  }
  function rs(Rt, zt, ar, Sr, gn, Gr, _n) {
    switch (ar) {
      case Yt:
        if (Rt.byteLength != zt.byteLength || Rt.byteOffset != zt.byteOffset)
          return !1;
        Rt = Rt.buffer, zt = zt.buffer;
      case er:
        return !(Rt.byteLength != zt.byteLength || !Gr(new bi(Rt), new bi(zt)));
      case st:
      case dt:
      case St:
        return la(+Rt, +zt);
      case ut:
        return Rt.name == zt.name && Rt.message == zt.message;
      case xt:
      case At:
        return Rt == zt + "";
      case lt:
        var ai = Mi;
      case Ct:
        var An = Sr & me;
        if (ai || (ai = ei), Rt.size != zt.size && !An)
          return !1;
        var bn = _n.get(Rt);
        if (bn)
          return bn == zt;
        Sr |= ge, _n.set(Rt, zt);
        var Ci = mu(ai(Rt), ai(zt), Sr, gn, Gr, _n);
        return _n.delete(Rt), Ci;
      case kt:
        if (Ha)
          return Ha.call(Rt) == Ha.call(zt);
    }
    return !1;
  }
  function ph(Rt, zt, ar, Sr, gn, Gr) {
    var _n = ar & me, ai = Ls(Rt), An = ai.length, bn = Ls(zt), Ci = bn.length;
    if (An != Ci && !_n)
      return !1;
    for (var ua = An; ua--; ) {
      var Wn = ai[ua];
      if (!(_n ? Wn in zt : Vn.call(zt, Wn)))
        return !1;
    }
    var Fi = Gr.get(Rt);
    if (Fi && Gr.get(zt))
      return Fi == zt;
    var fa = !0;
    Gr.set(Rt, zt), Gr.set(zt, Rt);
    for (var oi = _n; ++ua < An; ) {
      Wn = ai[ua];
      var Di = Rt[Wn], oo = zt[Wn];
      if (Sr)
        var ns = _n ? Sr(oo, Di, Wn, zt, Rt, Gr) : Sr(Di, oo, Wn, Rt, zt, Gr);
      if (!(ns === void 0 ? Di === oo || gn(Di, oo, ar, Sr, Gr) : ns)) {
        fa = !1;
        break;
      }
      oi || (oi = Wn == "constructor");
    }
    if (fa && !oi) {
      var El = Rt.constructor, is = zt.constructor;
      El != is && "constructor" in Rt && "constructor" in zt && !(typeof El == "function" && El instanceof El && typeof is == "function" && is instanceof is) && (fa = !1);
    }
    return Gr.delete(Rt), Gr.delete(zt), fa;
  }
  function Ls(Rt) {
    return du(Rt, Ac, vu);
  }
  function un(Rt, zt) {
    var ar = Rt.__data__;
    return gf(zt) ? ar[typeof zt == "string" ? "string" : "hash"] : ar.map;
  }
  function Vo(Rt, zt) {
    var ar = Dn(Rt, zt);
    return hu(ar) ? ar : void 0;
  }
  function wc(Rt) {
    var zt = Vn.call(Rt, vn), ar = Rt[vn];
    try {
      Rt[vn] = void 0;
      var Sr = !0;
    } catch {
    }
    var gn = Dr.call(Rt);
    return Sr && (zt ? Rt[vn] = ar : delete Rt[vn]), gn;
  }
  var vu = Ba ? function(Rt) {
    return Rt == null ? [] : (Rt = Object(Rt), zn(Ba(Rt), function(zt) {
      return ri.call(Rt, zt);
    }));
  } : gl, an = io;
  (su && an(new su(new ArrayBuffer(1))) != Yt || Lo && an(new Lo()) != lt || Ms && an(Ms.resolve()) != ft || lu && an(new lu()) != Ct || uu && an(new uu()) != ir) && (an = function(Rt) {
    var zt = io(Rt), ar = zt == pt ? Rt.constructor : void 0, Sr = ar ? mi(ar) : "";
    if (Sr)
      switch (Sr) {
        case df:
          return Yt;
        case hl:
          return lt;
        case fu:
          return ft;
        case ts:
          return Ct;
        case Fs:
          return ir;
      }
    return zt;
  });
  function _c(Rt, zt) {
    return zt = zt ?? be, !!zt && (typeof Rt == "number" || mr.test(Rt)) && Rt > -1 && Rt % 1 == 0 && Rt < zt;
  }
  function gf(Rt) {
    var zt = typeof Rt;
    return zt == "string" || zt == "number" || zt == "symbol" || zt == "boolean" ? Rt !== "__proto__" : Rt === null;
  }
  function Wr(Rt) {
    return !!vr && vr in Rt;
  }
  function vl(Rt) {
    var zt = Rt && Rt.constructor, ar = typeof zt == "function" && zt.prototype || wn;
    return Rt === ar;
  }
  function ii(Rt) {
    return Dr.call(Rt);
  }
  function mi(Rt) {
    if (Rt != null) {
      try {
        return Va.call(Rt);
      } catch {
      }
      try {
        return Rt + "";
      } catch {
      }
    }
    return "";
  }
  function la(Rt, zt) {
    return Rt === zt || Rt !== Rt && zt !== zt;
  }
  var yl = zo(/* @__PURE__ */ function() {
    return arguments;
  }()) ? zo : function(Rt) {
    return ao(Rt) && Vn.call(Rt, "callee") && !ri.call(Rt, "callee");
  }, Un = Array.isArray;
  function yn(Rt) {
    return Rt != null && _o(Rt.length) && !xi(Rt);
  }
  var Sf = ni || Sl;
  function ja(Rt, zt) {
    return wa(Rt, zt);
  }
  function xi(Rt) {
    if (!Ef(Rt))
      return !1;
    var zt = io(Rt);
    return zt == ht || zt == it || zt == rt || zt == vt;
  }
  function _o(Rt) {
    return typeof Rt == "number" && Rt > -1 && Rt % 1 == 0 && Rt <= be;
  }
  function Ef(Rt) {
    var zt = typeof Rt;
    return Rt != null && (zt == "object" || zt == "function");
  }
  function ao(Rt) {
    return Rt != null && typeof Rt == "object";
  }
  var yu = dr ? ki(dr) : yf;
  function Ac(Rt) {
    return yn(Rt) ? Tc(Rt) : pu(Rt);
  }
  function gl() {
    return [];
  }
  function Sl() {
    return !1;
  }
  L.exports = ja;
})(lodash_isequal, lodash_isequal.exports);
lodash_isequal.exports;
var B = createContext(void 0);
B.displayName = "InertiaHeadContext";
var N = createContext(void 0);
N.displayName = "InertiaPageContext";
var F = () => {
}, V = forwardRef(({ children: L, as: ne = "a", data: oe = {}, href: pe, method: me = "get", preserveScroll: ge = !1, preserveState: be = null, replace: Ie = !1, only: Ae = [], headers: rt = {}, queryStringArrayFormat: st = "brackets", onClick: dt = F, onCancelToken: ut = F, onBefore: ht = F, onStart: it = F, onProgress: lt = F, onFinish: St = F, onCancel: ot = F, onSuccess: pt = F, onError: ft = F, ...vt }, xt) => {
  let Ct = useCallback((Vt) => {
    dt(Vt), ee(Vt) && (Vt.preventDefault(), Oe.visit(pe, { data: oe, method: me, preserveScroll: ge, preserveState: be ?? me !== "get", replace: Ie, only: Ae, headers: rt, onCancelToken: ut, onBefore: ht, onStart: it, onProgress: lt, onFinish: St, onCancel: ot, onSuccess: pt, onError: ft }));
  }, [oe, pe, me, ge, be, Ie, Ae, rt, dt, ut, ht, it, lt, St, ot, pt, ft]);
  ne = ne.toLowerCase(), me = me.toLowerCase();
  let [At, kt] = k(me, pe || "", oe, st);
  return pe = At, oe = kt, ne === "a" && me !== "get" && console.warn(`Creating POST/PUT/PATCH/DELETE <a> links is discouraged as it causes "Open Link in New Tab/Window" accessibility issues.

Please specify a more appropriate element using the "as" attribute. For example:

<Link href="${pe}" method="${me}" as="button">...</Link>`), createElement(ne, { ...vt, ...ne === "a" ? { href: pe } : {}, ref: xt, onClick: Ct }, L);
});
V.displayName = "InertiaLink";
var de = V;
const ResponsiveNavLink = ({ active: L = !1, className: ne = "", children: oe, ...pe }) => /* @__PURE__ */ React__default.createElement(
  de,
  {
    href: "",
    ...pe,
    className: `w-full flex items-start pl-3 pr-4 py-2 border-l-4 ${L ? "border-indigo-400 text-indigo-700 bg-indigo-50 focus:text-indigo-800 focus:bg-indigo-100 focus:border-indigo-700" : "border-transparent text-gray-600 hover:text-gray-800 hover:bg-gray-50 hover:border-gray-300 focus:text-gray-800 focus:bg-gray-50 focus:border-gray-300"} text-base font-medium focus:outline-none transition duration-150 ease-in-out ${ne}`
  },
  oe
), PrimaryButton = ({ className: L = "", disabled: ne, children: oe, ...pe }) => /* @__PURE__ */ React__default.createElement(
  "button",
  {
    ...pe,
    className: `inline-flex items-center px-4 py-2 bg-gray-800 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-gray-700 focus:bg-gray-700 active:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition ease-in-out duration-150 ${ne && "opacity-25"} ` + L,
    disabled: ne
  },
  oe
);
export {
  MainNavbar,
  MainSidebar,
  NoAccess,
  PrimaryButton,
  ResponsiveNavLink
};
