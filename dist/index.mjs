import * as React from "react";
import React__default, { createContext, useRef, useState, useMemo, useContext, useEffect, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef, useCallback } from "react";
import "tailwindcss/tailwind.css";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(L) {
  return L && L.__esModule && Object.prototype.hasOwnProperty.call(L, "default") ? L.default : L;
}
function getAugmentedNamespace(L) {
  if (L.__esModule)
    return L;
  var ne = L.default;
  if (typeof ne == "function") {
    var oe = function pe() {
      return this instanceof pe ? Reflect.construct(ne, arguments, this.constructor) : ne.apply(this, arguments);
    };
    oe.prototype = ne.prototype;
  } else
    oe = {};
  return Object.defineProperty(oe, "__esModule", { value: !0 }), Object.keys(L).forEach(function(pe) {
    var me = Object.getOwnPropertyDescriptor(L, pe);
    Object.defineProperty(oe, pe, me.get ? me : {
      enumerable: !0,
      get: function() {
        return L[pe];
      }
    });
  }), oe;
}
var lottie = { exports: {} };
(function(module, exports) {
  typeof navigator < "u" && function(L, ne) {
    module.exports = ne();
  }(commonjsGlobal, function() {
    var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function(ne) {
      _useWebWorker = !!ne;
    }, getWebWorker = function() {
      return _useWebWorker;
    }, setLocationHref = function(ne) {
      locationHref = ne;
    }, getLocationHref = function() {
      return locationHref;
    };
    function createTag(L) {
      return document.createElement(L);
    }
    function extendPrototype(L, ne) {
      var oe, pe = L.length, me;
      for (oe = 0; oe < pe; oe += 1) {
        me = L[oe].prototype;
        for (var ge in me)
          Object.prototype.hasOwnProperty.call(me, ge) && (ne.prototype[ge] = me[ge]);
      }
    }
    function getDescriptor(L, ne) {
      return Object.getOwnPropertyDescriptor(L, ne);
    }
    function createProxyFunction(L) {
      function ne() {
      }
      return ne.prototype = L, ne;
    }
    var audioControllerFactory = function() {
      function L(ne) {
        this.audios = [], this.audioFactory = ne, this._volume = 1, this._isMuted = !1;
      }
      return L.prototype = {
        addAudio: function(oe) {
          this.audios.push(oe);
        },
        pause: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].pause();
        },
        resume: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].resume();
        },
        setRate: function(oe) {
          var pe, me = this.audios.length;
          for (pe = 0; pe < me; pe += 1)
            this.audios[pe].setRate(oe);
        },
        createAudio: function(oe) {
          return this.audioFactory ? this.audioFactory(oe) : window.Howl ? new window.Howl({
            src: [oe]
          }) : {
            isPlaying: !1,
            play: function() {
              this.isPlaying = !0;
            },
            seek: function() {
              this.isPlaying = !1;
            },
            playing: function() {
            },
            rate: function() {
            },
            setVolume: function() {
            }
          };
        },
        setAudioFactory: function(oe) {
          this.audioFactory = oe;
        },
        setVolume: function(oe) {
          this._volume = oe, this._updateVolume();
        },
        mute: function() {
          this._isMuted = !0, this._updateVolume();
        },
        unmute: function() {
          this._isMuted = !1, this._updateVolume();
        },
        getVolume: function() {
          return this._volume;
        },
        _updateVolume: function() {
          var oe, pe = this.audios.length;
          for (oe = 0; oe < pe; oe += 1)
            this.audios[oe].volume(this._volume * (this._isMuted ? 0 : 1));
        }
      }, function() {
        return new L();
      };
    }(), createTypedArray = /* @__PURE__ */ function() {
      function L(oe, pe) {
        var me = 0, ge = [], be;
        switch (oe) {
          case "int16":
          case "uint8c":
            be = 1;
            break;
          default:
            be = 1.1;
            break;
        }
        for (me = 0; me < pe; me += 1)
          ge.push(be);
        return ge;
      }
      function ne(oe, pe) {
        return oe === "float32" ? new Float32Array(pe) : oe === "int16" ? new Int16Array(pe) : oe === "uint8c" ? new Uint8ClampedArray(pe) : L(oe, pe);
      }
      return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? ne : L;
    }();
    function createSizedArray(L) {
      return Array.apply(null, {
        length: L
      });
    }
    function _typeof$6(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(oe) {
        return typeof oe;
      } : _typeof$6 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$6(L);
    }
    var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {};
    (function() {
      var L = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        BMMath[L[ne]] = Math[L[ne]];
    })(), BMMath.random = Math.random, BMMath.abs = function(L) {
      var ne = _typeof$6(L);
      if (ne === "object" && L.length) {
        var oe = createSizedArray(L.length), pe, me = L.length;
        for (pe = 0; pe < me; pe += 1)
          oe[pe] = Math.abs(L[pe]);
        return oe;
      }
      return Math.abs(L);
    };
    var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = 0.5519;
    function styleDiv(L) {
      L.style.position = "absolute", L.style.top = 0, L.style.left = 0, L.style.display = "block", L.style.transformOrigin = "0 0", L.style.webkitTransformOrigin = "0 0", L.style.backfaceVisibility = "visible", L.style.webkitBackfaceVisibility = "visible", L.style.transformStyle = "preserve-3d", L.style.webkitTransformStyle = "preserve-3d", L.style.mozTransformStyle = "preserve-3d";
    }
    function BMEnterFrameEvent(L, ne, oe, pe) {
      this.type = L, this.currentTime = ne, this.totalTime = oe, this.direction = pe < 0 ? -1 : 1;
    }
    function BMCompleteEvent(L, ne) {
      this.type = L, this.direction = ne < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(L, ne, oe, pe) {
      this.type = L, this.currentLoop = oe, this.totalLoops = ne, this.direction = pe < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(L, ne, oe) {
      this.type = L, this.firstFrame = ne, this.totalFrames = oe;
    }
    function BMDestroyEvent(L, ne) {
      this.type = L, this.target = ne;
    }
    function BMRenderFrameErrorEvent(L, ne) {
      this.type = "renderFrameError", this.nativeError = L, this.currentTime = ne;
    }
    function BMConfigErrorEvent(L) {
      this.type = "configError", this.nativeError = L;
    }
    var createElementID = /* @__PURE__ */ function() {
      var L = 0;
      return function() {
        return L += 1, idPrefix$1 + "__lottie_element_" + L;
      };
    }();
    function HSVtoRGB(L, ne, oe) {
      var pe, me, ge, be, Ie, Ae, rt, st;
      switch (be = Math.floor(L * 6), Ie = L * 6 - be, Ae = oe * (1 - ne), rt = oe * (1 - Ie * ne), st = oe * (1 - (1 - Ie) * ne), be % 6) {
        case 0:
          pe = oe, me = st, ge = Ae;
          break;
        case 1:
          pe = rt, me = oe, ge = Ae;
          break;
        case 2:
          pe = Ae, me = oe, ge = st;
          break;
        case 3:
          pe = Ae, me = rt, ge = oe;
          break;
        case 4:
          pe = st, me = Ae, ge = oe;
          break;
        case 5:
          pe = oe, me = Ae, ge = rt;
          break;
      }
      return [pe, me, ge];
    }
    function RGBtoHSV(L, ne, oe) {
      var pe = Math.max(L, ne, oe), me = Math.min(L, ne, oe), ge = pe - me, be, Ie = pe === 0 ? 0 : ge / pe, Ae = pe / 255;
      switch (pe) {
        case me:
          be = 0;
          break;
        case L:
          be = ne - oe + ge * (ne < oe ? 6 : 0), be /= 6 * ge;
          break;
        case ne:
          be = oe - L + ge * 2, be /= 6 * ge;
          break;
        case oe:
          be = L - ne + ge * 4, be /= 6 * ge;
          break;
      }
      return [be, Ie, Ae];
    }
    function addSaturationToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[1] += ne, oe[1] > 1 ? oe[1] = 1 : oe[1] <= 0 && (oe[1] = 0), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    function addBrightnessToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[2] += ne, oe[2] > 1 ? oe[2] = 1 : oe[2] < 0 && (oe[2] = 0), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    function addHueToRGB(L, ne) {
      var oe = RGBtoHSV(L[0] * 255, L[1] * 255, L[2] * 255);
      return oe[0] += ne / 360, oe[0] > 1 ? oe[0] -= 1 : oe[0] < 0 && (oe[0] += 1), HSVtoRGB(oe[0], oe[1], oe[2]);
    }
    var rgbToHex = function() {
      var L = [], ne, oe;
      for (ne = 0; ne < 256; ne += 1)
        oe = ne.toString(16), L[ne] = oe.length === 1 ? "0" + oe : oe;
      return function(pe, me, ge) {
        return pe < 0 && (pe = 0), me < 0 && (me = 0), ge < 0 && (ge = 0), "#" + L[pe] + L[me] + L[ge];
      };
    }(), setSubframeEnabled = function(ne) {
      subframeEnabled = !!ne;
    }, getSubframeEnabled = function() {
      return subframeEnabled;
    }, setExpressionsPlugin = function(ne) {
      expressionsPlugin = ne;
    }, getExpressionsPlugin = function() {
      return expressionsPlugin;
    }, setExpressionInterfaces = function(ne) {
      expressionsInterfaces = ne;
    }, getExpressionInterfaces = function() {
      return expressionsInterfaces;
    }, setDefaultCurveSegments = function(ne) {
      defaultCurveSegments = ne;
    }, getDefaultCurveSegments = function() {
      return defaultCurveSegments;
    }, setIdPrefix = function(ne) {
      idPrefix$1 = ne;
    };
    function createNS(L) {
      return document.createElementNS(svgNS, L);
    }
    function _typeof$5(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(oe) {
        return typeof oe;
      } : _typeof$5 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$5(L);
    }
    var dataManager = /* @__PURE__ */ function() {
      var L = 1, ne = [], oe, pe, me = {
        onmessage: function() {
        },
        postMessage: function(pt) {
          oe({
            data: pt
          });
        }
      }, ge = {
        postMessage: function(pt) {
          me.onmessage({
            data: pt
          });
        }
      };
      function be(lt) {
        if (window.Worker && window.Blob && getWebWorker()) {
          var pt = new Blob(["var _workerSelf = self; self.onmessage = ", lt.toString()], {
            type: "text/javascript"
          }), it = URL.createObjectURL(pt);
          return new Worker(it);
        }
        return oe = lt, me;
      }
      function Ie() {
        pe || (pe = be(function(pt) {
          function it() {
            function St(Qt, wt) {
              var Ft, yt, Et = Qt.length, Dt, Ot, nr, vr;
              for (yt = 0; yt < Et; yt += 1)
                if (Ft = Qt[yt], "ks" in Ft && !Ft.completed) {
                  if (Ft.completed = !0, Ft.hasMask) {
                    var pr = Ft.masksProperties;
                    for (Ot = pr.length, Dt = 0; Dt < Ot; Dt += 1)
                      if (pr[Dt].pt.k.i)
                        Ct(pr[Dt].pt.k);
                      else
                        for (vr = pr[Dt].pt.k.length, nr = 0; nr < vr; nr += 1)
                          pr[Dt].pt.k[nr].s && Ct(pr[Dt].pt.k[nr].s[0]), pr[Dt].pt.k[nr].e && Ct(pr[Dt].pt.k[nr].e[0]);
                  }
                  Ft.ty === 0 ? (Ft.layers = ft(Ft.refId, wt), St(Ft.layers, wt)) : Ft.ty === 4 ? vt(Ft.shapes) : Ft.ty === 5 && Jt(Ft);
                }
            }
            function ot(Qt, wt) {
              if (Qt) {
                var Ft = 0, yt = Qt.length;
                for (Ft = 0; Ft < yt; Ft += 1)
                  Qt[Ft].t === 1 && (Qt[Ft].data.layers = ft(Qt[Ft].data.refId, wt), St(Qt[Ft].data.layers, wt));
              }
            }
            function ht(Qt, wt) {
              for (var Ft = 0, yt = wt.length; Ft < yt; ) {
                if (wt[Ft].id === Qt)
                  return wt[Ft];
                Ft += 1;
              }
              return null;
            }
            function ft(Qt, wt) {
              var Ft = ht(Qt, wt);
              return Ft ? Ft.layers.__used ? JSON.parse(JSON.stringify(Ft.layers)) : (Ft.layers.__used = !0, Ft.layers) : null;
            }
            function vt(Qt) {
              var wt, Ft = Qt.length, yt, Et;
              for (wt = Ft - 1; wt >= 0; wt -= 1)
                if (Qt[wt].ty === "sh")
                  if (Qt[wt].ks.k.i)
                    Ct(Qt[wt].ks.k);
                  else
                    for (Et = Qt[wt].ks.k.length, yt = 0; yt < Et; yt += 1)
                      Qt[wt].ks.k[yt].s && Ct(Qt[wt].ks.k[yt].s[0]), Qt[wt].ks.k[yt].e && Ct(Qt[wt].ks.k[yt].e[0]);
                else
                  Qt[wt].ty === "gr" && vt(Qt[wt].it);
            }
            function Ct(Qt) {
              var wt, Ft = Qt.i.length;
              for (wt = 0; wt < Ft; wt += 1)
                Qt.i[wt][0] += Qt.v[wt][0], Qt.i[wt][1] += Qt.v[wt][1], Qt.o[wt][0] += Qt.v[wt][0], Qt.o[wt][1] += Qt.v[wt][1];
            }
            function xt(Qt, wt) {
              var Ft = wt ? wt.split(".") : [100, 100, 100];
              return Qt[0] > Ft[0] ? !0 : Ft[0] > Qt[0] ? !1 : Qt[1] > Ft[1] ? !0 : Ft[1] > Qt[1] ? !1 : Qt[2] > Ft[2] ? !0 : Ft[2] > Qt[2] ? !1 : null;
            }
            var At = /* @__PURE__ */ function() {
              var Qt = [4, 4, 14];
              function wt(yt) {
                var Et = yt.t.d;
                yt.t.d = {
                  k: [{
                    s: Et,
                    t: 0
                  }]
                };
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 5 && wt(yt[Et]);
              }
              return function(yt) {
                if (xt(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), kt = /* @__PURE__ */ function() {
              var Qt = [4, 7, 99];
              return function(wt) {
                if (wt.chars && !xt(Qt, wt.v)) {
                  var Ft, yt = wt.chars.length;
                  for (Ft = 0; Ft < yt; Ft += 1) {
                    var Et = wt.chars[Ft];
                    Et.data && Et.data.shapes && (vt(Et.data.shapes), Et.data.ip = 0, Et.data.op = 99999, Et.data.st = 0, Et.data.sr = 1, Et.data.ks = {
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      }
                    }, wt.chars[Ft].t || (Et.data.shapes.push({
                      ty: "no"
                    }), Et.data.shapes[0].it.push({
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      },
                      sk: {
                        k: 0,
                        a: 0
                      },
                      sa: {
                        k: 0,
                        a: 0
                      },
                      ty: "tr"
                    })));
                  }
                }
              };
            }(), Vt = /* @__PURE__ */ function() {
              var Qt = [5, 7, 15];
              function wt(yt) {
                var Et = yt.t.p;
                typeof Et.a == "number" && (Et.a = {
                  a: 0,
                  k: Et.a
                }), typeof Et.p == "number" && (Et.p = {
                  a: 0,
                  k: Et.p
                }), typeof Et.r == "number" && (Et.r = {
                  a: 0,
                  k: Et.r
                });
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 5 && wt(yt[Et]);
              }
              return function(yt) {
                if (xt(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), ir = /* @__PURE__ */ function() {
              var Qt = [4, 1, 9];
              function wt(yt) {
                var Et, Dt = yt.length, Ot, nr;
                for (Et = 0; Et < Dt; Et += 1)
                  if (yt[Et].ty === "gr")
                    wt(yt[Et].it);
                  else if (yt[Et].ty === "fl" || yt[Et].ty === "st")
                    if (yt[Et].c.k && yt[Et].c.k[0].i)
                      for (nr = yt[Et].c.k.length, Ot = 0; Ot < nr; Ot += 1)
                        yt[Et].c.k[Ot].s && (yt[Et].c.k[Ot].s[0] /= 255, yt[Et].c.k[Ot].s[1] /= 255, yt[Et].c.k[Ot].s[2] /= 255, yt[Et].c.k[Ot].s[3] /= 255), yt[Et].c.k[Ot].e && (yt[Et].c.k[Ot].e[0] /= 255, yt[Et].c.k[Ot].e[1] /= 255, yt[Et].c.k[Ot].e[2] /= 255, yt[Et].c.k[Ot].e[3] /= 255);
                    else
                      yt[Et].c.k[0] /= 255, yt[Et].c.k[1] /= 255, yt[Et].c.k[2] /= 255, yt[Et].c.k[3] /= 255;
              }
              function Ft(yt) {
                var Et, Dt = yt.length;
                for (Et = 0; Et < Dt; Et += 1)
                  yt[Et].ty === 4 && wt(yt[Et].shapes);
              }
              return function(yt) {
                if (xt(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }(), er = /* @__PURE__ */ function() {
              var Qt = [4, 4, 18];
              function wt(yt) {
                var Et, Dt = yt.length, Ot, nr;
                for (Et = Dt - 1; Et >= 0; Et -= 1)
                  if (yt[Et].ty === "sh")
                    if (yt[Et].ks.k.i)
                      yt[Et].ks.k.c = yt[Et].closed;
                    else
                      for (nr = yt[Et].ks.k.length, Ot = 0; Ot < nr; Ot += 1)
                        yt[Et].ks.k[Ot].s && (yt[Et].ks.k[Ot].s[0].c = yt[Et].closed), yt[Et].ks.k[Ot].e && (yt[Et].ks.k[Ot].e[0].c = yt[Et].closed);
                  else
                    yt[Et].ty === "gr" && wt(yt[Et].it);
              }
              function Ft(yt) {
                var Et, Dt, Ot = yt.length, nr, vr, pr, xr;
                for (Dt = 0; Dt < Ot; Dt += 1) {
                  if (Et = yt[Dt], Et.hasMask) {
                    var Ir = Et.masksProperties;
                    for (vr = Ir.length, nr = 0; nr < vr; nr += 1)
                      if (Ir[nr].pt.k.i)
                        Ir[nr].pt.k.c = Ir[nr].cl;
                      else
                        for (xr = Ir[nr].pt.k.length, pr = 0; pr < xr; pr += 1)
                          Ir[nr].pt.k[pr].s && (Ir[nr].pt.k[pr].s[0].c = Ir[nr].cl), Ir[nr].pt.k[pr].e && (Ir[nr].pt.k[pr].e[0].c = Ir[nr].cl);
                  }
                  Et.ty === 4 && wt(Et.shapes);
                }
              }
              return function(yt) {
                if (xt(Qt, yt.v) && (Ft(yt.layers), yt.assets)) {
                  var Et, Dt = yt.assets.length;
                  for (Et = 0; Et < Dt; Et += 1)
                    yt.assets[Et].layers && Ft(yt.assets[Et].layers);
                }
              };
            }();
            function Yt(Qt) {
              Qt.__complete || (ir(Qt), At(Qt), kt(Qt), Vt(Qt), er(Qt), St(Qt.layers, Qt.assets), ot(Qt.chars, Qt.assets), Qt.__complete = !0);
            }
            function Jt(Qt) {
              Qt.t.a.length === 0 && "m" in Qt.t.p;
            }
            var rr = {};
            return rr.completeData = Yt, rr.checkColors = ir, rr.checkChars = kt, rr.checkPathProperties = Vt, rr.checkShapes = er, rr.completeLayers = St, rr;
          }
          if (ge.dataManager || (ge.dataManager = it()), ge.assetLoader || (ge.assetLoader = /* @__PURE__ */ function() {
            function St(ht) {
              var ft = ht.getResponseHeader("content-type");
              return ft && ht.responseType === "json" && ft.indexOf("json") !== -1 || ht.response && _typeof$5(ht.response) === "object" ? ht.response : ht.response && typeof ht.response == "string" ? JSON.parse(ht.response) : ht.responseText ? JSON.parse(ht.responseText) : null;
            }
            function ot(ht, ft, vt, Ct) {
              var xt, At = new XMLHttpRequest();
              try {
                At.responseType = "json";
              } catch {
              }
              At.onreadystatechange = function() {
                if (At.readyState === 4)
                  if (At.status === 200)
                    xt = St(At), vt(xt);
                  else
                    try {
                      xt = St(At), vt(xt);
                    } catch (kt) {
                      Ct && Ct(kt);
                    }
              };
              try {
                At.open(["G", "E", "T"].join(""), ht, !0);
              } catch {
                At.open(["G", "E", "T"].join(""), ft + "/" + ht, !0);
              }
              At.send();
            }
            return {
              load: ot
            };
          }()), pt.data.type === "loadAnimation")
            ge.assetLoader.load(pt.data.path, pt.data.fullPath, function(St) {
              ge.dataManager.completeData(St), ge.postMessage({
                id: pt.data.id,
                payload: St,
                status: "success"
              });
            }, function() {
              ge.postMessage({
                id: pt.data.id,
                status: "error"
              });
            });
          else if (pt.data.type === "complete") {
            var ut = pt.data.animation;
            ge.dataManager.completeData(ut), ge.postMessage({
              id: pt.data.id,
              payload: ut,
              status: "success"
            });
          } else
            pt.data.type === "loadData" && ge.assetLoader.load(pt.data.path, pt.data.fullPath, function(St) {
              ge.postMessage({
                id: pt.data.id,
                payload: St,
                status: "success"
              });
            }, function() {
              ge.postMessage({
                id: pt.data.id,
                status: "error"
              });
            });
        }), pe.onmessage = function(lt) {
          var pt = lt.data, it = pt.id, ut = ne[it];
          ne[it] = null, pt.status === "success" ? ut.onComplete(pt.payload) : ut.onError && ut.onError();
        });
      }
      function Ae(lt, pt) {
        L += 1;
        var it = "processId_" + L;
        return ne[it] = {
          onComplete: lt,
          onError: pt
        }, it;
      }
      function rt(lt, pt, it) {
        Ie();
        var ut = Ae(pt, it);
        pe.postMessage({
          type: "loadAnimation",
          path: lt,
          fullPath: window.location.origin + window.location.pathname,
          id: ut
        });
      }
      function st(lt, pt, it) {
        Ie();
        var ut = Ae(pt, it);
        pe.postMessage({
          type: "loadData",
          path: lt,
          fullPath: window.location.origin + window.location.pathname,
          id: ut
        });
      }
      function dt(lt, pt, it) {
        Ie();
        var ut = Ae(pt, it);
        pe.postMessage({
          type: "complete",
          animation: lt,
          id: ut
        });
      }
      return {
        loadAnimation: rt,
        loadData: st,
        completeAnimation: dt
      };
    }(), ImagePreloader = function() {
      var L = function() {
        var ot = createTag("canvas");
        ot.width = 1, ot.height = 1;
        var ht = ot.getContext("2d");
        return ht.fillStyle = "rgba(0,0,0,0)", ht.fillRect(0, 0, 1, 1), ot;
      }();
      function ne() {
        this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function oe() {
        this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function pe(ot, ht, ft) {
        var vt = "";
        if (ot.e)
          vt = ot.p;
        else if (ht) {
          var Ct = ot.p;
          Ct.indexOf("images/") !== -1 && (Ct = Ct.split("/")[1]), vt = ht + Ct;
        } else
          vt = ft, vt += ot.u ? ot.u : "", vt += ot.p;
        return vt;
      }
      function me(ot) {
        var ht = 0, ft = setInterval((function() {
          var vt = ot.getBBox();
          (vt.width || ht > 500) && (this._imageLoaded(), clearInterval(ft)), ht += 1;
        }).bind(this), 50);
      }
      function ge(ot) {
        var ht = pe(ot, this.assetsPath, this.path), ft = createNS("image");
        isSafari ? this.testImageLoaded(ft) : ft.addEventListener("load", this._imageLoaded, !1), ft.addEventListener("error", (function() {
          vt.img = L, this._imageLoaded();
        }).bind(this), !1), ft.setAttributeNS("http://www.w3.org/1999/xlink", "href", ht), this._elementHelper.append ? this._elementHelper.append(ft) : this._elementHelper.appendChild(ft);
        var vt = {
          img: ft,
          assetData: ot
        };
        return vt;
      }
      function be(ot) {
        var ht = pe(ot, this.assetsPath, this.path), ft = createTag("img");
        ft.crossOrigin = "anonymous", ft.addEventListener("load", this._imageLoaded, !1), ft.addEventListener("error", (function() {
          vt.img = L, this._imageLoaded();
        }).bind(this), !1), ft.src = ht;
        var vt = {
          img: ft,
          assetData: ot
        };
        return vt;
      }
      function Ie(ot) {
        var ht = {
          assetData: ot
        }, ft = pe(ot, this.assetsPath, this.path);
        return dataManager.loadData(ft, (function(vt) {
          ht.img = vt, this._footageLoaded();
        }).bind(this), (function() {
          ht.img = {}, this._footageLoaded();
        }).bind(this)), ht;
      }
      function Ae(ot, ht) {
        this.imagesLoadedCb = ht;
        var ft, vt = ot.length;
        for (ft = 0; ft < vt; ft += 1)
          ot[ft].layers || (!ot[ft].t || ot[ft].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(ot[ft]))) : ot[ft].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(ot[ft]))));
      }
      function rt(ot) {
        this.path = ot || "";
      }
      function st(ot) {
        this.assetsPath = ot || "";
      }
      function dt(ot) {
        for (var ht = 0, ft = this.images.length; ht < ft; ) {
          if (this.images[ht].assetData === ot)
            return this.images[ht].img;
          ht += 1;
        }
        return null;
      }
      function lt() {
        this.imagesLoadedCb = null, this.images.length = 0;
      }
      function pt() {
        return this.totalImages === this.loadedAssets;
      }
      function it() {
        return this.totalFootages === this.loadedFootagesCount;
      }
      function ut(ot, ht) {
        ot === "svg" ? (this._elementHelper = ht, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this);
      }
      function St() {
        this._imageLoaded = ne.bind(this), this._footageLoaded = oe.bind(this), this.testImageLoaded = me.bind(this), this.createFootageData = Ie.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [];
      }
      return St.prototype = {
        loadAssets: Ae,
        setAssetsPath: st,
        setPath: rt,
        loadedImages: pt,
        loadedFootages: it,
        destroy: lt,
        getAsset: dt,
        createImgData: be,
        createImageData: ge,
        imageLoaded: ne,
        footageLoaded: oe,
        setCacheType: ut
      }, St;
    }();
    function BaseEvent() {
    }
    BaseEvent.prototype = {
      triggerEvent: function(ne, oe) {
        if (this._cbs[ne])
          for (var pe = this._cbs[ne], me = 0; me < pe.length; me += 1)
            pe[me](oe);
      },
      addEventListener: function(ne, oe) {
        return this._cbs[ne] || (this._cbs[ne] = []), this._cbs[ne].push(oe), (function() {
          this.removeEventListener(ne, oe);
        }).bind(this);
      },
      removeEventListener: function(ne, oe) {
        if (!oe)
          this._cbs[ne] = null;
        else if (this._cbs[ne]) {
          for (var pe = 0, me = this._cbs[ne].length; pe < me; )
            this._cbs[ne][pe] === oe && (this._cbs[ne].splice(pe, 1), pe -= 1, me -= 1), pe += 1;
          this._cbs[ne].length || (this._cbs[ne] = null);
        }
      }
    };
    var markerParser = /* @__PURE__ */ function() {
      function L(ne) {
        for (var oe = ne.split(`\r
`), pe = {}, me, ge = 0, be = 0; be < oe.length; be += 1)
          me = oe[be].split(":"), me.length === 2 && (pe[me[0]] = me[1].trim(), ge += 1);
        if (ge === 0)
          throw new Error();
        return pe;
      }
      return function(ne) {
        for (var oe = [], pe = 0; pe < ne.length; pe += 1) {
          var me = ne[pe], ge = {
            time: me.tm,
            duration: me.dr
          };
          try {
            ge.payload = JSON.parse(ne[pe].cm);
          } catch {
            try {
              ge.payload = L(ne[pe].cm);
            } catch {
              ge.payload = {
                name: ne[pe].cm
              };
            }
          }
          oe.push(ge);
        }
        return oe;
      };
    }(), ProjectInterface = /* @__PURE__ */ function() {
      function L(ne) {
        this.compositions.push(ne);
      }
      return function() {
        function ne(oe) {
          for (var pe = 0, me = this.compositions.length; pe < me; ) {
            if (this.compositions[pe].data && this.compositions[pe].data.nm === oe)
              return this.compositions[pe].prepareFrame && this.compositions[pe].data.xt && this.compositions[pe].prepareFrame(this.currentFrame), this.compositions[pe].compInterface;
            pe += 1;
          }
          return null;
        }
        return ne.compositions = [], ne.currentFrame = 0, ne.registerComposition = L, ne;
      };
    }(), renderers = {}, registerRenderer = function(ne, oe) {
      renderers[ne] = oe;
    };
    function getRenderer(L) {
      return renderers[L];
    }
    function getRegisteredRenderer() {
      if (renderers.canvas)
        return "canvas";
      for (var L in renderers)
        if (renderers[L])
          return L;
      return "";
    }
    function _typeof$4(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(oe) {
        return typeof oe;
      } : _typeof$4 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$4(L);
    }
    var AnimationItem = function() {
      this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader(), this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin();
    };
    extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(L) {
      (L.wrapper || L.container) && (this.wrapper = L.wrapper || L.container);
      var ne = "svg";
      L.animType ? ne = L.animType : L.renderer && (ne = L.renderer);
      var oe = getRenderer(ne);
      this.renderer = new oe(this, L.rendererSettings), this.imagePreloader.setCacheType(ne, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = ne, L.loop === "" || L.loop === null || L.loop === void 0 || L.loop === !0 ? this.loop = !0 : L.loop === !1 ? this.loop = !1 : this.loop = parseInt(L.loop, 10), this.autoplay = "autoplay" in L ? L.autoplay : !0, this.name = L.name ? L.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(L, "autoloadSegments") ? L.autoloadSegments : !0, this.assetsPath = L.assetsPath, this.initialSegment = L.initialSegment, L.audioFactory && this.audioController.setAudioFactory(L.audioFactory), L.animationData ? this.setupAnimation(L.animationData) : L.path && (L.path.lastIndexOf("\\") !== -1 ? this.path = L.path.substr(0, L.path.lastIndexOf("\\") + 1) : this.path = L.path.substr(0, L.path.lastIndexOf("/") + 1), this.fileName = L.path.substr(L.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(L.path, this.configAnimation, this.onSetupError));
    }, AnimationItem.prototype.onSetupError = function() {
      this.trigger("data_failed");
    }, AnimationItem.prototype.setupAnimation = function(L) {
      dataManager.completeAnimation(L, this.configAnimation);
    }, AnimationItem.prototype.setData = function(L, ne) {
      ne && _typeof$4(ne) !== "object" && (ne = JSON.parse(ne));
      var oe = {
        wrapper: L,
        animationData: ne
      }, pe = L.attributes;
      oe.path = pe.getNamedItem("data-animation-path") ? pe.getNamedItem("data-animation-path").value : pe.getNamedItem("data-bm-path") ? pe.getNamedItem("data-bm-path").value : pe.getNamedItem("bm-path") ? pe.getNamedItem("bm-path").value : "", oe.animType = pe.getNamedItem("data-anim-type") ? pe.getNamedItem("data-anim-type").value : pe.getNamedItem("data-bm-type") ? pe.getNamedItem("data-bm-type").value : pe.getNamedItem("bm-type") ? pe.getNamedItem("bm-type").value : pe.getNamedItem("data-bm-renderer") ? pe.getNamedItem("data-bm-renderer").value : pe.getNamedItem("bm-renderer") ? pe.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
      var me = pe.getNamedItem("data-anim-loop") ? pe.getNamedItem("data-anim-loop").value : pe.getNamedItem("data-bm-loop") ? pe.getNamedItem("data-bm-loop").value : pe.getNamedItem("bm-loop") ? pe.getNamedItem("bm-loop").value : "";
      me === "false" ? oe.loop = !1 : me === "true" ? oe.loop = !0 : me !== "" && (oe.loop = parseInt(me, 10));
      var ge = pe.getNamedItem("data-anim-autoplay") ? pe.getNamedItem("data-anim-autoplay").value : pe.getNamedItem("data-bm-autoplay") ? pe.getNamedItem("data-bm-autoplay").value : pe.getNamedItem("bm-autoplay") ? pe.getNamedItem("bm-autoplay").value : !0;
      oe.autoplay = ge !== "false", oe.name = pe.getNamedItem("data-name") ? pe.getNamedItem("data-name").value : pe.getNamedItem("data-bm-name") ? pe.getNamedItem("data-bm-name").value : pe.getNamedItem("bm-name") ? pe.getNamedItem("bm-name").value : "";
      var be = pe.getNamedItem("data-anim-prerender") ? pe.getNamedItem("data-anim-prerender").value : pe.getNamedItem("data-bm-prerender") ? pe.getNamedItem("data-bm-prerender").value : pe.getNamedItem("bm-prerender") ? pe.getNamedItem("bm-prerender").value : "";
      be === "false" && (oe.prerender = !1), oe.path ? this.setParams(oe) : this.trigger("destroy");
    }, AnimationItem.prototype.includeLayers = function(L) {
      L.op > this.animationData.op && (this.animationData.op = L.op, this.totalFrames = Math.floor(L.op - this.animationData.ip));
      var ne = this.animationData.layers, oe, pe = ne.length, me = L.layers, ge, be = me.length;
      for (ge = 0; ge < be; ge += 1)
        for (oe = 0; oe < pe; ) {
          if (ne[oe].id === me[ge].id) {
            ne[oe] = me[ge];
            break;
          }
          oe += 1;
        }
      if ((L.chars || L.fonts) && (this.renderer.globalData.fontManager.addChars(L.chars), this.renderer.globalData.fontManager.addFonts(L.fonts, this.renderer.globalData.defs)), L.assets)
        for (pe = L.assets.length, oe = 0; oe < pe; oe += 1)
          this.animationData.assets.push(L.assets[oe]);
      this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    }, AnimationItem.prototype.onSegmentComplete = function(L) {
      this.animationData = L;
      var ne = getExpressionsPlugin();
      ne && ne.initExpressions(this), this.loadNextSegment();
    }, AnimationItem.prototype.loadNextSegment = function() {
      var L = this.animationData.segments;
      if (!L || L.length === 0 || !this.autoloadSegments) {
        this.trigger("data_ready"), this.timeCompleted = this.totalFrames;
        return;
      }
      var ne = L.shift();
      this.timeCompleted = ne.time * this.frameRate;
      var oe = this.path + this.fileName + "_" + this.segmentPos + ".json";
      this.segmentPos += 1, dataManager.loadData(oe, this.includeLayers.bind(this), (function() {
        this.trigger("data_failed");
      }).bind(this));
    }, AnimationItem.prototype.loadSegments = function() {
      var L = this.animationData.segments;
      L || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
    }, AnimationItem.prototype.imagesLoaded = function() {
      this.trigger("loaded_images"), this.checkLoaded();
    }, AnimationItem.prototype.preloadImages = function() {
      this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    }, AnimationItem.prototype.configAnimation = function(L) {
      if (this.renderer)
        try {
          this.animationData = L, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(L), L.assets || (L.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(L.assets), this.markers = markerParser(L.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause();
        } catch (ne) {
          this.triggerConfigError(ne);
        }
    }, AnimationItem.prototype.waitForFontsLoaded = function() {
      this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20));
    }, AnimationItem.prototype.checkLoaded = function() {
      if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
        this.isLoaded = !0;
        var L = getExpressionsPlugin();
        L && L.initExpressions(this), this.renderer.initItems(), setTimeout((function() {
          this.trigger("DOMLoaded");
        }).bind(this), 0), this.gotoFrame(), this.autoplay && this.play();
      }
    }, AnimationItem.prototype.resize = function(L, ne) {
      var oe = typeof L == "number" ? L : void 0, pe = typeof ne == "number" ? ne : void 0;
      this.renderer.updateContainerSize(oe, pe);
    }, AnimationItem.prototype.setSubframe = function(L) {
      this.isSubframeEnabled = !!L;
    }, AnimationItem.prototype.gotoFrame = function() {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame");
    }, AnimationItem.prototype.renderFrame = function() {
      if (!(this.isLoaded === !1 || !this.renderer))
        try {
          this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (L) {
          this.triggerRenderFrameError(L);
        }
    }, AnimationItem.prototype.play = function(L) {
      L && this.name !== L || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")));
    }, AnimationItem.prototype.pause = function(L) {
      L && this.name !== L || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause());
    }, AnimationItem.prototype.togglePause = function(L) {
      L && this.name !== L || (this.isPaused === !0 ? this.play() : this.pause());
    }, AnimationItem.prototype.stop = function(L) {
      L && this.name !== L || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0));
    }, AnimationItem.prototype.getMarkerData = function(L) {
      for (var ne, oe = 0; oe < this.markers.length; oe += 1)
        if (ne = this.markers[oe], ne.payload && ne.payload.name === L)
          return ne;
      return null;
    }, AnimationItem.prototype.goToAndStop = function(L, ne, oe) {
      if (!(oe && this.name !== oe)) {
        var pe = Number(L);
        if (isNaN(pe)) {
          var me = this.getMarkerData(L);
          me && this.goToAndStop(me.time, !0);
        } else
          ne ? this.setCurrentRawFrameValue(L) : this.setCurrentRawFrameValue(L * this.frameModifier);
        this.pause();
      }
    }, AnimationItem.prototype.goToAndPlay = function(L, ne, oe) {
      if (!(oe && this.name !== oe)) {
        var pe = Number(L);
        if (isNaN(pe)) {
          var me = this.getMarkerData(L);
          me && (me.duration ? this.playSegments([me.time, me.time + me.duration], !0) : this.goToAndStop(me.time, !0));
        } else
          this.goToAndStop(pe, ne, oe);
        this.play();
      }
    }, AnimationItem.prototype.advanceTime = function(L) {
      if (!(this.isPaused === !0 || this.isLoaded === !1)) {
        var ne = this.currentRawFrame + L * this.frameModifier, oe = !1;
        ne >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(ne > this.totalFrames ? ne % this.totalFrames : 0) || (oe = !0, ne = this.totalFrames - 1) : ne >= this.totalFrames ? (this.playCount += 1, this.checkSegments(ne % this.totalFrames) || (this.setCurrentRawFrameValue(ne % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(ne) : ne < 0 ? this.checkSegments(ne % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + ne % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (oe = !0, ne = 0)) : this.setCurrentRawFrameValue(ne), oe && (this.setCurrentRawFrameValue(ne), this.pause(), this.trigger("complete"));
      }
    }, AnimationItem.prototype.adjustSegment = function(L, ne) {
      this.playCount = 0, L[1] < L[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = L[0] - L[1], this.timeCompleted = this.totalFrames, this.firstFrame = L[1], this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - ne)) : L[1] > L[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = L[1] - L[0], this.timeCompleted = this.totalFrames, this.firstFrame = L[0], this.setCurrentRawFrameValue(1e-3 + ne)), this.trigger("segmentStart");
    }, AnimationItem.prototype.setSegment = function(L, ne) {
      var oe = -1;
      this.isPaused && (this.currentRawFrame + this.firstFrame < L ? oe = L : this.currentRawFrame + this.firstFrame > ne && (oe = ne - L)), this.firstFrame = L, this.totalFrames = ne - L, this.timeCompleted = this.totalFrames, oe !== -1 && this.goToAndStop(oe, !0);
    }, AnimationItem.prototype.playSegments = function(L, ne) {
      if (ne && (this.segments.length = 0), _typeof$4(L[0]) === "object") {
        var oe, pe = L.length;
        for (oe = 0; oe < pe; oe += 1)
          this.segments.push(L[oe]);
      } else
        this.segments.push(L);
      this.segments.length && ne && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play();
    }, AnimationItem.prototype.resetSegments = function(L) {
      this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), L && this.checkSegments(0);
    }, AnimationItem.prototype.checkSegments = function(L) {
      return this.segments.length ? (this.adjustSegment(this.segments.shift(), L), !0) : !1;
    }, AnimationItem.prototype.destroy = function(L) {
      L && this.name !== L || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null);
    }, AnimationItem.prototype.setCurrentRawFrameValue = function(L) {
      this.currentRawFrame = L, this.gotoFrame();
    }, AnimationItem.prototype.setSpeed = function(L) {
      this.playSpeed = L, this.updaFrameModifier();
    }, AnimationItem.prototype.setDirection = function(L) {
      this.playDirection = L < 0 ? -1 : 1, this.updaFrameModifier();
    }, AnimationItem.prototype.setLoop = function(L) {
      this.loop = L;
    }, AnimationItem.prototype.setVolume = function(L, ne) {
      ne && this.name !== ne || this.audioController.setVolume(L);
    }, AnimationItem.prototype.getVolume = function() {
      return this.audioController.getVolume();
    }, AnimationItem.prototype.mute = function(L) {
      L && this.name !== L || this.audioController.mute();
    }, AnimationItem.prototype.unmute = function(L) {
      L && this.name !== L || this.audioController.unmute();
    }, AnimationItem.prototype.updaFrameModifier = function() {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection);
    }, AnimationItem.prototype.getPath = function() {
      return this.path;
    }, AnimationItem.prototype.getAssetsPath = function(L) {
      var ne = "";
      if (L.e)
        ne = L.p;
      else if (this.assetsPath) {
        var oe = L.p;
        oe.indexOf("images/") !== -1 && (oe = oe.split("/")[1]), ne = this.assetsPath + oe;
      } else
        ne = this.path, ne += L.u ? L.u : "", ne += L.p;
      return ne;
    }, AnimationItem.prototype.getAssetData = function(L) {
      for (var ne = 0, oe = this.assets.length; ne < oe; ) {
        if (L === this.assets[ne].id)
          return this.assets[ne];
        ne += 1;
      }
      return null;
    }, AnimationItem.prototype.hide = function() {
      this.renderer.hide();
    }, AnimationItem.prototype.show = function() {
      this.renderer.show();
    }, AnimationItem.prototype.getDuration = function(L) {
      return L ? this.totalFrames : this.totalFrames / this.frameRate;
    }, AnimationItem.prototype.updateDocumentData = function(L, ne, oe) {
      try {
        var pe = this.renderer.getElementByPath(L);
        pe.updateDocumentData(ne, oe);
      } catch {
      }
    }, AnimationItem.prototype.trigger = function(L) {
      if (this._cbs && this._cbs[L])
        switch (L) {
          case "enterFrame":
            this.triggerEvent(L, new BMEnterFrameEvent(L, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case "drawnFrame":
            this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(L, this.drawnFrameEvent);
            break;
          case "loopComplete":
            this.triggerEvent(L, new BMCompleteLoopEvent(L, this.loop, this.playCount, this.frameMult));
            break;
          case "complete":
            this.triggerEvent(L, new BMCompleteEvent(L, this.frameMult));
            break;
          case "segmentStart":
            this.triggerEvent(L, new BMSegmentStartEvent(L, this.firstFrame, this.totalFrames));
            break;
          case "destroy":
            this.triggerEvent(L, new BMDestroyEvent(L, this));
            break;
          default:
            this.triggerEvent(L);
        }
      L === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(L, this.currentFrame, this.totalFrames, this.frameMult)), L === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(L, this.loop, this.playCount, this.frameMult)), L === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(L, this.frameMult)), L === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(L, this.firstFrame, this.totalFrames)), L === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(L, this));
    }, AnimationItem.prototype.triggerRenderFrameError = function(L) {
      var ne = new BMRenderFrameErrorEvent(L, this.currentFrame);
      this.triggerEvent("error", ne), this.onError && this.onError.call(this, ne);
    }, AnimationItem.prototype.triggerConfigError = function(L) {
      var ne = new BMConfigErrorEvent(L, this.currentFrame);
      this.triggerEvent("error", ne), this.onError && this.onError.call(this, ne);
    };
    var animationManager = function() {
      var L = {}, ne = [], oe = 0, pe = 0, me = 0, ge = !0, be = !1;
      function Ie(wt) {
        for (var Ft = 0, yt = wt.target; Ft < pe; )
          ne[Ft].animation === yt && (ne.splice(Ft, 1), Ft -= 1, pe -= 1, yt.isPaused || dt()), Ft += 1;
      }
      function Ae(wt, Ft) {
        if (!wt)
          return null;
        for (var yt = 0; yt < pe; ) {
          if (ne[yt].elem === wt && ne[yt].elem !== null)
            return ne[yt].animation;
          yt += 1;
        }
        var Et = new AnimationItem();
        return lt(Et, wt), Et.setData(wt, Ft), Et;
      }
      function rt() {
        var wt, Ft = ne.length, yt = [];
        for (wt = 0; wt < Ft; wt += 1)
          yt.push(ne[wt].animation);
        return yt;
      }
      function st() {
        me += 1, ir();
      }
      function dt() {
        me -= 1;
      }
      function lt(wt, Ft) {
        wt.addEventListener("destroy", Ie), wt.addEventListener("_active", st), wt.addEventListener("_idle", dt), ne.push({
          elem: Ft,
          animation: wt
        }), pe += 1;
      }
      function pt(wt) {
        var Ft = new AnimationItem();
        return lt(Ft, null), Ft.setParams(wt), Ft;
      }
      function it(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setSpeed(wt, Ft);
      }
      function ut(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setDirection(wt, Ft);
      }
      function St(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.play(wt);
      }
      function ot(wt) {
        var Ft = wt - oe, yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.advanceTime(Ft);
        oe = wt, me && !be ? window.requestAnimationFrame(ot) : ge = !0;
      }
      function ht(wt) {
        oe = wt, window.requestAnimationFrame(ot);
      }
      function ft(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.pause(wt);
      }
      function vt(wt, Ft, yt) {
        var Et;
        for (Et = 0; Et < pe; Et += 1)
          ne[Et].animation.goToAndStop(wt, Ft, yt);
      }
      function Ct(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.stop(wt);
      }
      function xt(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.togglePause(wt);
      }
      function At(wt) {
        var Ft;
        for (Ft = pe - 1; Ft >= 0; Ft -= 1)
          ne[Ft].animation.destroy(wt);
      }
      function kt(wt, Ft, yt) {
        var Et = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Dt, Ot = Et.length;
        for (Dt = 0; Dt < Ot; Dt += 1)
          yt && Et[Dt].setAttribute("data-bm-type", yt), Ae(Et[Dt], wt);
        if (Ft && Ot === 0) {
          yt || (yt = "svg");
          var nr = document.getElementsByTagName("body")[0];
          nr.innerText = "";
          var vr = createTag("div");
          vr.style.width = "100%", vr.style.height = "100%", vr.setAttribute("data-bm-type", yt), nr.appendChild(vr), Ae(vr, wt);
        }
      }
      function Vt() {
        var wt;
        for (wt = 0; wt < pe; wt += 1)
          ne[wt].animation.resize();
      }
      function ir() {
        !be && me && ge && (window.requestAnimationFrame(ht), ge = !1);
      }
      function er() {
        be = !0;
      }
      function Yt() {
        be = !1, ir();
      }
      function Jt(wt, Ft) {
        var yt;
        for (yt = 0; yt < pe; yt += 1)
          ne[yt].animation.setVolume(wt, Ft);
      }
      function rr(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.mute(wt);
      }
      function Qt(wt) {
        var Ft;
        for (Ft = 0; Ft < pe; Ft += 1)
          ne[Ft].animation.unmute(wt);
      }
      return L.registerAnimation = Ae, L.loadAnimation = pt, L.setSpeed = it, L.setDirection = ut, L.play = St, L.pause = ft, L.stop = Ct, L.togglePause = xt, L.searchAnimations = kt, L.resize = Vt, L.goToAndStop = vt, L.destroy = At, L.freeze = er, L.unfreeze = Yt, L.setVolume = Jt, L.mute = rr, L.unmute = Qt, L.getRegisteredAnimations = rt, L;
    }(), BezierFactory = function() {
      var L = {};
      L.getBezierEasing = oe;
      var ne = {};
      function oe(ht, ft, vt, Ct, xt) {
        var At = xt || ("bez_" + ht + "_" + ft + "_" + vt + "_" + Ct).replace(/\./g, "p");
        if (ne[At])
          return ne[At];
        var kt = new ot([ht, ft, vt, Ct]);
        return ne[At] = kt, kt;
      }
      var pe = 4, me = 1e-3, ge = 1e-7, be = 10, Ie = 11, Ae = 1 / (Ie - 1), rt = typeof Float32Array == "function";
      function st(ht, ft) {
        return 1 - 3 * ft + 3 * ht;
      }
      function dt(ht, ft) {
        return 3 * ft - 6 * ht;
      }
      function lt(ht) {
        return 3 * ht;
      }
      function pt(ht, ft, vt) {
        return ((st(ft, vt) * ht + dt(ft, vt)) * ht + lt(ft)) * ht;
      }
      function it(ht, ft, vt) {
        return 3 * st(ft, vt) * ht * ht + 2 * dt(ft, vt) * ht + lt(ft);
      }
      function ut(ht, ft, vt, Ct, xt) {
        var At, kt, Vt = 0;
        do
          kt = ft + (vt - ft) / 2, At = pt(kt, Ct, xt) - ht, At > 0 ? vt = kt : ft = kt;
        while (Math.abs(At) > ge && ++Vt < be);
        return kt;
      }
      function St(ht, ft, vt, Ct) {
        for (var xt = 0; xt < pe; ++xt) {
          var At = it(ft, vt, Ct);
          if (At === 0)
            return ft;
          var kt = pt(ft, vt, Ct) - ht;
          ft -= kt / At;
        }
        return ft;
      }
      function ot(ht) {
        this._p = ht, this._mSampleValues = rt ? new Float32Array(Ie) : new Array(Ie), this._precomputed = !1, this.get = this.get.bind(this);
      }
      return ot.prototype = {
        get: function(ft) {
          var vt = this._p[0], Ct = this._p[1], xt = this._p[2], At = this._p[3];
          return this._precomputed || this._precompute(), vt === Ct && xt === At ? ft : ft === 0 ? 0 : ft === 1 ? 1 : pt(this._getTForX(ft), Ct, At);
        },
        // Private part
        _precompute: function() {
          var ft = this._p[0], vt = this._p[1], Ct = this._p[2], xt = this._p[3];
          this._precomputed = !0, (ft !== vt || Ct !== xt) && this._calcSampleValues();
        },
        _calcSampleValues: function() {
          for (var ft = this._p[0], vt = this._p[2], Ct = 0; Ct < Ie; ++Ct)
            this._mSampleValues[Ct] = pt(Ct * Ae, ft, vt);
        },
        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function(ft) {
          for (var vt = this._p[0], Ct = this._p[2], xt = this._mSampleValues, At = 0, kt = 1, Vt = Ie - 1; kt !== Vt && xt[kt] <= ft; ++kt)
            At += Ae;
          --kt;
          var ir = (ft - xt[kt]) / (xt[kt + 1] - xt[kt]), er = At + ir * Ae, Yt = it(er, vt, Ct);
          return Yt >= me ? St(ft, er, vt, Ct) : Yt === 0 ? er : ut(ft, At, At + Ae, vt, Ct);
        }
      }, L;
    }(), pooling = /* @__PURE__ */ function() {
      function L(ne) {
        return ne.concat(createSizedArray(ne.length));
      }
      return {
        double: L
      };
    }(), poolFactory = /* @__PURE__ */ function() {
      return function(L, ne, oe) {
        var pe = 0, me = L, ge = createSizedArray(me), be = {
          newElement: Ie,
          release: Ae
        };
        function Ie() {
          var rt;
          return pe ? (pe -= 1, rt = ge[pe]) : rt = ne(), rt;
        }
        function Ae(rt) {
          pe === me && (ge = pooling.double(ge), me *= 2), oe && oe(rt), ge[pe] = rt, pe += 1;
        }
        return be;
      };
    }(), bezierLengthPool = function() {
      function L() {
        return {
          addedLength: 0,
          percents: createTypedArray("float32", getDefaultCurveSegments()),
          lengths: createTypedArray("float32", getDefaultCurveSegments())
        };
      }
      return poolFactory(8, L);
    }(), segmentsLengthPool = function() {
      function L() {
        return {
          lengths: [],
          totalLength: 0
        };
      }
      function ne(oe) {
        var pe, me = oe.lengths.length;
        for (pe = 0; pe < me; pe += 1)
          bezierLengthPool.release(oe.lengths[pe]);
        oe.lengths.length = 0;
      }
      return poolFactory(8, L, ne);
    }();
    function bezFunction() {
      var L = Math;
      function ne(lt, pt, it, ut, St, ot) {
        var ht = lt * ut + pt * St + it * ot - St * ut - ot * lt - it * pt;
        return ht > -1e-3 && ht < 1e-3;
      }
      function oe(lt, pt, it, ut, St, ot, ht, ft, vt) {
        if (it === 0 && ot === 0 && vt === 0)
          return ne(lt, pt, ut, St, ht, ft);
        var Ct = L.sqrt(L.pow(ut - lt, 2) + L.pow(St - pt, 2) + L.pow(ot - it, 2)), xt = L.sqrt(L.pow(ht - lt, 2) + L.pow(ft - pt, 2) + L.pow(vt - it, 2)), At = L.sqrt(L.pow(ht - ut, 2) + L.pow(ft - St, 2) + L.pow(vt - ot, 2)), kt;
        return Ct > xt ? Ct > At ? kt = Ct - xt - At : kt = At - xt - Ct : At > xt ? kt = At - xt - Ct : kt = xt - Ct - At, kt > -1e-4 && kt < 1e-4;
      }
      var pe = /* @__PURE__ */ function() {
        return function(lt, pt, it, ut) {
          var St = getDefaultCurveSegments(), ot, ht, ft, vt, Ct, xt = 0, At, kt = [], Vt = [], ir = bezierLengthPool.newElement();
          for (ft = it.length, ot = 0; ot < St; ot += 1) {
            for (Ct = ot / (St - 1), At = 0, ht = 0; ht < ft; ht += 1)
              vt = bmPow(1 - Ct, 3) * lt[ht] + 3 * bmPow(1 - Ct, 2) * Ct * it[ht] + 3 * (1 - Ct) * bmPow(Ct, 2) * ut[ht] + bmPow(Ct, 3) * pt[ht], kt[ht] = vt, Vt[ht] !== null && (At += bmPow(kt[ht] - Vt[ht], 2)), Vt[ht] = kt[ht];
            At && (At = bmSqrt(At), xt += At), ir.percents[ot] = Ct, ir.lengths[ot] = xt;
          }
          return ir.addedLength = xt, ir;
        };
      }();
      function me(lt) {
        var pt = segmentsLengthPool.newElement(), it = lt.c, ut = lt.v, St = lt.o, ot = lt.i, ht, ft = lt._length, vt = pt.lengths, Ct = 0;
        for (ht = 0; ht < ft - 1; ht += 1)
          vt[ht] = pe(ut[ht], ut[ht + 1], St[ht], ot[ht + 1]), Ct += vt[ht].addedLength;
        return it && ft && (vt[ht] = pe(ut[ht], ut[0], St[ht], ot[0]), Ct += vt[ht].addedLength), pt.totalLength = Ct, pt;
      }
      function ge(lt) {
        this.segmentLength = 0, this.points = new Array(lt);
      }
      function be(lt, pt) {
        this.partialLength = lt, this.point = pt;
      }
      var Ie = /* @__PURE__ */ function() {
        var lt = {};
        return function(pt, it, ut, St) {
          var ot = (pt[0] + "_" + pt[1] + "_" + it[0] + "_" + it[1] + "_" + ut[0] + "_" + ut[1] + "_" + St[0] + "_" + St[1]).replace(/\./g, "p");
          if (!lt[ot]) {
            var ht = getDefaultCurveSegments(), ft, vt, Ct, xt, At, kt = 0, Vt, ir, er = null;
            pt.length === 2 && (pt[0] !== it[0] || pt[1] !== it[1]) && ne(pt[0], pt[1], it[0], it[1], pt[0] + ut[0], pt[1] + ut[1]) && ne(pt[0], pt[1], it[0], it[1], it[0] + St[0], it[1] + St[1]) && (ht = 2);
            var Yt = new ge(ht);
            for (Ct = ut.length, ft = 0; ft < ht; ft += 1) {
              for (ir = createSizedArray(Ct), At = ft / (ht - 1), Vt = 0, vt = 0; vt < Ct; vt += 1)
                xt = bmPow(1 - At, 3) * pt[vt] + 3 * bmPow(1 - At, 2) * At * (pt[vt] + ut[vt]) + 3 * (1 - At) * bmPow(At, 2) * (it[vt] + St[vt]) + bmPow(At, 3) * it[vt], ir[vt] = xt, er !== null && (Vt += bmPow(ir[vt] - er[vt], 2));
              Vt = bmSqrt(Vt), kt += Vt, Yt.points[ft] = new be(Vt, ir), er = ir;
            }
            Yt.segmentLength = kt, lt[ot] = Yt;
          }
          return lt[ot];
        };
      }();
      function Ae(lt, pt) {
        var it = pt.percents, ut = pt.lengths, St = it.length, ot = bmFloor((St - 1) * lt), ht = lt * pt.addedLength, ft = 0;
        if (ot === St - 1 || ot === 0 || ht === ut[ot])
          return it[ot];
        for (var vt = ut[ot] > ht ? -1 : 1, Ct = !0; Ct; )
          if (ut[ot] <= ht && ut[ot + 1] > ht ? (ft = (ht - ut[ot]) / (ut[ot + 1] - ut[ot]), Ct = !1) : ot += vt, ot < 0 || ot >= St - 1) {
            if (ot === St - 1)
              return it[ot];
            Ct = !1;
          }
        return it[ot] + (it[ot + 1] - it[ot]) * ft;
      }
      function rt(lt, pt, it, ut, St, ot) {
        var ht = Ae(St, ot), ft = 1 - ht, vt = L.round((ft * ft * ft * lt[0] + (ht * ft * ft + ft * ht * ft + ft * ft * ht) * it[0] + (ht * ht * ft + ft * ht * ht + ht * ft * ht) * ut[0] + ht * ht * ht * pt[0]) * 1e3) / 1e3, Ct = L.round((ft * ft * ft * lt[1] + (ht * ft * ft + ft * ht * ft + ft * ft * ht) * it[1] + (ht * ht * ft + ft * ht * ht + ht * ft * ht) * ut[1] + ht * ht * ht * pt[1]) * 1e3) / 1e3;
        return [vt, Ct];
      }
      var st = createTypedArray("float32", 8);
      function dt(lt, pt, it, ut, St, ot, ht) {
        St < 0 ? St = 0 : St > 1 && (St = 1);
        var ft = Ae(St, ht);
        ot = ot > 1 ? 1 : ot;
        var vt = Ae(ot, ht), Ct, xt = lt.length, At = 1 - ft, kt = 1 - vt, Vt = At * At * At, ir = ft * At * At * 3, er = ft * ft * At * 3, Yt = ft * ft * ft, Jt = At * At * kt, rr = ft * At * kt + At * ft * kt + At * At * vt, Qt = ft * ft * kt + At * ft * vt + ft * At * vt, wt = ft * ft * vt, Ft = At * kt * kt, yt = ft * kt * kt + At * vt * kt + At * kt * vt, Et = ft * vt * kt + At * vt * vt + ft * kt * vt, Dt = ft * vt * vt, Ot = kt * kt * kt, nr = vt * kt * kt + kt * vt * kt + kt * kt * vt, vr = vt * vt * kt + kt * vt * vt + vt * kt * vt, pr = vt * vt * vt;
        for (Ct = 0; Ct < xt; Ct += 1)
          st[Ct * 4] = L.round((Vt * lt[Ct] + ir * it[Ct] + er * ut[Ct] + Yt * pt[Ct]) * 1e3) / 1e3, st[Ct * 4 + 1] = L.round((Jt * lt[Ct] + rr * it[Ct] + Qt * ut[Ct] + wt * pt[Ct]) * 1e3) / 1e3, st[Ct * 4 + 2] = L.round((Ft * lt[Ct] + yt * it[Ct] + Et * ut[Ct] + Dt * pt[Ct]) * 1e3) / 1e3, st[Ct * 4 + 3] = L.round((Ot * lt[Ct] + nr * it[Ct] + vr * ut[Ct] + pr * pt[Ct]) * 1e3) / 1e3;
        return st;
      }
      return {
        getSegmentsLength: me,
        getNewSegment: dt,
        getPointInSegment: rt,
        buildBezierData: Ie,
        pointOnLine2D: ne,
        pointOnLine3D: oe
      };
    }
    var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs;
    function interpolateValue(L, ne) {
      var oe = this.offsetTime, pe;
      this.propType === "multidimensional" && (pe = createTypedArray("float32", this.pv.length));
      for (var me = ne.lastIndex, ge = me, be = this.keyframes.length - 1, Ie = !0, Ae, rt, st; Ie; ) {
        if (Ae = this.keyframes[ge], rt = this.keyframes[ge + 1], ge === be - 1 && L >= rt.t - oe) {
          Ae.h && (Ae = rt), me = 0;
          break;
        }
        if (rt.t - oe > L) {
          me = ge;
          break;
        }
        ge < be - 1 ? ge += 1 : (me = 0, Ie = !1);
      }
      st = this.keyframesMetadata[ge] || {};
      var dt, lt, pt, it, ut, St, ot = rt.t - oe, ht = Ae.t - oe, ft;
      if (Ae.to) {
        st.bezierData || (st.bezierData = bez.buildBezierData(Ae.s, rt.s || Ae.e, Ae.to, Ae.ti));
        var vt = st.bezierData;
        if (L >= ot || L < ht) {
          var Ct = L >= ot ? vt.points.length - 1 : 0;
          for (lt = vt.points[Ct].point.length, dt = 0; dt < lt; dt += 1)
            pe[dt] = vt.points[Ct].point[dt];
        } else {
          st.__fnct ? St = st.__fnct : (St = BezierFactory.getBezierEasing(Ae.o.x, Ae.o.y, Ae.i.x, Ae.i.y, Ae.n).get, st.__fnct = St), pt = St((L - ht) / (ot - ht));
          var xt = vt.segmentLength * pt, At, kt = ne.lastFrame < L && ne._lastKeyframeIndex === ge ? ne._lastAddedLength : 0;
          for (ut = ne.lastFrame < L && ne._lastKeyframeIndex === ge ? ne._lastPoint : 0, Ie = !0, it = vt.points.length; Ie; ) {
            if (kt += vt.points[ut].partialLength, xt === 0 || pt === 0 || ut === vt.points.length - 1) {
              for (lt = vt.points[ut].point.length, dt = 0; dt < lt; dt += 1)
                pe[dt] = vt.points[ut].point[dt];
              break;
            } else if (xt >= kt && xt < kt + vt.points[ut + 1].partialLength) {
              for (At = (xt - kt) / vt.points[ut + 1].partialLength, lt = vt.points[ut].point.length, dt = 0; dt < lt; dt += 1)
                pe[dt] = vt.points[ut].point[dt] + (vt.points[ut + 1].point[dt] - vt.points[ut].point[dt]) * At;
              break;
            }
            ut < it - 1 ? ut += 1 : Ie = !1;
          }
          ne._lastPoint = ut, ne._lastAddedLength = kt - vt.points[ut].partialLength, ne._lastKeyframeIndex = ge;
        }
      } else {
        var Vt, ir, er, Yt, Jt;
        if (be = Ae.s.length, ft = rt.s || Ae.e, this.sh && Ae.h !== 1)
          if (L >= ot)
            pe[0] = ft[0], pe[1] = ft[1], pe[2] = ft[2];
          else if (L <= ht)
            pe[0] = Ae.s[0], pe[1] = Ae.s[1], pe[2] = Ae.s[2];
          else {
            var rr = createQuaternion(Ae.s), Qt = createQuaternion(ft), wt = (L - ht) / (ot - ht);
            quaternionToEuler(pe, slerp(rr, Qt, wt));
          }
        else
          for (ge = 0; ge < be; ge += 1)
            Ae.h !== 1 && (L >= ot ? pt = 1 : L < ht ? pt = 0 : (Ae.o.x.constructor === Array ? (st.__fnct || (st.__fnct = []), st.__fnct[ge] ? St = st.__fnct[ge] : (Vt = Ae.o.x[ge] === void 0 ? Ae.o.x[0] : Ae.o.x[ge], ir = Ae.o.y[ge] === void 0 ? Ae.o.y[0] : Ae.o.y[ge], er = Ae.i.x[ge] === void 0 ? Ae.i.x[0] : Ae.i.x[ge], Yt = Ae.i.y[ge] === void 0 ? Ae.i.y[0] : Ae.i.y[ge], St = BezierFactory.getBezierEasing(Vt, ir, er, Yt).get, st.__fnct[ge] = St)) : st.__fnct ? St = st.__fnct : (Vt = Ae.o.x, ir = Ae.o.y, er = Ae.i.x, Yt = Ae.i.y, St = BezierFactory.getBezierEasing(Vt, ir, er, Yt).get, Ae.keyframeMetadata = St), pt = St((L - ht) / (ot - ht)))), ft = rt.s || Ae.e, Jt = Ae.h === 1 ? Ae.s[ge] : Ae.s[ge] + (ft[ge] - Ae.s[ge]) * pt, this.propType === "multidimensional" ? pe[ge] = Jt : pe = Jt;
      }
      return ne.lastIndex = me, pe;
    }
    function slerp(L, ne, oe) {
      var pe = [], me = L[0], ge = L[1], be = L[2], Ie = L[3], Ae = ne[0], rt = ne[1], st = ne[2], dt = ne[3], lt, pt, it, ut, St;
      return pt = me * Ae + ge * rt + be * st + Ie * dt, pt < 0 && (pt = -pt, Ae = -Ae, rt = -rt, st = -st, dt = -dt), 1 - pt > 1e-6 ? (lt = Math.acos(pt), it = Math.sin(lt), ut = Math.sin((1 - oe) * lt) / it, St = Math.sin(oe * lt) / it) : (ut = 1 - oe, St = oe), pe[0] = ut * me + St * Ae, pe[1] = ut * ge + St * rt, pe[2] = ut * be + St * st, pe[3] = ut * Ie + St * dt, pe;
    }
    function quaternionToEuler(L, ne) {
      var oe = ne[0], pe = ne[1], me = ne[2], ge = ne[3], be = Math.atan2(2 * pe * ge - 2 * oe * me, 1 - 2 * pe * pe - 2 * me * me), Ie = Math.asin(2 * oe * pe + 2 * me * ge), Ae = Math.atan2(2 * oe * ge - 2 * pe * me, 1 - 2 * oe * oe - 2 * me * me);
      L[0] = be / degToRads, L[1] = Ie / degToRads, L[2] = Ae / degToRads;
    }
    function createQuaternion(L) {
      var ne = L[0] * degToRads, oe = L[1] * degToRads, pe = L[2] * degToRads, me = Math.cos(ne / 2), ge = Math.cos(oe / 2), be = Math.cos(pe / 2), Ie = Math.sin(ne / 2), Ae = Math.sin(oe / 2), rt = Math.sin(pe / 2), st = me * ge * be - Ie * Ae * rt, dt = Ie * Ae * be + me * ge * rt, lt = Ie * ge * be + me * Ae * rt, pt = me * Ae * be - Ie * ge * rt;
      return [dt, lt, pt, st];
    }
    function getValueAtCurrentTime() {
      var L = this.comp.renderedFrame - this.offsetTime, ne = this.keyframes[0].t - this.offsetTime, oe = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      if (!(L === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= oe && L >= oe || this._caching.lastFrame < ne && L < ne))) {
        this._caching.lastFrame >= L && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
        var pe = this.interpolateValue(L, this._caching);
        this.pv = pe;
      }
      return this._caching.lastFrame = L, this.pv;
    }
    function setVValue(L) {
      var ne;
      if (this.propType === "unidimensional")
        ne = L * this.mult, mathAbs(this.v - ne) > 1e-5 && (this.v = ne, this._mdf = !0);
      else
        for (var oe = 0, pe = this.v.length; oe < pe; )
          ne = L[oe] * this.mult, mathAbs(this.v[oe] - ne) > 1e-5 && (this.v[oe] = ne, this._mdf = !0), oe += 1;
    }
    function processEffectsSequence() {
      if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = !0, this._mdf = this._isFirstFrame;
        var L, ne = this.effectsSequence.length, oe = this.kf ? this.pv : this.data.k;
        for (L = 0; L < ne; L += 1)
          oe = this.effectsSequence[L](oe);
        this.setVValue(oe), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }
    function addEffect(L) {
      this.effectsSequence.push(L), this.container.addDynamicProperty(this);
    }
    function ValueProperty(L, ne, oe, pe) {
      this.propType = "unidimensional", this.mult = oe || 1, this.data = ne, this.v = oe ? ne.k * oe : ne.k, this.pv = ne.k, this._mdf = !1, this.elem = L, this.container = pe, this.comp = L.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function MultiDimensionalProperty(L, ne, oe, pe) {
      this.propType = "multidimensional", this.mult = oe || 1, this.data = ne, this._mdf = !1, this.elem = L, this.container = pe, this.comp = L.comp, this.k = !1, this.kf = !1, this.frameId = -1;
      var me, ge = ne.k.length;
      for (this.v = createTypedArray("float32", ge), this.pv = createTypedArray("float32", ge), this.vel = createTypedArray("float32", ge), me = 0; me < ge; me += 1)
        this.v[me] = ne.k[me] * this.mult, this.pv[me] = ne.k[me];
      this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function KeyframedValueProperty(L, ne, oe, pe) {
      this.propType = "unidimensional", this.keyframes = ne.k, this.keyframesMetadata = [], this.offsetTime = L.data.st, this.frameId = -1, this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      }, this.k = !0, this.kf = !0, this.data = ne, this.mult = oe || 1, this.elem = L, this.container = pe, this.comp = L.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect;
    }
    function KeyframedMultidimensionalProperty(L, ne, oe, pe) {
      this.propType = "multidimensional";
      var me, ge = ne.k.length, be, Ie, Ae, rt;
      for (me = 0; me < ge - 1; me += 1)
        ne.k[me].to && ne.k[me].s && ne.k[me + 1] && ne.k[me + 1].s && (be = ne.k[me].s, Ie = ne.k[me + 1].s, Ae = ne.k[me].to, rt = ne.k[me].ti, (be.length === 2 && !(be[0] === Ie[0] && be[1] === Ie[1]) && bez.pointOnLine2D(be[0], be[1], Ie[0], Ie[1], be[0] + Ae[0], be[1] + Ae[1]) && bez.pointOnLine2D(be[0], be[1], Ie[0], Ie[1], Ie[0] + rt[0], Ie[1] + rt[1]) || be.length === 3 && !(be[0] === Ie[0] && be[1] === Ie[1] && be[2] === Ie[2]) && bez.pointOnLine3D(be[0], be[1], be[2], Ie[0], Ie[1], Ie[2], be[0] + Ae[0], be[1] + Ae[1], be[2] + Ae[2]) && bez.pointOnLine3D(be[0], be[1], be[2], Ie[0], Ie[1], Ie[2], Ie[0] + rt[0], Ie[1] + rt[1], Ie[2] + rt[2])) && (ne.k[me].to = null, ne.k[me].ti = null), be[0] === Ie[0] && be[1] === Ie[1] && Ae[0] === 0 && Ae[1] === 0 && rt[0] === 0 && rt[1] === 0 && (be.length === 2 || be[2] === Ie[2] && Ae[2] === 0 && rt[2] === 0) && (ne.k[me].to = null, ne.k[me].ti = null));
      this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = ne, this.keyframes = ne.k, this.keyframesMetadata = [], this.offsetTime = L.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = oe || 1, this.elem = L, this.container = pe, this.comp = L.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
      var st = ne.k[0].s.length;
      for (this.v = createTypedArray("float32", st), this.pv = createTypedArray("float32", st), me = 0; me < st; me += 1)
        this.v[me] = initFrame, this.pv[me] = initFrame;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray("float32", st)
      }, this.addEffect = addEffect;
    }
    var PropertyFactory = /* @__PURE__ */ function() {
      function L(oe, pe, me, ge, be) {
        pe.sid && (pe = oe.globalData.slotManager.getProp(pe));
        var Ie;
        if (!pe.k.length)
          Ie = new ValueProperty(oe, pe, ge, be);
        else if (typeof pe.k[0] == "number")
          Ie = new MultiDimensionalProperty(oe, pe, ge, be);
        else
          switch (me) {
            case 0:
              Ie = new KeyframedValueProperty(oe, pe, ge, be);
              break;
            case 1:
              Ie = new KeyframedMultidimensionalProperty(oe, pe, ge, be);
              break;
          }
        return Ie.effectsSequence.length && be.addDynamicProperty(Ie), Ie;
      }
      var ne = {
        getProp: L
      };
      return ne;
    }();
    function DynamicPropertyContainer() {
    }
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function(ne) {
        this.dynamicProperties.indexOf(ne) === -1 && (this.dynamicProperties.push(ne), this.container.addDynamicProperty(this), this._isAnimated = !0);
      },
      iterateDynamicProperties: function() {
        this._mdf = !1;
        var ne, oe = this.dynamicProperties.length;
        for (ne = 0; ne < oe; ne += 1)
          this.dynamicProperties[ne].getValue(), this.dynamicProperties[ne]._mdf && (this._mdf = !0);
      },
      initDynamicPropertyContainer: function(ne) {
        this.container = ne, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1;
      }
    };
    var pointPool = function() {
      function L() {
        return createTypedArray("float32", 2);
      }
      return poolFactory(8, L);
    }();
    function ShapePath() {
      this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function(L, ne) {
      this.c = L, this.setLength(ne);
      for (var oe = 0; oe < ne; )
        this.v[oe] = pointPool.newElement(), this.o[oe] = pointPool.newElement(), this.i[oe] = pointPool.newElement(), oe += 1;
    }, ShapePath.prototype.setLength = function(L) {
      for (; this._maxLength < L; )
        this.doubleArrayLength();
      this._length = L;
    }, ShapePath.prototype.doubleArrayLength = function() {
      this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2;
    }, ShapePath.prototype.setXYAt = function(L, ne, oe, pe, me) {
      var ge;
      switch (this._length = Math.max(this._length, pe + 1), this._length >= this._maxLength && this.doubleArrayLength(), oe) {
        case "v":
          ge = this.v;
          break;
        case "i":
          ge = this.i;
          break;
        case "o":
          ge = this.o;
          break;
        default:
          ge = [];
          break;
      }
      (!ge[pe] || ge[pe] && !me) && (ge[pe] = pointPool.newElement()), ge[pe][0] = L, ge[pe][1] = ne;
    }, ShapePath.prototype.setTripleAt = function(L, ne, oe, pe, me, ge, be, Ie) {
      this.setXYAt(L, ne, "v", be, Ie), this.setXYAt(oe, pe, "o", be, Ie), this.setXYAt(me, ge, "i", be, Ie);
    }, ShapePath.prototype.reverse = function() {
      var L = new ShapePath();
      L.setPathData(this.c, this._length);
      var ne = this.v, oe = this.o, pe = this.i, me = 0;
      this.c && (L.setTripleAt(ne[0][0], ne[0][1], pe[0][0], pe[0][1], oe[0][0], oe[0][1], 0, !1), me = 1);
      var ge = this._length - 1, be = this._length, Ie;
      for (Ie = me; Ie < be; Ie += 1)
        L.setTripleAt(ne[ge][0], ne[ge][1], pe[ge][0], pe[ge][1], oe[ge][0], oe[ge][1], Ie, !1), ge -= 1;
      return L;
    }, ShapePath.prototype.length = function() {
      return this._length;
    };
    var shapePool = function() {
      function L() {
        return new ShapePath();
      }
      function ne(me) {
        var ge = me._length, be;
        for (be = 0; be < ge; be += 1)
          pointPool.release(me.v[be]), pointPool.release(me.i[be]), pointPool.release(me.o[be]), me.v[be] = null, me.i[be] = null, me.o[be] = null;
        me._length = 0, me.c = !1;
      }
      function oe(me) {
        var ge = pe.newElement(), be, Ie = me._length === void 0 ? me.v.length : me._length;
        for (ge.setLength(Ie), ge.c = me.c, be = 0; be < Ie; be += 1)
          ge.setTripleAt(me.v[be][0], me.v[be][1], me.o[be][0], me.o[be][1], me.i[be][0], me.i[be][1], be);
        return ge;
      }
      var pe = poolFactory(4, L, ne);
      return pe.clone = oe, pe;
    }();
    function ShapeCollection() {
      this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function(L) {
      this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = L, this._length += 1;
    }, ShapeCollection.prototype.releaseShapes = function() {
      var L;
      for (L = 0; L < this._length; L += 1)
        shapePool.release(this.shapes[L]);
      this._length = 0;
    };
    var shapeCollectionPool = function() {
      var L = {
        newShapeCollection: me,
        release: ge
      }, ne = 0, oe = 4, pe = createSizedArray(oe);
      function me() {
        var be;
        return ne ? (ne -= 1, be = pe[ne]) : be = new ShapeCollection(), be;
      }
      function ge(be) {
        var Ie, Ae = be._length;
        for (Ie = 0; Ie < Ae; Ie += 1)
          shapePool.release(be.shapes[Ie]);
        be._length = 0, ne === oe && (pe = pooling.double(pe), oe *= 2), pe[ne] = be, ne += 1;
      }
      return L;
    }(), ShapePropertyFactory = function() {
      var L = -999999;
      function ne(ot, ht, ft) {
        var vt = ft.lastIndex, Ct, xt, At, kt, Vt, ir, er, Yt, Jt, rr = this.keyframes;
        if (ot < rr[0].t - this.offsetTime)
          Ct = rr[0].s[0], At = !0, vt = 0;
        else if (ot >= rr[rr.length - 1].t - this.offsetTime)
          Ct = rr[rr.length - 1].s ? rr[rr.length - 1].s[0] : rr[rr.length - 2].e[0], At = !0;
        else {
          for (var Qt = vt, wt = rr.length - 1, Ft = !0, yt, Et, Dt; Ft && (yt = rr[Qt], Et = rr[Qt + 1], !(Et.t - this.offsetTime > ot)); )
            Qt < wt - 1 ? Qt += 1 : Ft = !1;
          if (Dt = this.keyframesMetadata[Qt] || {}, At = yt.h === 1, vt = Qt, !At) {
            if (ot >= Et.t - this.offsetTime)
              Yt = 1;
            else if (ot < yt.t - this.offsetTime)
              Yt = 0;
            else {
              var Ot;
              Dt.__fnct ? Ot = Dt.__fnct : (Ot = BezierFactory.getBezierEasing(yt.o.x, yt.o.y, yt.i.x, yt.i.y).get, Dt.__fnct = Ot), Yt = Ot((ot - (yt.t - this.offsetTime)) / (Et.t - this.offsetTime - (yt.t - this.offsetTime)));
            }
            xt = Et.s ? Et.s[0] : yt.e[0];
          }
          Ct = yt.s[0];
        }
        for (ir = ht._length, er = Ct.i[0].length, ft.lastIndex = vt, kt = 0; kt < ir; kt += 1)
          for (Vt = 0; Vt < er; Vt += 1)
            Jt = At ? Ct.i[kt][Vt] : Ct.i[kt][Vt] + (xt.i[kt][Vt] - Ct.i[kt][Vt]) * Yt, ht.i[kt][Vt] = Jt, Jt = At ? Ct.o[kt][Vt] : Ct.o[kt][Vt] + (xt.o[kt][Vt] - Ct.o[kt][Vt]) * Yt, ht.o[kt][Vt] = Jt, Jt = At ? Ct.v[kt][Vt] : Ct.v[kt][Vt] + (xt.v[kt][Vt] - Ct.v[kt][Vt]) * Yt, ht.v[kt][Vt] = Jt;
      }
      function oe() {
        var ot = this.comp.renderedFrame - this.offsetTime, ht = this.keyframes[0].t - this.offsetTime, ft = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, vt = this._caching.lastFrame;
        return vt !== L && (vt < ht && ot < ht || vt > ft && ot > ft) || (this._caching.lastIndex = vt < ot ? this._caching.lastIndex : 0, this.interpolateShape(ot, this.pv, this._caching)), this._caching.lastFrame = ot, this.pv;
      }
      function pe() {
        this.paths = this.localShapeCollection;
      }
      function me(ot, ht) {
        if (ot._length !== ht._length || ot.c !== ht.c)
          return !1;
        var ft, vt = ot._length;
        for (ft = 0; ft < vt; ft += 1)
          if (ot.v[ft][0] !== ht.v[ft][0] || ot.v[ft][1] !== ht.v[ft][1] || ot.o[ft][0] !== ht.o[ft][0] || ot.o[ft][1] !== ht.o[ft][1] || ot.i[ft][0] !== ht.i[ft][0] || ot.i[ft][1] !== ht.i[ft][1])
            return !1;
        return !0;
      }
      function ge(ot) {
        me(this.v, ot) || (this.v = shapePool.clone(ot), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection);
      }
      function be() {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (!this.effectsSequence.length) {
            this._mdf = !1;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = !0, this._mdf = !1;
          var ot;
          this.kf ? ot = this.pv : this.data.ks ? ot = this.data.ks.k : ot = this.data.pt.k;
          var ht, ft = this.effectsSequence.length;
          for (ht = 0; ht < ft; ht += 1)
            ot = this.effectsSequence[ht](ot);
          this.setVValue(ot), this.lock = !1, this.frameId = this.elem.globalData.frameId;
        }
      }
      function Ie(ot, ht, ft) {
        this.propType = "shape", this.comp = ot.comp, this.container = ot, this.elem = ot, this.data = ht, this.k = !1, this.kf = !1, this._mdf = !1;
        var vt = ft === 3 ? ht.pt.k : ht.ks.k;
        this.v = shapePool.clone(vt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = pe, this.effectsSequence = [];
      }
      function Ae(ot) {
        this.effectsSequence.push(ot), this.container.addDynamicProperty(this);
      }
      Ie.prototype.interpolateShape = ne, Ie.prototype.getValue = be, Ie.prototype.setVValue = ge, Ie.prototype.addEffect = Ae;
      function rt(ot, ht, ft) {
        this.propType = "shape", this.comp = ot.comp, this.elem = ot, this.container = ot, this.offsetTime = ot.data.st, this.keyframes = ft === 3 ? ht.pt.k : ht.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
        var vt = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, vt), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = L, this.reset = pe, this._caching = {
          lastFrame: L,
          lastIndex: 0
        }, this.effectsSequence = [oe.bind(this)];
      }
      rt.prototype.getValue = be, rt.prototype.interpolateShape = ne, rt.prototype.setVValue = ge, rt.prototype.addEffect = Ae;
      var st = function() {
        var ot = roundCorner;
        function ht(ft, vt) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = vt.d, this.elem = ft, this.comp = ft.comp, this.frameId = -1, this.initDynamicPropertyContainer(ft), this.p = PropertyFactory.getProp(ft, vt.p, 1, 0, this), this.s = PropertyFactory.getProp(ft, vt.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath());
        }
        return ht.prototype = {
          reset: pe,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath());
          },
          convertEllToPath: function() {
            var vt = this.p.v[0], Ct = this.p.v[1], xt = this.s.v[0] / 2, At = this.s.v[1] / 2, kt = this.d !== 3, Vt = this.v;
            Vt.v[0][0] = vt, Vt.v[0][1] = Ct - At, Vt.v[1][0] = kt ? vt + xt : vt - xt, Vt.v[1][1] = Ct, Vt.v[2][0] = vt, Vt.v[2][1] = Ct + At, Vt.v[3][0] = kt ? vt - xt : vt + xt, Vt.v[3][1] = Ct, Vt.i[0][0] = kt ? vt - xt * ot : vt + xt * ot, Vt.i[0][1] = Ct - At, Vt.i[1][0] = kt ? vt + xt : vt - xt, Vt.i[1][1] = Ct - At * ot, Vt.i[2][0] = kt ? vt + xt * ot : vt - xt * ot, Vt.i[2][1] = Ct + At, Vt.i[3][0] = kt ? vt - xt : vt + xt, Vt.i[3][1] = Ct + At * ot, Vt.o[0][0] = kt ? vt + xt * ot : vt - xt * ot, Vt.o[0][1] = Ct - At, Vt.o[1][0] = kt ? vt + xt : vt - xt, Vt.o[1][1] = Ct + At * ot, Vt.o[2][0] = kt ? vt - xt * ot : vt + xt * ot, Vt.o[2][1] = Ct + At, Vt.o[3][0] = kt ? vt - xt : vt + xt, Vt.o[3][1] = Ct - At * ot;
          }
        }, extendPrototype([DynamicPropertyContainer], ht), ht;
      }(), dt = function() {
        function ot(ht, ft) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = ht, this.comp = ht.comp, this.data = ft, this.frameId = -1, this.d = ft.d, this.initDynamicPropertyContainer(ht), ft.sy === 1 ? (this.ir = PropertyFactory.getProp(ht, ft.ir, 0, 0, this), this.is = PropertyFactory.getProp(ht, ft.is, 0, 0.01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(ht, ft.pt, 0, 0, this), this.p = PropertyFactory.getProp(ht, ft.p, 1, 0, this), this.r = PropertyFactory.getProp(ht, ft.r, 0, degToRads, this), this.or = PropertyFactory.getProp(ht, ft.or, 0, 0, this), this.os = PropertyFactory.getProp(ht, ft.os, 0, 0.01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath());
        }
        return ot.prototype = {
          reset: pe,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath());
          },
          convertStarToPath: function() {
            var ft = Math.floor(this.pt.v) * 2, vt = Math.PI * 2 / ft, Ct = !0, xt = this.or.v, At = this.ir.v, kt = this.os.v, Vt = this.is.v, ir = 2 * Math.PI * xt / (ft * 2), er = 2 * Math.PI * At / (ft * 2), Yt, Jt, rr, Qt, wt = -Math.PI / 2;
            wt += this.r.v;
            var Ft = this.data.d === 3 ? -1 : 1;
            for (this.v._length = 0, Yt = 0; Yt < ft; Yt += 1) {
              Jt = Ct ? xt : At, rr = Ct ? kt : Vt, Qt = Ct ? ir : er;
              var yt = Jt * Math.cos(wt), Et = Jt * Math.sin(wt), Dt = yt === 0 && Et === 0 ? 0 : Et / Math.sqrt(yt * yt + Et * Et), Ot = yt === 0 && Et === 0 ? 0 : -yt / Math.sqrt(yt * yt + Et * Et);
              yt += +this.p.v[0], Et += +this.p.v[1], this.v.setTripleAt(yt, Et, yt - Dt * Qt * rr * Ft, Et - Ot * Qt * rr * Ft, yt + Dt * Qt * rr * Ft, Et + Ot * Qt * rr * Ft, Yt, !0), Ct = !Ct, wt += vt * Ft;
            }
          },
          convertPolygonToPath: function() {
            var ft = Math.floor(this.pt.v), vt = Math.PI * 2 / ft, Ct = this.or.v, xt = this.os.v, At = 2 * Math.PI * Ct / (ft * 4), kt, Vt = -Math.PI * 0.5, ir = this.data.d === 3 ? -1 : 1;
            for (Vt += this.r.v, this.v._length = 0, kt = 0; kt < ft; kt += 1) {
              var er = Ct * Math.cos(Vt), Yt = Ct * Math.sin(Vt), Jt = er === 0 && Yt === 0 ? 0 : Yt / Math.sqrt(er * er + Yt * Yt), rr = er === 0 && Yt === 0 ? 0 : -er / Math.sqrt(er * er + Yt * Yt);
              er += +this.p.v[0], Yt += +this.p.v[1], this.v.setTripleAt(er, Yt, er - Jt * At * xt * ir, Yt - rr * At * xt * ir, er + Jt * At * xt * ir, Yt + rr * At * xt * ir, kt, !0), Vt += vt * ir;
            }
            this.paths.length = 0, this.paths[0] = this.v;
          }
        }, extendPrototype([DynamicPropertyContainer], ot), ot;
      }(), lt = function() {
        function ot(ht, ft) {
          this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = ht, this.comp = ht.comp, this.frameId = -1, this.d = ft.d, this.initDynamicPropertyContainer(ht), this.p = PropertyFactory.getProp(ht, ft.p, 1, 0, this), this.s = PropertyFactory.getProp(ht, ft.s, 1, 0, this), this.r = PropertyFactory.getProp(ht, ft.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath());
        }
        return ot.prototype = {
          convertRectToPath: function() {
            var ft = this.p.v[0], vt = this.p.v[1], Ct = this.s.v[0] / 2, xt = this.s.v[1] / 2, At = bmMin(Ct, xt, this.r.v), kt = At * (1 - roundCorner);
            this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(ft + Ct, vt - xt + At, ft + Ct, vt - xt + At, ft + Ct, vt - xt + kt, 0, !0), this.v.setTripleAt(ft + Ct, vt + xt - At, ft + Ct, vt + xt - kt, ft + Ct, vt + xt - At, 1, !0), At !== 0 ? (this.v.setTripleAt(ft + Ct - At, vt + xt, ft + Ct - At, vt + xt, ft + Ct - kt, vt + xt, 2, !0), this.v.setTripleAt(ft - Ct + At, vt + xt, ft - Ct + kt, vt + xt, ft - Ct + At, vt + xt, 3, !0), this.v.setTripleAt(ft - Ct, vt + xt - At, ft - Ct, vt + xt - At, ft - Ct, vt + xt - kt, 4, !0), this.v.setTripleAt(ft - Ct, vt - xt + At, ft - Ct, vt - xt + kt, ft - Ct, vt - xt + At, 5, !0), this.v.setTripleAt(ft - Ct + At, vt - xt, ft - Ct + At, vt - xt, ft - Ct + kt, vt - xt, 6, !0), this.v.setTripleAt(ft + Ct - At, vt - xt, ft + Ct - kt, vt - xt, ft + Ct - At, vt - xt, 7, !0)) : (this.v.setTripleAt(ft - Ct, vt + xt, ft - Ct + kt, vt + xt, ft - Ct, vt + xt, 2), this.v.setTripleAt(ft - Ct, vt - xt, ft - Ct, vt - xt + kt, ft - Ct, vt - xt, 3))) : (this.v.setTripleAt(ft + Ct, vt - xt + At, ft + Ct, vt - xt + kt, ft + Ct, vt - xt + At, 0, !0), At !== 0 ? (this.v.setTripleAt(ft + Ct - At, vt - xt, ft + Ct - At, vt - xt, ft + Ct - kt, vt - xt, 1, !0), this.v.setTripleAt(ft - Ct + At, vt - xt, ft - Ct + kt, vt - xt, ft - Ct + At, vt - xt, 2, !0), this.v.setTripleAt(ft - Ct, vt - xt + At, ft - Ct, vt - xt + At, ft - Ct, vt - xt + kt, 3, !0), this.v.setTripleAt(ft - Ct, vt + xt - At, ft - Ct, vt + xt - kt, ft - Ct, vt + xt - At, 4, !0), this.v.setTripleAt(ft - Ct + At, vt + xt, ft - Ct + At, vt + xt, ft - Ct + kt, vt + xt, 5, !0), this.v.setTripleAt(ft + Ct - At, vt + xt, ft + Ct - kt, vt + xt, ft + Ct - At, vt + xt, 6, !0), this.v.setTripleAt(ft + Ct, vt + xt - At, ft + Ct, vt + xt - At, ft + Ct, vt + xt - kt, 7, !0)) : (this.v.setTripleAt(ft - Ct, vt - xt, ft - Ct + kt, vt - xt, ft - Ct, vt - xt, 1, !0), this.v.setTripleAt(ft - Ct, vt + xt, ft - Ct, vt + xt - kt, ft - Ct, vt + xt, 2, !0), this.v.setTripleAt(ft + Ct, vt + xt, ft + Ct - kt, vt + xt, ft + Ct, vt + xt, 3, !0)));
          },
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath());
          },
          reset: pe
        }, extendPrototype([DynamicPropertyContainer], ot), ot;
      }();
      function pt(ot, ht, ft) {
        var vt;
        if (ft === 3 || ft === 4) {
          var Ct = ft === 3 ? ht.pt : ht.ks, xt = Ct.k;
          xt.length ? vt = new rt(ot, ht, ft) : vt = new Ie(ot, ht, ft);
        } else
          ft === 5 ? vt = new lt(ot, ht) : ft === 6 ? vt = new st(ot, ht) : ft === 7 && (vt = new dt(ot, ht));
        return vt.k && ot.addDynamicProperty(vt), vt;
      }
      function it() {
        return Ie;
      }
      function ut() {
        return rt;
      }
      var St = {};
      return St.getShapeProp = pt, St.getConstructorFunction = it, St.getKeyframedConstructorFunction = ut, St;
    }();
    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */
    var Matrix = /* @__PURE__ */ function() {
      var L = Math.cos, ne = Math.sin, oe = Math.tan, pe = Math.round;
      function me() {
        return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this;
      }
      function ge(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function be(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(1, 0, 0, 0, 0, Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1);
      }
      function Ie(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, 0, Dt, 0, 0, 1, 0, 0, -Dt, 0, Et, 0, 0, 0, 0, 1);
      }
      function Ae(yt) {
        if (yt === 0)
          return this;
        var Et = L(yt), Dt = ne(yt);
        return this._t(Et, -Dt, 0, 0, Dt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function rt(yt, Et) {
        return this._t(1, Et, yt, 1, 0, 0);
      }
      function st(yt, Et) {
        return this.shear(oe(yt), oe(Et));
      }
      function dt(yt, Et) {
        var Dt = L(Et), Ot = ne(Et);
        return this._t(Dt, Ot, 0, 0, -Ot, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, oe(yt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Dt, -Ot, 0, 0, Ot, Dt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function lt(yt, Et, Dt) {
        return !Dt && Dt !== 0 && (Dt = 1), yt === 1 && Et === 1 && Dt === 1 ? this : this._t(yt, 0, 0, 0, 0, Et, 0, 0, 0, 0, Dt, 0, 0, 0, 0, 1);
      }
      function pt(yt, Et, Dt, Ot, nr, vr, pr, xr, Ir, fn, Zr, xn, kn, Lr, en, Rr) {
        return this.props[0] = yt, this.props[1] = Et, this.props[2] = Dt, this.props[3] = Ot, this.props[4] = nr, this.props[5] = vr, this.props[6] = pr, this.props[7] = xr, this.props[8] = Ir, this.props[9] = fn, this.props[10] = Zr, this.props[11] = xn, this.props[12] = kn, this.props[13] = Lr, this.props[14] = en, this.props[15] = Rr, this;
      }
      function it(yt, Et, Dt) {
        return Dt = Dt || 0, yt !== 0 || Et !== 0 || Dt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, yt, Et, Dt, 1) : this;
      }
      function ut(yt, Et, Dt, Ot, nr, vr, pr, xr, Ir, fn, Zr, xn, kn, Lr, en, Rr) {
        var cr = this.props;
        if (yt === 1 && Et === 0 && Dt === 0 && Ot === 0 && nr === 0 && vr === 1 && pr === 0 && xr === 0 && Ir === 0 && fn === 0 && Zr === 1 && xn === 0)
          return cr[12] = cr[12] * yt + cr[15] * kn, cr[13] = cr[13] * vr + cr[15] * Lr, cr[14] = cr[14] * Zr + cr[15] * en, cr[15] *= Rr, this._identityCalculated = !1, this;
        var Nn = cr[0], Xn = cr[1], Mn = cr[2], Kn = cr[3], Ri = cr[4], Si = cr[5], Fn = cr[6], ki = cr[7], Jn = cr[8], Zn = cr[9], ui = cr[10], ei = cr[11], Tn = cr[12], hi = cr[13], za = cr[14], zn = cr[15];
        return cr[0] = Nn * yt + Xn * nr + Mn * Ir + Kn * kn, cr[1] = Nn * Et + Xn * vr + Mn * fn + Kn * Lr, cr[2] = Nn * Dt + Xn * pr + Mn * Zr + Kn * en, cr[3] = Nn * Ot + Xn * xr + Mn * xn + Kn * Rr, cr[4] = Ri * yt + Si * nr + Fn * Ir + ki * kn, cr[5] = Ri * Et + Si * vr + Fn * fn + ki * Lr, cr[6] = Ri * Dt + Si * pr + Fn * Zr + ki * en, cr[7] = Ri * Ot + Si * xr + Fn * xn + ki * Rr, cr[8] = Jn * yt + Zn * nr + ui * Ir + ei * kn, cr[9] = Jn * Et + Zn * vr + ui * fn + ei * Lr, cr[10] = Jn * Dt + Zn * pr + ui * Zr + ei * en, cr[11] = Jn * Ot + Zn * xr + ui * xn + ei * Rr, cr[12] = Tn * yt + hi * nr + za * Ir + zn * kn, cr[13] = Tn * Et + hi * vr + za * fn + zn * Lr, cr[14] = Tn * Dt + hi * pr + za * Zr + zn * en, cr[15] = Tn * Ot + hi * xr + za * xn + zn * Rr, this._identityCalculated = !1, this;
      }
      function St(yt) {
        var Et = yt.props;
        return this.transform(Et[0], Et[1], Et[2], Et[3], Et[4], Et[5], Et[6], Et[7], Et[8], Et[9], Et[10], Et[11], Et[12], Et[13], Et[14], Et[15]);
      }
      function ot() {
        return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity;
      }
      function ht(yt) {
        for (var Et = 0; Et < 16; ) {
          if (yt.props[Et] !== this.props[Et])
            return !1;
          Et += 1;
        }
        return !0;
      }
      function ft(yt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          yt.props[Et] = this.props[Et];
        return yt;
      }
      function vt(yt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          this.props[Et] = yt[Et];
      }
      function Ct(yt, Et, Dt) {
        return {
          x: yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12],
          y: yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13],
          z: yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14]
        };
      }
      function xt(yt, Et, Dt) {
        return yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12];
      }
      function At(yt, Et, Dt) {
        return yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13];
      }
      function kt(yt, Et, Dt) {
        return yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14];
      }
      function Vt() {
        var yt = this.props[0] * this.props[5] - this.props[1] * this.props[4], Et = this.props[5] / yt, Dt = -this.props[1] / yt, Ot = -this.props[4] / yt, nr = this.props[0] / yt, vr = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / yt, pr = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / yt, xr = new Matrix();
        return xr.props[0] = Et, xr.props[1] = Dt, xr.props[4] = Ot, xr.props[5] = nr, xr.props[12] = vr, xr.props[13] = pr, xr;
      }
      function ir(yt) {
        var Et = this.getInverseMatrix();
        return Et.applyToPointArray(yt[0], yt[1], yt[2] || 0);
      }
      function er(yt) {
        var Et, Dt = yt.length, Ot = [];
        for (Et = 0; Et < Dt; Et += 1)
          Ot[Et] = ir(yt[Et]);
        return Ot;
      }
      function Yt(yt, Et, Dt) {
        var Ot = createTypedArray("float32", 6);
        if (this.isIdentity())
          Ot[0] = yt[0], Ot[1] = yt[1], Ot[2] = Et[0], Ot[3] = Et[1], Ot[4] = Dt[0], Ot[5] = Dt[1];
        else {
          var nr = this.props[0], vr = this.props[1], pr = this.props[4], xr = this.props[5], Ir = this.props[12], fn = this.props[13];
          Ot[0] = yt[0] * nr + yt[1] * pr + Ir, Ot[1] = yt[0] * vr + yt[1] * xr + fn, Ot[2] = Et[0] * nr + Et[1] * pr + Ir, Ot[3] = Et[0] * vr + Et[1] * xr + fn, Ot[4] = Dt[0] * nr + Dt[1] * pr + Ir, Ot[5] = Dt[0] * vr + Dt[1] * xr + fn;
        }
        return Ot;
      }
      function Jt(yt, Et, Dt) {
        var Ot;
        return this.isIdentity() ? Ot = [yt, Et, Dt] : Ot = [yt * this.props[0] + Et * this.props[4] + Dt * this.props[8] + this.props[12], yt * this.props[1] + Et * this.props[5] + Dt * this.props[9] + this.props[13], yt * this.props[2] + Et * this.props[6] + Dt * this.props[10] + this.props[14]], Ot;
      }
      function rr(yt, Et) {
        if (this.isIdentity())
          return yt + "," + Et;
        var Dt = this.props;
        return Math.round((yt * Dt[0] + Et * Dt[4] + Dt[12]) * 100) / 100 + "," + Math.round((yt * Dt[1] + Et * Dt[5] + Dt[13]) * 100) / 100;
      }
      function Qt() {
        for (var yt = 0, Et = this.props, Dt = "matrix3d(", Ot = 1e4; yt < 16; )
          Dt += pe(Et[yt] * Ot) / Ot, Dt += yt === 15 ? ")" : ",", yt += 1;
        return Dt;
      }
      function wt(yt) {
        var Et = 1e4;
        return yt < 1e-6 && yt > 0 || yt > -1e-6 && yt < 0 ? pe(yt * Et) / Et : yt;
      }
      function Ft() {
        var yt = this.props, Et = wt(yt[0]), Dt = wt(yt[1]), Ot = wt(yt[4]), nr = wt(yt[5]), vr = wt(yt[12]), pr = wt(yt[13]);
        return "matrix(" + Et + "," + Dt + "," + Ot + "," + nr + "," + vr + "," + pr + ")";
      }
      return function() {
        this.reset = me, this.rotate = ge, this.rotateX = be, this.rotateY = Ie, this.rotateZ = Ae, this.skew = st, this.skewFromAxis = dt, this.shear = rt, this.scale = lt, this.setTransform = pt, this.translate = it, this.transform = ut, this.multiply = St, this.applyToPoint = Ct, this.applyToX = xt, this.applyToY = At, this.applyToZ = kt, this.applyToPointArray = Jt, this.applyToTriplePoints = Yt, this.applyToPointStringified = rr, this.toCSS = Qt, this.to2dCSS = Ft, this.clone = ft, this.cloneFromProps = vt, this.equals = ht, this.inversePoints = er, this.inversePoint = ir, this.getInverseMatrix = Vt, this._t = this.transform, this.isIdentity = ot, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset();
      };
    }();
    function _typeof$3(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(oe) {
        return typeof oe;
      } : _typeof$3 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$3(L);
    }
    var lottie = {};
    function setLocation(L) {
      setLocationHref(L);
    }
    function searchAnimations() {
      animationManager.searchAnimations();
    }
    function setSubframeRendering(L) {
      setSubframeEnabled(L);
    }
    function setPrefix(L) {
      setIdPrefix(L);
    }
    function loadAnimation(L) {
      return animationManager.loadAnimation(L);
    }
    function setQuality(L) {
      if (typeof L == "string")
        switch (L) {
          case "high":
            setDefaultCurveSegments(200);
            break;
          default:
          case "medium":
            setDefaultCurveSegments(50);
            break;
          case "low":
            setDefaultCurveSegments(10);
            break;
        }
      else
        !isNaN(L) && L > 1 && setDefaultCurveSegments(L);
    }
    function inBrowser() {
      return typeof navigator < "u";
    }
    function installPlugin(L, ne) {
      L === "expressions" && setExpressionsPlugin(ne);
    }
    function getFactory(L) {
      switch (L) {
        case "propertyFactory":
          return PropertyFactory;
        case "shapePropertyFactory":
          return ShapePropertyFactory;
        case "matrix":
          return Matrix;
        default:
          return null;
      }
    }
    lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2";
    function checkReady() {
      document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations());
    }
    function getQueryVariable(L) {
      for (var ne = queryString.split("&"), oe = 0; oe < ne.length; oe += 1) {
        var pe = ne[oe].split("=");
        if (decodeURIComponent(pe[0]) == L)
          return decodeURIComponent(pe[1]);
      }
      return null;
    }
    var queryString = "";
    {
      var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || {
        src: ""
      };
      queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer");
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);
    try {
      _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
    } catch (L) {
    }
    var ShapeModifiers = function() {
      var L = {}, ne = {};
      L.registerModifier = oe, L.getModifier = pe;
      function oe(me, ge) {
        ne[me] || (ne[me] = ge);
      }
      function pe(me, ge, be) {
        return new ne[me](ge, be);
      }
      return L;
    }();
    function ShapeModifier() {
    }
    ShapeModifier.prototype.initModifierProperties = function() {
    }, ShapeModifier.prototype.addShapeToModifier = function() {
    }, ShapeModifier.prototype.addShape = function(L) {
      if (!this.closed) {
        L.sh.container.addDynamicProperty(L.sh);
        var ne = {
          shape: L.sh,
          data: L,
          localShapeCollection: shapeCollectionPool.newShapeCollection()
        };
        this.shapes.push(ne), this.addShapeToModifier(ne), this._isAnimated && L.setAsAnimated();
      }
    }, ShapeModifier.prototype.init = function(L, ne) {
      this.shapes = [], this.elem = L, this.initDynamicPropertyContainer(L), this.initModifierProperties(L, ne), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, ShapeModifier.prototype.processKeys = function() {
      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties());
    }, extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier() {
    }
    extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(L, ne) {
      this.s = PropertyFactory.getProp(L, ne.s, 0, 0.01, this), this.e = PropertyFactory.getProp(L, ne.e, 0, 0.01, this), this.o = PropertyFactory.getProp(L, ne.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = ne.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    }, TrimModifier.prototype.addShapeToModifier = function(L) {
      L.pathsData = [];
    }, TrimModifier.prototype.calculateShapeEdges = function(L, ne, oe, pe, me) {
      var ge = [];
      ne <= 1 ? ge.push({
        s: L,
        e: ne
      }) : L >= 1 ? ge.push({
        s: L - 1,
        e: ne - 1
      }) : (ge.push({
        s: L,
        e: 1
      }), ge.push({
        s: 0,
        e: ne - 1
      }));
      var be = [], Ie, Ae = ge.length, rt;
      for (Ie = 0; Ie < Ae; Ie += 1)
        if (rt = ge[Ie], !(rt.e * me < pe || rt.s * me > pe + oe)) {
          var st, dt;
          rt.s * me <= pe ? st = 0 : st = (rt.s * me - pe) / oe, rt.e * me >= pe + oe ? dt = 1 : dt = (rt.e * me - pe) / oe, be.push([st, dt]);
        }
      return be.length || be.push([0, 0]), be;
    }, TrimModifier.prototype.releasePathsData = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        segmentsLengthPool.release(L[ne]);
      return L.length = 0, L;
    }, TrimModifier.prototype.processShapes = function(L) {
      var ne, oe;
      if (this._mdf || L) {
        var pe = this.o.v % 360 / 360;
        if (pe < 0 && (pe += 1), this.s.v > 1 ? ne = 1 + pe : this.s.v < 0 ? ne = 0 + pe : ne = this.s.v + pe, this.e.v > 1 ? oe = 1 + pe : this.e.v < 0 ? oe = 0 + pe : oe = this.e.v + pe, ne > oe) {
          var me = ne;
          ne = oe, oe = me;
        }
        ne = Math.round(ne * 1e4) * 1e-4, oe = Math.round(oe * 1e4) * 1e-4, this.sValue = ne, this.eValue = oe;
      } else
        ne = this.sValue, oe = this.eValue;
      var ge, be, Ie = this.shapes.length, Ae, rt, st, dt, lt, pt = 0;
      if (oe === ne)
        for (be = 0; be < Ie; be += 1)
          this.shapes[be].localShapeCollection.releaseShapes(), this.shapes[be].shape._mdf = !0, this.shapes[be].shape.paths = this.shapes[be].localShapeCollection, this._mdf && (this.shapes[be].pathsData.length = 0);
      else if (oe === 1 && ne === 0 || oe === 0 && ne === 1) {
        if (this._mdf)
          for (be = 0; be < Ie; be += 1)
            this.shapes[be].pathsData.length = 0, this.shapes[be].shape._mdf = !0;
      } else {
        var it = [], ut, St;
        for (be = 0; be < Ie; be += 1)
          if (ut = this.shapes[be], !ut.shape._mdf && !this._mdf && !L && this.m !== 2)
            ut.shape.paths = ut.localShapeCollection;
          else {
            if (ge = ut.shape.paths, rt = ge._length, lt = 0, !ut.shape._mdf && ut.pathsData.length)
              lt = ut.totalShapeLength;
            else {
              for (st = this.releasePathsData(ut.pathsData), Ae = 0; Ae < rt; Ae += 1)
                dt = bez.getSegmentsLength(ge.shapes[Ae]), st.push(dt), lt += dt.totalLength;
              ut.totalShapeLength = lt, ut.pathsData = st;
            }
            pt += lt, ut.shape._mdf = !0;
          }
        var ot = ne, ht = oe, ft = 0, vt;
        for (be = Ie - 1; be >= 0; be -= 1)
          if (ut = this.shapes[be], ut.shape._mdf) {
            for (St = ut.localShapeCollection, St.releaseShapes(), this.m === 2 && Ie > 1 ? (vt = this.calculateShapeEdges(ne, oe, ut.totalShapeLength, ft, pt), ft += ut.totalShapeLength) : vt = [[ot, ht]], rt = vt.length, Ae = 0; Ae < rt; Ae += 1) {
              ot = vt[Ae][0], ht = vt[Ae][1], it.length = 0, ht <= 1 ? it.push({
                s: ut.totalShapeLength * ot,
                e: ut.totalShapeLength * ht
              }) : ot >= 1 ? it.push({
                s: ut.totalShapeLength * (ot - 1),
                e: ut.totalShapeLength * (ht - 1)
              }) : (it.push({
                s: ut.totalShapeLength * ot,
                e: ut.totalShapeLength
              }), it.push({
                s: 0,
                e: ut.totalShapeLength * (ht - 1)
              }));
              var Ct = this.addShapes(ut, it[0]);
              if (it[0].s !== it[0].e) {
                if (it.length > 1) {
                  var xt = ut.shape.paths.shapes[ut.shape.paths._length - 1];
                  if (xt.c) {
                    var At = Ct.pop();
                    this.addPaths(Ct, St), Ct = this.addShapes(ut, it[1], At);
                  } else
                    this.addPaths(Ct, St), Ct = this.addShapes(ut, it[1]);
                }
                this.addPaths(Ct, St);
              }
            }
            ut.shape.paths = St;
          }
      }
    }, TrimModifier.prototype.addPaths = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        ne.addShape(L[oe]);
    }, TrimModifier.prototype.addSegment = function(L, ne, oe, pe, me, ge, be) {
      me.setXYAt(ne[0], ne[1], "o", ge), me.setXYAt(oe[0], oe[1], "i", ge + 1), be && me.setXYAt(L[0], L[1], "v", ge), me.setXYAt(pe[0], pe[1], "v", ge + 1);
    }, TrimModifier.prototype.addSegmentFromArray = function(L, ne, oe, pe) {
      ne.setXYAt(L[1], L[5], "o", oe), ne.setXYAt(L[2], L[6], "i", oe + 1), pe && ne.setXYAt(L[0], L[4], "v", oe), ne.setXYAt(L[3], L[7], "v", oe + 1);
    }, TrimModifier.prototype.addShapes = function(L, ne, oe) {
      var pe = L.pathsData, me = L.shape.paths.shapes, ge, be = L.shape.paths._length, Ie, Ae, rt = 0, st, dt, lt, pt, it = [], ut, St = !0;
      for (oe ? (dt = oe._length, ut = oe._length) : (oe = shapePool.newElement(), dt = 0, ut = 0), it.push(oe), ge = 0; ge < be; ge += 1) {
        for (lt = pe[ge].lengths, oe.c = me[ge].c, Ae = me[ge].c ? lt.length : lt.length + 1, Ie = 1; Ie < Ae; Ie += 1)
          if (st = lt[Ie - 1], rt + st.addedLength < ne.s)
            rt += st.addedLength, oe.c = !1;
          else if (rt > ne.e) {
            oe.c = !1;
            break;
          } else
            ne.s <= rt && ne.e >= rt + st.addedLength ? (this.addSegment(me[ge].v[Ie - 1], me[ge].o[Ie - 1], me[ge].i[Ie], me[ge].v[Ie], oe, dt, St), St = !1) : (pt = bez.getNewSegment(me[ge].v[Ie - 1], me[ge].v[Ie], me[ge].o[Ie - 1], me[ge].i[Ie], (ne.s - rt) / st.addedLength, (ne.e - rt) / st.addedLength, lt[Ie - 1]), this.addSegmentFromArray(pt, oe, dt, St), St = !1, oe.c = !1), rt += st.addedLength, dt += 1;
        if (me[ge].c && lt.length) {
          if (st = lt[Ie - 1], rt <= ne.e) {
            var ot = lt[Ie - 1].addedLength;
            ne.s <= rt && ne.e >= rt + ot ? (this.addSegment(me[ge].v[Ie - 1], me[ge].o[Ie - 1], me[ge].i[0], me[ge].v[0], oe, dt, St), St = !1) : (pt = bez.getNewSegment(me[ge].v[Ie - 1], me[ge].v[0], me[ge].o[Ie - 1], me[ge].i[0], (ne.s - rt) / ot, (ne.e - rt) / ot, lt[Ie - 1]), this.addSegmentFromArray(pt, oe, dt, St), St = !1, oe.c = !1);
          } else
            oe.c = !1;
          rt += st.addedLength, dt += 1;
        }
        if (oe._length && (oe.setXYAt(oe.v[ut][0], oe.v[ut][1], "i", ut), oe.setXYAt(oe.v[oe._length - 1][0], oe.v[oe._length - 1][1], "o", oe._length - 1)), rt > ne.e)
          break;
        ge < be - 1 && (oe = shapePool.newElement(), St = !0, it.push(oe), dt = 0);
      }
      return it;
    };
    function PuckerAndBloatModifier() {
    }
    extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(L, ne.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length;
    }, PuckerAndBloatModifier.prototype.processPath = function(L, ne) {
      var oe = ne / 100, pe = [0, 0], me = L._length, ge = 0;
      for (ge = 0; ge < me; ge += 1)
        pe[0] += L.v[ge][0], pe[1] += L.v[ge][1];
      pe[0] /= me, pe[1] /= me;
      var be = shapePool.newElement();
      be.c = L.c;
      var Ie, Ae, rt, st, dt, lt;
      for (ge = 0; ge < me; ge += 1)
        Ie = L.v[ge][0] + (pe[0] - L.v[ge][0]) * oe, Ae = L.v[ge][1] + (pe[1] - L.v[ge][1]) * oe, rt = L.o[ge][0] + (pe[0] - L.o[ge][0]) * -oe, st = L.o[ge][1] + (pe[1] - L.o[ge][1]) * -oe, dt = L.i[ge][0] + (pe[0] - L.i[ge][0]) * -oe, lt = L.i[ge][1] + (pe[1] - L.i[ge][1]) * -oe, be.setTripleAt(Ie, Ae, rt, st, dt, lt, ge);
      return be;
    }, PuckerAndBloatModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amount.v;
      if (be !== 0) {
        var Ie, Ae;
        for (oe = 0; oe < pe; oe += 1) {
          if (Ie = this.shapes[oe], Ae = Ie.localShapeCollection, !(!Ie.shape._mdf && !this._mdf && !L))
            for (Ae.releaseShapes(), Ie.shape._mdf = !0, ne = Ie.shape.paths.shapes, ge = Ie.shape.paths._length, me = 0; me < ge; me += 1)
              Ae.addShape(this.processPath(ne[me], be));
          Ie.shape.paths = Ie.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    var TransformPropertyFactory = function() {
      var L = [0, 0];
      function ne(Ae) {
        var rt = this._mdf;
        this.iterateDynamicProperties(), this._mdf = this._mdf || rt, this.a && Ae.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && Ae.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && Ae.skewFromAxis(-this.sk.v, this.sa.v), this.r ? Ae.rotate(-this.r.v) : Ae.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? Ae.translate(this.px.v, this.py.v, -this.pz.v) : Ae.translate(this.px.v, this.py.v, 0) : Ae.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
      function oe(Ae) {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || Ae) {
            var rt;
            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
              var st, dt;
              if (rt = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime)
                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (st = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / rt, 0), dt = this.p.getValueAtTime(this.p.keyframes[0].t / rt, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (st = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / rt, 0), dt = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / rt, 0)) : (st = this.p.pv, dt = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / rt, this.p.offsetTime));
              else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                st = [], dt = [];
                var lt = this.px, pt = this.py;
                lt._caching.lastFrame + lt.offsetTime <= lt.keyframes[0].t ? (st[0] = lt.getValueAtTime((lt.keyframes[0].t + 0.01) / rt, 0), st[1] = pt.getValueAtTime((pt.keyframes[0].t + 0.01) / rt, 0), dt[0] = lt.getValueAtTime(lt.keyframes[0].t / rt, 0), dt[1] = pt.getValueAtTime(pt.keyframes[0].t / rt, 0)) : lt._caching.lastFrame + lt.offsetTime >= lt.keyframes[lt.keyframes.length - 1].t ? (st[0] = lt.getValueAtTime(lt.keyframes[lt.keyframes.length - 1].t / rt, 0), st[1] = pt.getValueAtTime(pt.keyframes[pt.keyframes.length - 1].t / rt, 0), dt[0] = lt.getValueAtTime((lt.keyframes[lt.keyframes.length - 1].t - 0.01) / rt, 0), dt[1] = pt.getValueAtTime((pt.keyframes[pt.keyframes.length - 1].t - 0.01) / rt, 0)) : (st = [lt.pv, pt.pv], dt[0] = lt.getValueAtTime((lt._caching.lastFrame + lt.offsetTime - 0.01) / rt, lt.offsetTime), dt[1] = pt.getValueAtTime((pt._caching.lastFrame + pt.offsetTime - 0.01) / rt, pt.offsetTime));
              } else
                dt = L, st = dt;
              this.v.rotate(-Math.atan2(st[1] - dt[1], st[0] - dt[0]));
            }
            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
          this.frameId = this.elem.globalData.frameId;
        }
      }
      function pe() {
        if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length)
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1;
        else
          return;
        if (!this.s.effectsSequence.length)
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2;
        else
          return;
        if (this.sk)
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
            this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3;
          else
            return;
        this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4);
      }
      function me() {
      }
      function ge(Ae) {
        this._addDynamicProperty(Ae), this.elem.addDynamicProperty(Ae), this._isDirty = !0;
      }
      function be(Ae, rt, st) {
        if (this.elem = Ae, this.frameId = -1, this.propType = "transform", this.data = rt, this.v = new Matrix(), this.pre = new Matrix(), this.appliedTransformations = 0, this.initDynamicPropertyContainer(st || Ae), rt.p && rt.p.s ? (this.px = PropertyFactory.getProp(Ae, rt.p.x, 0, 0, this), this.py = PropertyFactory.getProp(Ae, rt.p.y, 0, 0, this), rt.p.z && (this.pz = PropertyFactory.getProp(Ae, rt.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(Ae, rt.p || {
          k: [0, 0, 0]
        }, 1, 0, this), rt.rx) {
          if (this.rx = PropertyFactory.getProp(Ae, rt.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(Ae, rt.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(Ae, rt.rz, 0, degToRads, this), rt.or.k[0].ti) {
            var dt, lt = rt.or.k.length;
            for (dt = 0; dt < lt; dt += 1)
              rt.or.k[dt].to = null, rt.or.k[dt].ti = null;
          }
          this.or = PropertyFactory.getProp(Ae, rt.or, 1, degToRads, this), this.or.sh = !0;
        } else
          this.r = PropertyFactory.getProp(Ae, rt.r || {
            k: 0
          }, 0, degToRads, this);
        rt.sk && (this.sk = PropertyFactory.getProp(Ae, rt.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(Ae, rt.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(Ae, rt.a || {
          k: [0, 0, 0]
        }, 1, 0, this), this.s = PropertyFactory.getProp(Ae, rt.s || {
          k: [100, 100, 100]
        }, 1, 0.01, this), rt.o ? this.o = PropertyFactory.getProp(Ae, rt.o, 0, 0.01, Ae) : this.o = {
          _mdf: !1,
          v: 1
        }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0);
      }
      be.prototype = {
        applyToMatrix: ne,
        getValue: oe,
        precalculateMatrix: pe,
        autoOrient: me
      }, extendPrototype([DynamicPropertyContainer], be), be.prototype.addDynamicProperty = ge, be.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
      function Ie(Ae, rt, st) {
        return new be(Ae, rt, st);
      }
      return {
        getTransformProperty: Ie
      };
    }();
    function RepeaterModifier() {
    }
    extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.c = PropertyFactory.getProp(L, ne.c, 0, null, this), this.o = PropertyFactory.getProp(L, ne.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(L, ne.tr, this), this.so = PropertyFactory.getProp(L, ne.tr.so, 0, 0.01, this), this.eo = PropertyFactory.getProp(L, ne.tr.eo, 0, 0.01, this), this.data = ne, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix(), this.rMatrix = new Matrix(), this.sMatrix = new Matrix(), this.tMatrix = new Matrix(), this.matrix = new Matrix();
    }, RepeaterModifier.prototype.applyTransforms = function(L, ne, oe, pe, me, ge) {
      var be = ge ? -1 : 1, Ie = pe.s.v[0] + (1 - pe.s.v[0]) * (1 - me), Ae = pe.s.v[1] + (1 - pe.s.v[1]) * (1 - me);
      L.translate(pe.p.v[0] * be * me, pe.p.v[1] * be * me, pe.p.v[2]), ne.translate(-pe.a.v[0], -pe.a.v[1], pe.a.v[2]), ne.rotate(-pe.r.v * be * me), ne.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]), oe.translate(-pe.a.v[0], -pe.a.v[1], pe.a.v[2]), oe.scale(ge ? 1 / Ie : Ie, ge ? 1 / Ae : Ae), oe.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]);
    }, RepeaterModifier.prototype.init = function(L, ne, oe, pe) {
      for (this.elem = L, this.arr = ne, this.pos = oe, this.elemsData = pe, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(L), this.initModifierProperties(L, ne[oe]); oe > 0; )
        oe -= 1, this._elements.unshift(ne[oe]);
      this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, RepeaterModifier.prototype.resetElements = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne]._processed = !1, L[ne].ty === "gr" && this.resetElements(L[ne].it);
    }, RepeaterModifier.prototype.cloneElements = function(L) {
      var ne = JSON.parse(JSON.stringify(L));
      return this.resetElements(ne), ne;
    }, RepeaterModifier.prototype.changeGroupRender = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        L[oe]._render = ne, L[oe].ty === "gr" && this.changeGroupRender(L[oe].it, ne);
    }, RepeaterModifier.prototype.processShapes = function(L) {
      var ne, oe, pe, me, ge, be = !1;
      if (this._mdf || L) {
        var Ie = Math.ceil(this.c.v);
        if (this._groups.length < Ie) {
          for (; this._groups.length < Ie; ) {
            var Ae = {
              it: this.cloneElements(this._elements),
              ty: "gr"
            };
            Ae.it.push({
              a: {
                a: 0,
                ix: 1,
                k: [0, 0]
              },
              nm: "Transform",
              o: {
                a: 0,
                ix: 7,
                k: 100
              },
              p: {
                a: 0,
                ix: 2,
                k: [0, 0]
              },
              r: {
                a: 1,
                ix: 6,
                k: [{
                  s: 0,
                  e: 0,
                  t: 0
                }, {
                  s: 0,
                  e: 0,
                  t: 1
                }]
              },
              s: {
                a: 0,
                ix: 3,
                k: [100, 100]
              },
              sa: {
                a: 0,
                ix: 5,
                k: 0
              },
              sk: {
                a: 0,
                ix: 4,
                k: 0
              },
              ty: "tr"
            }), this.arr.splice(0, 0, Ae), this._groups.splice(0, 0, Ae), this._currentCopies += 1;
          }
          this.elem.reloadShapes(), be = !0;
        }
        ge = 0;
        var rt;
        for (pe = 0; pe <= this._groups.length - 1; pe += 1) {
          if (rt = ge < Ie, this._groups[pe]._render = rt, this.changeGroupRender(this._groups[pe].it, rt), !rt) {
            var st = this.elemsData[pe].it, dt = st[st.length - 1];
            dt.transform.op.v !== 0 ? (dt.transform.op._mdf = !0, dt.transform.op.v = 0) : dt.transform.op._mdf = !1;
          }
          ge += 1;
        }
        this._currentCopies = Ie;
        var lt = this.o.v, pt = lt % 1, it = lt > 0 ? Math.floor(lt) : Math.ceil(lt), ut = this.pMatrix.props, St = this.rMatrix.props, ot = this.sMatrix.props;
        this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
        var ht = 0;
        if (lt > 0) {
          for (; ht < it; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), ht += 1;
          pt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, pt, !1), ht += pt);
        } else if (lt < 0) {
          for (; ht > it; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), ht -= 1;
          pt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -pt, !0), ht -= pt);
        }
        pe = this.data.m === 1 ? 0 : this._currentCopies - 1, me = this.data.m === 1 ? 1 : -1, ge = this._currentCopies;
        for (var ft, vt; ge; ) {
          if (ne = this.elemsData[pe].it, oe = ne[ne.length - 1].transform.mProps.v.props, vt = oe.length, ne[ne.length - 1].transform.mProps._mdf = !0, ne[ne.length - 1].transform.op._mdf = !0, ne[ne.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (pe / (this._currentCopies - 1)), ht !== 0) {
            for ((pe !== 0 && me === 1 || pe !== this._currentCopies - 1 && me === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(St[0], St[1], St[2], St[3], St[4], St[5], St[6], St[7], St[8], St[9], St[10], St[11], St[12], St[13], St[14], St[15]), this.matrix.transform(ot[0], ot[1], ot[2], ot[3], ot[4], ot[5], ot[6], ot[7], ot[8], ot[9], ot[10], ot[11], ot[12], ot[13], ot[14], ot[15]), this.matrix.transform(ut[0], ut[1], ut[2], ut[3], ut[4], ut[5], ut[6], ut[7], ut[8], ut[9], ut[10], ut[11], ut[12], ut[13], ut[14], ut[15]), ft = 0; ft < vt; ft += 1)
              oe[ft] = this.matrix.props[ft];
            this.matrix.reset();
          } else
            for (this.matrix.reset(), ft = 0; ft < vt; ft += 1)
              oe[ft] = this.matrix.props[ft];
          ht += 1, ge -= 1, pe += me;
        }
      } else
        for (ge = this._currentCopies, pe = 0, me = 1; ge; )
          ne = this.elemsData[pe].it, oe = ne[ne.length - 1].transform.mProps.v.props, ne[ne.length - 1].transform.mProps._mdf = !1, ne[ne.length - 1].transform.op._mdf = !1, ge -= 1, pe += me;
      return be;
    }, RepeaterModifier.prototype.addShape = function() {
    };
    function RoundCornersModifier() {
    }
    extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(L, ne.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length;
    }, RoundCornersModifier.prototype.processPath = function(L, ne) {
      var oe = shapePool.newElement();
      oe.c = L.c;
      var pe, me = L._length, ge, be, Ie, Ae, rt, st, dt = 0, lt, pt, it, ut, St, ot;
      for (pe = 0; pe < me; pe += 1)
        ge = L.v[pe], Ie = L.o[pe], be = L.i[pe], ge[0] === Ie[0] && ge[1] === Ie[1] && ge[0] === be[0] && ge[1] === be[1] ? (pe === 0 || pe === me - 1) && !L.c ? (oe.setTripleAt(ge[0], ge[1], Ie[0], Ie[1], be[0], be[1], dt), dt += 1) : (pe === 0 ? Ae = L.v[me - 1] : Ae = L.v[pe - 1], rt = Math.sqrt(Math.pow(ge[0] - Ae[0], 2) + Math.pow(ge[1] - Ae[1], 2)), st = rt ? Math.min(rt / 2, ne) / rt : 0, St = ge[0] + (Ae[0] - ge[0]) * st, lt = St, ot = ge[1] - (ge[1] - Ae[1]) * st, pt = ot, it = lt - (lt - ge[0]) * roundCorner, ut = pt - (pt - ge[1]) * roundCorner, oe.setTripleAt(lt, pt, it, ut, St, ot, dt), dt += 1, pe === me - 1 ? Ae = L.v[0] : Ae = L.v[pe + 1], rt = Math.sqrt(Math.pow(ge[0] - Ae[0], 2) + Math.pow(ge[1] - Ae[1], 2)), st = rt ? Math.min(rt / 2, ne) / rt : 0, it = ge[0] + (Ae[0] - ge[0]) * st, lt = it, ut = ge[1] + (Ae[1] - ge[1]) * st, pt = ut, St = lt - (lt - ge[0]) * roundCorner, ot = pt - (pt - ge[1]) * roundCorner, oe.setTripleAt(lt, pt, it, ut, St, ot, dt), dt += 1) : (oe.setTripleAt(L.v[pe][0], L.v[pe][1], L.o[pe][0], L.o[pe][1], L.i[pe][0], L.i[pe][1], dt), dt += 1);
      return oe;
    }, RoundCornersModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.rd.v;
      if (be !== 0) {
        var Ie, Ae;
        for (oe = 0; oe < pe; oe += 1) {
          if (Ie = this.shapes[oe], Ae = Ie.localShapeCollection, !(!Ie.shape._mdf && !this._mdf && !L))
            for (Ae.releaseShapes(), Ie.shape._mdf = !0, ne = Ie.shape.paths.shapes, ge = Ie.shape.paths._length, me = 0; me < ge; me += 1)
              Ae.addShape(this.processPath(ne[me], be));
          Ie.shape.paths = Ie.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function floatEqual(L, ne) {
      return Math.abs(L - ne) * 1e5 <= Math.min(Math.abs(L), Math.abs(ne));
    }
    function floatZero(L) {
      return Math.abs(L) <= 1e-5;
    }
    function lerp(L, ne, oe) {
      return L * (1 - oe) + ne * oe;
    }
    function lerpPoint(L, ne, oe) {
      return [lerp(L[0], ne[0], oe), lerp(L[1], ne[1], oe)];
    }
    function quadRoots(L, ne, oe) {
      if (L === 0)
        return [];
      var pe = ne * ne - 4 * L * oe;
      if (pe < 0)
        return [];
      var me = -ne / (2 * L);
      if (pe === 0)
        return [me];
      var ge = Math.sqrt(pe) / (2 * L);
      return [me - ge, me + ge];
    }
    function polynomialCoefficients(L, ne, oe, pe) {
      return [-L + 3 * ne - 3 * oe + pe, 3 * L - 6 * ne + 3 * oe, -3 * L + 3 * ne, L];
    }
    function singlePoint(L) {
      return new PolynomialBezier(L, L, L, L, !1);
    }
    function PolynomialBezier(L, ne, oe, pe, me) {
      me && pointEqual(L, ne) && (ne = lerpPoint(L, pe, 1 / 3)), me && pointEqual(oe, pe) && (oe = lerpPoint(L, pe, 2 / 3));
      var ge = polynomialCoefficients(L[0], ne[0], oe[0], pe[0]), be = polynomialCoefficients(L[1], ne[1], oe[1], pe[1]);
      this.a = [ge[0], be[0]], this.b = [ge[1], be[1]], this.c = [ge[2], be[2]], this.d = [ge[3], be[3]], this.points = [L, ne, oe, pe];
    }
    PolynomialBezier.prototype.point = function(L) {
      return [((this.a[0] * L + this.b[0]) * L + this.c[0]) * L + this.d[0], ((this.a[1] * L + this.b[1]) * L + this.c[1]) * L + this.d[1]];
    }, PolynomialBezier.prototype.derivative = function(L) {
      return [(3 * L * this.a[0] + 2 * this.b[0]) * L + this.c[0], (3 * L * this.a[1] + 2 * this.b[1]) * L + this.c[1]];
    }, PolynomialBezier.prototype.tangentAngle = function(L) {
      var ne = this.derivative(L);
      return Math.atan2(ne[1], ne[0]);
    }, PolynomialBezier.prototype.normalAngle = function(L) {
      var ne = this.derivative(L);
      return Math.atan2(ne[0], ne[1]);
    }, PolynomialBezier.prototype.inflectionPoints = function() {
      var L = this.a[1] * this.b[0] - this.a[0] * this.b[1];
      if (floatZero(L))
        return [];
      var ne = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / L, oe = ne * ne - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / L;
      if (oe < 0)
        return [];
      var pe = Math.sqrt(oe);
      return floatZero(pe) ? pe > 0 && pe < 1 ? [ne] : [] : [ne - pe, ne + pe].filter(function(me) {
        return me > 0 && me < 1;
      });
    }, PolynomialBezier.prototype.split = function(L) {
      if (L <= 0)
        return [singlePoint(this.points[0]), this];
      if (L >= 1)
        return [this, singlePoint(this.points[this.points.length - 1])];
      var ne = lerpPoint(this.points[0], this.points[1], L), oe = lerpPoint(this.points[1], this.points[2], L), pe = lerpPoint(this.points[2], this.points[3], L), me = lerpPoint(ne, oe, L), ge = lerpPoint(oe, pe, L), be = lerpPoint(me, ge, L);
      return [new PolynomialBezier(this.points[0], ne, me, be, !0), new PolynomialBezier(be, ge, pe, this.points[3], !0)];
    };
    function extrema(L, ne) {
      var oe = L.points[0][ne], pe = L.points[L.points.length - 1][ne];
      if (oe > pe) {
        var me = pe;
        pe = oe, oe = me;
      }
      for (var ge = quadRoots(3 * L.a[ne], 2 * L.b[ne], L.c[ne]), be = 0; be < ge.length; be += 1)
        if (ge[be] > 0 && ge[be] < 1) {
          var Ie = L.point(ge[be])[ne];
          Ie < oe ? oe = Ie : Ie > pe && (pe = Ie);
        }
      return {
        min: oe,
        max: pe
      };
    }
    PolynomialBezier.prototype.bounds = function() {
      return {
        x: extrema(this, 0),
        y: extrema(this, 1)
      };
    }, PolynomialBezier.prototype.boundingBox = function() {
      var L = this.bounds();
      return {
        left: L.x.min,
        right: L.x.max,
        top: L.y.min,
        bottom: L.y.max,
        width: L.x.max - L.x.min,
        height: L.y.max - L.y.min,
        cx: (L.x.max + L.x.min) / 2,
        cy: (L.y.max + L.y.min) / 2
      };
    };
    function intersectData(L, ne, oe) {
      var pe = L.boundingBox();
      return {
        cx: pe.cx,
        cy: pe.cy,
        width: pe.width,
        height: pe.height,
        bez: L,
        t: (ne + oe) / 2,
        t1: ne,
        t2: oe
      };
    }
    function splitData(L) {
      var ne = L.bez.split(0.5);
      return [intersectData(ne[0], L.t1, L.t), intersectData(ne[1], L.t, L.t2)];
    }
    function boxIntersect(L, ne) {
      return Math.abs(L.cx - ne.cx) * 2 < L.width + ne.width && Math.abs(L.cy - ne.cy) * 2 < L.height + ne.height;
    }
    function intersectsImpl(L, ne, oe, pe, me, ge) {
      if (boxIntersect(L, ne)) {
        if (oe >= ge || L.width <= pe && L.height <= pe && ne.width <= pe && ne.height <= pe) {
          me.push([L.t, ne.t]);
          return;
        }
        var be = splitData(L), Ie = splitData(ne);
        intersectsImpl(be[0], Ie[0], oe + 1, pe, me, ge), intersectsImpl(be[0], Ie[1], oe + 1, pe, me, ge), intersectsImpl(be[1], Ie[0], oe + 1, pe, me, ge), intersectsImpl(be[1], Ie[1], oe + 1, pe, me, ge);
      }
    }
    PolynomialBezier.prototype.intersections = function(L, ne, oe) {
      ne === void 0 && (ne = 2), oe === void 0 && (oe = 7);
      var pe = [];
      return intersectsImpl(intersectData(this, 0, 1), intersectData(L, 0, 1), 0, ne, pe, oe), pe;
    }, PolynomialBezier.shapeSegment = function(L, ne) {
      var oe = (ne + 1) % L.length();
      return new PolynomialBezier(L.v[ne], L.o[ne], L.i[oe], L.v[oe], !0);
    }, PolynomialBezier.shapeSegmentInverted = function(L, ne) {
      var oe = (ne + 1) % L.length();
      return new PolynomialBezier(L.v[oe], L.i[oe], L.o[ne], L.v[ne], !0);
    };
    function crossProduct(L, ne) {
      return [L[1] * ne[2] - L[2] * ne[1], L[2] * ne[0] - L[0] * ne[2], L[0] * ne[1] - L[1] * ne[0]];
    }
    function lineIntersection(L, ne, oe, pe) {
      var me = [L[0], L[1], 1], ge = [ne[0], ne[1], 1], be = [oe[0], oe[1], 1], Ie = [pe[0], pe[1], 1], Ae = crossProduct(crossProduct(me, ge), crossProduct(be, Ie));
      return floatZero(Ae[2]) ? null : [Ae[0] / Ae[2], Ae[1] / Ae[2]];
    }
    function polarOffset(L, ne, oe) {
      return [L[0] + Math.cos(ne) * oe, L[1] - Math.sin(ne) * oe];
    }
    function pointDistance(L, ne) {
      return Math.hypot(L[0] - ne[0], L[1] - ne[1]);
    }
    function pointEqual(L, ne) {
      return floatEqual(L[0], ne[0]) && floatEqual(L[1], ne[1]);
    }
    function ZigZagModifier() {
    }
    extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(L, ne.s, 0, null, this), this.frequency = PropertyFactory.getProp(L, ne.r, 0, null, this), this.pointsType = PropertyFactory.getProp(L, ne.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
    };
    function setPoint(L, ne, oe, pe, me, ge, be) {
      var Ie = oe - Math.PI / 2, Ae = oe + Math.PI / 2, rt = ne[0] + Math.cos(oe) * pe * me, st = ne[1] - Math.sin(oe) * pe * me;
      L.setTripleAt(rt, st, rt + Math.cos(Ie) * ge, st - Math.sin(Ie) * ge, rt + Math.cos(Ae) * be, st - Math.sin(Ae) * be, L.length());
    }
    function getPerpendicularVector(L, ne) {
      var oe = [ne[0] - L[0], ne[1] - L[1]], pe = -Math.PI * 0.5, me = [Math.cos(pe) * oe[0] - Math.sin(pe) * oe[1], Math.sin(pe) * oe[0] + Math.cos(pe) * oe[1]];
      return me;
    }
    function getProjectingAngle(L, ne) {
      var oe = ne === 0 ? L.length() - 1 : ne - 1, pe = (ne + 1) % L.length(), me = L.v[oe], ge = L.v[pe], be = getPerpendicularVector(me, ge);
      return Math.atan2(0, 1) - Math.atan2(be[1], be[0]);
    }
    function zigZagCorner(L, ne, oe, pe, me, ge, be) {
      var Ie = getProjectingAngle(ne, oe), Ae = ne.v[oe % ne._length], rt = ne.v[oe === 0 ? ne._length - 1 : oe - 1], st = ne.v[(oe + 1) % ne._length], dt = ge === 2 ? Math.sqrt(Math.pow(Ae[0] - rt[0], 2) + Math.pow(Ae[1] - rt[1], 2)) : 0, lt = ge === 2 ? Math.sqrt(Math.pow(Ae[0] - st[0], 2) + Math.pow(Ae[1] - st[1], 2)) : 0;
      setPoint(L, ne.v[oe % ne._length], Ie, be, pe, lt / ((me + 1) * 2), dt / ((me + 1) * 2));
    }
    function zigZagSegment(L, ne, oe, pe, me, ge) {
      for (var be = 0; be < pe; be += 1) {
        var Ie = (be + 1) / (pe + 1), Ae = me === 2 ? Math.sqrt(Math.pow(ne.points[3][0] - ne.points[0][0], 2) + Math.pow(ne.points[3][1] - ne.points[0][1], 2)) : 0, rt = ne.normalAngle(Ie), st = ne.point(Ie);
        setPoint(L, st, rt, ge, oe, Ae / ((pe + 1) * 2), Ae / ((pe + 1) * 2)), ge = -ge;
      }
      return ge;
    }
    ZigZagModifier.prototype.processPath = function(L, ne, oe, pe) {
      var me = L._length, ge = shapePool.newElement();
      if (ge.c = L.c, L.c || (me -= 1), me === 0)
        return ge;
      var be = -1, Ie = PolynomialBezier.shapeSegment(L, 0);
      zigZagCorner(ge, L, 0, ne, oe, pe, be);
      for (var Ae = 0; Ae < me; Ae += 1)
        be = zigZagSegment(ge, Ie, ne, oe, pe, -be), Ae === me - 1 && !L.c ? Ie = null : Ie = PolynomialBezier.shapeSegment(L, (Ae + 1) % me), zigZagCorner(ge, L, Ae + 1, ne, oe, pe, be);
      return ge;
    }, ZigZagModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amplitude.v, Ie = Math.max(0, Math.round(this.frequency.v)), Ae = this.pointsType.v;
      if (be !== 0) {
        var rt, st;
        for (oe = 0; oe < pe; oe += 1) {
          if (rt = this.shapes[oe], st = rt.localShapeCollection, !(!rt.shape._mdf && !this._mdf && !L))
            for (st.releaseShapes(), rt.shape._mdf = !0, ne = rt.shape.paths.shapes, ge = rt.shape.paths._length, me = 0; me < ge; me += 1)
              st.addShape(this.processPath(ne[me], be, Ie, Ae));
          rt.shape.paths = rt.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function linearOffset(L, ne, oe) {
      var pe = Math.atan2(ne[0] - L[0], ne[1] - L[1]);
      return [polarOffset(L, pe, oe), polarOffset(ne, pe, oe)];
    }
    function offsetSegment(L, ne) {
      var oe, pe, me, ge, be, Ie, Ae;
      Ae = linearOffset(L.points[0], L.points[1], ne), oe = Ae[0], pe = Ae[1], Ae = linearOffset(L.points[1], L.points[2], ne), me = Ae[0], ge = Ae[1], Ae = linearOffset(L.points[2], L.points[3], ne), be = Ae[0], Ie = Ae[1];
      var rt = lineIntersection(oe, pe, me, ge);
      rt === null && (rt = pe);
      var st = lineIntersection(be, Ie, me, ge);
      return st === null && (st = be), new PolynomialBezier(oe, rt, st, Ie);
    }
    function joinLines(L, ne, oe, pe, me) {
      var ge = ne.points[3], be = oe.points[0];
      if (pe === 3 || pointEqual(ge, be))
        return ge;
      if (pe === 2) {
        var Ie = -ne.tangentAngle(1), Ae = -oe.tangentAngle(0) + Math.PI, rt = lineIntersection(ge, polarOffset(ge, Ie + Math.PI / 2, 100), be, polarOffset(be, Ie + Math.PI / 2, 100)), st = rt ? pointDistance(rt, ge) : pointDistance(ge, be) / 2, dt = polarOffset(ge, Ie, 2 * st * roundCorner);
        return L.setXYAt(dt[0], dt[1], "o", L.length() - 1), dt = polarOffset(be, Ae, 2 * st * roundCorner), L.setTripleAt(be[0], be[1], be[0], be[1], dt[0], dt[1], L.length()), be;
      }
      var lt = pointEqual(ge, ne.points[2]) ? ne.points[0] : ne.points[2], pt = pointEqual(be, oe.points[1]) ? oe.points[3] : oe.points[1], it = lineIntersection(lt, ge, be, pt);
      return it && pointDistance(it, ge) < me ? (L.setTripleAt(it[0], it[1], it[0], it[1], it[0], it[1], L.length()), it) : ge;
    }
    function getIntersection(L, ne) {
      var oe = L.intersections(ne);
      return oe.length && floatEqual(oe[0][0], 1) && oe.shift(), oe.length ? oe[0] : null;
    }
    function pruneSegmentIntersection(L, ne) {
      var oe = L.slice(), pe = ne.slice(), me = getIntersection(L[L.length - 1], ne[0]);
      return me && (oe[L.length - 1] = L[L.length - 1].split(me[0])[0], pe[0] = ne[0].split(me[1])[1]), L.length > 1 && ne.length > 1 && (me = getIntersection(L[0], ne[ne.length - 1]), me) ? [[L[0].split(me[0])[0]], [ne[ne.length - 1].split(me[1])[1]]] : [oe, pe];
    }
    function pruneIntersections(L) {
      for (var ne, oe = 1; oe < L.length; oe += 1)
        ne = pruneSegmentIntersection(L[oe - 1], L[oe]), L[oe - 1] = ne[0], L[oe] = ne[1];
      return L.length > 1 && (ne = pruneSegmentIntersection(L[L.length - 1], L[0]), L[L.length - 1] = ne[0], L[0] = ne[1]), L;
    }
    function offsetSegmentSplit(L, ne) {
      var oe = L.inflectionPoints(), pe, me, ge, be;
      if (oe.length === 0)
        return [offsetSegment(L, ne)];
      if (oe.length === 1 || floatEqual(oe[1], 1))
        return ge = L.split(oe[0]), pe = ge[0], me = ge[1], [offsetSegment(pe, ne), offsetSegment(me, ne)];
      ge = L.split(oe[0]), pe = ge[0];
      var Ie = (oe[1] - oe[0]) / (1 - oe[0]);
      return ge = ge[1].split(Ie), be = ge[0], me = ge[1], [offsetSegment(pe, ne), offsetSegment(be, ne), offsetSegment(me, ne)];
    }
    function OffsetPathModifier() {
    }
    extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function(L, ne) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(L, ne.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(L, ne.ml, 0, null, this), this.lineJoin = ne.lj, this._isAnimated = this.amount.effectsSequence.length !== 0;
    }, OffsetPathModifier.prototype.processPath = function(L, ne, oe, pe) {
      var me = shapePool.newElement();
      me.c = L.c;
      var ge = L.length();
      L.c || (ge -= 1);
      var be, Ie, Ae, rt = [];
      for (be = 0; be < ge; be += 1)
        Ae = PolynomialBezier.shapeSegment(L, be), rt.push(offsetSegmentSplit(Ae, ne));
      if (!L.c)
        for (be = ge - 1; be >= 0; be -= 1)
          Ae = PolynomialBezier.shapeSegmentInverted(L, be), rt.push(offsetSegmentSplit(Ae, ne));
      rt = pruneIntersections(rt);
      var st = null, dt = null;
      for (be = 0; be < rt.length; be += 1) {
        var lt = rt[be];
        for (dt && (st = joinLines(me, dt, lt[0], oe, pe)), dt = lt[lt.length - 1], Ie = 0; Ie < lt.length; Ie += 1)
          Ae = lt[Ie], st && pointEqual(Ae.points[0], st) ? me.setXYAt(Ae.points[1][0], Ae.points[1][1], "o", me.length() - 1) : me.setTripleAt(Ae.points[0][0], Ae.points[0][1], Ae.points[1][0], Ae.points[1][1], Ae.points[0][0], Ae.points[0][1], me.length()), me.setTripleAt(Ae.points[3][0], Ae.points[3][1], Ae.points[3][0], Ae.points[3][1], Ae.points[2][0], Ae.points[2][1], me.length()), st = Ae.points[3];
      }
      return rt.length && joinLines(me, dt, rt[0][0], oe, pe), me;
    }, OffsetPathModifier.prototype.processShapes = function(L) {
      var ne, oe, pe = this.shapes.length, me, ge, be = this.amount.v, Ie = this.miterLimit.v, Ae = this.lineJoin;
      if (be !== 0) {
        var rt, st;
        for (oe = 0; oe < pe; oe += 1) {
          if (rt = this.shapes[oe], st = rt.localShapeCollection, !(!rt.shape._mdf && !this._mdf && !L))
            for (st.releaseShapes(), rt.shape._mdf = !0, ne = rt.shape.paths.shapes, ge = rt.shape.paths._length, me = 0; me < ge; me += 1)
              st.addShape(this.processPath(ne[me], be, Ae, Ie));
          rt.shape.paths = rt.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function getFontProperties(L) {
      for (var ne = L.fStyle ? L.fStyle.split(" ") : [], oe = "normal", pe = "normal", me = ne.length, ge, be = 0; be < me; be += 1)
        switch (ge = ne[be].toLowerCase(), ge) {
          case "italic":
            pe = "italic";
            break;
          case "bold":
            oe = "700";
            break;
          case "black":
            oe = "900";
            break;
          case "medium":
            oe = "500";
            break;
          case "regular":
          case "normal":
            oe = "400";
            break;
          case "light":
          case "thin":
            oe = "200";
            break;
        }
      return {
        style: pe,
        weight: L.fWeight || oe
      };
    }
    var FontManager = function() {
      var L = 5e3, ne = {
        w: 0,
        size: 0,
        shapes: [],
        data: {
          shapes: []
        }
      }, oe = [];
      oe = oe.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
      var pe = 127988, me = 917631, ge = 917601, be = 917626, Ie = 65039, Ae = 8205, rt = 127462, st = 127487, dt = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
      function lt(wt) {
        var Ft = wt.split(","), yt, Et = Ft.length, Dt = [];
        for (yt = 0; yt < Et; yt += 1)
          Ft[yt] !== "sans-serif" && Ft[yt] !== "monospace" && Dt.push(Ft[yt]);
        return Dt.join(",");
      }
      function pt(wt, Ft) {
        var yt = createTag("span");
        yt.setAttribute("aria-hidden", !0), yt.style.fontFamily = Ft;
        var Et = createTag("span");
        Et.innerText = "giItT1WQy@!-/#", yt.style.position = "absolute", yt.style.left = "-10000px", yt.style.top = "-10000px", yt.style.fontSize = "300px", yt.style.fontVariant = "normal", yt.style.fontStyle = "normal", yt.style.fontWeight = "normal", yt.style.letterSpacing = "0", yt.appendChild(Et), document.body.appendChild(yt);
        var Dt = Et.offsetWidth;
        return Et.style.fontFamily = lt(wt) + ", " + Ft, {
          node: Et,
          w: Dt,
          parent: yt
        };
      }
      function it() {
        var wt, Ft = this.fonts.length, yt, Et, Dt = Ft;
        for (wt = 0; wt < Ft; wt += 1)
          this.fonts[wt].loaded ? Dt -= 1 : this.fonts[wt].fOrigin === "n" || this.fonts[wt].origin === 0 ? this.fonts[wt].loaded = !0 : (yt = this.fonts[wt].monoCase.node, Et = this.fonts[wt].monoCase.w, yt.offsetWidth !== Et ? (Dt -= 1, this.fonts[wt].loaded = !0) : (yt = this.fonts[wt].sansCase.node, Et = this.fonts[wt].sansCase.w, yt.offsetWidth !== Et && (Dt -= 1, this.fonts[wt].loaded = !0)), this.fonts[wt].loaded && (this.fonts[wt].sansCase.parent.parentNode.removeChild(this.fonts[wt].sansCase.parent), this.fonts[wt].monoCase.parent.parentNode.removeChild(this.fonts[wt].monoCase.parent)));
        Dt !== 0 && Date.now() - this.initTime < L ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10);
      }
      function ut(wt, Ft) {
        var yt = document.body && Ft ? "svg" : "canvas", Et, Dt = getFontProperties(wt);
        if (yt === "svg") {
          var Ot = createNS("text");
          Ot.style.fontSize = "100px", Ot.setAttribute("font-family", wt.fFamily), Ot.setAttribute("font-style", Dt.style), Ot.setAttribute("font-weight", Dt.weight), Ot.textContent = "1", wt.fClass ? (Ot.style.fontFamily = "inherit", Ot.setAttribute("class", wt.fClass)) : Ot.style.fontFamily = wt.fFamily, Ft.appendChild(Ot), Et = Ot;
        } else {
          var nr = new OffscreenCanvas(500, 500).getContext("2d");
          nr.font = Dt.style + " " + Dt.weight + " 100px " + wt.fFamily, Et = nr;
        }
        function vr(pr) {
          return yt === "svg" ? (Et.textContent = pr, Et.getComputedTextLength()) : Et.measureText(pr).width;
        }
        return {
          measureText: vr
        };
      }
      function St(wt, Ft) {
        if (!wt) {
          this.isLoaded = !0;
          return;
        }
        if (this.chars) {
          this.isLoaded = !0, this.fonts = wt.list;
          return;
        }
        if (!document.body) {
          this.isLoaded = !0, wt.list.forEach(function(Zr) {
            Zr.helper = ut(Zr), Zr.cache = {};
          }), this.fonts = wt.list;
          return;
        }
        var yt = wt.list, Et, Dt = yt.length, Ot = Dt;
        for (Et = 0; Et < Dt; Et += 1) {
          var nr = !0, vr, pr;
          if (yt[Et].loaded = !1, yt[Et].monoCase = pt(yt[Et].fFamily, "monospace"), yt[Et].sansCase = pt(yt[Et].fFamily, "sans-serif"), !yt[Et].fPath)
            yt[Et].loaded = !0, Ot -= 1;
          else if (yt[Et].fOrigin === "p" || yt[Et].origin === 3) {
            if (vr = document.querySelectorAll('style[f-forigin="p"][f-family="' + yt[Et].fFamily + '"], style[f-origin="3"][f-family="' + yt[Et].fFamily + '"]'), vr.length > 0 && (nr = !1), nr) {
              var xr = createTag("style");
              xr.setAttribute("f-forigin", yt[Et].fOrigin), xr.setAttribute("f-origin", yt[Et].origin), xr.setAttribute("f-family", yt[Et].fFamily), xr.type = "text/css", xr.innerText = "@font-face {font-family: " + yt[Et].fFamily + "; font-style: normal; src: url('" + yt[Et].fPath + "');}", Ft.appendChild(xr);
            }
          } else if (yt[Et].fOrigin === "g" || yt[Et].origin === 1) {
            for (vr = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), pr = 0; pr < vr.length; pr += 1)
              vr[pr].href.indexOf(yt[Et].fPath) !== -1 && (nr = !1);
            if (nr) {
              var Ir = createTag("link");
              Ir.setAttribute("f-forigin", yt[Et].fOrigin), Ir.setAttribute("f-origin", yt[Et].origin), Ir.type = "text/css", Ir.rel = "stylesheet", Ir.href = yt[Et].fPath, document.body.appendChild(Ir);
            }
          } else if (yt[Et].fOrigin === "t" || yt[Et].origin === 2) {
            for (vr = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), pr = 0; pr < vr.length; pr += 1)
              yt[Et].fPath === vr[pr].src && (nr = !1);
            if (nr) {
              var fn = createTag("link");
              fn.setAttribute("f-forigin", yt[Et].fOrigin), fn.setAttribute("f-origin", yt[Et].origin), fn.setAttribute("rel", "stylesheet"), fn.setAttribute("href", yt[Et].fPath), Ft.appendChild(fn);
            }
          }
          yt[Et].helper = ut(yt[Et], Ft), yt[Et].cache = {}, this.fonts.push(yt[Et]);
        }
        Ot === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100);
      }
      function ot(wt) {
        if (wt) {
          this.chars || (this.chars = []);
          var Ft, yt = wt.length, Et, Dt = this.chars.length, Ot;
          for (Ft = 0; Ft < yt; Ft += 1) {
            for (Et = 0, Ot = !1; Et < Dt; )
              this.chars[Et].style === wt[Ft].style && this.chars[Et].fFamily === wt[Ft].fFamily && this.chars[Et].ch === wt[Ft].ch && (Ot = !0), Et += 1;
            Ot || (this.chars.push(wt[Ft]), Dt += 1);
          }
        }
      }
      function ht(wt, Ft, yt) {
        for (var Et = 0, Dt = this.chars.length; Et < Dt; ) {
          if (this.chars[Et].ch === wt && this.chars[Et].style === Ft && this.chars[Et].fFamily === yt)
            return this.chars[Et];
          Et += 1;
        }
        return (typeof wt == "string" && wt.charCodeAt(0) !== 13 || !wt) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", wt, Ft, yt)), ne;
      }
      function ft(wt, Ft, yt) {
        var Et = this.getFontByName(Ft), Dt = wt;
        if (!Et.cache[Dt]) {
          var Ot = Et.helper;
          if (wt === " ") {
            var nr = Ot.measureText("|" + wt + "|"), vr = Ot.measureText("||");
            Et.cache[Dt] = (nr - vr) / 100;
          } else
            Et.cache[Dt] = Ot.measureText(wt) / 100;
        }
        return Et.cache[Dt] * yt;
      }
      function vt(wt) {
        for (var Ft = 0, yt = this.fonts.length; Ft < yt; ) {
          if (this.fonts[Ft].fName === wt)
            return this.fonts[Ft];
          Ft += 1;
        }
        return this.fonts[0];
      }
      function Ct(wt) {
        var Ft = 0, yt = wt.charCodeAt(0);
        if (yt >= 55296 && yt <= 56319) {
          var Et = wt.charCodeAt(1);
          Et >= 56320 && Et <= 57343 && (Ft = (yt - 55296) * 1024 + Et - 56320 + 65536);
        }
        return Ft;
      }
      function xt(wt, Ft) {
        var yt = wt.toString(16) + Ft.toString(16);
        return dt.indexOf(yt) !== -1;
      }
      function At(wt) {
        return wt === Ae;
      }
      function kt(wt) {
        return wt === Ie;
      }
      function Vt(wt) {
        var Ft = Ct(wt);
        return Ft >= rt && Ft <= st;
      }
      function ir(wt) {
        return Vt(wt.substr(0, 2)) && Vt(wt.substr(2, 2));
      }
      function er(wt) {
        return oe.indexOf(wt) !== -1;
      }
      function Yt(wt, Ft) {
        var yt = Ct(wt.substr(Ft, 2));
        if (yt !== pe)
          return !1;
        var Et = 0;
        for (Ft += 2; Et < 5; ) {
          if (yt = Ct(wt.substr(Ft, 2)), yt < ge || yt > be)
            return !1;
          Et += 1, Ft += 2;
        }
        return Ct(wt.substr(Ft, 2)) === me;
      }
      function Jt() {
        this.isLoaded = !0;
      }
      var rr = function() {
        this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      rr.isModifier = xt, rr.isZeroWidthJoiner = At, rr.isFlagEmoji = ir, rr.isRegionalCode = Vt, rr.isCombinedCharacter = er, rr.isRegionalFlag = Yt, rr.isVariationSelector = kt, rr.BLACK_FLAG_CODE_POINT = pe;
      var Qt = {
        addChars: ot,
        addFonts: St,
        getCharData: ht,
        getFontByName: vt,
        measureText: ft,
        checkLoadedFonts: it,
        setIsLoaded: Jt
      };
      return rr.prototype = Qt, rr;
    }();
    function SlotManager(L) {
      this.animationData = L;
    }
    SlotManager.prototype.getProp = function(L) {
      return this.animationData.slots && this.animationData.slots[L.sid] ? Object.assign(L, this.animationData.slots[L.sid].p) : L;
    };
    function slotFactory(L) {
      return new SlotManager(L);
    }
    function RenderableElement() {
    }
    RenderableElement.prototype = {
      initRenderable: function() {
        this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [];
      },
      addRenderableComponent: function(ne) {
        this.renderableComponents.indexOf(ne) === -1 && this.renderableComponents.push(ne);
      },
      removeRenderableComponent: function(ne) {
        this.renderableComponents.indexOf(ne) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(ne), 1);
      },
      prepareRenderableFrame: function(ne) {
        this.checkLayerLimits(ne);
      },
      checkTransparency: function() {
        this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show());
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function(ne) {
        this.data.ip - this.data.st <= ne && this.data.op - this.data.st > ne ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide());
      },
      renderRenderable: function() {
        var ne, oe = this.renderableComponents.length;
        for (ne = 0; ne < oe; ne += 1)
          this.renderableComponents[ne].renderFrame(this._isFirstFrame);
      },
      sourceRectAtTime: function() {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100
        };
      },
      getLayerSize: function() {
        return this.data.ty === 5 ? {
          w: this.data.textData.width,
          h: this.data.textData.height
        } : {
          w: this.data.width,
          h: this.data.height
        };
      }
    };
    var getBlendMode = /* @__PURE__ */ function() {
      var L = {
        0: "source-over",
        1: "multiply",
        2: "screen",
        3: "overlay",
        4: "darken",
        5: "lighten",
        6: "color-dodge",
        7: "color-burn",
        8: "hard-light",
        9: "soft-light",
        10: "difference",
        11: "exclusion",
        12: "hue",
        13: "saturation",
        14: "color",
        15: "luminosity"
      };
      return function(ne) {
        return L[ne] || "";
      };
    }();
    function SliderEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function AngleEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function ColorEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 1, 0, oe);
    }
    function PointEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 1, 0, oe);
    }
    function LayerIndexEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function MaskIndexEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function CheckboxEffect(L, ne, oe) {
      this.p = PropertyFactory.getProp(ne, L.v, 0, 0, oe);
    }
    function NoValueEffect() {
      this.p = {};
    }
    function EffectsManager(L, ne) {
      var oe = L.ef || [];
      this.effectElements = [];
      var pe, me = oe.length, ge;
      for (pe = 0; pe < me; pe += 1)
        ge = new GroupEffect(oe[pe], ne), this.effectElements.push(ge);
    }
    function GroupEffect(L, ne) {
      this.init(L, ne);
    }
    extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(L, ne) {
      this.data = L, this.effectElements = [], this.initDynamicPropertyContainer(ne);
      var oe, pe = this.data.ef.length, me, ge = this.data.ef;
      for (oe = 0; oe < pe; oe += 1) {
        switch (me = null, ge[oe].ty) {
          case 0:
            me = new SliderEffect(ge[oe], ne, this);
            break;
          case 1:
            me = new AngleEffect(ge[oe], ne, this);
            break;
          case 2:
            me = new ColorEffect(ge[oe], ne, this);
            break;
          case 3:
            me = new PointEffect(ge[oe], ne, this);
            break;
          case 4:
          case 7:
            me = new CheckboxEffect(ge[oe], ne, this);
            break;
          case 10:
            me = new LayerIndexEffect(ge[oe], ne, this);
            break;
          case 11:
            me = new MaskIndexEffect(ge[oe], ne, this);
            break;
          case 5:
            me = new EffectsManager(ge[oe], ne);
            break;
          default:
            me = new NoValueEffect(ge[oe]);
            break;
        }
        me && this.effectElements.push(me);
      }
    };
    function BaseElement() {
    }
    BaseElement.prototype = {
      checkMasks: function() {
        if (!this.data.hasMask)
          return !1;
        for (var ne = 0, oe = this.data.masksProperties.length; ne < oe; ) {
          if (this.data.masksProperties[ne].mode !== "n" && this.data.masksProperties[ne].cl !== !1)
            return !0;
          ne += 1;
        }
        return !1;
      },
      initExpressions: function() {
        var ne = getExpressionInterfaces();
        if (ne) {
          var oe = ne("layer"), pe = ne("effects"), me = ne("shape"), ge = ne("text"), be = ne("comp");
          this.layerInterface = oe(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
          var Ie = pe.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(Ie), this.data.ty === 0 || this.data.xt ? this.compInterface = be(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = me(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = ge(this), this.layerInterface.text = this.layerInterface.textInterface);
        }
      },
      setBlendMode: function() {
        var ne = getBlendMode(this.data.bm), oe = this.baseElement || this.layerElement;
        oe.style["mix-blend-mode"] = ne;
      },
      initBaseData: function(ne, oe, pe) {
        this.globalData = oe, this.comp = pe, this.data = ne, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function() {
        return this.type;
      },
      sourceRectAtTime: function() {
      }
    };
    function FrameElement() {
    }
    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function() {
        this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function(ne, oe) {
        var pe, me = this.dynamicProperties.length;
        for (pe = 0; pe < me; pe += 1)
          (oe || this._isParent && this.dynamicProperties[pe].propType === "transform") && (this.dynamicProperties[pe].getValue(), this.dynamicProperties[pe]._mdf && (this.globalData._mdf = !0, this._mdf = !0));
      },
      addDynamicProperty: function(ne) {
        this.dynamicProperties.indexOf(ne) === -1 && this.dynamicProperties.push(ne);
      }
    };
    function FootageElement(L, ne, oe) {
      this.initFrame(), this.initRenderable(), this.assetData = ne.getAssetData(L.refId), this.footageData = ne.imageLoader.getAsset(this.assetData), this.initBaseData(L, ne, oe);
    }
    FootageElement.prototype.prepareFrame = function() {
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
      return null;
    }, FootageElement.prototype.renderFrame = function() {
    }, FootageElement.prototype.destroy = function() {
    }, FootageElement.prototype.initExpressions = function() {
      var L = getExpressionInterfaces();
      if (L) {
        var ne = L("footage");
        this.layerInterface = ne(this);
      }
    }, FootageElement.prototype.getFootageData = function() {
      return this.footageData;
    };
    function AudioElement(L, ne, oe) {
      this.initFrame(), this.initRenderable(), this.assetData = ne.getAssetData(L.refId), this.initBaseData(L, ne, oe), this._isPlaying = !1, this._canPlay = !1;
      var pe = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(pe), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      }, this.lv = PropertyFactory.getProp(this, L.au && L.au.lv ? L.au.lv : {
        k: [100]
      }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function(L) {
      if (this.prepareRenderableFrame(L, !0), this.prepareProperties(L, !0), this.tm._placeholder)
        this._currentTime = L / this.data.sr;
      else {
        var ne = this.tm.v;
        this._currentTime = ne;
      }
      this._volume = this.lv.v[0];
      var oe = this._volume * this._volumeMultiplier;
      this._previousVolume !== oe && (this._previousVolume = oe, this.audio.volume(oe));
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
      this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0));
    }, AudioElement.prototype.show = function() {
    }, AudioElement.prototype.hide = function() {
      this.audio.pause(), this._isPlaying = !1;
    }, AudioElement.prototype.pause = function() {
      this.audio.pause(), this._isPlaying = !1, this._canPlay = !1;
    }, AudioElement.prototype.resume = function() {
      this._canPlay = !0;
    }, AudioElement.prototype.setRate = function(L) {
      this.audio.rate(L);
    }, AudioElement.prototype.volume = function(L) {
      this._volumeMultiplier = L, this._previousVolume = L * this._volume, this.audio.volume(this._previousVolume);
    }, AudioElement.prototype.getBaseElement = function() {
      return null;
    }, AudioElement.prototype.destroy = function() {
    }, AudioElement.prototype.sourceRectAtTime = function() {
    }, AudioElement.prototype.initExpressions = function() {
    };
    function BaseRenderer() {
    }
    BaseRenderer.prototype.checkLayers = function(L) {
      var ne, oe = this.layers.length, pe;
      for (this.completeLayers = !0, ne = oe - 1; ne >= 0; ne -= 1)
        this.elements[ne] || (pe = this.layers[ne], pe.ip - pe.st <= L - this.layers[ne].st && pe.op - pe.st > L - this.layers[ne].st && this.buildItem(ne)), this.completeLayers = this.elements[ne] ? this.completeLayers : !1;
      this.checkPendingElements();
    }, BaseRenderer.prototype.createItem = function(L) {
      switch (L.ty) {
        case 2:
          return this.createImage(L);
        case 0:
          return this.createComp(L);
        case 1:
          return this.createSolid(L);
        case 3:
          return this.createNull(L);
        case 4:
          return this.createShape(L);
        case 5:
          return this.createText(L);
        case 6:
          return this.createAudio(L);
        case 13:
          return this.createCamera(L);
        case 15:
          return this.createFootage(L);
        default:
          return this.createNull(L);
      }
    }, BaseRenderer.prototype.createCamera = function() {
      throw new Error("You're using a 3d camera. Try the html renderer.");
    }, BaseRenderer.prototype.createAudio = function(L) {
      return new AudioElement(L, this.globalData, this);
    }, BaseRenderer.prototype.createFootage = function(L) {
      return new FootageElement(L, this.globalData, this);
    }, BaseRenderer.prototype.buildAllItems = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        this.buildItem(L);
      this.checkPendingElements();
    }, BaseRenderer.prototype.includeLayers = function(L) {
      this.completeLayers = !1;
      var ne, oe = L.length, pe, me = this.layers.length;
      for (ne = 0; ne < oe; ne += 1)
        for (pe = 0; pe < me; ) {
          if (this.layers[pe].id === L[ne].id) {
            this.layers[pe] = L[ne];
            break;
          }
          pe += 1;
        }
    }, BaseRenderer.prototype.setProjectInterface = function(L) {
      this.globalData.projectInterface = L;
    }, BaseRenderer.prototype.initItems = function() {
      this.globalData.progressiveLoad || this.buildAllItems();
    }, BaseRenderer.prototype.buildElementParenting = function(L, ne, oe) {
      for (var pe = this.elements, me = this.layers, ge = 0, be = me.length; ge < be; )
        me[ge].ind == ne && (!pe[ge] || pe[ge] === !0 ? (this.buildItem(ge), this.addPendingElement(L)) : (oe.push(pe[ge]), pe[ge].setAsParent(), me[ge].parent !== void 0 ? this.buildElementParenting(L, me[ge].parent, oe) : L.setHierarchy(oe))), ge += 1;
    }, BaseRenderer.prototype.addPendingElement = function(L) {
      this.pendingElements.push(L);
    }, BaseRenderer.prototype.searchExtraCompositions = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        if (L[ne].xt) {
          var pe = this.createComp(L[ne]);
          pe.initExpressions(), this.globalData.projectInterface.registerComposition(pe);
        }
    }, BaseRenderer.prototype.getElementById = function(L) {
      var ne, oe = this.elements.length;
      for (ne = 0; ne < oe; ne += 1)
        if (this.elements[ne].data.ind === L)
          return this.elements[ne];
      return null;
    }, BaseRenderer.prototype.getElementByPath = function(L) {
      var ne = L.shift(), oe;
      if (typeof ne == "number")
        oe = this.elements[ne];
      else {
        var pe, me = this.elements.length;
        for (pe = 0; pe < me; pe += 1)
          if (this.elements[pe].data.nm === ne) {
            oe = this.elements[pe];
            break;
          }
      }
      return L.length === 0 ? oe : oe.getElementByPath(L);
    }, BaseRenderer.prototype.setupGlobalData = function(L, ne) {
      this.globalData.fontManager = new FontManager(), this.globalData.slotManager = slotFactory(L), this.globalData.fontManager.addChars(L.chars), this.globalData.fontManager.addFonts(L.fonts, ne), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = L.fr, this.globalData.nm = L.nm, this.globalData.compSize = {
        w: L.w,
        h: L.h
      };
    };
    var effectTypes = {
      TRANSFORM_EFFECT: "transformEFfect"
    };
    function TransformElement() {
    }
    TransformElement.prototype = {
      initTransform: function() {
        var ne = new Matrix();
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
            o: 0
          },
          _matMdf: !1,
          _localMatMdf: !1,
          _opMdf: !1,
          mat: ne,
          localMat: ne,
          localOpacity: 1
        }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty;
      },
      renderTransform: function() {
        if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
          var ne, oe = this.finalTransform.mat, pe = 0, me = this.hierarchy.length;
          if (!this.finalTransform._matMdf)
            for (; pe < me; ) {
              if (this.hierarchy[pe].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = !0;
                break;
              }
              pe += 1;
            }
          if (this.finalTransform._matMdf)
            for (ne = this.finalTransform.mProp.v.props, oe.cloneFromProps(ne), pe = 0; pe < me; pe += 1)
              oe.multiply(this.hierarchy[pe].finalTransform.mProp.v);
        }
        this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v);
      },
      renderLocalTransform: function() {
        if (this.localTransforms) {
          var ne = 0, oe = this.localTransforms.length;
          if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            for (; ne < oe; )
              this.localTransforms[ne]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[ne]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), ne += 1;
          if (this.finalTransform._localMatMdf) {
            var pe = this.finalTransform.localMat;
            for (this.localTransforms[0].matrix.clone(pe), ne = 1; ne < oe; ne += 1) {
              var me = this.localTransforms[ne].matrix;
              pe.multiply(me);
            }
            pe.multiply(this.finalTransform.mat);
          }
          if (this.finalTransform._opMdf) {
            var ge = this.finalTransform.localOpacity;
            for (ne = 0; ne < oe; ne += 1)
              ge *= this.localTransforms[ne].opacity * 0.01;
            this.finalTransform.localOpacity = ge;
          }
        }
      },
      searchEffectTransforms: function() {
        if (this.renderableEffectsManager) {
          var ne = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          if (ne.length) {
            this.localTransforms = [], this.finalTransform.localMat = new Matrix();
            var oe = 0, pe = ne.length;
            for (oe = 0; oe < pe; oe += 1)
              this.localTransforms.push(ne[oe]);
          }
        }
      },
      globalToLocal: function(ne) {
        var oe = [];
        oe.push(this.finalTransform);
        for (var pe = !0, me = this.comp; pe; )
          me.finalTransform ? (me.data.hasMask && oe.splice(0, 0, me.finalTransform), me = me.comp) : pe = !1;
        var ge, be = oe.length, Ie;
        for (ge = 0; ge < be; ge += 1)
          Ie = oe[ge].mat.applyToPointArray(0, 0, 0), ne = [ne[0] - Ie[0], ne[1] - Ie[1], 0];
        return ne;
      },
      mHelper: new Matrix()
    };
    function MaskElement(L, ne, oe) {
      this.data = L, this.element = ne, this.globalData = oe, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
      var pe = this.globalData.defs, me, ge = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(ge), this.solidPath = "";
      var be, Ie = this.masksProperties, Ae = 0, rt = [], st, dt, lt = createElementID(), pt, it, ut, St, ot = "clipPath", ht = "clip-path";
      for (me = 0; me < ge; me += 1)
        if ((Ie[me].mode !== "a" && Ie[me].mode !== "n" || Ie[me].inv || Ie[me].o.k !== 100 || Ie[me].o.x) && (ot = "mask", ht = "mask"), (Ie[me].mode === "s" || Ie[me].mode === "i") && Ae === 0 ? (pt = createNS("rect"), pt.setAttribute("fill", "#ffffff"), pt.setAttribute("width", this.element.comp.data.w || 0), pt.setAttribute("height", this.element.comp.data.h || 0), rt.push(pt)) : pt = null, be = createNS("path"), Ie[me].mode === "n")
          this.viewData[me] = {
            op: PropertyFactory.getProp(this.element, Ie[me].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, Ie[me], 3),
            elem: be,
            lastPath: ""
          }, pe.appendChild(be);
        else {
          Ae += 1, be.setAttribute("fill", Ie[me].mode === "s" ? "#000000" : "#ffffff"), be.setAttribute("clip-rule", "nonzero");
          var ft;
          if (Ie[me].x.k !== 0 ? (ot = "mask", ht = "mask", St = PropertyFactory.getProp(this.element, Ie[me].x, 0, null, this.element), ft = createElementID(), it = createNS("filter"), it.setAttribute("id", ft), ut = createNS("feMorphology"), ut.setAttribute("operator", "erode"), ut.setAttribute("in", "SourceGraphic"), ut.setAttribute("radius", "0"), it.appendChild(ut), pe.appendChild(it), be.setAttribute("stroke", Ie[me].mode === "s" ? "#000000" : "#ffffff")) : (ut = null, St = null), this.storedData[me] = {
            elem: be,
            x: St,
            expan: ut,
            lastPath: "",
            lastOperator: "",
            filterId: ft,
            lastRadius: 0
          }, Ie[me].mode === "i") {
            dt = rt.length;
            var vt = createNS("g");
            for (st = 0; st < dt; st += 1)
              vt.appendChild(rt[st]);
            var Ct = createNS("mask");
            Ct.setAttribute("mask-type", "alpha"), Ct.setAttribute("id", lt + "_" + Ae), Ct.appendChild(be), pe.appendChild(Ct), vt.setAttribute("mask", "url(" + getLocationHref() + "#" + lt + "_" + Ae + ")"), rt.length = 0, rt.push(vt);
          } else
            rt.push(be);
          Ie[me].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[me] = {
            elem: be,
            lastPath: "",
            op: PropertyFactory.getProp(this.element, Ie[me].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, Ie[me], 3),
            invRect: pt
          }, this.viewData[me].prop.k || this.drawPath(Ie[me], this.viewData[me].prop.v, this.viewData[me]);
        }
      for (this.maskElement = createNS(ot), ge = rt.length, me = 0; me < ge; me += 1)
        this.maskElement.appendChild(rt[me]);
      Ae > 0 && (this.maskElement.setAttribute("id", lt), this.element.maskedElement.setAttribute(ht, "url(" + getLocationHref() + "#" + lt + ")"), pe.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this);
    }
    MaskElement.prototype.getMaskProperty = function(L) {
      return this.viewData[L].prop;
    }, MaskElement.prototype.renderFrame = function(L) {
      var ne = this.element.finalTransform.mat, oe, pe = this.masksProperties.length;
      for (oe = 0; oe < pe; oe += 1)
        if ((this.viewData[oe].prop._mdf || L) && this.drawPath(this.masksProperties[oe], this.viewData[oe].prop.v, this.viewData[oe]), (this.viewData[oe].op._mdf || L) && this.viewData[oe].elem.setAttribute("fill-opacity", this.viewData[oe].op.v), this.masksProperties[oe].mode !== "n" && (this.viewData[oe].invRect && (this.element.finalTransform.mProp._mdf || L) && this.viewData[oe].invRect.setAttribute("transform", ne.getInverseMatrix().to2dCSS()), this.storedData[oe].x && (this.storedData[oe].x._mdf || L))) {
          var me = this.storedData[oe].expan;
          this.storedData[oe].x.v < 0 ? (this.storedData[oe].lastOperator !== "erode" && (this.storedData[oe].lastOperator = "erode", this.storedData[oe].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[oe].filterId + ")")), me.setAttribute("radius", -this.storedData[oe].x.v)) : (this.storedData[oe].lastOperator !== "dilate" && (this.storedData[oe].lastOperator = "dilate", this.storedData[oe].elem.setAttribute("filter", null)), this.storedData[oe].elem.setAttribute("stroke-width", this.storedData[oe].x.v * 2));
        }
    }, MaskElement.prototype.getMaskelement = function() {
      return this.maskElement;
    }, MaskElement.prototype.createLayerSolidPath = function() {
      var L = "M0,0 ";
      return L += " h" + this.globalData.compSize.w, L += " v" + this.globalData.compSize.h, L += " h-" + this.globalData.compSize.w, L += " v-" + this.globalData.compSize.h + " ", L;
    }, MaskElement.prototype.drawPath = function(L, ne, oe) {
      var pe = " M" + ne.v[0][0] + "," + ne.v[0][1], me, ge;
      for (ge = ne._length, me = 1; me < ge; me += 1)
        pe += " C" + ne.o[me - 1][0] + "," + ne.o[me - 1][1] + " " + ne.i[me][0] + "," + ne.i[me][1] + " " + ne.v[me][0] + "," + ne.v[me][1];
      if (ne.c && ge > 1 && (pe += " C" + ne.o[me - 1][0] + "," + ne.o[me - 1][1] + " " + ne.i[0][0] + "," + ne.i[0][1] + " " + ne.v[0][0] + "," + ne.v[0][1]), oe.lastPath !== pe) {
        var be = "";
        oe.elem && (ne.c && (be = L.inv ? this.solidPath + pe : pe), oe.elem.setAttribute("d", be)), oe.lastPath = pe;
      }
    }, MaskElement.prototype.destroy = function() {
      this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null;
    };
    var filtersFactory = function() {
      var L = {};
      L.createFilter = ne, L.createAlphaToLuminanceFilter = oe;
      function ne(pe, me) {
        var ge = createNS("filter");
        return ge.setAttribute("id", pe), me !== !0 && (ge.setAttribute("filterUnits", "objectBoundingBox"), ge.setAttribute("x", "0%"), ge.setAttribute("y", "0%"), ge.setAttribute("width", "100%"), ge.setAttribute("height", "100%")), ge;
      }
      function oe() {
        var pe = createNS("feColorMatrix");
        return pe.setAttribute("type", "matrix"), pe.setAttribute("color-interpolation-filters", "sRGB"), pe.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), pe;
      }
      return L;
    }(), featureSupport = function() {
      var L = {
        maskType: !0,
        svgLumaHidden: !0,
        offscreenCanvas: typeof OffscreenCanvas < "u"
      };
      return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (L.maskType = !1), /firefox/i.test(navigator.userAgent) && (L.svgLumaHidden = !1), L;
    }(), registeredEffects$1 = {}, idPrefix = "filter_result_";
    function SVGEffects(L) {
      var ne, oe = "SourceGraphic", pe = L.data.ef ? L.data.ef.length : 0, me = createElementID(), ge = filtersFactory.createFilter(me, !0), be = 0;
      this.filters = [];
      var Ie;
      for (ne = 0; ne < pe; ne += 1) {
        Ie = null;
        var Ae = L.data.ef[ne].ty;
        if (registeredEffects$1[Ae]) {
          var rt = registeredEffects$1[Ae].effect;
          Ie = new rt(ge, L.effectsManager.effectElements[ne], L, idPrefix + be, oe), oe = idPrefix + be, registeredEffects$1[Ae].countsAsEffect && (be += 1);
        }
        Ie && this.filters.push(Ie);
      }
      be && (L.globalData.defs.appendChild(ge), L.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + me + ")")), this.filters.length && L.addRenderableComponent(this);
    }
    SVGEffects.prototype.renderFrame = function(L) {
      var ne, oe = this.filters.length;
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].renderFrame(L);
    }, SVGEffects.prototype.getEffects = function(L) {
      var ne, oe = this.filters.length, pe = [];
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].type === L && pe.push(this.filters[ne]);
      return pe;
    };
    function registerEffect$1(L, ne, oe) {
      registeredEffects$1[L] = {
        effect: ne,
        countsAsEffect: oe
      };
    }
    function SVGBaseElement() {
    }
    SVGBaseElement.prototype = {
      initRendererElement: function() {
        this.layerElement = createNS("g");
      },
      createContainerElements: function() {
        this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
        var ne = null;
        if (this.data.td) {
          this.matteMasks = {};
          var oe = createNS("g");
          oe.setAttribute("id", this.layerId), oe.appendChild(this.layerElement), ne = oe, this.globalData.defs.appendChild(oe);
        } else
          this.data.tt ? (this.matteElement.appendChild(this.layerElement), ne = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
        if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) {
          var pe = createNS("clipPath"), me = createNS("path");
          me.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
          var ge = createElementID();
          if (pe.setAttribute("id", ge), pe.appendChild(me), this.globalData.defs.appendChild(pe), this.checkMasks()) {
            var be = createNS("g");
            be.setAttribute("clip-path", "url(" + getLocationHref() + "#" + ge + ")"), be.appendChild(this.layerElement), this.transformedElement = be, ne ? ne.appendChild(this.transformedElement) : this.baseElement = this.transformedElement;
          } else
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + ge + ")");
        }
        this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
      },
      destroyBaseElement: function() {
        this.layerElement = null, this.matteElement = null, this.maskManager.destroy();
      },
      getBaseElement: function() {
        return this.data.hd ? null : this.baseElement;
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms();
      },
      getMatte: function(ne) {
        if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[ne]) {
          var oe = this.layerId + "_" + ne, pe, me, ge, be;
          if (ne === 1 || ne === 3) {
            var Ie = createNS("mask");
            Ie.setAttribute("id", oe), Ie.setAttribute("mask-type", ne === 3 ? "luminance" : "alpha"), ge = createNS("use"), ge.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), Ie.appendChild(ge), this.globalData.defs.appendChild(Ie), !featureSupport.maskType && ne === 1 && (Ie.setAttribute("mask-type", "luminance"), pe = createElementID(), me = filtersFactory.createFilter(pe), this.globalData.defs.appendChild(me), me.appendChild(filtersFactory.createAlphaToLuminanceFilter()), be = createNS("g"), be.appendChild(ge), Ie.appendChild(be), be.setAttribute("filter", "url(" + getLocationHref() + "#" + pe + ")"));
          } else if (ne === 2) {
            var Ae = createNS("mask");
            Ae.setAttribute("id", oe), Ae.setAttribute("mask-type", "alpha");
            var rt = createNS("g");
            Ae.appendChild(rt), pe = createElementID(), me = filtersFactory.createFilter(pe);
            var st = createNS("feComponentTransfer");
            st.setAttribute("in", "SourceGraphic"), me.appendChild(st);
            var dt = createNS("feFuncA");
            dt.setAttribute("type", "table"), dt.setAttribute("tableValues", "1.0 0.0"), st.appendChild(dt), this.globalData.defs.appendChild(me);
            var lt = createNS("rect");
            lt.setAttribute("width", this.comp.data.w), lt.setAttribute("height", this.comp.data.h), lt.setAttribute("x", "0"), lt.setAttribute("y", "0"), lt.setAttribute("fill", "#ffffff"), lt.setAttribute("opacity", "0"), rt.setAttribute("filter", "url(" + getLocationHref() + "#" + pe + ")"), rt.appendChild(lt), ge = createNS("use"), ge.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), rt.appendChild(ge), featureSupport.maskType || (Ae.setAttribute("mask-type", "luminance"), me.appendChild(filtersFactory.createAlphaToLuminanceFilter()), be = createNS("g"), rt.appendChild(lt), be.appendChild(this.layerElement), rt.appendChild(be)), this.globalData.defs.appendChild(Ae);
          }
          this.matteMasks[ne] = oe;
        }
        return this.matteMasks[ne];
      },
      setMatte: function(ne) {
        this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + ne + ")");
      }
    };
    function HierarchyElement() {
    }
    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function() {
        this.hierarchy = [], this._isParent = !1, this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function(ne) {
        this.hierarchy = ne;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function() {
        this._isParent = !0;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function() {
        this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []);
      }
    };
    function RenderableDOMElement() {
    }
    (function() {
      var L = {
        initElement: function(oe, pe, me) {
          this.initFrame(), this.initBaseData(oe, pe, me), this.initTransform(oe, pe, me), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide();
        },
        hide: function() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var oe = this.baseElement || this.layerElement;
            oe.style.display = "none", this.hidden = !0;
          }
        },
        show: function() {
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var oe = this.baseElement || this.layerElement;
              oe.style.display = "block";
            }
            this.hidden = !1, this._isFirstFrame = !0;
          }
        },
        renderFrame: function() {
          this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
        },
        renderInnerContent: function() {
        },
        prepareFrame: function(oe) {
          this._mdf = !1, this.prepareRenderableFrame(oe), this.prepareProperties(oe, this.isInRange), this.checkTransparency();
        },
        destroy: function() {
          this.innerElem = null, this.destroyBaseElement();
        }
      };
      extendPrototype([RenderableElement, createProxyFunction(L)], RenderableDOMElement);
    })();
    function IImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.assetData && this.assetData.sid && (this.assetData = ne.slotManager.getProp(this.assetData)), this.initElement(L, ne, oe), this.sourceRect = {
        top: 0,
        left: 0,
        width: this.assetData.w,
        height: this.assetData.h
      };
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
      var L = this.globalData.getAssetsPath(this.assetData);
      this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", L), this.layerElement.appendChild(this.innerElem);
    }, IImageElement.prototype.sourceRectAtTime = function() {
      return this.sourceRect;
    };
    function ProcessedElement(L, ne) {
      this.elem = L, this.pos = ne;
    }
    function IShapeElement() {
    }
    IShapeElement.prototype = {
      addShapeToModifiers: function(ne) {
        var oe, pe = this.shapeModifiers.length;
        for (oe = 0; oe < pe; oe += 1)
          this.shapeModifiers[oe].addShape(ne);
      },
      isShapeInAnimatedModifiers: function(ne) {
        for (var oe = 0, pe = this.shapeModifiers.length; oe < pe; )
          if (this.shapeModifiers[oe].isAnimatedWithShape(ne))
            return !0;
        return !1;
      },
      renderModifiers: function() {
        if (this.shapeModifiers.length) {
          var ne, oe = this.shapes.length;
          for (ne = 0; ne < oe; ne += 1)
            this.shapes[ne].sh.reset();
          oe = this.shapeModifiers.length;
          var pe;
          for (ne = oe - 1; ne >= 0 && (pe = this.shapeModifiers[ne].processShapes(this._isFirstFrame), !pe); ne -= 1)
            ;
        }
      },
      searchProcessedElement: function(ne) {
        for (var oe = this.processedElements, pe = 0, me = oe.length; pe < me; ) {
          if (oe[pe].elem === ne)
            return oe[pe].pos;
          pe += 1;
        }
        return 0;
      },
      addProcessedElement: function(ne, oe) {
        for (var pe = this.processedElements, me = pe.length; me; )
          if (me -= 1, pe[me].elem === ne) {
            pe[me].pos = oe;
            return;
          }
        pe.push(new ProcessedElement(ne, oe));
      },
      prepareFrame: function(ne) {
        this.prepareRenderableFrame(ne), this.prepareProperties(ne, this.isInRange);
      }
    };
    var lineCapEnum = {
      1: "butt",
      2: "round",
      3: "square"
    }, lineJoinEnum = {
      1: "miter",
      2: "round",
      3: "bevel"
    };
    function SVGShapeData(L, ne, oe) {
      this.caches = [], this.styles = [], this.transformers = L, this.lStr = "", this.sh = oe, this.lvl = ne, this._isAnimated = !!oe.k;
      for (var pe = 0, me = L.length; pe < me; ) {
        if (L[pe].mProps.dynamicProperties.length) {
          this._isAnimated = !0;
          break;
        }
        pe += 1;
      }
    }
    SVGShapeData.prototype.setAsAnimated = function() {
      this._isAnimated = !0;
    };
    function SVGStyleData(L, ne) {
      this.data = L, this.type = L.ty, this.d = "", this.lvl = ne, this._mdf = !1, this.closed = L.hd === !0, this.pElem = createNS("path"), this.msElem = null;
    }
    SVGStyleData.prototype.reset = function() {
      this.d = "", this._mdf = !1;
    };
    function DashProperty(L, ne, oe, pe) {
      this.elem = L, this.frameId = -1, this.dataProps = createSizedArray(ne.length), this.renderer = oe, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", ne.length ? ne.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(pe);
      var me, ge = ne.length || 0, be;
      for (me = 0; me < ge; me += 1)
        be = PropertyFactory.getProp(L, ne[me].v, 0, 0, this), this.k = be.k || this.k, this.dataProps[me] = {
          n: ne[me].n,
          p: be
        };
      this.k || this.getValue(!0), this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function(L) {
      if (!(this.elem.globalData.frameId === this.frameId && !L) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || L, this._mdf)) {
        var ne = 0, oe = this.dataProps.length;
        for (this.renderer === "svg" && (this.dashStr = ""), ne = 0; ne < oe; ne += 1)
          this.dataProps[ne].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[ne].p.v : this.dashArray[ne] = this.dataProps[ne].p.v : this.dashoffset[0] = this.dataProps[ne].p.v;
      }
    }, extendPrototype([DynamicPropertyContainer], DashProperty);
    function SVGStrokeStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.w = PropertyFactory.getProp(L, ne.w, 0, null, this), this.d = new DashProperty(L, ne.d || {}, "svg", this), this.c = PropertyFactory.getProp(L, ne.c, 1, 255, this), this.style = oe, this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.c = PropertyFactory.getProp(L, ne.c, 1, 255, this), this.style = oe;
    }
    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGNoStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.style = oe;
    }
    extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
    function GradientProperty(L, ne, oe) {
      this.data = ne, this.c = createTypedArray("uint8c", ne.p * 4);
      var pe = ne.k.k[0].s ? ne.k.k[0].s.length - ne.p * 4 : ne.k.k.length - ne.p * 4;
      this.o = createTypedArray("float32", pe), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = pe, this.initDynamicPropertyContainer(oe), this.prop = PropertyFactory.getProp(L, ne.k, 1, null, this), this.k = this.prop.k, this.getValue(!0);
    }
    GradientProperty.prototype.comparePoints = function(L, ne) {
      for (var oe = 0, pe = this.o.length / 2, me; oe < pe; ) {
        if (me = Math.abs(L[oe * 4] - L[ne * 4 + oe * 2]), me > 0.01)
          return !1;
        oe += 1;
      }
      return !0;
    }, GradientProperty.prototype.checkCollapsable = function() {
      if (this.o.length / 2 !== this.c.length / 4)
        return !1;
      if (this.data.k.k[0].s)
        for (var L = 0, ne = this.data.k.k.length; L < ne; ) {
          if (!this.comparePoints(this.data.k.k[L].s, this.data.p))
            return !1;
          L += 1;
        }
      else if (!this.comparePoints(this.data.k.k, this.data.p))
        return !1;
      return !0;
    }, GradientProperty.prototype.getValue = function(L) {
      if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || L) {
        var ne, oe = this.data.p * 4, pe, me;
        for (ne = 0; ne < oe; ne += 1)
          pe = ne % 4 === 0 ? 100 : 255, me = Math.round(this.prop.v[ne] * pe), this.c[ne] !== me && (this.c[ne] = me, this._cmdf = !L);
        if (this.o.length)
          for (oe = this.prop.v.length, ne = this.data.p * 4; ne < oe; ne += 1)
            pe = ne % 2 === 0 ? 100 : 1, me = ne % 2 === 0 ? Math.round(this.prop.v[ne] * 100) : this.prop.v[ne], this.o[ne - this.data.p * 4] !== me && (this.o[ne - this.data.p * 4] = me, this._omdf = !L);
        this._mdf = !L;
      }
    }, extendPrototype([DynamicPropertyContainer], GradientProperty);
    function SVGGradientFillStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.initGradientData(L, ne, oe);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function(L, ne, oe) {
      this.o = PropertyFactory.getProp(L, ne.o, 0, 0.01, this), this.s = PropertyFactory.getProp(L, ne.s, 1, null, this), this.e = PropertyFactory.getProp(L, ne.e, 1, null, this), this.h = PropertyFactory.getProp(L, ne.h || {
        k: 0
      }, 0, 0.01, this), this.a = PropertyFactory.getProp(L, ne.a || {
        k: 0
      }, 0, degToRads, this), this.g = new GradientProperty(L, ne.g, this), this.style = oe, this.stops = [], this.setGradientData(oe.pElem, ne), this.setGradientOpacity(ne, oe), this._isAnimated = !!this._isAnimated;
    }, SVGGradientFillStyleData.prototype.setGradientData = function(L, ne) {
      var oe = createElementID(), pe = createNS(ne.t === 1 ? "linearGradient" : "radialGradient");
      pe.setAttribute("id", oe), pe.setAttribute("spreadMethod", "pad"), pe.setAttribute("gradientUnits", "userSpaceOnUse");
      var me = [], ge, be, Ie;
      for (Ie = ne.g.p * 4, be = 0; be < Ie; be += 4)
        ge = createNS("stop"), pe.appendChild(ge), me.push(ge);
      L.setAttribute(ne.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + oe + ")"), this.gf = pe, this.cst = me;
    }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(L, ne) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var oe, pe, me, ge = createNS("mask"), be = createNS("path");
        ge.appendChild(be);
        var Ie = createElementID(), Ae = createElementID();
        ge.setAttribute("id", Ae);
        var rt = createNS(L.t === 1 ? "linearGradient" : "radialGradient");
        rt.setAttribute("id", Ie), rt.setAttribute("spreadMethod", "pad"), rt.setAttribute("gradientUnits", "userSpaceOnUse"), me = L.g.k.k[0].s ? L.g.k.k[0].s.length : L.g.k.k.length;
        var st = this.stops;
        for (pe = L.g.p * 4; pe < me; pe += 2)
          oe = createNS("stop"), oe.setAttribute("stop-color", "rgb(255,255,255)"), rt.appendChild(oe), st.push(oe);
        be.setAttribute(L.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + Ie + ")"), L.ty === "gs" && (be.setAttribute("stroke-linecap", lineCapEnum[L.lc || 2]), be.setAttribute("stroke-linejoin", lineJoinEnum[L.lj || 2]), L.lj === 1 && be.setAttribute("stroke-miterlimit", L.ml)), this.of = rt, this.ms = ge, this.ost = st, this.maskId = Ae, ne.msElem = be;
      }
    }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(L, ne, oe) {
      this.initDynamicPropertyContainer(L), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(L, ne.w, 0, null, this), this.d = new DashProperty(L, ne.d || {}, "svg", this), this.initGradientData(L, ne, oe), this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
      this.it = [], this.prevViewData = [], this.gr = createNS("g");
    }
    function SVGTransformData(L, ne, oe) {
      this.transform = {
        mProps: L,
        op: ne,
        container: oe
      }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function(ne, oe, pe, me) {
      if (oe === 0)
        return "";
      var ge = ne.o, be = ne.i, Ie = ne.v, Ae, rt = " M" + me.applyToPointStringified(Ie[0][0], Ie[0][1]);
      for (Ae = 1; Ae < oe; Ae += 1)
        rt += " C" + me.applyToPointStringified(ge[Ae - 1][0], ge[Ae - 1][1]) + " " + me.applyToPointStringified(be[Ae][0], be[Ae][1]) + " " + me.applyToPointStringified(Ie[Ae][0], Ie[Ae][1]);
      return pe && oe && (rt += " C" + me.applyToPointStringified(ge[Ae - 1][0], ge[Ae - 1][1]) + " " + me.applyToPointStringified(be[0][0], be[0][1]) + " " + me.applyToPointStringified(Ie[0][0], Ie[0][1]), rt += "z"), rt;
    }, SVGElementsRenderer = function() {
      var L = new Matrix(), ne = new Matrix(), oe = {
        createRenderFunction: pe
      };
      function pe(dt) {
        switch (dt.ty) {
          case "fl":
            return Ie;
          case "gf":
            return rt;
          case "gs":
            return Ae;
          case "st":
            return st;
          case "sh":
          case "el":
          case "rc":
          case "sr":
            return be;
          case "tr":
            return me;
          case "no":
            return ge;
          default:
            return null;
        }
      }
      function me(dt, lt, pt) {
        (pt || lt.transform.op._mdf) && lt.transform.container.setAttribute("opacity", lt.transform.op.v), (pt || lt.transform.mProps._mdf) && lt.transform.container.setAttribute("transform", lt.transform.mProps.v.to2dCSS());
      }
      function ge() {
      }
      function be(dt, lt, pt) {
        var it, ut, St, ot, ht, ft, vt = lt.styles.length, Ct = lt.lvl, xt, At, kt, Vt;
        for (ft = 0; ft < vt; ft += 1) {
          if (ot = lt.sh._mdf || pt, lt.styles[ft].lvl < Ct) {
            for (At = ne.reset(), kt = Ct - lt.styles[ft].lvl, Vt = lt.transformers.length - 1; !ot && kt > 0; )
              ot = lt.transformers[Vt].mProps._mdf || ot, kt -= 1, Vt -= 1;
            if (ot)
              for (kt = Ct - lt.styles[ft].lvl, Vt = lt.transformers.length - 1; kt > 0; )
                At.multiply(lt.transformers[Vt].mProps.v), kt -= 1, Vt -= 1;
          } else
            At = L;
          if (xt = lt.sh.paths, ut = xt._length, ot) {
            for (St = "", it = 0; it < ut; it += 1)
              ht = xt.shapes[it], ht && ht._length && (St += buildShapeString(ht, ht._length, ht.c, At));
            lt.caches[ft] = St;
          } else
            St = lt.caches[ft];
          lt.styles[ft].d += dt.hd === !0 ? "" : St, lt.styles[ft]._mdf = ot || lt.styles[ft]._mdf;
        }
      }
      function Ie(dt, lt, pt) {
        var it = lt.style;
        (lt.c._mdf || pt) && it.pElem.setAttribute("fill", "rgb(" + bmFloor(lt.c.v[0]) + "," + bmFloor(lt.c.v[1]) + "," + bmFloor(lt.c.v[2]) + ")"), (lt.o._mdf || pt) && it.pElem.setAttribute("fill-opacity", lt.o.v);
      }
      function Ae(dt, lt, pt) {
        rt(dt, lt, pt), st(dt, lt, pt);
      }
      function rt(dt, lt, pt) {
        var it = lt.gf, ut = lt.g._hasOpacity, St = lt.s.v, ot = lt.e.v;
        if (lt.o._mdf || pt) {
          var ht = dt.ty === "gf" ? "fill-opacity" : "stroke-opacity";
          lt.style.pElem.setAttribute(ht, lt.o.v);
        }
        if (lt.s._mdf || pt) {
          var ft = dt.t === 1 ? "x1" : "cx", vt = ft === "x1" ? "y1" : "cy";
          it.setAttribute(ft, St[0]), it.setAttribute(vt, St[1]), ut && !lt.g._collapsable && (lt.of.setAttribute(ft, St[0]), lt.of.setAttribute(vt, St[1]));
        }
        var Ct, xt, At, kt;
        if (lt.g._cmdf || pt) {
          Ct = lt.cst;
          var Vt = lt.g.c;
          for (At = Ct.length, xt = 0; xt < At; xt += 1)
            kt = Ct[xt], kt.setAttribute("offset", Vt[xt * 4] + "%"), kt.setAttribute("stop-color", "rgb(" + Vt[xt * 4 + 1] + "," + Vt[xt * 4 + 2] + "," + Vt[xt * 4 + 3] + ")");
        }
        if (ut && (lt.g._omdf || pt)) {
          var ir = lt.g.o;
          for (lt.g._collapsable ? Ct = lt.cst : Ct = lt.ost, At = Ct.length, xt = 0; xt < At; xt += 1)
            kt = Ct[xt], lt.g._collapsable || kt.setAttribute("offset", ir[xt * 2] + "%"), kt.setAttribute("stop-opacity", ir[xt * 2 + 1]);
        }
        if (dt.t === 1)
          (lt.e._mdf || pt) && (it.setAttribute("x2", ot[0]), it.setAttribute("y2", ot[1]), ut && !lt.g._collapsable && (lt.of.setAttribute("x2", ot[0]), lt.of.setAttribute("y2", ot[1])));
        else {
          var er;
          if ((lt.s._mdf || lt.e._mdf || pt) && (er = Math.sqrt(Math.pow(St[0] - ot[0], 2) + Math.pow(St[1] - ot[1], 2)), it.setAttribute("r", er), ut && !lt.g._collapsable && lt.of.setAttribute("r", er)), lt.e._mdf || lt.h._mdf || lt.a._mdf || pt) {
            er || (er = Math.sqrt(Math.pow(St[0] - ot[0], 2) + Math.pow(St[1] - ot[1], 2)));
            var Yt = Math.atan2(ot[1] - St[1], ot[0] - St[0]), Jt = lt.h.v;
            Jt >= 1 ? Jt = 0.99 : Jt <= -1 && (Jt = -0.99);
            var rr = er * Jt, Qt = Math.cos(Yt + lt.a.v) * rr + St[0], wt = Math.sin(Yt + lt.a.v) * rr + St[1];
            it.setAttribute("fx", Qt), it.setAttribute("fy", wt), ut && !lt.g._collapsable && (lt.of.setAttribute("fx", Qt), lt.of.setAttribute("fy", wt));
          }
        }
      }
      function st(dt, lt, pt) {
        var it = lt.style, ut = lt.d;
        ut && (ut._mdf || pt) && ut.dashStr && (it.pElem.setAttribute("stroke-dasharray", ut.dashStr), it.pElem.setAttribute("stroke-dashoffset", ut.dashoffset[0])), lt.c && (lt.c._mdf || pt) && it.pElem.setAttribute("stroke", "rgb(" + bmFloor(lt.c.v[0]) + "," + bmFloor(lt.c.v[1]) + "," + bmFloor(lt.c.v[2]) + ")"), (lt.o._mdf || pt) && it.pElem.setAttribute("stroke-opacity", lt.o.v), (lt.w._mdf || pt) && (it.pElem.setAttribute("stroke-width", lt.w.v), it.msElem && it.msElem.setAttribute("stroke-width", lt.w.v));
      }
      return oe;
    }();
    function SVGShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(L, ne, oe), this.prevViewData = [];
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {
    }, SVGShapeElement.prototype.identityMatrix = new Matrix(), SVGShapeElement.prototype.buildExpressionInterface = function() {
    }, SVGShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes();
    }, SVGShapeElement.prototype.filterUniqueShapes = function() {
      var L, ne = this.shapes.length, oe, pe, me = this.stylesList.length, ge, be = [], Ie = !1;
      for (pe = 0; pe < me; pe += 1) {
        for (ge = this.stylesList[pe], Ie = !1, be.length = 0, L = 0; L < ne; L += 1)
          oe = this.shapes[L], oe.styles.indexOf(ge) !== -1 && (be.push(oe), Ie = oe._isAnimated || Ie);
        be.length > 1 && Ie && this.setShapesAsAnimated(be);
      }
    }, SVGShapeElement.prototype.setShapesAsAnimated = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne].setAsAnimated();
    }, SVGShapeElement.prototype.createStyleElement = function(L, ne) {
      var oe, pe = new SVGStyleData(L, ne), me = pe.pElem;
      if (L.ty === "st")
        oe = new SVGStrokeStyleData(this, L, pe);
      else if (L.ty === "fl")
        oe = new SVGFillStyleData(this, L, pe);
      else if (L.ty === "gf" || L.ty === "gs") {
        var ge = L.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        oe = new ge(this, L, pe), this.globalData.defs.appendChild(oe.gf), oe.maskId && (this.globalData.defs.appendChild(oe.ms), this.globalData.defs.appendChild(oe.of), me.setAttribute("mask", "url(" + getLocationHref() + "#" + oe.maskId + ")"));
      } else
        L.ty === "no" && (oe = new SVGNoStyleData(this, L, pe));
      return (L.ty === "st" || L.ty === "gs") && (me.setAttribute("stroke-linecap", lineCapEnum[L.lc || 2]), me.setAttribute("stroke-linejoin", lineJoinEnum[L.lj || 2]), me.setAttribute("fill-opacity", "0"), L.lj === 1 && me.setAttribute("stroke-miterlimit", L.ml)), L.r === 2 && me.setAttribute("fill-rule", "evenodd"), L.ln && me.setAttribute("id", L.ln), L.cl && me.setAttribute("class", L.cl), L.bm && (me.style["mix-blend-mode"] = getBlendMode(L.bm)), this.stylesList.push(pe), this.addToAnimatedContents(L, oe), oe;
    }, SVGShapeElement.prototype.createGroupElement = function(L) {
      var ne = new ShapeGroupData();
      return L.ln && ne.gr.setAttribute("id", L.ln), L.cl && ne.gr.setAttribute("class", L.cl), L.bm && (ne.gr.style["mix-blend-mode"] = getBlendMode(L.bm)), ne;
    }, SVGShapeElement.prototype.createTransformElement = function(L, ne) {
      var oe = TransformPropertyFactory.getTransformProperty(this, L, this), pe = new SVGTransformData(oe, oe.o, ne);
      return this.addToAnimatedContents(L, pe), pe;
    }, SVGShapeElement.prototype.createShapeElement = function(L, ne, oe) {
      var pe = 4;
      L.ty === "rc" ? pe = 5 : L.ty === "el" ? pe = 6 : L.ty === "sr" && (pe = 7);
      var me = ShapePropertyFactory.getShapeProp(this, L, pe, this), ge = new SVGShapeData(ne, oe, me);
      return this.shapes.push(ge), this.addShapeToModifiers(ge), this.addToAnimatedContents(L, ge), ge;
    }, SVGShapeElement.prototype.addToAnimatedContents = function(L, ne) {
      for (var oe = 0, pe = this.animatedContents.length; oe < pe; ) {
        if (this.animatedContents[oe].element === ne)
          return;
        oe += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(L),
        element: ne,
        data: L
      });
    }, SVGShapeElement.prototype.setElementStyles = function(L) {
      var ne = L.styles, oe, pe = this.stylesList.length;
      for (oe = 0; oe < pe; oe += 1)
        this.stylesList[oe].closed || ne.push(this.stylesList[oe]);
    }, SVGShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var L, ne = this.itemsData.length;
      for (L = 0; L < ne; L += 1)
        this.prevViewData[L] = this.itemsData[L];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), ne = this.dynamicProperties.length, L = 0; L < ne; L += 1)
        this.dynamicProperties[L].getValue();
      this.renderModifiers();
    }, SVGShapeElement.prototype.searchShapes = function(L, ne, oe, pe, me, ge, be) {
      var Ie = [].concat(ge), Ae, rt = L.length - 1, st, dt, lt = [], pt = [], it, ut, St;
      for (Ae = rt; Ae >= 0; Ae -= 1) {
        if (St = this.searchProcessedElement(L[Ae]), St ? ne[Ae] = oe[St - 1] : L[Ae]._render = be, L[Ae].ty === "fl" || L[Ae].ty === "st" || L[Ae].ty === "gf" || L[Ae].ty === "gs" || L[Ae].ty === "no")
          St ? ne[Ae].style.closed = !1 : ne[Ae] = this.createStyleElement(L[Ae], me), L[Ae]._render && ne[Ae].style.pElem.parentNode !== pe && pe.appendChild(ne[Ae].style.pElem), lt.push(ne[Ae].style);
        else if (L[Ae].ty === "gr") {
          if (!St)
            ne[Ae] = this.createGroupElement(L[Ae]);
          else
            for (dt = ne[Ae].it.length, st = 0; st < dt; st += 1)
              ne[Ae].prevViewData[st] = ne[Ae].it[st];
          this.searchShapes(L[Ae].it, ne[Ae].it, ne[Ae].prevViewData, ne[Ae].gr, me + 1, Ie, be), L[Ae]._render && ne[Ae].gr.parentNode !== pe && pe.appendChild(ne[Ae].gr);
        } else
          L[Ae].ty === "tr" ? (St || (ne[Ae] = this.createTransformElement(L[Ae], pe)), it = ne[Ae].transform, Ie.push(it)) : L[Ae].ty === "sh" || L[Ae].ty === "rc" || L[Ae].ty === "el" || L[Ae].ty === "sr" ? (St || (ne[Ae] = this.createShapeElement(L[Ae], Ie, me)), this.setElementStyles(ne[Ae])) : L[Ae].ty === "tm" || L[Ae].ty === "rd" || L[Ae].ty === "ms" || L[Ae].ty === "pb" || L[Ae].ty === "zz" || L[Ae].ty === "op" ? (St ? (ut = ne[Ae], ut.closed = !1) : (ut = ShapeModifiers.getModifier(L[Ae].ty), ut.init(this, L[Ae]), ne[Ae] = ut, this.shapeModifiers.push(ut)), pt.push(ut)) : L[Ae].ty === "rp" && (St ? (ut = ne[Ae], ut.closed = !0) : (ut = ShapeModifiers.getModifier(L[Ae].ty), ne[Ae] = ut, ut.init(this, L, Ae, ne), this.shapeModifiers.push(ut), be = !1), pt.push(ut));
        this.addProcessedElement(L[Ae], Ae + 1);
      }
      for (rt = lt.length, Ae = 0; Ae < rt; Ae += 1)
        lt[Ae].closed = !0;
      for (rt = pt.length, Ae = 0; Ae < rt; Ae += 1)
        pt[Ae].closed = !0;
    }, SVGShapeElement.prototype.renderInnerContent = function() {
      this.renderModifiers();
      var L, ne = this.stylesList.length;
      for (L = 0; L < ne; L += 1)
        this.stylesList[L].reset();
      for (this.renderShape(), L = 0; L < ne; L += 1)
        (this.stylesList[L]._mdf || this._isFirstFrame) && (this.stylesList[L].msElem && (this.stylesList[L].msElem.setAttribute("d", this.stylesList[L].d), this.stylesList[L].d = "M0 0" + this.stylesList[L].d), this.stylesList[L].pElem.setAttribute("d", this.stylesList[L].d || "M0 0"));
    }, SVGShapeElement.prototype.renderShape = function() {
      var L, ne = this.animatedContents.length, oe;
      for (L = 0; L < ne; L += 1)
        oe = this.animatedContents[L], (this._isFirstFrame || oe.element._isAnimated) && oe.data !== !0 && oe.fn(oe.data, oe.element, this._isFirstFrame);
    }, SVGShapeElement.prototype.destroy = function() {
      this.destroyBaseElement(), this.shapesData = null, this.itemsData = null;
    };
    function LetterProps(L, ne, oe, pe, me, ge) {
      this.o = L, this.sw = ne, this.sc = oe, this.fc = pe, this.m = me, this.p = ge, this._mdf = {
        o: !0,
        sw: !!ne,
        sc: !!oe,
        fc: !!pe,
        m: !0,
        p: !0
      };
    }
    LetterProps.prototype.update = function(L, ne, oe, pe, me, ge) {
      this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
      var be = !1;
      return this.o !== L && (this.o = L, this._mdf.o = !0, be = !0), this.sw !== ne && (this.sw = ne, this._mdf.sw = !0, be = !0), this.sc !== oe && (this.sc = oe, this._mdf.sc = !0, be = !0), this.fc !== pe && (this.fc = pe, this._mdf.fc = !0, be = !0), this.m !== me && (this.m = me, this._mdf.m = !0, be = !0), ge.length && (this.p[0] !== ge[0] || this.p[1] !== ge[1] || this.p[4] !== ge[4] || this.p[5] !== ge[5] || this.p[12] !== ge[12] || this.p[13] !== ge[13]) && (this.p = ge, this._mdf.p = !0, be = !0), be;
    };
    function TextProperty(L, ne) {
      this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, ne.d && ne.d.sid && (ne.d = L.globalData.slotManager.getProp(ne.d)), this.data = ne, this.elem = L, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: "",
        fStyle: "",
        fWeight: "",
        fc: "",
        j: "",
        justifyOffset: "",
        l: [],
        lh: 0,
        lineWidths: [],
        ls: "",
        of: "",
        s: "",
        sc: "",
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: !1,
        strokeColorAnim: !1,
        strokeWidthAnim: !1,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: !1
      }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData);
    }
    TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(L, ne) {
      for (var oe in ne)
        Object.prototype.hasOwnProperty.call(ne, oe) && (L[oe] = ne[oe]);
      return L;
    }, TextProperty.prototype.setCurrentData = function(L) {
      L.__complete || this.completeTextData(L), this.currentData = L, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0;
    }, TextProperty.prototype.searchProperty = function() {
      return this.searchKeyframes();
    }, TextProperty.prototype.searchKeyframes = function() {
      return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf;
    }, TextProperty.prototype.addEffect = function(L) {
      this.effectsSequence.push(L), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.getValue = function(L) {
      if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !L)) {
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var ne = this.currentData, oe = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = !0, this._mdf = !1;
        var pe, me = this.effectsSequence.length, ge = L || this.data.d.k[this.keysIndex].s;
        for (pe = 0; pe < me; pe += 1)
          oe !== this.keysIndex ? ge = this.effectsSequence[pe](ge, ge.t) : ge = this.effectsSequence[pe](this.currentData, ge.t);
        ne !== ge && this.setCurrentData(ge), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }, TextProperty.prototype.getKeyframeValue = function() {
      for (var L = this.data.d.k, ne = this.elem.comp.renderedFrame, oe = 0, pe = L.length; oe <= pe - 1 && !(oe === pe - 1 || L[oe + 1].t > ne); )
        oe += 1;
      return this.keysIndex !== oe && (this.keysIndex = oe), this.data.d.k[this.keysIndex].s;
    }, TextProperty.prototype.buildFinalText = function(L) {
      for (var ne = [], oe = 0, pe = L.length, me, ge, be = !1, Ie = !1, Ae = ""; oe < pe; )
        be = Ie, Ie = !1, me = L.charCodeAt(oe), Ae = L.charAt(oe), FontManager.isCombinedCharacter(me) ? be = !0 : me >= 55296 && me <= 56319 ? FontManager.isRegionalFlag(L, oe) ? Ae = L.substr(oe, 14) : (ge = L.charCodeAt(oe + 1), ge >= 56320 && ge <= 57343 && (FontManager.isModifier(me, ge) ? (Ae = L.substr(oe, 2), be = !0) : FontManager.isFlagEmoji(L.substr(oe, 4)) ? Ae = L.substr(oe, 4) : Ae = L.substr(oe, 2))) : me > 56319 ? (ge = L.charCodeAt(oe + 1), FontManager.isVariationSelector(me) && (be = !0)) : FontManager.isZeroWidthJoiner(me) && (be = !0, Ie = !0), be ? (ne[ne.length - 1] += Ae, be = !1) : ne.push(Ae), oe += Ae.length;
      return ne;
    }, TextProperty.prototype.completeTextData = function(L) {
      L.__complete = !0;
      var ne = this.elem.globalData.fontManager, oe = this.data, pe = [], me, ge, be, Ie = 0, Ae, rt = oe.m.g, st = 0, dt = 0, lt = 0, pt = [], it = 0, ut = 0, St, ot, ht = ne.getFontByName(L.f), ft, vt = 0, Ct = getFontProperties(ht);
      L.fWeight = Ct.weight, L.fStyle = Ct.style, L.finalSize = L.s, L.finalText = this.buildFinalText(L.t), ge = L.finalText.length, L.finalLineHeight = L.lh;
      var xt = L.tr / 1e3 * L.finalSize, At;
      if (L.sz)
        for (var kt = !0, Vt = L.sz[0], ir = L.sz[1], er, Yt; kt; ) {
          Yt = this.buildFinalText(L.t), er = 0, it = 0, ge = Yt.length, xt = L.tr / 1e3 * L.finalSize;
          var Jt = -1;
          for (me = 0; me < ge; me += 1)
            At = Yt[me].charCodeAt(0), be = !1, Yt[me] === " " ? Jt = me : (At === 13 || At === 3) && (it = 0, be = !0, er += L.finalLineHeight || L.finalSize * 1.2), ne.chars ? (ft = ne.getCharData(Yt[me], ht.fStyle, ht.fFamily), vt = be ? 0 : ft.w * L.finalSize / 100) : vt = ne.measureText(Yt[me], L.f, L.finalSize), it + vt > Vt && Yt[me] !== " " ? (Jt === -1 ? ge += 1 : me = Jt, er += L.finalLineHeight || L.finalSize * 1.2, Yt.splice(me, Jt === me ? 1 : 0, "\r"), Jt = -1, it = 0) : (it += vt, it += xt);
          er += ht.ascent * L.finalSize / 100, this.canResize && L.finalSize > this.minimumFontSize && ir < er ? (L.finalSize -= 1, L.finalLineHeight = L.finalSize * L.lh / L.s) : (L.finalText = Yt, ge = L.finalText.length, kt = !1);
        }
      it = -xt, vt = 0;
      var rr = 0, Qt;
      for (me = 0; me < ge; me += 1)
        if (be = !1, Qt = L.finalText[me], At = Qt.charCodeAt(0), At === 13 || At === 3 ? (rr = 0, pt.push(it), ut = it > ut ? it : ut, it = -2 * xt, Ae = "", be = !0, lt += 1) : Ae = Qt, ne.chars ? (ft = ne.getCharData(Qt, ht.fStyle, ne.getFontByName(L.f).fFamily), vt = be ? 0 : ft.w * L.finalSize / 100) : vt = ne.measureText(Ae, L.f, L.finalSize), Qt === " " ? rr += vt + xt : (it += vt + xt + rr, rr = 0), pe.push({
          l: vt,
          an: vt,
          add: st,
          n: be,
          anIndexes: [],
          val: Ae,
          line: lt,
          animatorJustifyOffset: 0
        }), rt == 2) {
          if (st += vt, Ae === "" || Ae === " " || me === ge - 1) {
            for ((Ae === "" || Ae === " ") && (st -= vt); dt <= me; )
              pe[dt].an = st, pe[dt].ind = Ie, pe[dt].extra = vt, dt += 1;
            Ie += 1, st = 0;
          }
        } else if (rt == 3) {
          if (st += vt, Ae === "" || me === ge - 1) {
            for (Ae === "" && (st -= vt); dt <= me; )
              pe[dt].an = st, pe[dt].ind = Ie, pe[dt].extra = vt, dt += 1;
            st = 0, Ie += 1;
          }
        } else
          pe[Ie].ind = Ie, pe[Ie].extra = 0, Ie += 1;
      if (L.l = pe, ut = it > ut ? it : ut, pt.push(it), L.sz)
        L.boxWidth = L.sz[0], L.justifyOffset = 0;
      else
        switch (L.boxWidth = ut, L.j) {
          case 1:
            L.justifyOffset = -L.boxWidth;
            break;
          case 2:
            L.justifyOffset = -L.boxWidth / 2;
            break;
          default:
            L.justifyOffset = 0;
        }
      L.lineWidths = pt;
      var wt = oe.a, Ft, yt;
      ot = wt.length;
      var Et, Dt, Ot = [];
      for (St = 0; St < ot; St += 1) {
        for (Ft = wt[St], Ft.a.sc && (L.strokeColorAnim = !0), Ft.a.sw && (L.strokeWidthAnim = !0), (Ft.a.fc || Ft.a.fh || Ft.a.fs || Ft.a.fb) && (L.fillColorAnim = !0), Dt = 0, Et = Ft.s.b, me = 0; me < ge; me += 1)
          yt = pe[me], yt.anIndexes[St] = Dt, (Et == 1 && yt.val !== "" || Et == 2 && yt.val !== "" && yt.val !== " " || Et == 3 && (yt.n || yt.val == " " || me == ge - 1) || Et == 4 && (yt.n || me == ge - 1)) && (Ft.s.rn === 1 && Ot.push(Dt), Dt += 1);
        oe.a[St].s.totalChars = Dt;
        var nr = -1, vr;
        if (Ft.s.rn === 1)
          for (me = 0; me < ge; me += 1)
            yt = pe[me], nr != yt.anIndexes[St] && (nr = yt.anIndexes[St], vr = Ot.splice(Math.floor(Math.random() * Ot.length), 1)[0]), yt.anIndexes[St] = vr;
      }
      L.yOffset = L.finalLineHeight || L.finalSize * 1.2, L.ls = L.ls || 0, L.ascent = ht.ascent * L.finalSize / 100;
    }, TextProperty.prototype.updateDocumentData = function(L, ne) {
      ne = ne === void 0 ? this.keysIndex : ne;
      var oe = this.copyData({}, this.data.d.k[ne].s);
      oe = this.copyData(oe, L), this.data.d.k[ne].s = oe, this.recalculate(ne), this.setCurrentData(oe), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.recalculate = function(L) {
      var ne = this.data.d.k[L].s;
      ne.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(ne);
    }, TextProperty.prototype.canResizeFont = function(L) {
      this.canResize = L, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.setMinimumFontSize = function(L) {
      this.minimumFontSize = Math.floor(L) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function() {
      var L = Math.max, ne = Math.min, oe = Math.floor;
      function pe(ge, be) {
        this._currentTextLength = -1, this.k = !1, this.data = be, this.elem = ge, this.comp = ge.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(ge), this.s = PropertyFactory.getProp(ge, be.s || {
          k: 0
        }, 0, 0, this), "e" in be ? this.e = PropertyFactory.getProp(ge, be.e, 0, 0, this) : this.e = {
          v: 100
        }, this.o = PropertyFactory.getProp(ge, be.o || {
          k: 0
        }, 0, 0, this), this.xe = PropertyFactory.getProp(ge, be.xe || {
          k: 0
        }, 0, 0, this), this.ne = PropertyFactory.getProp(ge, be.ne || {
          k: 0
        }, 0, 0, this), this.sm = PropertyFactory.getProp(ge, be.sm || {
          k: 100
        }, 0, 0, this), this.a = PropertyFactory.getProp(ge, be.a, 0, 0.01, this), this.dynamicProperties.length || this.getValue();
      }
      pe.prototype = {
        getMult: function(be) {
          this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
          var Ie = 0, Ae = 0, rt = 1, st = 1;
          this.ne.v > 0 ? Ie = this.ne.v / 100 : Ae = -this.ne.v / 100, this.xe.v > 0 ? rt = 1 - this.xe.v / 100 : st = 1 + this.xe.v / 100;
          var dt = BezierFactory.getBezierEasing(Ie, Ae, rt, st).get, lt = 0, pt = this.finalS, it = this.finalE, ut = this.data.sh;
          if (ut === 2)
            it === pt ? lt = be >= it ? 1 : 0 : lt = L(0, ne(0.5 / (it - pt) + (be - pt) / (it - pt), 1)), lt = dt(lt);
          else if (ut === 3)
            it === pt ? lt = be >= it ? 0 : 1 : lt = 1 - L(0, ne(0.5 / (it - pt) + (be - pt) / (it - pt), 1)), lt = dt(lt);
          else if (ut === 4)
            it === pt ? lt = 0 : (lt = L(0, ne(0.5 / (it - pt) + (be - pt) / (it - pt), 1)), lt < 0.5 ? lt *= 2 : lt = 1 - 2 * (lt - 0.5)), lt = dt(lt);
          else if (ut === 5) {
            if (it === pt)
              lt = 0;
            else {
              var St = it - pt;
              be = ne(L(0, be + 0.5 - pt), it - pt);
              var ot = -St / 2 + be, ht = St / 2;
              lt = Math.sqrt(1 - ot * ot / (ht * ht));
            }
            lt = dt(lt);
          } else
            ut === 6 ? (it === pt ? lt = 0 : (be = ne(L(0, be + 0.5 - pt), it - pt), lt = (1 + Math.cos(Math.PI + Math.PI * 2 * be / (it - pt))) / 2), lt = dt(lt)) : (be >= oe(pt) && (be - pt < 0 ? lt = L(0, ne(ne(it, 1) - (pt - be), 1)) : lt = L(0, ne(it - be, 1))), lt = dt(lt));
          if (this.sm.v !== 100) {
            var ft = this.sm.v * 0.01;
            ft === 0 && (ft = 1e-8);
            var vt = 0.5 - ft * 0.5;
            lt < vt ? lt = 0 : (lt = (lt - vt) / ft, lt > 1 && (lt = 1));
          }
          return lt * this.a.v;
        },
        getValue: function(be) {
          this.iterateDynamicProperties(), this._mdf = be || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, be && this.data.r === 2 && (this.e.v = this._currentTextLength);
          var Ie = this.data.r === 2 ? 1 : 100 / this.data.totalChars, Ae = this.o.v / Ie, rt = this.s.v / Ie + Ae, st = this.e.v / Ie + Ae;
          if (rt > st) {
            var dt = rt;
            rt = st, st = dt;
          }
          this.finalS = rt, this.finalE = st;
        }
      }, extendPrototype([DynamicPropertyContainer], pe);
      function me(ge, be, Ie) {
        return new pe(ge, be);
      }
      return {
        getTextSelectorProp: me
      };
    }();
    function TextAnimatorDataProperty(L, ne, oe) {
      var pe = {
        propType: !1
      }, me = PropertyFactory.getProp, ge = ne.a;
      this.a = {
        r: ge.r ? me(L, ge.r, 0, degToRads, oe) : pe,
        rx: ge.rx ? me(L, ge.rx, 0, degToRads, oe) : pe,
        ry: ge.ry ? me(L, ge.ry, 0, degToRads, oe) : pe,
        sk: ge.sk ? me(L, ge.sk, 0, degToRads, oe) : pe,
        sa: ge.sa ? me(L, ge.sa, 0, degToRads, oe) : pe,
        s: ge.s ? me(L, ge.s, 1, 0.01, oe) : pe,
        a: ge.a ? me(L, ge.a, 1, 0, oe) : pe,
        o: ge.o ? me(L, ge.o, 0, 0.01, oe) : pe,
        p: ge.p ? me(L, ge.p, 1, 0, oe) : pe,
        sw: ge.sw ? me(L, ge.sw, 0, 0, oe) : pe,
        sc: ge.sc ? me(L, ge.sc, 1, 0, oe) : pe,
        fc: ge.fc ? me(L, ge.fc, 1, 0, oe) : pe,
        fh: ge.fh ? me(L, ge.fh, 0, 0, oe) : pe,
        fs: ge.fs ? me(L, ge.fs, 0, 0.01, oe) : pe,
        fb: ge.fb ? me(L, ge.fb, 0, 0.01, oe) : pe,
        t: ge.t ? me(L, ge.t, 0, 0, oe) : pe
      }, this.s = TextSelectorProp.getTextSelectorProp(L, ne.s, oe), this.s.t = ne.s.t;
    }
    function TextAnimatorProperty(L, ne, oe) {
      this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = L, this._renderType = ne, this._elem = oe, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
        alignment: {}
      }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(oe);
    }
    TextAnimatorProperty.prototype.searchProperties = function() {
      var L, ne = this._textData.a.length, oe, pe = PropertyFactory.getProp;
      for (L = 0; L < ne; L += 1)
        oe = this._textData.a[L], this._animatorsData[L] = new TextAnimatorDataProperty(this._elem, oe, this);
      this._textData.p && "m" in this._textData.p ? (this._pathData = {
        a: pe(this._elem, this._textData.p.a, 0, 0, this),
        f: pe(this._elem, this._textData.p.f, 0, 0, this),
        l: pe(this._elem, this._textData.p.l, 0, 0, this),
        r: pe(this._elem, this._textData.p.r, 0, 0, this),
        p: pe(this._elem, this._textData.p.p, 0, 0, this),
        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
      }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = pe(this._elem, this._textData.m.a, 1, 0, this);
    }, TextAnimatorProperty.prototype.getMeasures = function(L, ne) {
      if (this.lettersChangedFlag = ne, !(!this._mdf && !this._isFirstFrame && !ne && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
        this._isFirstFrame = !1;
        var oe = this._moreOptions.alignment.v, pe = this._animatorsData, me = this._textData, ge = this.mHelper, be = this._renderType, Ie = this.renderedLetters.length, Ae, rt, st, dt, lt = L.l, pt, it, ut, St, ot, ht, ft, vt, Ct, xt, At, kt, Vt, ir, er;
        if (this._hasMaskedPath) {
          if (er = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
            var Yt = er.v;
            this._pathData.r.v && (Yt = Yt.reverse()), pt = {
              tLength: 0,
              segments: []
            }, dt = Yt._length - 1;
            var Jt;
            for (kt = 0, st = 0; st < dt; st += 1)
              Jt = bez.buildBezierData(Yt.v[st], Yt.v[st + 1], [Yt.o[st][0] - Yt.v[st][0], Yt.o[st][1] - Yt.v[st][1]], [Yt.i[st + 1][0] - Yt.v[st + 1][0], Yt.i[st + 1][1] - Yt.v[st + 1][1]]), pt.tLength += Jt.segmentLength, pt.segments.push(Jt), kt += Jt.segmentLength;
            st = dt, er.v.c && (Jt = bez.buildBezierData(Yt.v[st], Yt.v[0], [Yt.o[st][0] - Yt.v[st][0], Yt.o[st][1] - Yt.v[st][1]], [Yt.i[0][0] - Yt.v[0][0], Yt.i[0][1] - Yt.v[0][1]]), pt.tLength += Jt.segmentLength, pt.segments.push(Jt), kt += Jt.segmentLength), this._pathData.pi = pt;
          }
          if (pt = this._pathData.pi, it = this._pathData.f.v, ft = 0, ht = 1, St = 0, ot = !0, xt = pt.segments, it < 0 && er.v.c)
            for (pt.tLength < Math.abs(it) && (it = -Math.abs(it) % pt.tLength), ft = xt.length - 1, Ct = xt[ft].points, ht = Ct.length - 1; it < 0; )
              it += Ct[ht].partialLength, ht -= 1, ht < 0 && (ft -= 1, Ct = xt[ft].points, ht = Ct.length - 1);
          Ct = xt[ft].points, vt = Ct[ht - 1], ut = Ct[ht], At = ut.partialLength;
        }
        dt = lt.length, Ae = 0, rt = 0;
        var rr = L.finalSize * 1.2 * 0.714, Qt = !0, wt, Ft, yt, Et, Dt;
        Et = pe.length;
        var Ot, nr = -1, vr, pr, xr, Ir = it, fn = ft, Zr = ht, xn = -1, kn, Lr, en, Rr, cr, Nn, Xn, Mn, Kn = "", Ri = this.defaultPropsArray, Si;
        if (L.j === 2 || L.j === 1) {
          var Fn = 0, ki = 0, Jn = L.j === 2 ? -0.5 : -1, Zn = 0, ui = !0;
          for (st = 0; st < dt; st += 1)
            if (lt[st].n) {
              for (Fn && (Fn += ki); Zn < st; )
                lt[Zn].animatorJustifyOffset = Fn, Zn += 1;
              Fn = 0, ui = !0;
            } else {
              for (yt = 0; yt < Et; yt += 1)
                wt = pe[yt].a, wt.t.propType && (ui && L.j === 2 && (ki += wt.t.v * Jn), Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? Fn += wt.t.v * Ot[0] * Jn : Fn += wt.t.v * Ot * Jn);
              ui = !1;
            }
          for (Fn && (Fn += ki); Zn < st; )
            lt[Zn].animatorJustifyOffset = Fn, Zn += 1;
        }
        for (st = 0; st < dt; st += 1) {
          if (ge.reset(), kn = 1, lt[st].n)
            Ae = 0, rt += L.yOffset, rt += Qt ? 1 : 0, it = Ir, Qt = !1, this._hasMaskedPath && (ft = fn, ht = Zr, Ct = xt[ft].points, vt = Ct[ht - 1], ut = Ct[ht], At = ut.partialLength, St = 0), Kn = "", Mn = "", Nn = "", Si = "", Ri = this.defaultPropsArray;
          else {
            if (this._hasMaskedPath) {
              if (xn !== lt[st].line) {
                switch (L.j) {
                  case 1:
                    it += kt - L.lineWidths[lt[st].line];
                    break;
                  case 2:
                    it += (kt - L.lineWidths[lt[st].line]) / 2;
                    break;
                }
                xn = lt[st].line;
              }
              nr !== lt[st].ind && (lt[nr] && (it += lt[nr].extra), it += lt[st].an / 2, nr = lt[st].ind), it += oe[0] * lt[st].an * 5e-3;
              var ei = 0;
              for (yt = 0; yt < Et; yt += 1)
                wt = pe[yt].a, wt.p.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ei += wt.p.v[0] * Ot[0] : ei += wt.p.v[0] * Ot), wt.a.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ei += wt.a.v[0] * Ot[0] : ei += wt.a.v[0] * Ot);
              for (ot = !0, this._pathData.a.v && (it = lt[0].an * 0.5 + (kt - this._pathData.f.v - lt[0].an * 0.5 - lt[lt.length - 1].an * 0.5) * nr / (dt - 1), it += this._pathData.f.v); ot; )
                St + At >= it + ei || !Ct ? (Vt = (it + ei - St) / ut.partialLength, pr = vt.point[0] + (ut.point[0] - vt.point[0]) * Vt, xr = vt.point[1] + (ut.point[1] - vt.point[1]) * Vt, ge.translate(-oe[0] * lt[st].an * 5e-3, -(oe[1] * rr) * 0.01), ot = !1) : Ct && (St += ut.partialLength, ht += 1, ht >= Ct.length && (ht = 0, ft += 1, xt[ft] ? Ct = xt[ft].points : er.v.c ? (ht = 0, ft = 0, Ct = xt[ft].points) : (St -= ut.partialLength, Ct = null)), Ct && (vt = ut, ut = Ct[ht], At = ut.partialLength));
              vr = lt[st].an / 2 - lt[st].add, ge.translate(-vr, 0, 0);
            } else
              vr = lt[st].an / 2 - lt[st].add, ge.translate(-vr, 0, 0), ge.translate(-oe[0] * lt[st].an * 5e-3, -oe[1] * rr * 0.01, 0);
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.t.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), (Ae !== 0 || L.j !== 0) && (this._hasMaskedPath ? Ot.length ? it += wt.t.v * Ot[0] : it += wt.t.v * Ot : Ot.length ? Ae += wt.t.v * Ot[0] : Ae += wt.t.v * Ot));
            for (L.strokeWidthAnim && (en = L.sw || 0), L.strokeColorAnim && (L.sc ? Lr = [L.sc[0], L.sc[1], L.sc[2]] : Lr = [0, 0, 0]), L.fillColorAnim && L.fc && (Rr = [L.fc[0], L.fc[1], L.fc[2]]), yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.a.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ge.translate(-wt.a.v[0] * Ot[0], -wt.a.v[1] * Ot[1], wt.a.v[2] * Ot[2]) : ge.translate(-wt.a.v[0] * Ot, -wt.a.v[1] * Ot, wt.a.v[2] * Ot));
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.s.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), Ot.length ? ge.scale(1 + (wt.s.v[0] - 1) * Ot[0], 1 + (wt.s.v[1] - 1) * Ot[1], 1) : ge.scale(1 + (wt.s.v[0] - 1) * Ot, 1 + (wt.s.v[1] - 1) * Ot, 1));
            for (yt = 0; yt < Et; yt += 1) {
              if (wt = pe[yt].a, Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), wt.sk.propType && (Ot.length ? ge.skewFromAxis(-wt.sk.v * Ot[0], wt.sa.v * Ot[1]) : ge.skewFromAxis(-wt.sk.v * Ot, wt.sa.v * Ot)), wt.r.propType && (Ot.length ? ge.rotateZ(-wt.r.v * Ot[2]) : ge.rotateZ(-wt.r.v * Ot)), wt.ry.propType && (Ot.length ? ge.rotateY(wt.ry.v * Ot[1]) : ge.rotateY(wt.ry.v * Ot)), wt.rx.propType && (Ot.length ? ge.rotateX(wt.rx.v * Ot[0]) : ge.rotateX(wt.rx.v * Ot)), wt.o.propType && (Ot.length ? kn += (wt.o.v * Ot[0] - kn) * Ot[0] : kn += (wt.o.v * Ot - kn) * Ot), L.strokeWidthAnim && wt.sw.propType && (Ot.length ? en += wt.sw.v * Ot[0] : en += wt.sw.v * Ot), L.strokeColorAnim && wt.sc.propType)
                for (cr = 0; cr < 3; cr += 1)
                  Ot.length ? Lr[cr] += (wt.sc.v[cr] - Lr[cr]) * Ot[0] : Lr[cr] += (wt.sc.v[cr] - Lr[cr]) * Ot;
              if (L.fillColorAnim && L.fc) {
                if (wt.fc.propType)
                  for (cr = 0; cr < 3; cr += 1)
                    Ot.length ? Rr[cr] += (wt.fc.v[cr] - Rr[cr]) * Ot[0] : Rr[cr] += (wt.fc.v[cr] - Rr[cr]) * Ot;
                wt.fh.propType && (Ot.length ? Rr = addHueToRGB(Rr, wt.fh.v * Ot[0]) : Rr = addHueToRGB(Rr, wt.fh.v * Ot)), wt.fs.propType && (Ot.length ? Rr = addSaturationToRGB(Rr, wt.fs.v * Ot[0]) : Rr = addSaturationToRGB(Rr, wt.fs.v * Ot)), wt.fb.propType && (Ot.length ? Rr = addBrightnessToRGB(Rr, wt.fb.v * Ot[0]) : Rr = addBrightnessToRGB(Rr, wt.fb.v * Ot));
              }
            }
            for (yt = 0; yt < Et; yt += 1)
              wt = pe[yt].a, wt.p.propType && (Ft = pe[yt].s, Ot = Ft.getMult(lt[st].anIndexes[yt], me.a[yt].s.totalChars), this._hasMaskedPath ? Ot.length ? ge.translate(0, wt.p.v[1] * Ot[0], -wt.p.v[2] * Ot[1]) : ge.translate(0, wt.p.v[1] * Ot, -wt.p.v[2] * Ot) : Ot.length ? ge.translate(wt.p.v[0] * Ot[0], wt.p.v[1] * Ot[1], -wt.p.v[2] * Ot[2]) : ge.translate(wt.p.v[0] * Ot, wt.p.v[1] * Ot, -wt.p.v[2] * Ot));
            if (L.strokeWidthAnim && (Nn = en < 0 ? 0 : en), L.strokeColorAnim && (Xn = "rgb(" + Math.round(Lr[0] * 255) + "," + Math.round(Lr[1] * 255) + "," + Math.round(Lr[2] * 255) + ")"), L.fillColorAnim && L.fc && (Mn = "rgb(" + Math.round(Rr[0] * 255) + "," + Math.round(Rr[1] * 255) + "," + Math.round(Rr[2] * 255) + ")"), this._hasMaskedPath) {
              if (ge.translate(0, -L.ls), ge.translate(0, oe[1] * rr * 0.01 + rt, 0), this._pathData.p.v) {
                ir = (ut.point[1] - vt.point[1]) / (ut.point[0] - vt.point[0]);
                var Tn = Math.atan(ir) * 180 / Math.PI;
                ut.point[0] < vt.point[0] && (Tn += 180), ge.rotate(-Tn * Math.PI / 180);
              }
              ge.translate(pr, xr, 0), it -= oe[0] * lt[st].an * 5e-3, lt[st + 1] && nr !== lt[st + 1].ind && (it += lt[st].an / 2, it += L.tr * 1e-3 * L.finalSize);
            } else {
              switch (ge.translate(Ae, rt, 0), L.ps && ge.translate(L.ps[0], L.ps[1] + L.ascent, 0), L.j) {
                case 1:
                  ge.translate(lt[st].animatorJustifyOffset + L.justifyOffset + (L.boxWidth - L.lineWidths[lt[st].line]), 0, 0);
                  break;
                case 2:
                  ge.translate(lt[st].animatorJustifyOffset + L.justifyOffset + (L.boxWidth - L.lineWidths[lt[st].line]) / 2, 0, 0);
                  break;
              }
              ge.translate(0, -L.ls), ge.translate(vr, 0, 0), ge.translate(oe[0] * lt[st].an * 5e-3, oe[1] * rr * 0.01, 0), Ae += lt[st].l + L.tr * 1e-3 * L.finalSize;
            }
            be === "html" ? Kn = ge.toCSS() : be === "svg" ? Kn = ge.to2dCSS() : Ri = [ge.props[0], ge.props[1], ge.props[2], ge.props[3], ge.props[4], ge.props[5], ge.props[6], ge.props[7], ge.props[8], ge.props[9], ge.props[10], ge.props[11], ge.props[12], ge.props[13], ge.props[14], ge.props[15]], Si = kn;
          }
          Ie <= st ? (Dt = new LetterProps(Si, Nn, Xn, Mn, Kn, Ri), this.renderedLetters.push(Dt), Ie += 1, this.lettersChangedFlag = !0) : (Dt = this.renderedLetters[st], this.lettersChangedFlag = Dt.update(Si, Nn, Xn, Mn, Kn, Ri) || this.lettersChangedFlag);
        }
      }
    }, TextAnimatorProperty.prototype.getValue = function() {
      this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties());
    }, TextAnimatorProperty.prototype.mHelper = new Matrix(), TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function ITextElement() {
    }
    ITextElement.prototype.initElement = function(L, ne, oe) {
      this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(L, ne, oe), this.textProperty = new TextProperty(this, L.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(L.t, this.renderType, this), this.initTransform(L, ne, oe), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties);
    }, ITextElement.prototype.prepareFrame = function(L) {
      this._mdf = !1, this.prepareRenderableFrame(L), this.prepareProperties(L, this.isInRange);
    }, ITextElement.prototype.createPathShape = function(L, ne) {
      var oe, pe = ne.length, me, ge = "";
      for (oe = 0; oe < pe; oe += 1)
        ne[oe].ty === "sh" && (me = ne[oe].ks.k, ge += buildShapeString(me, me.i.length, !0, L));
      return ge;
    }, ITextElement.prototype.updateDocumentData = function(L, ne) {
      this.textProperty.updateDocumentData(L, ne);
    }, ITextElement.prototype.canResizeFont = function(L) {
      this.textProperty.canResizeFont(L);
    }, ITextElement.prototype.setMinimumFontSize = function(L) {
      this.textProperty.setMinimumFontSize(L);
    }, ITextElement.prototype.applyTextPropertiesToMatrix = function(L, ne, oe, pe, me) {
      switch (L.ps && ne.translate(L.ps[0], L.ps[1] + L.ascent, 0), ne.translate(0, -L.ls, 0), L.j) {
        case 1:
          ne.translate(L.justifyOffset + (L.boxWidth - L.lineWidths[oe]), 0, 0);
          break;
        case 2:
          ne.translate(L.justifyOffset + (L.boxWidth - L.lineWidths[oe]) / 2, 0, 0);
          break;
      }
      ne.translate(pe, me, 0);
    }, ITextElement.prototype.buildColor = function(L) {
      return "rgb(" + Math.round(L[0] * 255) + "," + Math.round(L[1] * 255) + "," + Math.round(L[2] * 255) + ")";
    }, ITextElement.prototype.emptyProp = new LetterProps(), ITextElement.prototype.destroy = function() {
    }, ITextElement.prototype.validateText = function() {
      (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1);
    };
    var emptyShapeData = {
      shapes: []
    };
    function SVGTextLottieElement(L, ne, oe) {
      this.textSpans = [], this.renderType = "svg", this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
      this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"));
    }, SVGTextLottieElement.prototype.buildTextContents = function(L) {
      for (var ne = 0, oe = L.length, pe = [], me = ""; ne < oe; )
        L[ne] === "\r" || L[ne] === "" ? (pe.push(me), me = "") : me += L[ne], ne += 1;
      return pe.push(me), pe;
    }, SVGTextLottieElement.prototype.buildShapeData = function(L, ne) {
      if (L.shapes && L.shapes.length) {
        var oe = L.shapes[0];
        if (oe.it) {
          var pe = oe.it[oe.it.length - 1];
          pe.s && (pe.s.k[0] = ne, pe.s.k[1] = ne);
        }
      }
      return L;
    }, SVGTextLottieElement.prototype.buildNewText = function() {
      this.addDynamicProperty(this);
      var L, ne, oe = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(oe ? oe.l.length : 0), oe.fc ? this.layerElement.setAttribute("fill", this.buildColor(oe.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), oe.sc && (this.layerElement.setAttribute("stroke", this.buildColor(oe.sc)), this.layerElement.setAttribute("stroke-width", oe.sw)), this.layerElement.setAttribute("font-size", oe.finalSize);
      var pe = this.globalData.fontManager.getFontByName(oe.f);
      if (pe.fClass)
        this.layerElement.setAttribute("class", pe.fClass);
      else {
        this.layerElement.setAttribute("font-family", pe.fFamily);
        var me = oe.fWeight, ge = oe.fStyle;
        this.layerElement.setAttribute("font-style", ge), this.layerElement.setAttribute("font-weight", me);
      }
      this.layerElement.setAttribute("aria-label", oe.t);
      var be = oe.l || [], Ie = !!this.globalData.fontManager.chars;
      ne = be.length;
      var Ae, rt = this.mHelper, st = "", dt = this.data.singleShape, lt = 0, pt = 0, it = !0, ut = oe.tr * 1e-3 * oe.finalSize;
      if (dt && !Ie && !oe.sz) {
        var St = this.textContainer, ot = "start";
        switch (oe.j) {
          case 1:
            ot = "end";
            break;
          case 2:
            ot = "middle";
            break;
          default:
            ot = "start";
            break;
        }
        St.setAttribute("text-anchor", ot), St.setAttribute("letter-spacing", ut);
        var ht = this.buildTextContents(oe.finalText);
        for (ne = ht.length, pt = oe.ps ? oe.ps[1] + oe.ascent : 0, L = 0; L < ne; L += 1)
          Ae = this.textSpans[L].span || createNS("tspan"), Ae.textContent = ht[L], Ae.setAttribute("x", 0), Ae.setAttribute("y", pt), Ae.style.display = "inherit", St.appendChild(Ae), this.textSpans[L] || (this.textSpans[L] = {
            span: null,
            glyph: null
          }), this.textSpans[L].span = Ae, pt += oe.finalLineHeight;
        this.layerElement.appendChild(St);
      } else {
        var ft = this.textSpans.length, vt;
        for (L = 0; L < ne; L += 1) {
          if (this.textSpans[L] || (this.textSpans[L] = {
            span: null,
            childSpan: null,
            glyph: null
          }), !Ie || !dt || L === 0) {
            if (Ae = ft > L ? this.textSpans[L].span : createNS(Ie ? "g" : "text"), ft <= L) {
              if (Ae.setAttribute("stroke-linecap", "butt"), Ae.setAttribute("stroke-linejoin", "round"), Ae.setAttribute("stroke-miterlimit", "4"), this.textSpans[L].span = Ae, Ie) {
                var Ct = createNS("g");
                Ae.appendChild(Ct), this.textSpans[L].childSpan = Ct;
              }
              this.textSpans[L].span = Ae, this.layerElement.appendChild(Ae);
            }
            Ae.style.display = "inherit";
          }
          if (rt.reset(), dt && (be[L].n && (lt = -ut, pt += oe.yOffset, pt += it ? 1 : 0, it = !1), this.applyTextPropertiesToMatrix(oe, rt, be[L].line, lt, pt), lt += be[L].l || 0, lt += ut), Ie) {
            vt = this.globalData.fontManager.getCharData(oe.finalText[L], pe.fStyle, this.globalData.fontManager.getFontByName(oe.f).fFamily);
            var xt;
            if (vt.t === 1)
              xt = new SVGCompElement(vt.data, this.globalData, this);
            else {
              var At = emptyShapeData;
              vt.data && vt.data.shapes && (At = this.buildShapeData(vt.data, oe.finalSize)), xt = new SVGShapeElement(At, this.globalData, this);
            }
            if (this.textSpans[L].glyph) {
              var kt = this.textSpans[L].glyph;
              this.textSpans[L].childSpan.removeChild(kt.layerElement), kt.destroy();
            }
            this.textSpans[L].glyph = xt, xt._debug = !0, xt.prepareFrame(0), xt.renderFrame(), this.textSpans[L].childSpan.appendChild(xt.layerElement), vt.t === 1 && this.textSpans[L].childSpan.setAttribute("transform", "scale(" + oe.finalSize / 100 + "," + oe.finalSize / 100 + ")");
          } else
            dt && Ae.setAttribute("transform", "translate(" + rt.props[12] + "," + rt.props[13] + ")"), Ae.textContent = be[L].val, Ae.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        }
        dt && Ae && Ae.setAttribute("d", st);
      }
      for (; L < this.textSpans.length; )
        this.textSpans[L].span.style.display = "none", L += 1;
      this._sizeChanged = !0;
    }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
      if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
        this._sizeChanged = !1;
        var L = this.layerElement.getBBox();
        this.bbox = {
          top: L.y,
          left: L.x,
          width: L.width,
          height: L.height
        };
      }
      return this.bbox;
    }, SVGTextLottieElement.prototype.getValue = function() {
      var L, ne = this.textSpans.length, oe;
      for (this.renderedFrame = this.comp.renderedFrame, L = 0; L < ne; L += 1)
        oe = this.textSpans[L].glyph, oe && (oe.prepareFrame(this.comp.renderedFrame - this.data.st), oe._mdf && (this._mdf = !0));
    }, SVGTextLottieElement.prototype.renderInnerContent = function() {
      if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
        this._sizeChanged = !0;
        var L, ne, oe = this.textAnimator.renderedLetters, pe = this.textProperty.currentData.l;
        ne = pe.length;
        var me, ge, be;
        for (L = 0; L < ne; L += 1)
          pe[L].n || (me = oe[L], ge = this.textSpans[L].span, be = this.textSpans[L].glyph, be && be.renderFrame(), me._mdf.m && ge.setAttribute("transform", me.m), me._mdf.o && ge.setAttribute("opacity", me.o), me._mdf.sw && ge.setAttribute("stroke-width", me.sw), me._mdf.sc && ge.setAttribute("stroke", me.sc), me._mdf.fc && ge.setAttribute("fill", me.fc));
      }
    };
    function ISolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
      var L = createNS("rect");
      L.setAttribute("width", this.data.sw), L.setAttribute("height", this.data.sh), L.setAttribute("fill", this.data.sc), this.layerElement.appendChild(L);
    };
    function NullElement(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initFrame(), this.initTransform(L, ne, oe), this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function(L) {
      this.prepareProperties(L, !0);
    }, NullElement.prototype.renderFrame = function() {
    }, NullElement.prototype.getBaseElement = function() {
      return null;
    }, NullElement.prototype.destroy = function() {
    }, NullElement.prototype.sourceRectAtTime = function() {
    }, NullElement.prototype.hide = function() {
    }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
    function SVGRendererBase() {
    }
    extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function(L) {
      return new NullElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createShape = function(L) {
      return new SVGShapeElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createText = function(L) {
      return new SVGTextLottieElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createImage = function(L) {
      return new IImageElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.createSolid = function(L) {
      return new ISolidElement(L, this.globalData, this);
    }, SVGRendererBase.prototype.configAnimation = function(L) {
      this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + L.w + " " + L.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", L.w), this.svgElement.setAttribute("height", L.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
      var ne = this.globalData.defs;
      this.setupGlobalData(L, ne), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = L;
      var oe = createNS("clipPath"), pe = createNS("rect");
      pe.setAttribute("width", L.w), pe.setAttribute("height", L.h), pe.setAttribute("x", 0), pe.setAttribute("y", 0);
      var me = createElementID();
      oe.setAttribute("id", me), oe.appendChild(pe), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + me + ")"), ne.appendChild(oe), this.layers = L.layers, this.elements = createSizedArray(L.layers.length);
    }, SVGRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, SVGRendererBase.prototype.updateContainerSize = function() {
    }, SVGRendererBase.prototype.findIndexByInd = function(L) {
      var ne = 0, oe = this.layers.length;
      for (ne = 0; ne < oe; ne += 1)
        if (this.layers[ne].ind === L)
          return ne;
      return -1;
    }, SVGRendererBase.prototype.buildItem = function(L) {
      var ne = this.elements;
      if (!(ne[L] || this.layers[L].ty === 99)) {
        ne[L] = !0;
        var oe = this.createItem(this.layers[L]);
        if (ne[L] = oe, getExpressionsPlugin() && (this.layers[L].ty === 0 && this.globalData.projectInterface.registerComposition(oe), oe.initExpressions()), this.appendElementInPos(oe, L), this.layers[L].tt) {
          var pe = "tp" in this.layers[L] ? this.findIndexByInd(this.layers[L].tp) : L - 1;
          if (pe === -1)
            return;
          if (!this.elements[pe] || this.elements[pe] === !0)
            this.buildItem(pe), this.addPendingElement(oe);
          else {
            var me = ne[pe], ge = me.getMatte(this.layers[L].tt);
            oe.setMatte(ge);
          }
        }
      }
    }, SVGRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        if (L.checkParenting(), L.data.tt)
          for (var ne = 0, oe = this.elements.length; ne < oe; ) {
            if (this.elements[ne] === L) {
              var pe = "tp" in L.data ? this.findIndexByInd(L.data.tp) : ne - 1, me = this.elements[pe], ge = me.getMatte(this.layers[ne].tt);
              L.setMatte(ge);
              break;
            }
            ne += 1;
          }
      }
    }, SVGRendererBase.prototype.renderFrame = function(L) {
      if (!(this.renderedFrame === L || this.destroyed)) {
        L === null ? L = this.renderedFrame : this.renderedFrame = L, this.globalData.frameNum = L, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = L, this.globalData._mdf = !1;
        var ne, oe = this.layers.length;
        for (this.completeLayers || this.checkLayers(L), ne = oe - 1; ne >= 0; ne -= 1)
          (this.completeLayers || this.elements[ne]) && this.elements[ne].prepareFrame(L - this.layers[ne].st);
        if (this.globalData._mdf)
          for (ne = 0; ne < oe; ne += 1)
            (this.completeLayers || this.elements[ne]) && this.elements[ne].renderFrame();
      }
    }, SVGRendererBase.prototype.appendElementInPos = function(L, ne) {
      var oe = L.getBaseElement();
      if (oe) {
        for (var pe = 0, me; pe < ne; )
          this.elements[pe] && this.elements[pe] !== !0 && this.elements[pe].getBaseElement() && (me = this.elements[pe].getBaseElement()), pe += 1;
        me ? this.layerElement.insertBefore(oe, me) : this.layerElement.appendChild(oe);
      }
    }, SVGRendererBase.prototype.hide = function() {
      this.layerElement.style.display = "none";
    }, SVGRendererBase.prototype.show = function() {
      this.layerElement.style.display = "block";
    };
    function ICompElement() {
    }
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initTransform(L, ne, oe), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !ne.progressiveLoad) && this.buildAllItems(), this.hide();
    }, ICompElement.prototype.prepareFrame = function(L) {
      if (this._mdf = !1, this.prepareRenderableFrame(L), this.prepareProperties(L, this.isInRange), !(!this.isInRange && !this.data.xt)) {
        if (this.tm._placeholder)
          this.renderedFrame = L / this.data.sr;
        else {
          var ne = this.tm.v;
          ne === this.data.op && (ne = this.data.op - 1), this.renderedFrame = ne;
        }
        var oe, pe = this.elements.length;
        for (this.completeLayers || this.checkLayers(this.renderedFrame), oe = pe - 1; oe >= 0; oe -= 1)
          (this.completeLayers || this.elements[oe]) && (this.elements[oe].prepareFrame(this.renderedFrame - this.layers[oe].st), this.elements[oe]._mdf && (this._mdf = !0));
      }
    }, ICompElement.prototype.renderInnerContent = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        (this.completeLayers || this.elements[L]) && this.elements[L].renderFrame();
    }, ICompElement.prototype.setElements = function(L) {
      this.elements = L;
    }, ICompElement.prototype.getElements = function() {
      return this.elements;
    }, ICompElement.prototype.destroyElements = function() {
      var L, ne = this.layers.length;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy();
    }, ICompElement.prototype.destroy = function() {
      this.destroyElements(), this.destroyBaseElement();
    };
    function SVGCompElement(L, ne, oe) {
      this.layers = L.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function(L) {
      return new SVGCompElement(L, this.globalData, this);
    };
    function SVGRenderer(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
      var oe = "";
      if (ne && ne.title) {
        var pe = createNS("title"), me = createElementID();
        pe.setAttribute("id", me), pe.textContent = ne.title, this.svgElement.appendChild(pe), oe += me;
      }
      if (ne && ne.description) {
        var ge = createNS("desc"), be = createElementID();
        ge.setAttribute("id", be), ge.textContent = ne.description, this.svgElement.appendChild(ge), oe += " " + be;
      }
      oe && this.svgElement.setAttribute("aria-labelledby", oe);
      var Ie = createNS("defs");
      this.svgElement.appendChild(Ie);
      var Ae = createNS("g");
      this.svgElement.appendChild(Ae), this.layerElement = Ae, this.renderConfig = {
        preserveAspectRatio: ne && ne.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: ne && ne.contentVisibility || "visible",
        progressiveLoad: ne && ne.progressiveLoad || !1,
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        viewBoxOnly: ne && ne.viewBoxOnly || !1,
        viewBoxSize: ne && ne.viewBoxSize || !1,
        className: ne && ne.className || "",
        id: ne && ne.id || "",
        focusable: ne && ne.focusable,
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "100%",
          height: ne && ne.filterSize && ne.filterSize.height || "100%",
          x: ne && ne.filterSize && ne.filterSize.x || "0%",
          y: ne && ne.filterSize && ne.filterSize.y || "0%"
        },
        width: ne && ne.width,
        height: ne && ne.height,
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        defs: Ie,
        renderConfig: this.renderConfig
      }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg";
    }
    extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function(L) {
      return new SVGCompElement(L, this.globalData, this);
    };
    function ShapeTransformManager() {
      this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
      addTransformSequence: function(ne) {
        var oe, pe = ne.length, me = "_";
        for (oe = 0; oe < pe; oe += 1)
          me += ne[oe].transform.key + "_";
        var ge = this.sequences[me];
        return ge || (ge = {
          transforms: [].concat(ne),
          finalTransform: new Matrix(),
          _mdf: !1
        }, this.sequences[me] = ge, this.sequenceList.push(ge)), ge;
      },
      processSequence: function(ne, oe) {
        for (var pe = 0, me = ne.transforms.length, ge = oe; pe < me && !oe; ) {
          if (ne.transforms[pe].transform.mProps._mdf) {
            ge = !0;
            break;
          }
          pe += 1;
        }
        if (ge)
          for (ne.finalTransform.reset(), pe = me - 1; pe >= 0; pe -= 1)
            ne.finalTransform.multiply(ne.transforms[pe].transform.mProps.v);
        ne._mdf = ge;
      },
      processSequences: function(ne) {
        var oe, pe = this.sequenceList.length;
        for (oe = 0; oe < pe; oe += 1)
          this.processSequence(this.sequenceList[oe], ne);
      },
      getNewKey: function() {
        return this.transform_key_count += 1, "_" + this.transform_key_count;
      }
    };
    var lumaLoader = function() {
      var ne = "__lottie_element_luma_buffer", oe = null, pe = null, me = null;
      function ge() {
        var Ae = createNS("svg"), rt = createNS("filter"), st = createNS("feColorMatrix");
        return rt.setAttribute("id", ne), st.setAttribute("type", "matrix"), st.setAttribute("color-interpolation-filters", "sRGB"), st.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), rt.appendChild(st), Ae.appendChild(rt), Ae.setAttribute("id", ne + "_svg"), featureSupport.svgLumaHidden && (Ae.style.display = "none"), Ae;
      }
      function be() {
        oe || (me = ge(), document.body.appendChild(me), oe = createTag("canvas"), pe = oe.getContext("2d"), pe.filter = "url(#" + ne + ")", pe.fillStyle = "rgba(0,0,0,0)", pe.fillRect(0, 0, 1, 1));
      }
      function Ie(Ae) {
        return oe || be(), oe.width = Ae.width, oe.height = Ae.height, pe.filter = "url(#" + ne + ")", oe;
      }
      return {
        load: be,
        get: Ie
      };
    };
    function createCanvas(L, ne) {
      if (featureSupport.offscreenCanvas)
        return new OffscreenCanvas(L, ne);
      var oe = createTag("canvas");
      return oe.width = L, oe.height = ne, oe;
    }
    var assetLoader = function() {
      return {
        loadLumaCanvas: lumaLoader.load,
        getLumaCanvas: lumaLoader.get,
        createCanvas
      };
    }(), registeredEffects = {};
    function CVEffects(L) {
      var ne, oe = L.data.ef ? L.data.ef.length : 0;
      this.filters = [];
      var pe;
      for (ne = 0; ne < oe; ne += 1) {
        pe = null;
        var me = L.data.ef[ne].ty;
        if (registeredEffects[me]) {
          var ge = registeredEffects[me].effect;
          pe = new ge(L.effectsManager.effectElements[ne], L);
        }
        pe && this.filters.push(pe);
      }
      this.filters.length && L.addRenderableComponent(this);
    }
    CVEffects.prototype.renderFrame = function(L) {
      var ne, oe = this.filters.length;
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].renderFrame(L);
    }, CVEffects.prototype.getEffects = function(L) {
      var ne, oe = this.filters.length, pe = [];
      for (ne = 0; ne < oe; ne += 1)
        this.filters[ne].type === L && pe.push(this.filters[ne]);
      return pe;
    };
    function registerEffect(L, ne) {
      registeredEffects[L] = {
        effect: ne
      };
    }
    function CVMaskElement(L, ne) {
      this.data = L, this.element = ne, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
      var oe, pe = this.masksProperties.length, me = !1;
      for (oe = 0; oe < pe; oe += 1)
        this.masksProperties[oe].mode !== "n" && (me = !0), this.viewData[oe] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[oe], 3);
      this.hasMasks = me, me && this.element.addRenderableComponent(this);
    }
    CVMaskElement.prototype.renderFrame = function() {
      if (this.hasMasks) {
        var L = this.element.finalTransform.mat, ne = this.element.canvasContext, oe, pe = this.masksProperties.length, me, ge, be;
        for (ne.beginPath(), oe = 0; oe < pe; oe += 1)
          if (this.masksProperties[oe].mode !== "n") {
            this.masksProperties[oe].inv && (ne.moveTo(0, 0), ne.lineTo(this.element.globalData.compSize.w, 0), ne.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), ne.lineTo(0, this.element.globalData.compSize.h), ne.lineTo(0, 0)), be = this.viewData[oe].v, me = L.applyToPointArray(be.v[0][0], be.v[0][1], 0), ne.moveTo(me[0], me[1]);
            var Ie, Ae = be._length;
            for (Ie = 1; Ie < Ae; Ie += 1)
              ge = L.applyToTriplePoints(be.o[Ie - 1], be.i[Ie], be.v[Ie]), ne.bezierCurveTo(ge[0], ge[1], ge[2], ge[3], ge[4], ge[5]);
            ge = L.applyToTriplePoints(be.o[Ie - 1], be.i[0], be.v[0]), ne.bezierCurveTo(ge[0], ge[1], ge[2], ge[3], ge[4], ge[5]);
          }
        this.element.globalData.renderer.save(!0), ne.clip();
      }
    }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
      this.element = null;
    };
    function CVBaseElement() {
    }
    var operationsMap = {
      1: "source-in",
      2: "source-out",
      3: "source-in",
      4: "source-out"
    };
    CVBaseElement.prototype = {
      createElements: function() {
      },
      initRendererElement: function() {
      },
      createContainerElements: function() {
        if (this.data.tt >= 1) {
          this.buffers = [];
          var ne = this.globalData.canvasContext, oe = assetLoader.createCanvas(ne.canvas.width, ne.canvas.height);
          this.buffers.push(oe);
          var pe = assetLoader.createCanvas(ne.canvas.width, ne.canvas.height);
          this.buffers.push(pe), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas();
        }
        this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms();
      },
      createContent: function() {
      },
      setBlendMode: function() {
        var ne = this.globalData;
        if (ne.blendMode !== this.data.bm) {
          ne.blendMode = this.data.bm;
          var oe = getBlendMode(this.data.bm);
          ne.canvasContext.globalCompositeOperation = oe;
        }
      },
      createRenderableComponents: function() {
        this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
      },
      hideElement: function() {
        !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0);
      },
      showElement: function() {
        this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0);
      },
      clearCanvas: function(ne) {
        ne.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
      },
      prepareLayer: function() {
        if (this.data.tt >= 1) {
          var ne = this.buffers[0], oe = ne.getContext("2d");
          this.clearCanvas(oe), oe.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
        }
      },
      exitLayer: function() {
        if (this.data.tt >= 1) {
          var ne = this.buffers[1], oe = ne.getContext("2d");
          this.clearCanvas(oe), oe.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
          var pe = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
          if (pe.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
            var me = assetLoader.getLumaCanvas(this.canvasContext.canvas), ge = me.getContext("2d");
            ge.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(me, 0, 0);
          }
          this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(ne, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over";
        }
      },
      renderFrame: function(ne) {
        if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !ne)) {
          this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
          var oe = this.data.ty === 0;
          this.prepareLayer(), this.globalData.renderer.save(oe), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(oe), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1);
        }
      },
      destroy: function() {
        this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy();
      },
      mHelper: new Matrix()
    }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(L, ne, oe, pe) {
      this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
      var me = 4;
      ne.ty === "rc" ? me = 5 : ne.ty === "el" ? me = 6 : ne.ty === "sr" && (me = 7), this.sh = ShapePropertyFactory.getShapeProp(L, ne, me, L);
      var ge, be = oe.length, Ie;
      for (ge = 0; ge < be; ge += 1)
        oe[ge].closed || (Ie = {
          transforms: pe.addTransformSequence(oe[ge].transforms),
          trNodes: []
        }, this.styledShapes.push(Ie), oe[ge].elements.push(Ie));
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager(), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
      opacity: 1,
      _opMdf: !1
    }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []);
    }, CVShapeElement.prototype.createStyleElement = function(L, ne) {
      var oe = {
        data: L,
        type: L.ty,
        preTransforms: this.transformsManager.addTransformSequence(ne),
        transforms: [],
        elements: [],
        closed: L.hd === !0
      }, pe = {};
      if (L.ty === "fl" || L.ty === "st" ? (pe.c = PropertyFactory.getProp(this, L.c, 1, 255, this), pe.c.k || (oe.co = "rgb(" + bmFloor(pe.c.v[0]) + "," + bmFloor(pe.c.v[1]) + "," + bmFloor(pe.c.v[2]) + ")")) : (L.ty === "gf" || L.ty === "gs") && (pe.s = PropertyFactory.getProp(this, L.s, 1, null, this), pe.e = PropertyFactory.getProp(this, L.e, 1, null, this), pe.h = PropertyFactory.getProp(this, L.h || {
        k: 0
      }, 0, 0.01, this), pe.a = PropertyFactory.getProp(this, L.a || {
        k: 0
      }, 0, degToRads, this), pe.g = new GradientProperty(this, L.g, this)), pe.o = PropertyFactory.getProp(this, L.o, 0, 0.01, this), L.ty === "st" || L.ty === "gs") {
        if (oe.lc = lineCapEnum[L.lc || 2], oe.lj = lineJoinEnum[L.lj || 2], L.lj == 1 && (oe.ml = L.ml), pe.w = PropertyFactory.getProp(this, L.w, 0, null, this), pe.w.k || (oe.wi = pe.w.v), L.d) {
          var me = new DashProperty(this, L.d, "canvas", this);
          pe.d = me, pe.d.k || (oe.da = pe.d.dashArray, oe.do = pe.d.dashoffset[0]);
        }
      } else
        oe.r = L.r === 2 ? "evenodd" : "nonzero";
      return this.stylesList.push(oe), pe.style = oe, pe;
    }, CVShapeElement.prototype.createGroupElement = function() {
      var L = {
        it: [],
        prevViewData: []
      };
      return L;
    }, CVShapeElement.prototype.createTransformElement = function(L) {
      var ne = {
        transform: {
          opacity: 1,
          _opMdf: !1,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, L.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, L, this)
        }
      };
      return ne;
    }, CVShapeElement.prototype.createShapeElement = function(L) {
      var ne = new CVShapeData(this, L, this.stylesList, this.transformsManager);
      return this.shapes.push(ne), this.addShapeToModifiers(ne), ne;
    }, CVShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var L, ne = this.itemsData.length;
      for (L = 0; L < ne; L += 1)
        this.prevViewData[L] = this.itemsData[L];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), ne = this.dynamicProperties.length, L = 0; L < ne; L += 1)
        this.dynamicProperties[L].getValue();
      this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame);
    }, CVShapeElement.prototype.addTransformToStyleList = function(L) {
      var ne, oe = this.stylesList.length;
      for (ne = 0; ne < oe; ne += 1)
        this.stylesList[ne].closed || this.stylesList[ne].transforms.push(L);
    }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
      var L, ne = this.stylesList.length;
      for (L = 0; L < ne; L += 1)
        this.stylesList[L].closed || this.stylesList[L].transforms.pop();
    }, CVShapeElement.prototype.closeStyles = function(L) {
      var ne, oe = L.length;
      for (ne = 0; ne < oe; ne += 1)
        L[ne].closed = !0;
    }, CVShapeElement.prototype.searchShapes = function(L, ne, oe, pe, me) {
      var ge, be = L.length - 1, Ie, Ae, rt = [], st = [], dt, lt, pt, it = [].concat(me);
      for (ge = be; ge >= 0; ge -= 1) {
        if (dt = this.searchProcessedElement(L[ge]), dt ? ne[ge] = oe[dt - 1] : L[ge]._shouldRender = pe, L[ge].ty === "fl" || L[ge].ty === "st" || L[ge].ty === "gf" || L[ge].ty === "gs")
          dt ? ne[ge].style.closed = !1 : ne[ge] = this.createStyleElement(L[ge], it), rt.push(ne[ge].style);
        else if (L[ge].ty === "gr") {
          if (!dt)
            ne[ge] = this.createGroupElement(L[ge]);
          else
            for (Ae = ne[ge].it.length, Ie = 0; Ie < Ae; Ie += 1)
              ne[ge].prevViewData[Ie] = ne[ge].it[Ie];
          this.searchShapes(L[ge].it, ne[ge].it, ne[ge].prevViewData, pe, it);
        } else
          L[ge].ty === "tr" ? (dt || (pt = this.createTransformElement(L[ge]), ne[ge] = pt), it.push(ne[ge]), this.addTransformToStyleList(ne[ge])) : L[ge].ty === "sh" || L[ge].ty === "rc" || L[ge].ty === "el" || L[ge].ty === "sr" ? dt || (ne[ge] = this.createShapeElement(L[ge])) : L[ge].ty === "tm" || L[ge].ty === "rd" || L[ge].ty === "pb" || L[ge].ty === "zz" || L[ge].ty === "op" ? (dt ? (lt = ne[ge], lt.closed = !1) : (lt = ShapeModifiers.getModifier(L[ge].ty), lt.init(this, L[ge]), ne[ge] = lt, this.shapeModifiers.push(lt)), st.push(lt)) : L[ge].ty === "rp" && (dt ? (lt = ne[ge], lt.closed = !0) : (lt = ShapeModifiers.getModifier(L[ge].ty), ne[ge] = lt, lt.init(this, L, ge, ne), this.shapeModifiers.push(lt), pe = !1), st.push(lt));
        this.addProcessedElement(L[ge], ge + 1);
      }
      for (this.removeTransformFromStyleList(), this.closeStyles(rt), be = st.length, ge = 0; ge < be; ge += 1)
        st[ge].closed = !0;
    }, CVShapeElement.prototype.renderInnerContent = function() {
      this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0);
    }, CVShapeElement.prototype.renderShapeTransform = function(L, ne) {
      (L._opMdf || ne.op._mdf || this._isFirstFrame) && (ne.opacity = L.opacity, ne.opacity *= ne.op.v, ne._opMdf = !0);
    }, CVShapeElement.prototype.drawLayer = function() {
      var L, ne = this.stylesList.length, oe, pe, me, ge, be, Ie, Ae = this.globalData.renderer, rt = this.globalData.canvasContext, st, dt;
      for (L = 0; L < ne; L += 1)
        if (dt = this.stylesList[L], st = dt.type, !((st === "st" || st === "gs") && dt.wi === 0 || !dt.data._shouldRender || dt.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          for (Ae.save(), be = dt.elements, st === "st" || st === "gs" ? (Ae.ctxStrokeStyle(st === "st" ? dt.co : dt.grd), Ae.ctxLineWidth(dt.wi), Ae.ctxLineCap(dt.lc), Ae.ctxLineJoin(dt.lj), Ae.ctxMiterLimit(dt.ml || 0)) : Ae.ctxFillStyle(st === "fl" ? dt.co : dt.grd), Ae.ctxOpacity(dt.coOp), st !== "st" && st !== "gs" && rt.beginPath(), Ae.ctxTransform(dt.preTransforms.finalTransform.props), pe = be.length, oe = 0; oe < pe; oe += 1) {
            for ((st === "st" || st === "gs") && (rt.beginPath(), dt.da && (rt.setLineDash(dt.da), rt.lineDashOffset = dt.do)), Ie = be[oe].trNodes, ge = Ie.length, me = 0; me < ge; me += 1)
              Ie[me].t === "m" ? rt.moveTo(Ie[me].p[0], Ie[me].p[1]) : Ie[me].t === "c" ? rt.bezierCurveTo(Ie[me].pts[0], Ie[me].pts[1], Ie[me].pts[2], Ie[me].pts[3], Ie[me].pts[4], Ie[me].pts[5]) : rt.closePath();
            (st === "st" || st === "gs") && (Ae.ctxStroke(), dt.da && rt.setLineDash(this.dashResetter));
          }
          st !== "st" && st !== "gs" && this.globalData.renderer.ctxFill(dt.r), Ae.restore();
        }
    }, CVShapeElement.prototype.renderShape = function(L, ne, oe, pe) {
      var me, ge = ne.length - 1, be;
      for (be = L, me = ge; me >= 0; me -= 1)
        ne[me].ty === "tr" ? (be = oe[me].transform, this.renderShapeTransform(L, be)) : ne[me].ty === "sh" || ne[me].ty === "el" || ne[me].ty === "rc" || ne[me].ty === "sr" ? this.renderPath(ne[me], oe[me]) : ne[me].ty === "fl" ? this.renderFill(ne[me], oe[me], be) : ne[me].ty === "st" ? this.renderStroke(ne[me], oe[me], be) : ne[me].ty === "gf" || ne[me].ty === "gs" ? this.renderGradientFill(ne[me], oe[me], be) : ne[me].ty === "gr" ? this.renderShape(be, ne[me].it, oe[me].it) : ne[me].ty;
      pe && this.drawLayer();
    }, CVShapeElement.prototype.renderStyledShape = function(L, ne) {
      if (this._isFirstFrame || ne._mdf || L.transforms._mdf) {
        var oe = L.trNodes, pe = ne.paths, me, ge, be, Ie = pe._length;
        oe.length = 0;
        var Ae = L.transforms.finalTransform;
        for (be = 0; be < Ie; be += 1) {
          var rt = pe.shapes[be];
          if (rt && rt.v) {
            for (ge = rt._length, me = 1; me < ge; me += 1)
              me === 1 && oe.push({
                t: "m",
                p: Ae.applyToPointArray(rt.v[0][0], rt.v[0][1], 0)
              }), oe.push({
                t: "c",
                pts: Ae.applyToTriplePoints(rt.o[me - 1], rt.i[me], rt.v[me])
              });
            ge === 1 && oe.push({
              t: "m",
              p: Ae.applyToPointArray(rt.v[0][0], rt.v[0][1], 0)
            }), rt.c && ge && (oe.push({
              t: "c",
              pts: Ae.applyToTriplePoints(rt.o[me - 1], rt.i[0], rt.v[0])
            }), oe.push({
              t: "z"
            }));
          }
        }
        L.trNodes = oe;
      }
    }, CVShapeElement.prototype.renderPath = function(L, ne) {
      if (L.hd !== !0 && L._shouldRender) {
        var oe, pe = ne.styledShapes.length;
        for (oe = 0; oe < pe; oe += 1)
          this.renderStyledShape(ne.styledShapes[oe], ne.sh);
      }
    }, CVShapeElement.prototype.renderFill = function(L, ne, oe) {
      var pe = ne.style;
      (ne.c._mdf || this._isFirstFrame) && (pe.co = "rgb(" + bmFloor(ne.c.v[0]) + "," + bmFloor(ne.c.v[1]) + "," + bmFloor(ne.c.v[2]) + ")"), (ne.o._mdf || oe._opMdf || this._isFirstFrame) && (pe.coOp = ne.o.v * oe.opacity);
    }, CVShapeElement.prototype.renderGradientFill = function(L, ne, oe) {
      var pe = ne.style, me;
      if (!pe.grd || ne.g._mdf || ne.s._mdf || ne.e._mdf || L.t !== 1 && (ne.h._mdf || ne.a._mdf)) {
        var ge = this.globalData.canvasContext, be = ne.s.v, Ie = ne.e.v;
        if (L.t === 1)
          me = ge.createLinearGradient(be[0], be[1], Ie[0], Ie[1]);
        else {
          var Ae = Math.sqrt(Math.pow(be[0] - Ie[0], 2) + Math.pow(be[1] - Ie[1], 2)), rt = Math.atan2(Ie[1] - be[1], Ie[0] - be[0]), st = ne.h.v;
          st >= 1 ? st = 0.99 : st <= -1 && (st = -0.99);
          var dt = Ae * st, lt = Math.cos(rt + ne.a.v) * dt + be[0], pt = Math.sin(rt + ne.a.v) * dt + be[1];
          me = ge.createRadialGradient(lt, pt, 0, be[0], be[1], Ae);
        }
        var it, ut = L.g.p, St = ne.g.c, ot = 1;
        for (it = 0; it < ut; it += 1)
          ne.g._hasOpacity && ne.g._collapsable && (ot = ne.g.o[it * 2 + 1]), me.addColorStop(St[it * 4] / 100, "rgba(" + St[it * 4 + 1] + "," + St[it * 4 + 2] + "," + St[it * 4 + 3] + "," + ot + ")");
        pe.grd = me;
      }
      pe.coOp = ne.o.v * oe.opacity;
    }, CVShapeElement.prototype.renderStroke = function(L, ne, oe) {
      var pe = ne.style, me = ne.d;
      me && (me._mdf || this._isFirstFrame) && (pe.da = me.dashArray, pe.do = me.dashoffset[0]), (ne.c._mdf || this._isFirstFrame) && (pe.co = "rgb(" + bmFloor(ne.c.v[0]) + "," + bmFloor(ne.c.v[1]) + "," + bmFloor(ne.c.v[2]) + ")"), (ne.o._mdf || oe._opMdf || this._isFirstFrame) && (pe.coOp = ne.o.v * oe.opacity), (ne.w._mdf || this._isFirstFrame) && (pe.wi = ne.w.v);
    }, CVShapeElement.prototype.destroy = function() {
      this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0;
    };
    function CVTextElement(L, ne, oe) {
      this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
        fill: "rgba(0,0,0,0)",
        stroke: "rgba(0,0,0,0)",
        sWidth: 0,
        fValue: ""
      }, this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
      var L = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(L.l ? L.l.length : 0);
      var ne = !1;
      L.fc ? (ne = !0, this.values.fill = this.buildColor(L.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = ne;
      var oe = !1;
      L.sc && (oe = !0, this.values.stroke = this.buildColor(L.sc), this.values.sWidth = L.sw);
      var pe = this.globalData.fontManager.getFontByName(L.f), me, ge, be = L.l, Ie = this.mHelper;
      this.stroke = oe, this.values.fValue = L.finalSize + "px " + this.globalData.fontManager.getFontByName(L.f).fFamily, ge = L.finalText.length;
      var Ae, rt, st, dt, lt, pt, it, ut, St, ot, ht = this.data.singleShape, ft = L.tr * 1e-3 * L.finalSize, vt = 0, Ct = 0, xt = !0, At = 0;
      for (me = 0; me < ge; me += 1) {
        Ae = this.globalData.fontManager.getCharData(L.finalText[me], pe.fStyle, this.globalData.fontManager.getFontByName(L.f).fFamily), rt = Ae && Ae.data || {}, Ie.reset(), ht && be[me].n && (vt = -ft, Ct += L.yOffset, Ct += xt ? 1 : 0, xt = !1), lt = rt.shapes ? rt.shapes[0].it : [], it = lt.length, Ie.scale(L.finalSize / 100, L.finalSize / 100), ht && this.applyTextPropertiesToMatrix(L, Ie, be[me].line, vt, Ct), St = createSizedArray(it - 1);
        var kt = 0;
        for (pt = 0; pt < it; pt += 1)
          if (lt[pt].ty === "sh") {
            for (dt = lt[pt].ks.k.i.length, ut = lt[pt].ks.k, ot = [], st = 1; st < dt; st += 1)
              st === 1 && ot.push(Ie.applyToX(ut.v[0][0], ut.v[0][1], 0), Ie.applyToY(ut.v[0][0], ut.v[0][1], 0)), ot.push(Ie.applyToX(ut.o[st - 1][0], ut.o[st - 1][1], 0), Ie.applyToY(ut.o[st - 1][0], ut.o[st - 1][1], 0), Ie.applyToX(ut.i[st][0], ut.i[st][1], 0), Ie.applyToY(ut.i[st][0], ut.i[st][1], 0), Ie.applyToX(ut.v[st][0], ut.v[st][1], 0), Ie.applyToY(ut.v[st][0], ut.v[st][1], 0));
            ot.push(Ie.applyToX(ut.o[st - 1][0], ut.o[st - 1][1], 0), Ie.applyToY(ut.o[st - 1][0], ut.o[st - 1][1], 0), Ie.applyToX(ut.i[0][0], ut.i[0][1], 0), Ie.applyToY(ut.i[0][0], ut.i[0][1], 0), Ie.applyToX(ut.v[0][0], ut.v[0][1], 0), Ie.applyToY(ut.v[0][0], ut.v[0][1], 0)), St[kt] = ot, kt += 1;
          }
        ht && (vt += be[me].l, vt += ft), this.textSpans[At] ? this.textSpans[At].elem = St : this.textSpans[At] = {
          elem: St
        }, At += 1;
      }
    }, CVTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var L = this.canvasContext;
      L.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      var ne, oe, pe, me, ge, be, Ie = this.textAnimator.renderedLetters, Ae = this.textProperty.currentData.l;
      oe = Ae.length;
      var rt, st = null, dt = null, lt = null, pt, it, ut = this.globalData.renderer;
      for (ne = 0; ne < oe; ne += 1)
        if (!Ae[ne].n) {
          if (rt = Ie[ne], rt && (ut.save(), ut.ctxTransform(rt.p), ut.ctxOpacity(rt.o)), this.fill) {
            for (rt && rt.fc ? st !== rt.fc && (ut.ctxFillStyle(rt.fc), st = rt.fc) : st !== this.values.fill && (st = this.values.fill, ut.ctxFillStyle(this.values.fill)), pt = this.textSpans[ne].elem, me = pt.length, this.globalData.canvasContext.beginPath(), pe = 0; pe < me; pe += 1)
              for (it = pt[pe], be = it.length, this.globalData.canvasContext.moveTo(it[0], it[1]), ge = 2; ge < be; ge += 6)
                this.globalData.canvasContext.bezierCurveTo(it[ge], it[ge + 1], it[ge + 2], it[ge + 3], it[ge + 4], it[ge + 5]);
            this.globalData.canvasContext.closePath(), ut.ctxFill();
          }
          if (this.stroke) {
            for (rt && rt.sw ? lt !== rt.sw && (lt = rt.sw, ut.ctxLineWidth(rt.sw)) : lt !== this.values.sWidth && (lt = this.values.sWidth, ut.ctxLineWidth(this.values.sWidth)), rt && rt.sc ? dt !== rt.sc && (dt = rt.sc, ut.ctxStrokeStyle(rt.sc)) : dt !== this.values.stroke && (dt = this.values.stroke, ut.ctxStrokeStyle(this.values.stroke)), pt = this.textSpans[ne].elem, me = pt.length, this.globalData.canvasContext.beginPath(), pe = 0; pe < me; pe += 1)
              for (it = pt[pe], be = it.length, this.globalData.canvasContext.moveTo(it[0], it[1]), ge = 2; ge < be; ge += 6)
                this.globalData.canvasContext.bezierCurveTo(it[ge], it[ge + 1], it[ge + 2], it[ge + 3], it[ge + 4], it[ge + 5]);
            this.globalData.canvasContext.closePath(), ut.ctxStroke();
          }
          rt && this.globalData.renderer.restore();
        }
    };
    function CVImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.img = ne.imageLoader.getAsset(this.assetData), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var L = createTag("canvas");
        L.width = this.assetData.w, L.height = this.assetData.h;
        var ne = L.getContext("2d"), oe = this.img.width, pe = this.img.height, me = oe / pe, ge = this.assetData.w / this.assetData.h, be, Ie, Ae = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        me > ge && Ae === "xMidYMid slice" || me < ge && Ae !== "xMidYMid slice" ? (Ie = pe, be = Ie * ge) : (be = oe, Ie = be / ge), ne.drawImage(this.img, (oe - be) / 2, (pe - Ie) / 2, be, Ie, 0, 0, this.assetData.w, this.assetData.h), this.img = L;
      }
    }, CVImageElement.prototype.renderInnerContent = function() {
      this.canvasContext.drawImage(this.img, 0, 0);
    }, CVImageElement.prototype.destroy = function() {
      this.img = null;
    };
    function CVSolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
      this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
    };
    function CanvasRendererBase() {
    }
    extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function(L) {
      return new CVShapeElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createText = function(L) {
      return new CVTextElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createImage = function(L) {
      return new CVImageElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createSolid = function(L) {
      return new CVSolidElement(L, this.globalData, this);
    }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function(L) {
      L[0] === 1 && L[1] === 0 && L[4] === 0 && L[5] === 1 && L[12] === 0 && L[13] === 0 || this.canvasContext.transform(L[0], L[1], L[4], L[5], L[12], L[13]);
    }, CanvasRendererBase.prototype.ctxOpacity = function(L) {
      this.canvasContext.globalAlpha *= L < 0 ? 0 : L;
    }, CanvasRendererBase.prototype.ctxFillStyle = function(L) {
      this.canvasContext.fillStyle = L;
    }, CanvasRendererBase.prototype.ctxStrokeStyle = function(L) {
      this.canvasContext.strokeStyle = L;
    }, CanvasRendererBase.prototype.ctxLineWidth = function(L) {
      this.canvasContext.lineWidth = L;
    }, CanvasRendererBase.prototype.ctxLineCap = function(L) {
      this.canvasContext.lineCap = L;
    }, CanvasRendererBase.prototype.ctxLineJoin = function(L) {
      this.canvasContext.lineJoin = L;
    }, CanvasRendererBase.prototype.ctxMiterLimit = function(L) {
      this.canvasContext.miterLimit = L;
    }, CanvasRendererBase.prototype.ctxFill = function(L) {
      this.canvasContext.fill(L);
    }, CanvasRendererBase.prototype.ctxFillRect = function(L, ne, oe, pe) {
      this.canvasContext.fillRect(L, ne, oe, pe);
    }, CanvasRendererBase.prototype.ctxStroke = function() {
      this.canvasContext.stroke();
    }, CanvasRendererBase.prototype.reset = function() {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    }, CanvasRendererBase.prototype.save = function() {
      this.canvasContext.save();
    }, CanvasRendererBase.prototype.restore = function(L) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      L && (this.globalData.blendMode = "source-over"), this.contextData.restore(L);
    }, CanvasRendererBase.prototype.configAnimation = function(L) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag("canvas");
        var ne = this.animationItem.container.style;
        ne.width = "100%", ne.height = "100%";
        var oe = "0px 0px 0px";
        ne.transformOrigin = oe, ne.mozTransformOrigin = oe, ne.webkitTransformOrigin = oe, ne["-webkit-transform"] = oe, ne.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id);
      } else
        this.canvasContext = this.renderConfig.context;
      this.contextData.setContext(this.canvasContext), this.data = L, this.layers = L.layers, this.transformCanvas = {
        w: L.w,
        h: L.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0
      }, this.setupGlobalData(L, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(L.layers.length), this.updateContainerSize();
    }, CanvasRendererBase.prototype.updateContainerSize = function(L, ne) {
      this.reset();
      var oe, pe;
      L ? (oe = L, pe = ne, this.canvasContext.canvas.width = oe, this.canvasContext.canvas.height = pe) : (this.animationItem.wrapper && this.animationItem.container ? (oe = this.animationItem.wrapper.offsetWidth, pe = this.animationItem.wrapper.offsetHeight) : (oe = this.canvasContext.canvas.width, pe = this.canvasContext.canvas.height), this.canvasContext.canvas.width = oe * this.renderConfig.dpr, this.canvasContext.canvas.height = pe * this.renderConfig.dpr);
      var me, ge;
      if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
        var be = this.renderConfig.preserveAspectRatio.split(" "), Ie = be[1] || "meet", Ae = be[0] || "xMidYMid", rt = Ae.substr(0, 4), st = Ae.substr(4);
        me = oe / pe, ge = this.transformCanvas.w / this.transformCanvas.h, ge > me && Ie === "meet" || ge < me && Ie === "slice" ? (this.transformCanvas.sx = oe / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = oe / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = pe / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = pe / (this.transformCanvas.h / this.renderConfig.dpr)), rt === "xMid" && (ge < me && Ie === "meet" || ge > me && Ie === "slice") ? this.transformCanvas.tx = (oe - this.transformCanvas.w * (pe / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : rt === "xMax" && (ge < me && Ie === "meet" || ge > me && Ie === "slice") ? this.transformCanvas.tx = (oe - this.transformCanvas.w * (pe / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, st === "YMid" && (ge > me && Ie === "meet" || ge < me && Ie === "slice") ? this.transformCanvas.ty = (pe - this.transformCanvas.h * (oe / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : st === "YMax" && (ge > me && Ie === "meet" || ge < me && Ie === "slice") ? this.transformCanvas.ty = (pe - this.transformCanvas.h * (oe / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0;
      } else
        this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = oe / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = pe / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0);
    }, CanvasRendererBase.prototype.destroy = function() {
      this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = ne - 1; L >= 0; L -= 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0;
    }, CanvasRendererBase.prototype.renderFrame = function(L, ne) {
      if (!(this.renderedFrame === L && this.renderConfig.clearCanvas === !0 && !ne || this.destroyed || L === -1)) {
        this.renderedFrame = L, this.globalData.frameNum = L - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || ne, this.globalData.projectInterface.currentFrame = L;
        var oe, pe = this.layers.length;
        for (this.completeLayers || this.checkLayers(L), oe = pe - 1; oe >= 0; oe -= 1)
          (this.completeLayers || this.elements[oe]) && this.elements[oe].prepareFrame(L - this.layers[oe].st);
        if (this.globalData._mdf) {
          for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), oe = pe - 1; oe >= 0; oe -= 1)
            (this.completeLayers || this.elements[oe]) && this.elements[oe].renderFrame();
          this.renderConfig.clearCanvas !== !0 && this.restore();
        }
      }
    }, CanvasRendererBase.prototype.buildItem = function(L) {
      var ne = this.elements;
      if (!(ne[L] || this.layers[L].ty === 99)) {
        var oe = this.createItem(this.layers[L], this, this.globalData);
        ne[L] = oe, oe.initExpressions();
      }
    }, CanvasRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        L.checkParenting();
      }
    }, CanvasRendererBase.prototype.hide = function() {
      this.animationItem.container.style.display = "none";
    }, CanvasRendererBase.prototype.show = function() {
      this.animationItem.container.style.display = "block";
    };
    function CanvasContext() {
      this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random();
    }
    function CVContextData() {
      this.stack = [], this.cArrPos = 0, this.cTr = new Matrix();
      var L, ne = 15;
      for (L = 0; L < ne; L += 1) {
        var oe = new CanvasContext();
        this.stack[L] = oe;
      }
      this._length = ne, this.nativeContext = null, this.transformMat = new Matrix(), this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "";
    }
    CVContextData.prototype.duplicate = function() {
      var L = this._length * 2, ne = 0;
      for (ne = this._length; ne < L; ne += 1)
        this.stack[ne] = new CanvasContext();
      this._length = L;
    }, CVContextData.prototype.reset = function() {
      this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1;
    }, CVContextData.prototype.restore = function(L) {
      this.cArrPos -= 1;
      var ne = this.stack[this.cArrPos], oe = ne.transform, pe, me = this.cTr.props;
      for (pe = 0; pe < 16; pe += 1)
        me[pe] = oe[pe];
      if (L) {
        this.nativeContext.restore();
        var ge = this.stack[this.cArrPos + 1];
        this.appliedFillStyle = ge.fillStyle, this.appliedStrokeStyle = ge.strokeStyle, this.appliedLineWidth = ge.lineWidth, this.appliedLineCap = ge.lineCap, this.appliedLineJoin = ge.lineJoin, this.appliedMiterLimit = ge.miterLimit;
      }
      this.nativeContext.setTransform(oe[0], oe[1], oe[4], oe[5], oe[12], oe[13]), (L || ne.opacity !== -1 && this.currentOpacity !== ne.opacity) && (this.nativeContext.globalAlpha = ne.opacity, this.currentOpacity = ne.opacity), this.currentFillStyle = ne.fillStyle, this.currentStrokeStyle = ne.strokeStyle, this.currentLineWidth = ne.lineWidth, this.currentLineCap = ne.lineCap, this.currentLineJoin = ne.lineJoin, this.currentMiterLimit = ne.miterLimit;
    }, CVContextData.prototype.save = function(L) {
      L && this.nativeContext.save();
      var ne = this.cTr.props;
      this._length <= this.cArrPos && this.duplicate();
      var oe = this.stack[this.cArrPos], pe;
      for (pe = 0; pe < 16; pe += 1)
        oe.transform[pe] = ne[pe];
      this.cArrPos += 1;
      var me = this.stack[this.cArrPos];
      me.opacity = oe.opacity, me.fillStyle = oe.fillStyle, me.strokeStyle = oe.strokeStyle, me.lineWidth = oe.lineWidth, me.lineCap = oe.lineCap, me.lineJoin = oe.lineJoin, me.miterLimit = oe.miterLimit;
    }, CVContextData.prototype.setOpacity = function(L) {
      this.stack[this.cArrPos].opacity = L;
    }, CVContextData.prototype.setContext = function(L) {
      this.nativeContext = L;
    }, CVContextData.prototype.fillStyle = function(L) {
      this.stack[this.cArrPos].fillStyle !== L && (this.currentFillStyle = L, this.stack[this.cArrPos].fillStyle = L);
    }, CVContextData.prototype.strokeStyle = function(L) {
      this.stack[this.cArrPos].strokeStyle !== L && (this.currentStrokeStyle = L, this.stack[this.cArrPos].strokeStyle = L);
    }, CVContextData.prototype.lineWidth = function(L) {
      this.stack[this.cArrPos].lineWidth !== L && (this.currentLineWidth = L, this.stack[this.cArrPos].lineWidth = L);
    }, CVContextData.prototype.lineCap = function(L) {
      this.stack[this.cArrPos].lineCap !== L && (this.currentLineCap = L, this.stack[this.cArrPos].lineCap = L);
    }, CVContextData.prototype.lineJoin = function(L) {
      this.stack[this.cArrPos].lineJoin !== L && (this.currentLineJoin = L, this.stack[this.cArrPos].lineJoin = L);
    }, CVContextData.prototype.miterLimit = function(L) {
      this.stack[this.cArrPos].miterLimit !== L && (this.currentMiterLimit = L, this.stack[this.cArrPos].miterLimit = L);
    }, CVContextData.prototype.transform = function(L) {
      this.transformMat.cloneFromProps(L);
      var ne = this.cTr;
      this.transformMat.multiply(ne), ne.cloneFromProps(this.transformMat.props);
      var oe = ne.props;
      this.nativeContext.setTransform(oe[0], oe[1], oe[4], oe[5], oe[12], oe[13]);
    }, CVContextData.prototype.opacity = function(L) {
      var ne = this.stack[this.cArrPos].opacity;
      ne *= L < 0 ? 0 : L, this.stack[this.cArrPos].opacity !== ne && (this.currentOpacity !== L && (this.nativeContext.globalAlpha = L, this.currentOpacity = L), this.stack[this.cArrPos].opacity = ne);
    }, CVContextData.prototype.fill = function(L) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(L);
    }, CVContextData.prototype.fillRect = function(L, ne, oe, pe) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(L, ne, oe, pe);
    }, CVContextData.prototype.stroke = function() {
      this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke();
    };
    function CVCompElement(L, ne, oe) {
      this.completeLayers = !1, this.layers = L.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
      var L = this.canvasContext;
      L.beginPath(), L.moveTo(0, 0), L.lineTo(this.data.w, 0), L.lineTo(this.data.w, this.data.h), L.lineTo(0, this.data.h), L.lineTo(0, 0), L.clip();
      var ne, oe = this.layers.length;
      for (ne = oe - 1; ne >= 0; ne -= 1)
        (this.completeLayers || this.elements[ne]) && this.elements[ne].renderFrame();
    }, CVCompElement.prototype.destroy = function() {
      var L, ne = this.layers.length;
      for (L = ne - 1; L >= 0; L -= 1)
        this.elements[L] && this.elements[L].destroy();
      this.layers = null, this.elements = null;
    }, CVCompElement.prototype.createComp = function(L) {
      return new CVCompElement(L, this.globalData, this);
    };
    function CanvasRenderer(L, ne) {
      this.animationItem = L, this.renderConfig = {
        clearCanvas: ne && ne.clearCanvas !== void 0 ? ne.clearCanvas : !0,
        context: ne && ne.context || null,
        progressiveLoad: ne && ne.progressiveLoad || !1,
        preserveAspectRatio: ne && ne.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: ne && ne.contentVisibility || "visible",
        className: ne && ne.className || "",
        id: ne && ne.id || "",
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.renderConfig.dpr = ne && ne.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = ne && ne.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
        frameNum: -1,
        _mdf: !1,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1
      }, this.contextData = new CVContextData(), this.elements = [], this.pendingElements = [], this.transformMat = new Matrix(), this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData));
    }
    extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function(L) {
      return new CVCompElement(L, this.globalData, this);
    };
    function HBaseElement() {
    }
    HBaseElement.prototype = {
      checkBlendMode: function() {
      },
      initRendererElement: function() {
        this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement);
      },
      createContainerElements: function() {
        this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        var ne = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var oe = this.finalTransform.mat.toCSS();
          ne.transform = oe, ne.webkitTransform = oe;
        }
        this.finalTransform._opMdf && (ne.opacity = this.finalTransform.mProp.o.v);
      },
      renderFrame: function() {
        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
      },
      destroy: function() {
        this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null);
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function() {
      },
      setMatte: function() {
      }
    }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(L, ne, oe) {
      this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
      var L;
      this.data.hasMask ? (L = createNS("rect"), L.setAttribute("width", this.data.sw), L.setAttribute("height", this.data.sh), L.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (L = createTag("div"), L.style.width = this.data.sw + "px", L.style.height = this.data.sh + "px", L.style.backgroundColor = this.data.sc), this.layerElement.appendChild(L);
    };
    function HShapeElement(L, ne, oe) {
      this.shapes = [], this.shapesData = L.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(L, ne, oe), this.prevViewData = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
      var L;
      if (this.baseElement.style.fontSize = 0, this.data.hasMask)
        this.layerElement.appendChild(this.shapesContainer), L = this.svgElement;
      else {
        L = createNS("svg");
        var ne = this.comp.data ? this.comp.data : this.globalData.compSize;
        L.setAttribute("width", ne.w), L.setAttribute("height", ne.h), L.appendChild(this.shapesContainer), this.layerElement.appendChild(L);
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = L;
    }, HShapeElement.prototype.getTransformedPoint = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        ne = L[oe].mProps.v.applyToPointArray(ne[0], ne[1], 0);
      return ne;
    }, HShapeElement.prototype.calculateShapeBoundingBox = function(L, ne) {
      var oe = L.sh.v, pe = L.transformers, me, ge = oe._length, be, Ie, Ae, rt;
      if (!(ge <= 1)) {
        for (me = 0; me < ge - 1; me += 1)
          be = this.getTransformedPoint(pe, oe.v[me]), Ie = this.getTransformedPoint(pe, oe.o[me]), Ae = this.getTransformedPoint(pe, oe.i[me + 1]), rt = this.getTransformedPoint(pe, oe.v[me + 1]), this.checkBounds(be, Ie, Ae, rt, ne);
        oe.c && (be = this.getTransformedPoint(pe, oe.v[me]), Ie = this.getTransformedPoint(pe, oe.o[me]), Ae = this.getTransformedPoint(pe, oe.i[0]), rt = this.getTransformedPoint(pe, oe.v[0]), this.checkBounds(be, Ie, Ae, rt, ne));
      }
    }, HShapeElement.prototype.checkBounds = function(L, ne, oe, pe, me) {
      this.getBoundsOfCurve(L, ne, oe, pe);
      var ge = this.shapeBoundingBox;
      me.x = bmMin(ge.left, me.x), me.xMax = bmMax(ge.right, me.xMax), me.y = bmMin(ge.top, me.y), me.yMax = bmMax(ge.bottom, me.yMax);
    }, HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0
    }, HShapeElement.prototype.getBoundsOfCurve = function(L, ne, oe, pe) {
      for (var me = [[L[0], pe[0]], [L[1], pe[1]]], ge, be, Ie, Ae, rt, st, dt, lt = 0; lt < 2; ++lt)
        be = 6 * L[lt] - 12 * ne[lt] + 6 * oe[lt], ge = -3 * L[lt] + 9 * ne[lt] - 9 * oe[lt] + 3 * pe[lt], Ie = 3 * ne[lt] - 3 * L[lt], be |= 0, ge |= 0, Ie |= 0, ge === 0 && be === 0 || (ge === 0 ? (Ae = -Ie / be, Ae > 0 && Ae < 1 && me[lt].push(this.calculateF(Ae, L, ne, oe, pe, lt))) : (rt = be * be - 4 * Ie * ge, rt >= 0 && (st = (-be + bmSqrt(rt)) / (2 * ge), st > 0 && st < 1 && me[lt].push(this.calculateF(st, L, ne, oe, pe, lt)), dt = (-be - bmSqrt(rt)) / (2 * ge), dt > 0 && dt < 1 && me[lt].push(this.calculateF(dt, L, ne, oe, pe, lt)))));
      this.shapeBoundingBox.left = bmMin.apply(null, me[0]), this.shapeBoundingBox.top = bmMin.apply(null, me[1]), this.shapeBoundingBox.right = bmMax.apply(null, me[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, me[1]);
    }, HShapeElement.prototype.calculateF = function(L, ne, oe, pe, me, ge) {
      return bmPow(1 - L, 3) * ne[ge] + 3 * bmPow(1 - L, 2) * L * oe[ge] + 3 * (1 - L) * bmPow(L, 2) * pe[ge] + bmPow(L, 3) * me[ge];
    }, HShapeElement.prototype.calculateBoundingBox = function(L, ne) {
      var oe, pe = L.length;
      for (oe = 0; oe < pe; oe += 1)
        L[oe] && L[oe].sh ? this.calculateShapeBoundingBox(L[oe], ne) : L[oe] && L[oe].it ? this.calculateBoundingBox(L[oe].it, ne) : L[oe] && L[oe].style && L[oe].w && this.expandStrokeBoundingBox(L[oe].w, ne);
    }, HShapeElement.prototype.expandStrokeBoundingBox = function(L, ne) {
      var oe = 0;
      if (L.keyframes) {
        for (var pe = 0; pe < L.keyframes.length; pe += 1) {
          var me = L.keyframes[pe].s;
          me > oe && (oe = me);
        }
        oe *= L.mult;
      } else
        oe = L.v * L.mult;
      ne.x -= oe, ne.xMax += oe, ne.y -= oe, ne.yMax += oe;
    }, HShapeElement.prototype.currentBoxContains = function(L) {
      return this.currentBBox.x <= L.x && this.currentBBox.y <= L.y && this.currentBBox.width + this.currentBBox.x >= L.x + L.width && this.currentBBox.height + this.currentBBox.y >= L.y + L.height;
    }, HShapeElement.prototype.renderInnerContent = function() {
      if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
        var L = this.tempBoundingBox, ne = 999999;
        if (L.x = ne, L.xMax = -ne, L.y = ne, L.yMax = -ne, this.calculateBoundingBox(this.itemsData, L), L.width = L.xMax < L.x ? 0 : L.xMax - L.x, L.height = L.yMax < L.y ? 0 : L.yMax - L.y, this.currentBoxContains(L))
          return;
        var oe = !1;
        if (this.currentBBox.w !== L.width && (this.currentBBox.w = L.width, this.shapeCont.setAttribute("width", L.width), oe = !0), this.currentBBox.h !== L.height && (this.currentBBox.h = L.height, this.shapeCont.setAttribute("height", L.height), oe = !0), oe || this.currentBBox.x !== L.x || this.currentBBox.y !== L.y) {
          this.currentBBox.w = L.width, this.currentBBox.h = L.height, this.currentBBox.x = L.x, this.currentBBox.y = L.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
          var pe = this.shapeCont.style, me = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
          pe.transform = me, pe.webkitTransform = me;
        }
      }
    };
    function HTextElement(L, ne, oe) {
      this.textSpans = [], this.textPaths = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      }, this.renderType = "svg", this.isMasked = !1, this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
      if (this.isMasked = this.checkMasks(), this.isMasked) {
        this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
        var L = createNS("g");
        this.maskedElement.appendChild(L), this.innerElem = L;
      } else
        this.renderType = "html", this.innerElem = this.layerElement;
      this.checkParenting();
    }, HTextElement.prototype.buildNewText = function() {
      var L = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(L.l ? L.l.length : 0);
      var ne = this.innerElem.style, oe = L.fc ? this.buildColor(L.fc) : "rgba(0,0,0,0)";
      ne.fill = oe, ne.color = oe, L.sc && (ne.stroke = this.buildColor(L.sc), ne.strokeWidth = L.sw + "px");
      var pe = this.globalData.fontManager.getFontByName(L.f);
      if (!this.globalData.fontManager.chars)
        if (ne.fontSize = L.finalSize + "px", ne.lineHeight = L.finalSize + "px", pe.fClass)
          this.innerElem.className = pe.fClass;
        else {
          ne.fontFamily = pe.fFamily;
          var me = L.fWeight, ge = L.fStyle;
          ne.fontStyle = ge, ne.fontWeight = me;
        }
      var be, Ie, Ae = L.l;
      Ie = Ae.length;
      var rt, st, dt, lt = this.mHelper, pt, it = "", ut = 0;
      for (be = 0; be < Ie; be += 1) {
        if (this.globalData.fontManager.chars ? (this.textPaths[ut] ? rt = this.textPaths[ut] : (rt = createNS("path"), rt.setAttribute("stroke-linecap", lineCapEnum[1]), rt.setAttribute("stroke-linejoin", lineJoinEnum[2]), rt.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[ut] ? (st = this.textSpans[ut], dt = st.children[0]) : (st = createTag("div"), st.style.lineHeight = 0, dt = createNS("svg"), dt.appendChild(rt), styleDiv(st)))) : this.isMasked ? rt = this.textPaths[ut] ? this.textPaths[ut] : createNS("text") : this.textSpans[ut] ? (st = this.textSpans[ut], rt = this.textPaths[ut]) : (st = createTag("span"), styleDiv(st), rt = createTag("span"), styleDiv(rt), st.appendChild(rt)), this.globalData.fontManager.chars) {
          var St = this.globalData.fontManager.getCharData(L.finalText[be], pe.fStyle, this.globalData.fontManager.getFontByName(L.f).fFamily), ot;
          if (St ? ot = St.data : ot = null, lt.reset(), ot && ot.shapes && ot.shapes.length && (pt = ot.shapes[0].it, lt.scale(L.finalSize / 100, L.finalSize / 100), it = this.createPathShape(lt, pt), rt.setAttribute("d", it)), this.isMasked)
            this.innerElem.appendChild(rt);
          else {
            if (this.innerElem.appendChild(st), ot && ot.shapes) {
              document.body.appendChild(dt);
              var ht = dt.getBBox();
              dt.setAttribute("width", ht.width + 2), dt.setAttribute("height", ht.height + 2), dt.setAttribute("viewBox", ht.x - 1 + " " + (ht.y - 1) + " " + (ht.width + 2) + " " + (ht.height + 2));
              var ft = dt.style, vt = "translate(" + (ht.x - 1) + "px," + (ht.y - 1) + "px)";
              ft.transform = vt, ft.webkitTransform = vt, Ae[be].yOffset = ht.y - 1;
            } else
              dt.setAttribute("width", 1), dt.setAttribute("height", 1);
            st.appendChild(dt);
          }
        } else if (rt.textContent = Ae[be].val, rt.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked)
          this.innerElem.appendChild(rt);
        else {
          this.innerElem.appendChild(st);
          var Ct = rt.style, xt = "translate3d(0," + -L.finalSize / 1.2 + "px,0)";
          Ct.transform = xt, Ct.webkitTransform = xt;
        }
        this.isMasked ? this.textSpans[ut] = rt : this.textSpans[ut] = st, this.textSpans[ut].style.display = "block", this.textPaths[ut] = rt, ut += 1;
      }
      for (; ut < this.textSpans.length; )
        this.textSpans[ut].style.display = "none", ut += 1;
    }, HTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var L;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag)
          return;
        if (this.isMasked && this.finalTransform._matMdf) {
          this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), L = this.svgElement.style;
          var ne = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
          L.transform = ne, L.webkitTransform = ne;
        }
      }
      if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
        var oe, pe, me = 0, ge = this.textAnimator.renderedLetters, be = this.textProperty.currentData.l;
        pe = be.length;
        var Ie, Ae, rt;
        for (oe = 0; oe < pe; oe += 1)
          be[oe].n ? me += 1 : (Ae = this.textSpans[oe], rt = this.textPaths[oe], Ie = ge[me], me += 1, Ie._mdf.m && (this.isMasked ? Ae.setAttribute("transform", Ie.m) : (Ae.style.webkitTransform = Ie.m, Ae.style.transform = Ie.m)), Ae.style.opacity = Ie.o, Ie.sw && Ie._mdf.sw && rt.setAttribute("stroke-width", Ie.sw), Ie.sc && Ie._mdf.sc && rt.setAttribute("stroke", Ie.sc), Ie.fc && Ie._mdf.fc && (rt.setAttribute("fill", Ie.fc), rt.style.color = Ie.fc));
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var st = this.innerElem.getBBox();
          this.currentBBox.w !== st.width && (this.currentBBox.w = st.width, this.svgElement.setAttribute("width", st.width)), this.currentBBox.h !== st.height && (this.currentBBox.h = st.height, this.svgElement.setAttribute("height", st.height));
          var dt = 1;
          if (this.currentBBox.w !== st.width + dt * 2 || this.currentBBox.h !== st.height + dt * 2 || this.currentBBox.x !== st.x - dt || this.currentBBox.y !== st.y - dt) {
            this.currentBBox.w = st.width + dt * 2, this.currentBBox.h = st.height + dt * 2, this.currentBBox.x = st.x - dt, this.currentBBox.y = st.y - dt, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), L = this.svgElement.style;
            var lt = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            L.transform = lt, L.webkitTransform = lt;
          }
        }
      }
    };
    function HCameraElement(L, ne, oe) {
      this.initFrame(), this.initBaseData(L, ne, oe), this.initHierarchy();
      var pe = PropertyFactory.getProp;
      if (this.pe = pe(this, L.pe, 0, 0, this), L.ks.p.s ? (this.px = pe(this, L.ks.p.x, 1, 0, this), this.py = pe(this, L.ks.p.y, 1, 0, this), this.pz = pe(this, L.ks.p.z, 1, 0, this)) : this.p = pe(this, L.ks.p, 1, 0, this), L.ks.a && (this.a = pe(this, L.ks.a, 1, 0, this)), L.ks.or.k.length && L.ks.or.k[0].to) {
        var me, ge = L.ks.or.k.length;
        for (me = 0; me < ge; me += 1)
          L.ks.or.k[me].to = null, L.ks.or.k[me].ti = null;
      }
      this.or = pe(this, L.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = pe(this, L.ks.rx, 0, degToRads, this), this.ry = pe(this, L.ks.ry, 0, degToRads, this), this.rz = pe(this, L.ks.rz, 0, degToRads, this), this.mat = new Matrix(), this._prevMat = new Matrix(), this._isFirstFrame = !0, this.finalTransform = {
        mProp: this
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
      var L, ne = this.comp.threeDElements.length, oe, pe, me;
      for (L = 0; L < ne; L += 1)
        if (oe = this.comp.threeDElements[L], oe.type === "3d") {
          pe = oe.perspectiveElem.style, me = oe.container.style;
          var ge = this.pe.v + "px", be = "0px 0px 0px", Ie = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          pe.perspective = ge, pe.webkitPerspective = ge, me.transformOrigin = be, me.mozTransformOrigin = be, me.webkitTransformOrigin = be, pe.transform = Ie, pe.webkitTransform = Ie;
        }
    }, HCameraElement.prototype.createElements = function() {
    }, HCameraElement.prototype.hide = function() {
    }, HCameraElement.prototype.renderFrame = function() {
      var L = this._isFirstFrame, ne, oe;
      if (this.hierarchy)
        for (oe = this.hierarchy.length, ne = 0; ne < oe; ne += 1)
          L = this.hierarchy[ne].finalTransform.mProp._mdf || L;
      if (L || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
        if (this.mat.reset(), this.hierarchy)
          for (oe = this.hierarchy.length - 1, ne = oe; ne >= 0; ne -= 1) {
            var pe = this.hierarchy[ne].finalTransform.mProp;
            this.mat.translate(-pe.p.v[0], -pe.p.v[1], pe.p.v[2]), this.mat.rotateX(-pe.or.v[0]).rotateY(-pe.or.v[1]).rotateZ(pe.or.v[2]), this.mat.rotateX(-pe.rx.v).rotateY(-pe.ry.v).rotateZ(pe.rz.v), this.mat.scale(1 / pe.s.v[0], 1 / pe.s.v[1], 1 / pe.s.v[2]), this.mat.translate(pe.a.v[0], pe.a.v[1], pe.a.v[2]);
          }
        if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
          var me;
          this.p ? me = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : me = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          var ge = Math.sqrt(Math.pow(me[0], 2) + Math.pow(me[1], 2) + Math.pow(me[2], 2)), be = [me[0] / ge, me[1] / ge, me[2] / ge], Ie = Math.sqrt(be[2] * be[2] + be[0] * be[0]), Ae = Math.atan2(be[1], Ie), rt = Math.atan2(be[0], -be[2]);
          this.mat.rotateY(rt).rotateX(-Ae);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
        var st = !this._prevMat.equals(this.mat);
        if ((st || this.pe._mdf) && this.comp.threeDElements) {
          oe = this.comp.threeDElements.length;
          var dt, lt, pt;
          for (ne = 0; ne < oe; ne += 1)
            if (dt = this.comp.threeDElements[ne], dt.type === "3d") {
              if (st) {
                var it = this.mat.toCSS();
                pt = dt.container.style, pt.transform = it, pt.webkitTransform = it;
              }
              this.pe._mdf && (lt = dt.perspectiveElem.style, lt.perspective = this.pe.v + "px", lt.webkitPerspective = this.pe.v + "px");
            }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = !1;
    }, HCameraElement.prototype.prepareFrame = function(L) {
      this.prepareProperties(L, !0);
    }, HCameraElement.prototype.destroy = function() {
    }, HCameraElement.prototype.getBaseElement = function() {
      return null;
    };
    function HImageElement(L, ne, oe) {
      this.assetData = ne.getAssetData(L.refId), this.initElement(L, ne, oe);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
      var L = this.globalData.getAssetsPath(this.assetData), ne = new Image();
      this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", L), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(ne), ne.crossOrigin = "anonymous", ne.src = L, this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
    };
    function HybridRendererBase(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: ne && ne.className || "",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "400%",
          height: ne && ne.filterSize && ne.filterSize.height || "400%",
          x: ne && ne.filterSize && ne.filterSize.x || "-100%",
          y: ne && ne.filterSize && ne.filterSize.y || "-100%"
        }
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var L = this.pendingElements.pop();
        L.checkParenting();
      }
    }, HybridRendererBase.prototype.appendElementInPos = function(L, ne) {
      var oe = L.getBaseElement();
      if (oe) {
        var pe = this.layers[ne];
        if (!pe.ddd || !this.supports3d)
          if (this.threeDElements)
            this.addTo3dContainer(oe, ne);
          else {
            for (var me = 0, ge, be, Ie; me < ne; )
              this.elements[me] && this.elements[me] !== !0 && this.elements[me].getBaseElement && (be = this.elements[me], Ie = this.layers[me].ddd ? this.getThreeDContainerByPos(me) : be.getBaseElement(), ge = Ie || ge), me += 1;
            ge ? (!pe.ddd || !this.supports3d) && this.layerElement.insertBefore(oe, ge) : (!pe.ddd || !this.supports3d) && this.layerElement.appendChild(oe);
          }
        else
          this.addTo3dContainer(oe, ne);
      }
    }, HybridRendererBase.prototype.createShape = function(L) {
      return this.supports3d ? new HShapeElement(L, this.globalData, this) : new SVGShapeElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createText = function(L) {
      return this.supports3d ? new HTextElement(L, this.globalData, this) : new SVGTextLottieElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createCamera = function(L) {
      return this.camera = new HCameraElement(L, this.globalData, this), this.camera;
    }, HybridRendererBase.prototype.createImage = function(L) {
      return this.supports3d ? new HImageElement(L, this.globalData, this) : new IImageElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createSolid = function(L) {
      return this.supports3d ? new HSolidElement(L, this.globalData, this) : new ISolidElement(L, this.globalData, this);
    }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function(L) {
      for (var ne = 0, oe = this.threeDElements.length; ne < oe; ) {
        if (this.threeDElements[ne].startPos <= L && this.threeDElements[ne].endPos >= L)
          return this.threeDElements[ne].perspectiveElem;
        ne += 1;
      }
      return null;
    }, HybridRendererBase.prototype.createThreeDContainer = function(L, ne) {
      var oe = createTag("div"), pe, me;
      styleDiv(oe);
      var ge = createTag("div");
      if (styleDiv(ge), ne === "3d") {
        pe = oe.style, pe.width = this.globalData.compSize.w + "px", pe.height = this.globalData.compSize.h + "px";
        var be = "50% 50%";
        pe.webkitTransformOrigin = be, pe.mozTransformOrigin = be, pe.transformOrigin = be, me = ge.style;
        var Ie = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
        me.transform = Ie, me.webkitTransform = Ie;
      }
      oe.appendChild(ge);
      var Ae = {
        container: ge,
        perspectiveElem: oe,
        startPos: L,
        endPos: L,
        type: ne
      };
      return this.threeDElements.push(Ae), Ae;
    }, HybridRendererBase.prototype.build3dContainers = function() {
      var L, ne = this.layers.length, oe, pe = "";
      for (L = 0; L < ne; L += 1)
        this.layers[L].ddd && this.layers[L].ty !== 3 ? (pe !== "3d" && (pe = "3d", oe = this.createThreeDContainer(L, "3d")), oe.endPos = Math.max(oe.endPos, L)) : (pe !== "2d" && (pe = "2d", oe = this.createThreeDContainer(L, "2d")), oe.endPos = Math.max(oe.endPos, L));
      for (ne = this.threeDElements.length, L = ne - 1; L >= 0; L -= 1)
        this.resizerElem.appendChild(this.threeDElements[L].perspectiveElem);
    }, HybridRendererBase.prototype.addTo3dContainer = function(L, ne) {
      for (var oe = 0, pe = this.threeDElements.length; oe < pe; ) {
        if (ne <= this.threeDElements[oe].endPos) {
          for (var me = this.threeDElements[oe].startPos, ge; me < ne; )
            this.elements[me] && this.elements[me].getBaseElement && (ge = this.elements[me].getBaseElement()), me += 1;
          ge ? this.threeDElements[oe].container.insertBefore(L, ge) : this.threeDElements[oe].container.appendChild(L);
          break;
        }
        oe += 1;
      }
    }, HybridRendererBase.prototype.configAnimation = function(L) {
      var ne = createTag("div"), oe = this.animationItem.wrapper, pe = ne.style;
      pe.width = L.w + "px", pe.height = L.h + "px", this.resizerElem = ne, styleDiv(ne), pe.transformStyle = "flat", pe.mozTransformStyle = "flat", pe.webkitTransformStyle = "flat", this.renderConfig.className && ne.setAttribute("class", this.renderConfig.className), oe.appendChild(ne), pe.overflow = "hidden";
      var me = createNS("svg");
      me.setAttribute("width", "1"), me.setAttribute("height", "1"), styleDiv(me), this.resizerElem.appendChild(me);
      var ge = createNS("defs");
      me.appendChild(ge), this.data = L, this.setupGlobalData(L, me), this.globalData.defs = ge, this.layers = L.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize();
    }, HybridRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
      var L, ne = this.layers ? this.layers.length : 0;
      for (L = 0; L < ne; L += 1)
        this.elements[L] && this.elements[L].destroy && this.elements[L].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, HybridRendererBase.prototype.updateContainerSize = function() {
      var L = this.animationItem.wrapper.offsetWidth, ne = this.animationItem.wrapper.offsetHeight, oe = L / ne, pe = this.globalData.compSize.w / this.globalData.compSize.h, me, ge, be, Ie;
      pe > oe ? (me = L / this.globalData.compSize.w, ge = L / this.globalData.compSize.w, be = 0, Ie = (ne - this.globalData.compSize.h * (L / this.globalData.compSize.w)) / 2) : (me = ne / this.globalData.compSize.h, ge = ne / this.globalData.compSize.h, be = (L - this.globalData.compSize.w * (ne / this.globalData.compSize.h)) / 2, Ie = 0);
      var Ae = this.resizerElem.style;
      Ae.webkitTransform = "matrix3d(" + me + ",0,0,0,0," + ge + ",0,0,0,0,1,0," + be + "," + Ie + ",0,1)", Ae.transform = Ae.webkitTransform;
    }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function() {
      this.resizerElem.style.display = "none";
    }, HybridRendererBase.prototype.show = function() {
      this.resizerElem.style.display = "block";
    }, HybridRendererBase.prototype.initItems = function() {
      if (this.buildAllItems(), this.camera)
        this.camera.setup();
      else {
        var L = this.globalData.compSize.w, ne = this.globalData.compSize.h, oe, pe = this.threeDElements.length;
        for (oe = 0; oe < pe; oe += 1) {
          var me = this.threeDElements[oe].perspectiveElem.style;
          me.webkitPerspective = Math.sqrt(Math.pow(L, 2) + Math.pow(ne, 2)) + "px", me.perspective = me.webkitPerspective;
        }
      }
    }, HybridRendererBase.prototype.searchExtraCompositions = function(L) {
      var ne, oe = L.length, pe = createTag("div");
      for (ne = 0; ne < oe; ne += 1)
        if (L[ne].xt) {
          var me = this.createComp(L[ne], pe, this.globalData.comp, null);
          me.initExpressions(), this.globalData.projectInterface.registerComposition(me);
        }
    };
    function HCompElement(L, ne, oe) {
      this.layers = L.layers, this.supports3d = !L.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(L, ne, oe), this.tm = L.tm ? PropertyFactory.getProp(this, L.tm, 0, ne.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
      this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement;
    }, HCompElement.prototype.addTo3dContainer = function(L, ne) {
      for (var oe = 0, pe; oe < ne; )
        this.elements[oe] && this.elements[oe].getBaseElement && (pe = this.elements[oe].getBaseElement()), oe += 1;
      pe ? this.layerElement.insertBefore(L, pe) : this.layerElement.appendChild(L);
    }, HCompElement.prototype.createComp = function(L) {
      return this.supports3d ? new HCompElement(L, this.globalData, this) : new SVGCompElement(L, this.globalData, this);
    };
    function HybridRenderer(L, ne) {
      this.animationItem = L, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: ne && ne.className || "",
        imagePreserveAspectRatio: ne && ne.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(ne && ne.hideOnTransparent === !1),
        filterSize: {
          width: ne && ne.filterSize && ne.filterSize.width || "400%",
          height: ne && ne.filterSize && ne.filterSize.height || "400%",
          x: ne && ne.filterSize && ne.filterSize.x || "-100%",
          y: ne && ne.filterSize && ne.filterSize.y || "-100%"
        },
        runExpressions: !ne || ne.runExpressions === void 0 || ne.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function(L) {
      return this.supports3d ? new HCompElement(L, this.globalData, this) : new SVGCompElement(L, this.globalData, this);
    };
    var CompExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        function ne(oe) {
          for (var pe = 0, me = L.layers.length; pe < me; ) {
            if (L.layers[pe].nm === oe || L.layers[pe].ind === oe)
              return L.elements[pe].layerInterface;
            pe += 1;
          }
          return null;
        }
        return Object.defineProperty(ne, "_name", {
          value: L.data.nm
        }), ne.layer = ne, ne.pixelAspect = 1, ne.height = L.data.h || L.globalData.compSize.h, ne.width = L.data.w || L.globalData.compSize.w, ne.pixelAspect = 1, ne.frameDuration = 1 / L.globalData.frameRate, ne.displayStartTime = 0, ne.numLayers = L.layers.length, ne;
      };
    }();
    function _typeof$2(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(oe) {
        return typeof oe;
      } : _typeof$2 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$2(L);
    }
    function seedRandom(L, ne) {
      var oe = this, pe = 256, me = 6, ge = 52, be = "random", Ie = ne.pow(pe, me), Ae = ne.pow(2, ge), rt = Ae * 2, st = pe - 1, dt;
      function lt(ft, vt, Ct) {
        var xt = [];
        vt = vt === !0 ? {
          entropy: !0
        } : vt || {};
        var At = St(ut(vt.entropy ? [ft, ht(L)] : ft === null ? ot() : ft, 3), xt), kt = new pt(xt), Vt = function() {
          for (var er = kt.g(me), Yt = Ie, Jt = 0; er < Ae; )
            er = (er + Jt) * pe, Yt *= pe, Jt = kt.g(1);
          for (; er >= rt; )
            er /= 2, Yt /= 2, Jt >>>= 1;
          return (er + Jt) / Yt;
        };
        return Vt.int32 = function() {
          return kt.g(4) | 0;
        }, Vt.quick = function() {
          return kt.g(4) / 4294967296;
        }, Vt.double = Vt, St(ht(kt.S), L), (vt.pass || Ct || function(ir, er, Yt, Jt) {
          return Jt && (Jt.S && it(Jt, kt), ir.state = function() {
            return it(kt, {});
          }), Yt ? (ne[be] = ir, er) : ir;
        })(Vt, At, "global" in vt ? vt.global : this == ne, vt.state);
      }
      ne["seed" + be] = lt;
      function pt(ft) {
        var vt, Ct = ft.length, xt = this, At = 0, kt = xt.i = xt.j = 0, Vt = xt.S = [];
        for (Ct || (ft = [Ct++]); At < pe; )
          Vt[At] = At++;
        for (At = 0; At < pe; At++)
          Vt[At] = Vt[kt = st & kt + ft[At % Ct] + (vt = Vt[At])], Vt[kt] = vt;
        xt.g = function(ir) {
          for (var er, Yt = 0, Jt = xt.i, rr = xt.j, Qt = xt.S; ir--; )
            er = Qt[Jt = st & Jt + 1], Yt = Yt * pe + Qt[st & (Qt[Jt] = Qt[rr = st & rr + er]) + (Qt[rr] = er)];
          return xt.i = Jt, xt.j = rr, Yt;
        };
      }
      function it(ft, vt) {
        return vt.i = ft.i, vt.j = ft.j, vt.S = ft.S.slice(), vt;
      }
      function ut(ft, vt) {
        var Ct = [], xt = _typeof$2(ft), At;
        if (vt && xt == "object")
          for (At in ft)
            try {
              Ct.push(ut(ft[At], vt - 1));
            } catch {
            }
        return Ct.length ? Ct : xt == "string" ? ft : ft + "\0";
      }
      function St(ft, vt) {
        for (var Ct = ft + "", xt, At = 0; At < Ct.length; )
          vt[st & At] = st & (xt ^= vt[st & At] * 19) + Ct.charCodeAt(At++);
        return ht(vt);
      }
      function ot() {
        try {
          var ft = new Uint8Array(pe);
          return (oe.crypto || oe.msCrypto).getRandomValues(ft), ht(ft);
        } catch {
          var vt = oe.navigator, Ct = vt && vt.plugins;
          return [+/* @__PURE__ */ new Date(), oe, Ct, oe.screen, ht(L)];
        }
      }
      function ht(ft) {
        return String.fromCharCode.apply(0, ft);
      }
      St(ne.random(), L);
    }
    function initialize$2(L) {
      seedRandom([], L);
    }
    var propTypes = {
      SHAPE: "shape"
    };
    function _typeof$1(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(oe) {
        return typeof oe;
      } : _typeof$1 = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof$1(L);
    }
    var ExpressionManager = function() {
      var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {};
      initialize$2(BMMath);
      function resetFrame() {
        _lottieGlobal = {};
      }
      function $bm_isInstanceOfArray(L) {
        return L.constructor === Array || L.constructor === Float32Array;
      }
      function isNumerable(L, ne) {
        return L === "number" || ne instanceof Number || L === "boolean" || L === "string";
      }
      function $bm_neg(L) {
        var ne = _typeof$1(L);
        if (ne === "number" || L instanceof Number || ne === "boolean")
          return -L;
        if ($bm_isInstanceOfArray(L)) {
          var oe, pe = L.length, me = [];
          for (oe = 0; oe < pe; oe += 1)
            me[oe] = -L[oe];
          return me;
        }
        return L.propType ? L.v : -L;
      }
      var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
      function sum(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne);
        if (isNumerable(oe, L) && isNumerable(pe, ne) || oe === "string" || pe === "string")
          return L + ne;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne))
          return L = L.slice(0), L[0] += ne, L;
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne))
          return ne = ne.slice(0), ne[0] = L + ne[0], ne;
        if ($bm_isInstanceOfArray(L) && $bm_isInstanceOfArray(ne)) {
          for (var me = 0, ge = L.length, be = ne.length, Ie = []; me < ge || me < be; )
            (typeof L[me] == "number" || L[me] instanceof Number) && (typeof ne[me] == "number" || ne[me] instanceof Number) ? Ie[me] = L[me] + ne[me] : Ie[me] = ne[me] === void 0 ? L[me] : L[me] || ne[me], me += 1;
          return Ie;
        }
        return 0;
      }
      var add = sum;
      function sub(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne);
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return oe === "string" && (L = parseInt(L, 10)), pe === "string" && (ne = parseInt(ne, 10)), L - ne;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne))
          return L = L.slice(0), L[0] -= ne, L;
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne))
          return ne = ne.slice(0), ne[0] = L - ne[0], ne;
        if ($bm_isInstanceOfArray(L) && $bm_isInstanceOfArray(ne)) {
          for (var me = 0, ge = L.length, be = ne.length, Ie = []; me < ge || me < be; )
            (typeof L[me] == "number" || L[me] instanceof Number) && (typeof ne[me] == "number" || ne[me] instanceof Number) ? Ie[me] = L[me] - ne[me] : Ie[me] = ne[me] === void 0 ? L[me] : L[me] || ne[me], me += 1;
          return Ie;
        }
        return 0;
      }
      function mul(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne), me;
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return L * ne;
        var ge, be;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne)) {
          for (be = L.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L[ge] * ne;
          return me;
        }
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne)) {
          for (be = ne.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L * ne[ge];
          return me;
        }
        return 0;
      }
      function div(L, ne) {
        var oe = _typeof$1(L), pe = _typeof$1(ne), me;
        if (isNumerable(oe, L) && isNumerable(pe, ne))
          return L / ne;
        var ge, be;
        if ($bm_isInstanceOfArray(L) && isNumerable(pe, ne)) {
          for (be = L.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L[ge] / ne;
          return me;
        }
        if (isNumerable(oe, L) && $bm_isInstanceOfArray(ne)) {
          for (be = ne.length, me = createTypedArray("float32", be), ge = 0; ge < be; ge += 1)
            me[ge] = L / ne[ge];
          return me;
        }
        return 0;
      }
      function mod(L, ne) {
        return typeof L == "string" && (L = parseInt(L, 10)), typeof ne == "string" && (ne = parseInt(ne, 10)), L % ne;
      }
      var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod;
      function clamp(L, ne, oe) {
        if (ne > oe) {
          var pe = oe;
          oe = ne, ne = pe;
        }
        return Math.min(Math.max(L, ne), oe);
      }
      function radiansToDegrees(L) {
        return L / degToRads;
      }
      var radians_to_degrees = radiansToDegrees;
      function degreesToRadians(L) {
        return L * degToRads;
      }
      var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0];
      function length(L, ne) {
        if (typeof L == "number" || L instanceof Number)
          return ne = ne || 0, Math.abs(L - ne);
        ne || (ne = helperLengthArray);
        var oe, pe = Math.min(L.length, ne.length), me = 0;
        for (oe = 0; oe < pe; oe += 1)
          me += Math.pow(ne[oe] - L[oe], 2);
        return Math.sqrt(me);
      }
      function normalize(L) {
        return div(L, length(L));
      }
      function rgbToHsl(L) {
        var ne = L[0], oe = L[1], pe = L[2], me = Math.max(ne, oe, pe), ge = Math.min(ne, oe, pe), be, Ie, Ae = (me + ge) / 2;
        if (me === ge)
          be = 0, Ie = 0;
        else {
          var rt = me - ge;
          switch (Ie = Ae > 0.5 ? rt / (2 - me - ge) : rt / (me + ge), me) {
            case ne:
              be = (oe - pe) / rt + (oe < pe ? 6 : 0);
              break;
            case oe:
              be = (pe - ne) / rt + 2;
              break;
            case pe:
              be = (ne - oe) / rt + 4;
              break;
          }
          be /= 6;
        }
        return [be, Ie, Ae, L[3]];
      }
      function hue2rgb(L, ne, oe) {
        return oe < 0 && (oe += 1), oe > 1 && (oe -= 1), oe < 1 / 6 ? L + (ne - L) * 6 * oe : oe < 1 / 2 ? ne : oe < 2 / 3 ? L + (ne - L) * (2 / 3 - oe) * 6 : L;
      }
      function hslToRgb(L) {
        var ne = L[0], oe = L[1], pe = L[2], me, ge, be;
        if (oe === 0)
          me = pe, be = pe, ge = pe;
        else {
          var Ie = pe < 0.5 ? pe * (1 + oe) : pe + oe - pe * oe, Ae = 2 * pe - Ie;
          me = hue2rgb(Ae, Ie, ne + 1 / 3), ge = hue2rgb(Ae, Ie, ne), be = hue2rgb(Ae, Ie, ne - 1 / 3);
        }
        return [me, ge, be, L[3]];
      }
      function linear(L, ne, oe, pe, me) {
        if ((pe === void 0 || me === void 0) && (pe = ne, me = oe, ne = 0, oe = 1), oe < ne) {
          var ge = oe;
          oe = ne, ne = ge;
        }
        if (L <= ne)
          return pe;
        if (L >= oe)
          return me;
        var be = oe === ne ? 0 : (L - ne) / (oe - ne);
        if (!pe.length)
          return pe + (me - pe) * be;
        var Ie, Ae = pe.length, rt = createTypedArray("float32", Ae);
        for (Ie = 0; Ie < Ae; Ie += 1)
          rt[Ie] = pe[Ie] + (me[Ie] - pe[Ie]) * be;
        return rt;
      }
      function random(L, ne) {
        if (ne === void 0 && (L === void 0 ? (L = 0, ne = 1) : (ne = L, L = void 0)), ne.length) {
          var oe, pe = ne.length;
          L || (L = createTypedArray("float32", pe));
          var me = createTypedArray("float32", pe), ge = BMMath.random();
          for (oe = 0; oe < pe; oe += 1)
            me[oe] = L[oe] + ge * (ne[oe] - L[oe]);
          return me;
        }
        L === void 0 && (L = 0);
        var be = BMMath.random();
        return L + be * (ne - L);
      }
      function createPath(L, ne, oe, pe) {
        var me, ge = L.length, be = shapePool.newElement();
        be.setPathData(!!pe, ge);
        var Ie = [0, 0], Ae, rt;
        for (me = 0; me < ge; me += 1)
          Ae = ne && ne[me] ? ne[me] : Ie, rt = oe && oe[me] ? oe[me] : Ie, be.setTripleAt(L[me][0], L[me][1], rt[0] + L[me][0], rt[1] + L[me][1], Ae[0] + L[me][0], Ae[1] + L[me][1], me, !0);
        return be;
      }
      function initiateExpression(elem, data, property) {
        function noOp(L) {
          return L;
        }
        if (!elem.globalData.renderConfig.runExpressions)
          return noOp;
        var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
          get: function() {
            return thisProperty.v;
          }
        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
        var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function L(ne, oe) {
          var pe, me, ge = this.pv.length ? this.pv.length : 1, be = createTypedArray("float32", ge);
          ne = 5;
          var Ie = Math.floor(time * ne);
          for (pe = 0, me = 0; pe < Ie; ) {
            for (me = 0; me < ge; me += 1)
              be[me] += -oe + oe * 2 * BMMath.random();
            pe += 1;
          }
          var Ae = time * ne, rt = Ae - Math.floor(Ae), st = createTypedArray("float32", ge);
          if (ge > 1) {
            for (me = 0; me < ge; me += 1)
              st[me] = this.pv[me] + be[me] + (-oe + oe * 2 * BMMath.random()) * rt;
            return st;
          }
          return this.pv + be[0] + (-oe + oe * 2 * BMMath.random()) * rt;
        }).bind(this);
        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
        function loopInDuration(L, ne) {
          return loopIn(L, ne, !0);
        }
        function loopOutDuration(L, ne) {
          return loopOut(L, ne, !0);
        }
        this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
        function lookAt(L, ne) {
          var oe = [ne[0] - L[0], ne[1] - L[1], ne[2] - L[2]], pe = Math.atan2(oe[0], Math.sqrt(oe[1] * oe[1] + oe[2] * oe[2])) / degToRads, me = -Math.atan2(oe[1], oe[2]) / degToRads;
          return [me, pe, 0];
        }
        function easeOut(L, ne, oe, pe, me) {
          return applyEase(easeOutBez, L, ne, oe, pe, me);
        }
        function easeIn(L, ne, oe, pe, me) {
          return applyEase(easeInBez, L, ne, oe, pe, me);
        }
        function ease(L, ne, oe, pe, me) {
          return applyEase(easeInOutBez, L, ne, oe, pe, me);
        }
        function applyEase(L, ne, oe, pe, me, ge) {
          me === void 0 ? (me = oe, ge = pe) : ne = (ne - oe) / (pe - oe), ne > 1 ? ne = 1 : ne < 0 && (ne = 0);
          var be = L(ne);
          if ($bm_isInstanceOfArray(me)) {
            var Ie, Ae = me.length, rt = createTypedArray("float32", Ae);
            for (Ie = 0; Ie < Ae; Ie += 1)
              rt[Ie] = (ge[Ie] - me[Ie]) * be + me[Ie];
            return rt;
          }
          return (ge - me) * be + me;
        }
        function nearestKey(L) {
          var ne, oe = data.k.length, pe, me;
          if (!data.k.length || typeof data.k[0] == "number")
            pe = 0, me = 0;
          else if (pe = -1, L *= elem.comp.globalData.frameRate, L < data.k[0].t)
            pe = 1, me = data.k[0].t;
          else {
            for (ne = 0; ne < oe - 1; ne += 1)
              if (L === data.k[ne].t) {
                pe = ne + 1, me = data.k[ne].t;
                break;
              } else if (L > data.k[ne].t && L < data.k[ne + 1].t) {
                L - data.k[ne].t > data.k[ne + 1].t - L ? (pe = ne + 2, me = data.k[ne + 1].t) : (pe = ne + 1, me = data.k[ne].t);
                break;
              }
            pe === -1 && (pe = ne + 1, me = data.k[ne].t);
          }
          var ge = {};
          return ge.index = pe, ge.time = me / elem.comp.globalData.frameRate, ge;
        }
        function key(L) {
          var ne, oe, pe;
          if (!data.k.length || typeof data.k[0] == "number")
            throw new Error("The property has no keyframe at index " + L);
          L -= 1, ne = {
            time: data.k[L].t / elem.comp.globalData.frameRate,
            value: []
          };
          var me = Object.prototype.hasOwnProperty.call(data.k[L], "s") ? data.k[L].s : data.k[L - 1].e;
          for (pe = me.length, oe = 0; oe < pe; oe += 1)
            ne[oe] = me[oe], ne.value[oe] = me[oe];
          return ne;
        }
        function framesToTime(L, ne) {
          return ne || (ne = elem.comp.globalData.frameRate), L / ne;
        }
        function timeToFrames(L, ne) {
          return !L && L !== 0 && (L = time), ne || (ne = elem.comp.globalData.frameRate), L * ne;
        }
        function seedRandom(L) {
          BMMath.seedrandom(randSeed + L);
        }
        function sourceRectAtTime() {
          return elem.sourceRectAtTime();
        }
        function substring(L, ne) {
          return typeof value == "string" ? ne === void 0 ? value.substring(L) : value.substring(L, ne) : "";
        }
        function substr(L, ne) {
          return typeof value == "string" ? ne === void 0 ? value.substr(L) : value.substr(L, ne) : "";
        }
        function posterizeTime(L) {
          time = L === 0 ? 0 : Math.floor(time * L) / L, value = valueAtTime(time);
        }
        var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
        function executeExpression(L) {
          return value = L, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt);
        }
        return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression;
      }
      return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob;
    }(), Expressions = function() {
      var L = {};
      L.initExpressions = ne, L.resetFrame = ExpressionManager.resetFrame;
      function ne(oe) {
        var pe = 0, me = [];
        function ge() {
          pe += 1;
        }
        function be() {
          pe -= 1, pe === 0 && Ae();
        }
        function Ie(rt) {
          me.indexOf(rt) === -1 && me.push(rt);
        }
        function Ae() {
          var rt, st = me.length;
          for (rt = 0; rt < st; rt += 1)
            me[rt].release();
          me.length = 0;
        }
        oe.renderer.compInterface = CompExpressionInterface(oe.renderer), oe.renderer.globalData.projectInterface.registerComposition(oe.renderer), oe.renderer.globalData.pushExpression = ge, oe.renderer.globalData.popExpression = be, oe.renderer.globalData.registerExpressionProperty = Ie;
      }
      return L;
    }(), MaskManagerInterface = function() {
      function L(oe, pe) {
        this._mask = oe, this._data = pe;
      }
      Object.defineProperty(L.prototype, "maskPath", {
        get: function() {
          return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop;
        }
      }), Object.defineProperty(L.prototype, "maskOpacity", {
        get: function() {
          return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100;
        }
      });
      var ne = function(pe) {
        var me = createSizedArray(pe.viewData.length), ge, be = pe.viewData.length;
        for (ge = 0; ge < be; ge += 1)
          me[ge] = new L(pe.viewData[ge], pe.masksProperties[ge]);
        var Ie = function(rt) {
          for (ge = 0; ge < be; ) {
            if (pe.masksProperties[ge].nm === rt)
              return me[ge];
            ge += 1;
          }
          return null;
        };
        return Ie;
      };
      return ne;
    }(), ExpressionPropertyInterface = /* @__PURE__ */ function() {
      var L = {
        pv: 0,
        v: 0,
        mult: 1
      }, ne = {
        pv: [0, 0, 0],
        v: [0, 0, 0],
        mult: 1
      };
      function oe(be, Ie, Ae) {
        Object.defineProperty(be, "velocity", {
          get: function() {
            return Ie.getVelocityAtTime(Ie.comp.currentFrame);
          }
        }), be.numKeys = Ie.keyframes ? Ie.keyframes.length : 0, be.key = function(rt) {
          if (!be.numKeys)
            return 0;
          var st = "";
          "s" in Ie.keyframes[rt - 1] ? st = Ie.keyframes[rt - 1].s : "e" in Ie.keyframes[rt - 2] ? st = Ie.keyframes[rt - 2].e : st = Ie.keyframes[rt - 2].s;
          var dt = Ae === "unidimensional" ? new Number(st) : Object.assign({}, st);
          return dt.time = Ie.keyframes[rt - 1].t / Ie.elem.comp.globalData.frameRate, dt.value = Ae === "unidimensional" ? st[0] : st, dt;
        }, be.valueAtTime = Ie.getValueAtTime, be.speedAtTime = Ie.getSpeedAtTime, be.velocityAtTime = Ie.getVelocityAtTime, be.propertyGroup = Ie.propertyGroup;
      }
      function pe(be) {
        (!be || !("pv" in be)) && (be = L);
        var Ie = 1 / be.mult, Ae = be.pv * Ie, rt = new Number(Ae);
        return rt.value = Ae, oe(rt, be, "unidimensional"), function() {
          return be.k && be.getValue(), Ae = be.v * Ie, rt.value !== Ae && (rt = new Number(Ae), rt.value = Ae, oe(rt, be, "unidimensional")), rt;
        };
      }
      function me(be) {
        (!be || !("pv" in be)) && (be = ne);
        var Ie = 1 / be.mult, Ae = be.data && be.data.l || be.pv.length, rt = createTypedArray("float32", Ae), st = createTypedArray("float32", Ae);
        return rt.value = st, oe(rt, be, "multidimensional"), function() {
          be.k && be.getValue();
          for (var dt = 0; dt < Ae; dt += 1)
            st[dt] = be.v[dt] * Ie, rt[dt] = st[dt];
          return rt;
        };
      }
      function ge() {
        return L;
      }
      return function(be) {
        return be ? be.propType === "unidimensional" ? pe(be) : me(be) : ge;
      };
    }(), TransformExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        function ne(be) {
          switch (be) {
            case "scale":
            case "Scale":
            case "ADBE Scale":
            case 6:
              return ne.scale;
            case "rotation":
            case "Rotation":
            case "ADBE Rotation":
            case "ADBE Rotate Z":
            case 10:
              return ne.rotation;
            case "ADBE Rotate X":
              return ne.xRotation;
            case "ADBE Rotate Y":
              return ne.yRotation;
            case "position":
            case "Position":
            case "ADBE Position":
            case 2:
              return ne.position;
            case "ADBE Position_0":
              return ne.xPosition;
            case "ADBE Position_1":
              return ne.yPosition;
            case "ADBE Position_2":
              return ne.zPosition;
            case "anchorPoint":
            case "AnchorPoint":
            case "Anchor Point":
            case "ADBE AnchorPoint":
            case 1:
              return ne.anchorPoint;
            case "opacity":
            case "Opacity":
            case 11:
              return ne.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(ne, "rotation", {
          get: ExpressionPropertyInterface(L.r || L.rz)
        }), Object.defineProperty(ne, "zRotation", {
          get: ExpressionPropertyInterface(L.rz || L.r)
        }), Object.defineProperty(ne, "xRotation", {
          get: ExpressionPropertyInterface(L.rx)
        }), Object.defineProperty(ne, "yRotation", {
          get: ExpressionPropertyInterface(L.ry)
        }), Object.defineProperty(ne, "scale", {
          get: ExpressionPropertyInterface(L.s)
        });
        var oe, pe, me, ge;
        return L.p ? ge = ExpressionPropertyInterface(L.p) : (oe = ExpressionPropertyInterface(L.px), pe = ExpressionPropertyInterface(L.py), L.pz && (me = ExpressionPropertyInterface(L.pz))), Object.defineProperty(ne, "position", {
          get: function() {
            return L.p ? ge() : [oe(), pe(), me ? me() : 0];
          }
        }), Object.defineProperty(ne, "xPosition", {
          get: ExpressionPropertyInterface(L.px)
        }), Object.defineProperty(ne, "yPosition", {
          get: ExpressionPropertyInterface(L.py)
        }), Object.defineProperty(ne, "zPosition", {
          get: ExpressionPropertyInterface(L.pz)
        }), Object.defineProperty(ne, "anchorPoint", {
          get: ExpressionPropertyInterface(L.a)
        }), Object.defineProperty(ne, "opacity", {
          get: ExpressionPropertyInterface(L.o)
        }), Object.defineProperty(ne, "skew", {
          get: ExpressionPropertyInterface(L.sk)
        }), Object.defineProperty(ne, "skewAxis", {
          get: ExpressionPropertyInterface(L.sa)
        }), Object.defineProperty(ne, "orientation", {
          get: ExpressionPropertyInterface(L.or)
        }), ne;
      };
    }(), LayerExpressionInterface = /* @__PURE__ */ function() {
      function L(rt) {
        var st = new Matrix();
        if (rt !== void 0) {
          var dt = this._elem.finalTransform.mProp.getValueAtTime(rt);
          dt.clone(st);
        } else {
          var lt = this._elem.finalTransform.mProp;
          lt.applyToMatrix(st);
        }
        return st;
      }
      function ne(rt, st) {
        var dt = this.getMatrix(st);
        return dt.props[12] = 0, dt.props[13] = 0, dt.props[14] = 0, this.applyPoint(dt, rt);
      }
      function oe(rt, st) {
        var dt = this.getMatrix(st);
        return this.applyPoint(dt, rt);
      }
      function pe(rt, st) {
        var dt = this.getMatrix(st);
        return dt.props[12] = 0, dt.props[13] = 0, dt.props[14] = 0, this.invertPoint(dt, rt);
      }
      function me(rt, st) {
        var dt = this.getMatrix(st);
        return this.invertPoint(dt, rt);
      }
      function ge(rt, st) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, lt = this._elem.hierarchy.length;
          for (dt = 0; dt < lt; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(rt);
        }
        return rt.applyToPointArray(st[0], st[1], st[2] || 0);
      }
      function be(rt, st) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, lt = this._elem.hierarchy.length;
          for (dt = 0; dt < lt; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(rt);
        }
        return rt.inversePoint(st);
      }
      function Ie(rt) {
        var st = new Matrix();
        if (st.reset(), this._elem.finalTransform.mProp.applyToMatrix(st), this._elem.hierarchy && this._elem.hierarchy.length) {
          var dt, lt = this._elem.hierarchy.length;
          for (dt = 0; dt < lt; dt += 1)
            this._elem.hierarchy[dt].finalTransform.mProp.applyToMatrix(st);
          return st.inversePoint(rt);
        }
        return st.inversePoint(rt);
      }
      function Ae() {
        return [1, 1, 1, 1];
      }
      return function(rt) {
        var st;
        function dt(ut) {
          pt.mask = new MaskManagerInterface(ut, rt);
        }
        function lt(ut) {
          pt.effect = ut;
        }
        function pt(ut) {
          switch (ut) {
            case "ADBE Root Vectors Group":
            case "Contents":
            case 2:
              return pt.shapeInterface;
            case 1:
            case 6:
            case "Transform":
            case "transform":
            case "ADBE Transform Group":
              return st;
            case 4:
            case "ADBE Effect Parade":
            case "effects":
            case "Effects":
              return pt.effect;
            case "ADBE Text Properties":
              return pt.textInterface;
            default:
              return null;
          }
        }
        pt.getMatrix = L, pt.invertPoint = be, pt.applyPoint = ge, pt.toWorld = oe, pt.toWorldVec = ne, pt.fromWorld = me, pt.fromWorldVec = pe, pt.toComp = oe, pt.fromComp = Ie, pt.sampleImage = Ae, pt.sourceRectAtTime = rt.sourceRectAtTime.bind(rt), pt._elem = rt, st = TransformExpressionInterface(rt.finalTransform.mProp);
        var it = getDescriptor(st, "anchorPoint");
        return Object.defineProperties(pt, {
          hasParent: {
            get: function() {
              return rt.hierarchy.length;
            }
          },
          parent: {
            get: function() {
              return rt.hierarchy[0].layerInterface;
            }
          },
          rotation: getDescriptor(st, "rotation"),
          scale: getDescriptor(st, "scale"),
          position: getDescriptor(st, "position"),
          opacity: getDescriptor(st, "opacity"),
          anchorPoint: it,
          anchor_point: it,
          transform: {
            get: function() {
              return st;
            }
          },
          active: {
            get: function() {
              return rt.isInRange;
            }
          }
        }), pt.startTime = rt.data.st, pt.index = rt.data.ind, pt.source = rt.data.refId, pt.height = rt.data.ty === 0 ? rt.data.h : 100, pt.width = rt.data.ty === 0 ? rt.data.w : 100, pt.inPoint = rt.data.ip / rt.comp.globalData.frameRate, pt.outPoint = rt.data.op / rt.comp.globalData.frameRate, pt._name = rt.data.nm, pt.registerMaskInterface = dt, pt.registerEffectsInterface = lt, pt;
      };
    }(), propertyGroupFactory = /* @__PURE__ */ function() {
      return function(L, ne) {
        return function(oe) {
          return oe = oe === void 0 ? 1 : oe, oe <= 0 ? L : ne(oe - 1);
        };
      };
    }(), PropertyInterface = /* @__PURE__ */ function() {
      return function(L, ne) {
        var oe = {
          _name: L
        };
        function pe(me) {
          return me = me === void 0 ? 1 : me, me <= 0 ? oe : ne(me - 1);
        }
        return pe;
      };
    }(), EffectsExpressionInterface = /* @__PURE__ */ function() {
      var L = {
        createEffectsInterface: ne
      };
      function ne(me, ge) {
        if (me.effectsManager) {
          var be = [], Ie = me.data.ef, Ae, rt = me.effectsManager.effectElements.length;
          for (Ae = 0; Ae < rt; Ae += 1)
            be.push(oe(Ie[Ae], me.effectsManager.effectElements[Ae], ge, me));
          var st = me.data.ef || [], dt = function(pt) {
            for (Ae = 0, rt = st.length; Ae < rt; ) {
              if (pt === st[Ae].nm || pt === st[Ae].mn || pt === st[Ae].ix)
                return be[Ae];
              Ae += 1;
            }
            return null;
          };
          return Object.defineProperty(dt, "numProperties", {
            get: function() {
              return st.length;
            }
          }), dt;
        }
        return null;
      }
      function oe(me, ge, be, Ie) {
        function Ae(pt) {
          for (var it = me.ef, ut = 0, St = it.length; ut < St; ) {
            if (pt === it[ut].nm || pt === it[ut].mn || pt === it[ut].ix)
              return it[ut].ty === 5 ? st[ut] : st[ut]();
            ut += 1;
          }
          throw new Error();
        }
        var rt = propertyGroupFactory(Ae, be), st = [], dt, lt = me.ef.length;
        for (dt = 0; dt < lt; dt += 1)
          me.ef[dt].ty === 5 ? st.push(oe(me.ef[dt], ge.effectElements[dt], ge.effectElements[dt].propertyGroup, Ie)) : st.push(pe(ge.effectElements[dt], me.ef[dt].ty, Ie, rt));
        return me.mn === "ADBE Color Control" && Object.defineProperty(Ae, "color", {
          get: function() {
            return st[0]();
          }
        }), Object.defineProperties(Ae, {
          numProperties: {
            get: function() {
              return me.np;
            }
          },
          _name: {
            value: me.nm
          },
          propertyGroup: {
            value: rt
          }
        }), Ae.enabled = me.en !== 0, Ae.active = Ae.enabled, Ae;
      }
      function pe(me, ge, be, Ie) {
        var Ae = ExpressionPropertyInterface(me.p);
        function rt() {
          return ge === 10 ? be.comp.compInterface(me.p.v) : Ae();
        }
        return me.p.setGroupProperty && me.p.setGroupProperty(PropertyInterface("", Ie)), rt;
      }
      return L;
    }(), ShapePathInterface = /* @__PURE__ */ function() {
      return function(ne, oe, pe) {
        var me = oe.sh;
        function ge(Ie) {
          return Ie === "Shape" || Ie === "shape" || Ie === "Path" || Ie === "path" || Ie === "ADBE Vector Shape" || Ie === 2 ? ge.path : null;
        }
        var be = propertyGroupFactory(ge, pe);
        return me.setGroupProperty(PropertyInterface("Path", be)), Object.defineProperties(ge, {
          path: {
            get: function() {
              return me.k && me.getValue(), me;
            }
          },
          shape: {
            get: function() {
              return me.k && me.getValue(), me;
            }
          },
          _name: {
            value: ne.nm
          },
          ix: {
            value: ne.ix
          },
          propertyIndex: {
            value: ne.ix
          },
          mn: {
            value: ne.mn
          },
          propertyGroup: {
            value: pe
          }
        }), ge;
      };
    }(), ShapeExpressionInterface = /* @__PURE__ */ function() {
      function L(it, ut, St) {
        var ot = [], ht, ft = it ? it.length : 0;
        for (ht = 0; ht < ft; ht += 1)
          it[ht].ty === "gr" ? ot.push(oe(it[ht], ut[ht], St)) : it[ht].ty === "fl" ? ot.push(pe(it[ht], ut[ht], St)) : it[ht].ty === "st" ? ot.push(be(it[ht], ut[ht], St)) : it[ht].ty === "tm" ? ot.push(Ie(it[ht], ut[ht], St)) : it[ht].ty === "tr" || (it[ht].ty === "el" ? ot.push(rt(it[ht], ut[ht], St)) : it[ht].ty === "sr" ? ot.push(st(it[ht], ut[ht], St)) : it[ht].ty === "sh" ? ot.push(ShapePathInterface(it[ht], ut[ht], St)) : it[ht].ty === "rc" ? ot.push(dt(it[ht], ut[ht], St)) : it[ht].ty === "rd" ? ot.push(lt(it[ht], ut[ht], St)) : it[ht].ty === "rp" ? ot.push(pt(it[ht], ut[ht], St)) : it[ht].ty === "gf" ? ot.push(me(it[ht], ut[ht], St)) : ot.push(ge(it[ht], ut[ht])));
        return ot;
      }
      function ne(it, ut, St) {
        var ot, ht = function(Ct) {
          for (var xt = 0, At = ot.length; xt < At; ) {
            if (ot[xt]._name === Ct || ot[xt].mn === Ct || ot[xt].propertyIndex === Ct || ot[xt].ix === Ct || ot[xt].ind === Ct)
              return ot[xt];
            xt += 1;
          }
          return typeof Ct == "number" ? ot[Ct - 1] : null;
        };
        ht.propertyGroup = propertyGroupFactory(ht, St), ot = L(it.it, ut.it, ht.propertyGroup), ht.numProperties = ot.length;
        var ft = Ae(it.it[it.it.length - 1], ut.it[ut.it.length - 1], ht.propertyGroup);
        return ht.transform = ft, ht.propertyIndex = it.cix, ht._name = it.nm, ht;
      }
      function oe(it, ut, St) {
        var ot = function(Ct) {
          switch (Ct) {
            case "ADBE Vectors Group":
            case "Contents":
            case 2:
              return ot.content;
            default:
              return ot.transform;
          }
        };
        ot.propertyGroup = propertyGroupFactory(ot, St);
        var ht = ne(it, ut, ot.propertyGroup), ft = Ae(it.it[it.it.length - 1], ut.it[ut.it.length - 1], ot.propertyGroup);
        return ot.content = ht, ot.transform = ft, Object.defineProperty(ot, "_name", {
          get: function() {
            return it.nm;
          }
        }), ot.numProperties = it.np, ot.propertyIndex = it.ix, ot.nm = it.nm, ot.mn = it.mn, ot;
      }
      function pe(it, ut, St) {
        function ot(ht) {
          return ht === "Color" || ht === "color" ? ot.color : ht === "Opacity" || ht === "opacity" ? ot.opacity : null;
        }
        return Object.defineProperties(ot, {
          color: {
            get: ExpressionPropertyInterface(ut.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(ut.o)
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), ut.c.setGroupProperty(PropertyInterface("Color", St)), ut.o.setGroupProperty(PropertyInterface("Opacity", St)), ot;
      }
      function me(it, ut, St) {
        function ot(ht) {
          return ht === "Start Point" || ht === "start point" ? ot.startPoint : ht === "End Point" || ht === "end point" ? ot.endPoint : ht === "Opacity" || ht === "opacity" ? ot.opacity : null;
        }
        return Object.defineProperties(ot, {
          startPoint: {
            get: ExpressionPropertyInterface(ut.s)
          },
          endPoint: {
            get: ExpressionPropertyInterface(ut.e)
          },
          opacity: {
            get: ExpressionPropertyInterface(ut.o)
          },
          type: {
            get: function() {
              return "a";
            }
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), ut.s.setGroupProperty(PropertyInterface("Start Point", St)), ut.e.setGroupProperty(PropertyInterface("End Point", St)), ut.o.setGroupProperty(PropertyInterface("Opacity", St)), ot;
      }
      function ge() {
        function it() {
          return null;
        }
        return it;
      }
      function be(it, ut, St) {
        var ot = propertyGroupFactory(At, St), ht = propertyGroupFactory(xt, ot);
        function ft(kt) {
          Object.defineProperty(xt, it.d[kt].nm, {
            get: ExpressionPropertyInterface(ut.d.dataProps[kt].p)
          });
        }
        var vt, Ct = it.d ? it.d.length : 0, xt = {};
        for (vt = 0; vt < Ct; vt += 1)
          ft(vt), ut.d.dataProps[vt].p.setGroupProperty(ht);
        function At(kt) {
          return kt === "Color" || kt === "color" ? At.color : kt === "Opacity" || kt === "opacity" ? At.opacity : kt === "Stroke Width" || kt === "stroke width" ? At.strokeWidth : null;
        }
        return Object.defineProperties(At, {
          color: {
            get: ExpressionPropertyInterface(ut.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(ut.o)
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(ut.w)
          },
          dash: {
            get: function() {
              return xt;
            }
          },
          _name: {
            value: it.nm
          },
          mn: {
            value: it.mn
          }
        }), ut.c.setGroupProperty(PropertyInterface("Color", ot)), ut.o.setGroupProperty(PropertyInterface("Opacity", ot)), ut.w.setGroupProperty(PropertyInterface("Stroke Width", ot)), At;
      }
      function Ie(it, ut, St) {
        function ot(ft) {
          return ft === it.e.ix || ft === "End" || ft === "end" ? ot.end : ft === it.s.ix ? ot.start : ft === it.o.ix ? ot.offset : null;
        }
        var ht = propertyGroupFactory(ot, St);
        return ot.propertyIndex = it.ix, ut.s.setGroupProperty(PropertyInterface("Start", ht)), ut.e.setGroupProperty(PropertyInterface("End", ht)), ut.o.setGroupProperty(PropertyInterface("Offset", ht)), ot.propertyIndex = it.ix, ot.propertyGroup = St, Object.defineProperties(ot, {
          start: {
            get: ExpressionPropertyInterface(ut.s)
          },
          end: {
            get: ExpressionPropertyInterface(ut.e)
          },
          offset: {
            get: ExpressionPropertyInterface(ut.o)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function Ae(it, ut, St) {
        function ot(ft) {
          return it.a.ix === ft || ft === "Anchor Point" ? ot.anchorPoint : it.o.ix === ft || ft === "Opacity" ? ot.opacity : it.p.ix === ft || ft === "Position" ? ot.position : it.r.ix === ft || ft === "Rotation" || ft === "ADBE Vector Rotation" ? ot.rotation : it.s.ix === ft || ft === "Scale" ? ot.scale : it.sk && it.sk.ix === ft || ft === "Skew" ? ot.skew : it.sa && it.sa.ix === ft || ft === "Skew Axis" ? ot.skewAxis : null;
        }
        var ht = propertyGroupFactory(ot, St);
        return ut.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", ht)), ut.transform.mProps.p.setGroupProperty(PropertyInterface("Position", ht)), ut.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", ht)), ut.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", ht)), ut.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", ht)), ut.transform.mProps.sk && (ut.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", ht)), ut.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", ht))), ut.transform.op.setGroupProperty(PropertyInterface("Opacity", ht)), Object.defineProperties(ot, {
          opacity: {
            get: ExpressionPropertyInterface(ut.transform.mProps.o)
          },
          position: {
            get: ExpressionPropertyInterface(ut.transform.mProps.p)
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(ut.transform.mProps.a)
          },
          scale: {
            get: ExpressionPropertyInterface(ut.transform.mProps.s)
          },
          rotation: {
            get: ExpressionPropertyInterface(ut.transform.mProps.r)
          },
          skew: {
            get: ExpressionPropertyInterface(ut.transform.mProps.sk)
          },
          skewAxis: {
            get: ExpressionPropertyInterface(ut.transform.mProps.sa)
          },
          _name: {
            value: it.nm
          }
        }), ot.ty = "tr", ot.mn = it.mn, ot.propertyGroup = St, ot;
      }
      function rt(it, ut, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.s.ix === vt ? ot.size : null;
        }
        var ht = propertyGroupFactory(ot, St);
        ot.propertyIndex = it.ix;
        var ft = ut.sh.ty === "tm" ? ut.sh.prop : ut.sh;
        return ft.s.setGroupProperty(PropertyInterface("Size", ht)), ft.p.setGroupProperty(PropertyInterface("Position", ht)), Object.defineProperties(ot, {
          size: {
            get: ExpressionPropertyInterface(ft.s)
          },
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function st(it, ut, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.r.ix === vt ? ot.rotation : it.pt.ix === vt ? ot.points : it.or.ix === vt || vt === "ADBE Vector Star Outer Radius" ? ot.outerRadius : it.os.ix === vt ? ot.outerRoundness : it.ir && (it.ir.ix === vt || vt === "ADBE Vector Star Inner Radius") ? ot.innerRadius : it.is && it.is.ix === vt ? ot.innerRoundness : null;
        }
        var ht = propertyGroupFactory(ot, St), ft = ut.sh.ty === "tm" ? ut.sh.prop : ut.sh;
        return ot.propertyIndex = it.ix, ft.or.setGroupProperty(PropertyInterface("Outer Radius", ht)), ft.os.setGroupProperty(PropertyInterface("Outer Roundness", ht)), ft.pt.setGroupProperty(PropertyInterface("Points", ht)), ft.p.setGroupProperty(PropertyInterface("Position", ht)), ft.r.setGroupProperty(PropertyInterface("Rotation", ht)), it.ir && (ft.ir.setGroupProperty(PropertyInterface("Inner Radius", ht)), ft.is.setGroupProperty(PropertyInterface("Inner Roundness", ht))), Object.defineProperties(ot, {
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          rotation: {
            get: ExpressionPropertyInterface(ft.r)
          },
          points: {
            get: ExpressionPropertyInterface(ft.pt)
          },
          outerRadius: {
            get: ExpressionPropertyInterface(ft.or)
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(ft.os)
          },
          innerRadius: {
            get: ExpressionPropertyInterface(ft.ir)
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(ft.is)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function dt(it, ut, St) {
        function ot(vt) {
          return it.p.ix === vt ? ot.position : it.r.ix === vt ? ot.roundness : it.s.ix === vt || vt === "Size" || vt === "ADBE Vector Rect Size" ? ot.size : null;
        }
        var ht = propertyGroupFactory(ot, St), ft = ut.sh.ty === "tm" ? ut.sh.prop : ut.sh;
        return ot.propertyIndex = it.ix, ft.p.setGroupProperty(PropertyInterface("Position", ht)), ft.s.setGroupProperty(PropertyInterface("Size", ht)), ft.r.setGroupProperty(PropertyInterface("Rotation", ht)), Object.defineProperties(ot, {
          position: {
            get: ExpressionPropertyInterface(ft.p)
          },
          roundness: {
            get: ExpressionPropertyInterface(ft.r)
          },
          size: {
            get: ExpressionPropertyInterface(ft.s)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function lt(it, ut, St) {
        function ot(vt) {
          return it.r.ix === vt || vt === "Round Corners 1" ? ot.radius : null;
        }
        var ht = propertyGroupFactory(ot, St), ft = ut;
        return ot.propertyIndex = it.ix, ft.rd.setGroupProperty(PropertyInterface("Radius", ht)), Object.defineProperties(ot, {
          radius: {
            get: ExpressionPropertyInterface(ft.rd)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      function pt(it, ut, St) {
        function ot(vt) {
          return it.c.ix === vt || vt === "Copies" ? ot.copies : it.o.ix === vt || vt === "Offset" ? ot.offset : null;
        }
        var ht = propertyGroupFactory(ot, St), ft = ut;
        return ot.propertyIndex = it.ix, ft.c.setGroupProperty(PropertyInterface("Copies", ht)), ft.o.setGroupProperty(PropertyInterface("Offset", ht)), Object.defineProperties(ot, {
          copies: {
            get: ExpressionPropertyInterface(ft.c)
          },
          offset: {
            get: ExpressionPropertyInterface(ft.o)
          },
          _name: {
            value: it.nm
          }
        }), ot.mn = it.mn, ot;
      }
      return function(it, ut, St) {
        var ot;
        function ht(vt) {
          if (typeof vt == "number")
            return vt = vt === void 0 ? 1 : vt, vt === 0 ? St : ot[vt - 1];
          for (var Ct = 0, xt = ot.length; Ct < xt; ) {
            if (ot[Ct]._name === vt)
              return ot[Ct];
            Ct += 1;
          }
          return null;
        }
        function ft() {
          return St;
        }
        return ht.propertyGroup = propertyGroupFactory(ht, ft), ot = L(it, ut, ht.propertyGroup), ht.numProperties = ot.length, ht._name = "Contents", ht;
      };
    }(), TextExpressionInterface = /* @__PURE__ */ function() {
      return function(L) {
        var ne;
        function oe(pe) {
          switch (pe) {
            case "ADBE Text Document":
              return oe.sourceText;
            default:
              return null;
          }
        }
        return Object.defineProperty(oe, "sourceText", {
          get: function() {
            L.textProperty.getValue();
            var me = L.textProperty.currentData.t;
            return (!ne || me !== ne.value) && (ne = new String(me), ne.value = me || new String(me), Object.defineProperty(ne, "style", {
              get: function() {
                return {
                  fillColor: L.textProperty.currentData.fc
                };
              }
            })), ne;
          }
        }), oe;
      };
    }();
    function _typeof(L) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(oe) {
        return typeof oe;
      } : _typeof = function(oe) {
        return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
      }, _typeof(L);
    }
    var FootageInterface = /* @__PURE__ */ function() {
      var L = function(pe) {
        var me = "", ge = pe.getFootageData();
        function be() {
          return me = "", ge = pe.getFootageData(), Ie;
        }
        function Ie(Ae) {
          if (ge[Ae])
            return me = Ae, ge = ge[Ae], _typeof(ge) === "object" ? Ie : ge;
          var rt = Ae.indexOf(me);
          if (rt !== -1) {
            var st = parseInt(Ae.substr(rt + me.length), 10);
            return ge = ge[st], _typeof(ge) === "object" ? Ie : ge;
          }
          return "";
        }
        return be;
      }, ne = function(pe) {
        function me(ge) {
          return ge === "Outline" ? me.outlineInterface() : null;
        }
        return me._name = "Outline", me.outlineInterface = L(pe), me;
      };
      return function(oe) {
        function pe(me) {
          return me === "Data" ? pe.dataInterface : null;
        }
        return pe._name = "Data", pe.dataInterface = ne(oe), pe;
      };
    }(), interfaces = {
      layer: LayerExpressionInterface,
      effects: EffectsExpressionInterface,
      comp: CompExpressionInterface,
      shape: ShapeExpressionInterface,
      text: TextExpressionInterface,
      footage: FootageInterface
    };
    function getInterface(L) {
      return interfaces[L] || null;
    }
    var expressionHelpers = /* @__PURE__ */ function() {
      function L(be, Ie, Ae) {
        Ie.x && (Ae.k = !0, Ae.x = !0, Ae.initiateExpression = ExpressionManager.initiateExpression, Ae.effectsSequence.push(Ae.initiateExpression(be, Ie, Ae).bind(Ae)));
      }
      function ne(be) {
        return be *= this.elem.globalData.frameRate, be -= this.offsetTime, be !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < be ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(be, this._cachingAtTime), this._cachingAtTime.lastFrame = be), this._cachingAtTime.value;
      }
      function oe(be) {
        var Ie = -0.01, Ae = this.getValueAtTime(be), rt = this.getValueAtTime(be + Ie), st = 0;
        if (Ae.length) {
          var dt;
          for (dt = 0; dt < Ae.length; dt += 1)
            st += Math.pow(rt[dt] - Ae[dt], 2);
          st = Math.sqrt(st) * 100;
        } else
          st = 0;
        return st;
      }
      function pe(be) {
        if (this.vel !== void 0)
          return this.vel;
        var Ie = -1e-3, Ae = this.getValueAtTime(be), rt = this.getValueAtTime(be + Ie), st;
        if (Ae.length) {
          st = createTypedArray("float32", Ae.length);
          var dt;
          for (dt = 0; dt < Ae.length; dt += 1)
            st[dt] = (rt[dt] - Ae[dt]) / Ie;
        } else
          st = (rt - Ae) / Ie;
        return st;
      }
      function me() {
        return this.pv;
      }
      function ge(be) {
        this.propertyGroup = be;
      }
      return {
        searchExpressions: L,
        getSpeedAtTime: oe,
        getVelocityAtTime: pe,
        getValueAtTime: ne,
        getStaticValueAtTime: me,
        setGroupProperty: ge
      };
    }();
    function addPropertyDecorator() {
      function L(lt, pt, it) {
        if (!this.k || !this.keyframes)
          return this.pv;
        lt = lt ? lt.toLowerCase() : "";
        var ut = this.comp.renderedFrame, St = this.keyframes, ot = St[St.length - 1].t;
        if (ut <= ot)
          return this.pv;
        var ht, ft;
        it ? (pt ? ht = Math.abs(ot - this.elem.comp.globalData.frameRate * pt) : ht = Math.max(0, ot - this.elem.data.ip), ft = ot - ht) : ((!pt || pt > St.length - 1) && (pt = St.length - 1), ft = St[St.length - 1 - pt].t, ht = ot - ft);
        var vt, Ct, xt;
        if (lt === "pingpong") {
          var At = Math.floor((ut - ft) / ht);
          if (At % 2 !== 0)
            return this.getValueAtTime((ht - (ut - ft) % ht + ft) / this.comp.globalData.frameRate, 0);
        } else if (lt === "offset") {
          var kt = this.getValueAtTime(ft / this.comp.globalData.frameRate, 0), Vt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), ir = this.getValueAtTime(((ut - ft) % ht + ft) / this.comp.globalData.frameRate, 0), er = Math.floor((ut - ft) / ht);
          if (this.pv.length) {
            for (xt = new Array(kt.length), Ct = xt.length, vt = 0; vt < Ct; vt += 1)
              xt[vt] = (Vt[vt] - kt[vt]) * er + ir[vt];
            return xt;
          }
          return (Vt - kt) * er + ir;
        } else if (lt === "continue") {
          var Yt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Jt = this.getValueAtTime((ot - 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (xt = new Array(Yt.length), Ct = xt.length, vt = 0; vt < Ct; vt += 1)
              xt[vt] = Yt[vt] + (Yt[vt] - Jt[vt]) * ((ut - ot) / this.comp.globalData.frameRate) / 5e-4;
            return xt;
          }
          return Yt + (Yt - Jt) * ((ut - ot) / 1e-3);
        }
        return this.getValueAtTime(((ut - ft) % ht + ft) / this.comp.globalData.frameRate, 0);
      }
      function ne(lt, pt, it) {
        if (!this.k)
          return this.pv;
        lt = lt ? lt.toLowerCase() : "";
        var ut = this.comp.renderedFrame, St = this.keyframes, ot = St[0].t;
        if (ut >= ot)
          return this.pv;
        var ht, ft;
        it ? (pt ? ht = Math.abs(this.elem.comp.globalData.frameRate * pt) : ht = Math.max(0, this.elem.data.op - ot), ft = ot + ht) : ((!pt || pt > St.length - 1) && (pt = St.length - 1), ft = St[pt].t, ht = ft - ot);
        var vt, Ct, xt;
        if (lt === "pingpong") {
          var At = Math.floor((ot - ut) / ht);
          if (At % 2 === 0)
            return this.getValueAtTime(((ot - ut) % ht + ot) / this.comp.globalData.frameRate, 0);
        } else if (lt === "offset") {
          var kt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Vt = this.getValueAtTime(ft / this.comp.globalData.frameRate, 0), ir = this.getValueAtTime((ht - (ot - ut) % ht + ot) / this.comp.globalData.frameRate, 0), er = Math.floor((ot - ut) / ht) + 1;
          if (this.pv.length) {
            for (xt = new Array(kt.length), Ct = xt.length, vt = 0; vt < Ct; vt += 1)
              xt[vt] = ir[vt] - (Vt[vt] - kt[vt]) * er;
            return xt;
          }
          return ir - (Vt - kt) * er;
        } else if (lt === "continue") {
          var Yt = this.getValueAtTime(ot / this.comp.globalData.frameRate, 0), Jt = this.getValueAtTime((ot + 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (xt = new Array(Yt.length), Ct = xt.length, vt = 0; vt < Ct; vt += 1)
              xt[vt] = Yt[vt] + (Yt[vt] - Jt[vt]) * (ot - ut) / 1e-3;
            return xt;
          }
          return Yt + (Yt - Jt) * (ot - ut) / 1e-3;
        }
        return this.getValueAtTime((ht - ((ot - ut) % ht + ot)) / this.comp.globalData.frameRate, 0);
      }
      function oe(lt, pt) {
        if (!this.k)
          return this.pv;
        if (lt = (lt || 0.4) * 0.5, pt = Math.floor(pt || 5), pt <= 1)
          return this.pv;
        var it = this.comp.renderedFrame / this.comp.globalData.frameRate, ut = it - lt, St = it + lt, ot = pt > 1 ? (St - ut) / (pt - 1) : 1, ht = 0, ft = 0, vt;
        this.pv.length ? vt = createTypedArray("float32", this.pv.length) : vt = 0;
        for (var Ct; ht < pt; ) {
          if (Ct = this.getValueAtTime(ut + ht * ot), this.pv.length)
            for (ft = 0; ft < this.pv.length; ft += 1)
              vt[ft] += Ct[ft];
          else
            vt += Ct;
          ht += 1;
        }
        if (this.pv.length)
          for (ft = 0; ft < this.pv.length; ft += 1)
            vt[ft] /= pt;
        else
          vt /= pt;
        return vt;
      }
      function pe(lt) {
        this._transformCachingAtTime || (this._transformCachingAtTime = {
          v: new Matrix()
        });
        var pt = this._transformCachingAtTime.v;
        if (pt.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
          var it = this.a.getValueAtTime(lt);
          pt.translate(-it[0] * this.a.mult, -it[1] * this.a.mult, it[2] * this.a.mult);
        }
        if (this.appliedTransformations < 2) {
          var ut = this.s.getValueAtTime(lt);
          pt.scale(ut[0] * this.s.mult, ut[1] * this.s.mult, ut[2] * this.s.mult);
        }
        if (this.sk && this.appliedTransformations < 3) {
          var St = this.sk.getValueAtTime(lt), ot = this.sa.getValueAtTime(lt);
          pt.skewFromAxis(-St * this.sk.mult, ot * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var ht = this.r.getValueAtTime(lt);
          pt.rotate(-ht * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var ft = this.rz.getValueAtTime(lt), vt = this.ry.getValueAtTime(lt), Ct = this.rx.getValueAtTime(lt), xt = this.or.getValueAtTime(lt);
          pt.rotateZ(-ft * this.rz.mult).rotateY(vt * this.ry.mult).rotateX(Ct * this.rx.mult).rotateZ(-xt[2] * this.or.mult).rotateY(xt[1] * this.or.mult).rotateX(xt[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var At = this.px.getValueAtTime(lt), kt = this.py.getValueAtTime(lt);
          if (this.data.p.z) {
            var Vt = this.pz.getValueAtTime(lt);
            pt.translate(At * this.px.mult, kt * this.py.mult, -Vt * this.pz.mult);
          } else
            pt.translate(At * this.px.mult, kt * this.py.mult, 0);
        } else {
          var ir = this.p.getValueAtTime(lt);
          pt.translate(ir[0] * this.p.mult, ir[1] * this.p.mult, -ir[2] * this.p.mult);
        }
        return pt;
      }
      function me() {
        return this.v.clone(new Matrix());
      }
      var ge = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function(lt, pt, it) {
        var ut = ge(lt, pt, it);
        return ut.dynamicProperties.length ? ut.getValueAtTime = pe.bind(ut) : ut.getValueAtTime = me.bind(ut), ut.setGroupProperty = expressionHelpers.setGroupProperty, ut;
      };
      var be = PropertyFactory.getProp;
      PropertyFactory.getProp = function(lt, pt, it, ut, St) {
        var ot = be(lt, pt, it, ut, St);
        ot.kf ? ot.getValueAtTime = expressionHelpers.getValueAtTime.bind(ot) : ot.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(ot), ot.setGroupProperty = expressionHelpers.setGroupProperty, ot.loopOut = L, ot.loopIn = ne, ot.smooth = oe, ot.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(ot), ot.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ot), ot.numKeys = pt.a === 1 ? pt.k.length : 0, ot.propertyIndex = pt.ix;
        var ht = 0;
        return it !== 0 && (ht = createTypedArray("float32", pt.a === 1 ? pt.k[0].s.length : pt.k.length)), ot._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: ht
        }, expressionHelpers.searchExpressions(lt, pt, ot), ot.k && St.addDynamicProperty(ot), ot;
      };
      function Ie(lt) {
        return this._cachingAtTime || (this._cachingAtTime = {
          shapeValue: shapePool.clone(this.pv),
          lastIndex: 0,
          lastTime: initialDefaultFrame
        }), lt *= this.elem.globalData.frameRate, lt -= this.offsetTime, lt !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < lt ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = lt, this.interpolateShape(lt, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue;
      }
      var Ae = ShapePropertyFactory.getConstructorFunction(), rt = ShapePropertyFactory.getKeyframedConstructorFunction();
      function st() {
      }
      st.prototype = {
        vertices: function(pt, it) {
          this.k && this.getValue();
          var ut = this.v;
          it !== void 0 && (ut = this.getValueAtTime(it, 0));
          var St, ot = ut._length, ht = ut[pt], ft = ut.v, vt = createSizedArray(ot);
          for (St = 0; St < ot; St += 1)
            pt === "i" || pt === "o" ? vt[St] = [ht[St][0] - ft[St][0], ht[St][1] - ft[St][1]] : vt[St] = [ht[St][0], ht[St][1]];
          return vt;
        },
        points: function(pt) {
          return this.vertices("v", pt);
        },
        inTangents: function(pt) {
          return this.vertices("i", pt);
        },
        outTangents: function(pt) {
          return this.vertices("o", pt);
        },
        isClosed: function() {
          return this.v.c;
        },
        pointOnPath: function(pt, it) {
          var ut = this.v;
          it !== void 0 && (ut = this.getValueAtTime(it, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(ut));
          for (var St = this._segmentsLength, ot = St.lengths, ht = St.totalLength * pt, ft = 0, vt = ot.length, Ct = 0, xt; ft < vt; ) {
            if (Ct + ot[ft].addedLength > ht) {
              var At = ft, kt = ut.c && ft === vt - 1 ? 0 : ft + 1, Vt = (ht - Ct) / ot[ft].addedLength;
              xt = bez.getPointInSegment(ut.v[At], ut.v[kt], ut.o[At], ut.i[kt], Vt, ot[ft]);
              break;
            } else
              Ct += ot[ft].addedLength;
            ft += 1;
          }
          return xt || (xt = ut.c ? [ut.v[0][0], ut.v[0][1]] : [ut.v[ut._length - 1][0], ut.v[ut._length - 1][1]]), xt;
        },
        vectorOnPath: function(pt, it, ut) {
          pt == 1 ? pt = this.v.c : pt == 0 && (pt = 0.999);
          var St = this.pointOnPath(pt, it), ot = this.pointOnPath(pt + 1e-3, it), ht = ot[0] - St[0], ft = ot[1] - St[1], vt = Math.sqrt(Math.pow(ht, 2) + Math.pow(ft, 2));
          if (vt === 0)
            return [0, 0];
          var Ct = ut === "tangent" ? [ht / vt, ft / vt] : [-ft / vt, ht / vt];
          return Ct;
        },
        tangentOnPath: function(pt, it) {
          return this.vectorOnPath(pt, it, "tangent");
        },
        normalOnPath: function(pt, it) {
          return this.vectorOnPath(pt, it, "normal");
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime
      }, extendPrototype([st], Ae), extendPrototype([st], rt), rt.prototype.getValueAtTime = Ie, rt.prototype.initiateExpression = ExpressionManager.initiateExpression;
      var dt = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function(lt, pt, it, ut, St) {
        var ot = dt(lt, pt, it, ut, St);
        return ot.propertyIndex = pt.ix, ot.lock = !1, it === 3 ? expressionHelpers.searchExpressions(lt, pt.pt, ot) : it === 4 && expressionHelpers.searchExpressions(lt, pt.ks, ot), ot.k && lt.addDynamicProperty(ot), ot;
      };
    }
    function initialize$1() {
      addPropertyDecorator();
    }
    function addDecorator() {
      function L() {
        return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null;
      }
      TextProperty.prototype.getExpressionValue = function(ne, oe) {
        var pe = this.calculateExpression(oe);
        if (ne.t !== pe) {
          var me = {};
          return this.copyData(me, ne), me.t = pe.toString(), me.__complete = !1, me;
        }
        return ne;
      }, TextProperty.prototype.searchProperty = function() {
        var ne = this.searchKeyframes(), oe = this.searchExpressions();
        return this.kf = ne || oe, this.kf;
      }, TextProperty.prototype.searchExpressions = L;
    }
    function initialize() {
      addDecorator();
    }
    function SVGComposableEffect() {
    }
    SVGComposableEffect.prototype = {
      createMergeNode: function L(ne, oe) {
        var pe = createNS("feMerge");
        pe.setAttribute("result", ne);
        var me, ge;
        for (ge = 0; ge < oe.length; ge += 1)
          me = createNS("feMergeNode"), me.setAttribute("in", oe[ge]), pe.appendChild(me), pe.appendChild(me);
        return pe;
      }
    };
    var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
    function SVGTintFilter(L, ne, oe, pe, me) {
      this.filterManager = ne;
      var ge = createNS("feColorMatrix");
      ge.setAttribute("type", "matrix"), ge.setAttribute("color-interpolation-filters", "linearRGB"), ge.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = ge, ge.setAttribute("result", pe + "_tint_1"), L.appendChild(ge), ge = createNS("feColorMatrix"), ge.setAttribute("type", "matrix"), ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), ge.setAttribute("result", pe + "_tint_2"), L.appendChild(ge), this.matrixFilter = ge;
      var be = this.createMergeNode(pe, [me, pe + "_tint_1", pe + "_tint_2"]);
      L.appendChild(be);
    }
    extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[0].p.v, oe = this.filterManager.effectElements[1].p.v, pe = this.filterManager.effectElements[2].p.v / 100;
        this.linearFilter.setAttribute("values", linearFilterValue + " " + pe + " 0"), this.matrixFilter.setAttribute("values", oe[0] - ne[0] + " 0 0 0 " + ne[0] + " " + (oe[1] - ne[1]) + " 0 0 0 " + ne[1] + " " + (oe[2] - ne[2]) + " 0 0 0 " + ne[2] + " 0 0 0 1 0");
      }
    };
    function SVGFillFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = createNS("feColorMatrix");
      me.setAttribute("type", "matrix"), me.setAttribute("color-interpolation-filters", "sRGB"), me.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), me.setAttribute("result", pe), L.appendChild(me), this.matrixFilter = me;
    }
    SVGFillFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[2].p.v, oe = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute("values", "0 0 0 0 " + ne[0] + " 0 0 0 0 " + ne[1] + " 0 0 0 0 " + ne[2] + " 0 0 0 " + oe + " 0");
      }
    };
    function SVGStrokeEffect(L, ne, oe) {
      this.initialized = !1, this.filterManager = ne, this.elem = oe, this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function() {
      var L = this.elem.layerElement.children || this.elem.layerElement.childNodes, ne, oe, pe, me;
      for (this.filterManager.effectElements[1].p.v === 1 ? (me = this.elem.maskManager.masksProperties.length, pe = 0) : (pe = this.filterManager.effectElements[0].p.v - 1, me = pe + 1), oe = createNS("g"), oe.setAttribute("fill", "none"), oe.setAttribute("stroke-linecap", "round"), oe.setAttribute("stroke-dashoffset", 1), pe; pe < me; pe += 1)
        ne = createNS("path"), oe.appendChild(ne), this.paths.push({
          p: ne,
          m: pe
        });
      if (this.filterManager.effectElements[10].p.v === 3) {
        var ge = createNS("mask"), be = createElementID();
        ge.setAttribute("id", be), ge.setAttribute("mask-type", "alpha"), ge.appendChild(oe), this.elem.globalData.defs.appendChild(ge);
        var Ie = createNS("g");
        for (Ie.setAttribute("mask", "url(" + getLocationHref() + "#" + be + ")"); L[0]; )
          Ie.appendChild(L[0]);
        this.elem.layerElement.appendChild(Ie), this.masker = ge, oe.setAttribute("stroke", "#fff");
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2)
          for (L = this.elem.layerElement.children || this.elem.layerElement.childNodes; L.length; )
            this.elem.layerElement.removeChild(L[0]);
        this.elem.layerElement.appendChild(oe), this.elem.layerElement.removeAttribute("mask"), oe.setAttribute("stroke", "#fff");
      }
      this.initialized = !0, this.pathMasker = oe;
    }, SVGStrokeEffect.prototype.renderFrame = function(L) {
      this.initialized || this.initialize();
      var ne, oe = this.paths.length, pe, me;
      for (ne = 0; ne < oe; ne += 1)
        if (this.paths[ne].m !== -1 && (pe = this.elem.maskManager.viewData[this.paths[ne].m], me = this.paths[ne].p, (L || this.filterManager._mdf || pe.prop._mdf) && me.setAttribute("d", pe.lastPath), L || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || pe.prop._mdf)) {
          var ge;
          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
            var be = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, Ie = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, Ae = me.getTotalLength();
            ge = "0 0 0 " + Ae * be + " ";
            var rt = Ae * (Ie - be), st = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01, dt = Math.floor(rt / st), lt;
            for (lt = 0; lt < dt; lt += 1)
              ge += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
            ge += "0 " + Ae * 10 + " 0 0";
          } else
            ge = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          me.setAttribute("stroke-dasharray", ge);
        }
      if ((L || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (L || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (L || this.filterManager.effectElements[3].p._mdf)) {
        var pt = this.filterManager.effectElements[3].p.v;
        this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(pt[0] * 255) + "," + bmFloor(pt[1] * 255) + "," + bmFloor(pt[2] * 255) + ")");
      }
    };
    function SVGTritoneFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = createNS("feColorMatrix");
      me.setAttribute("type", "matrix"), me.setAttribute("color-interpolation-filters", "linearRGB"), me.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), L.appendChild(me);
      var ge = createNS("feComponentTransfer");
      ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("result", pe), this.matrixFilter = ge;
      var be = createNS("feFuncR");
      be.setAttribute("type", "table"), ge.appendChild(be), this.feFuncR = be;
      var Ie = createNS("feFuncG");
      Ie.setAttribute("type", "table"), ge.appendChild(Ie), this.feFuncG = Ie;
      var Ae = createNS("feFuncB");
      Ae.setAttribute("type", "table"), ge.appendChild(Ae), this.feFuncB = Ae, L.appendChild(ge);
    }
    SVGTritoneFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = this.filterManager.effectElements[0].p.v, oe = this.filterManager.effectElements[1].p.v, pe = this.filterManager.effectElements[2].p.v, me = pe[0] + " " + oe[0] + " " + ne[0], ge = pe[1] + " " + oe[1] + " " + ne[1], be = pe[2] + " " + oe[2] + " " + ne[2];
        this.feFuncR.setAttribute("tableValues", me), this.feFuncG.setAttribute("tableValues", ge), this.feFuncB.setAttribute("tableValues", be);
      }
    };
    function SVGProLevelsFilter(L, ne, oe, pe) {
      this.filterManager = ne;
      var me = this.filterManager.effectElements, ge = createNS("feComponentTransfer");
      (me[10].p.k || me[10].p.v !== 0 || me[11].p.k || me[11].p.v !== 1 || me[12].p.k || me[12].p.v !== 1 || me[13].p.k || me[13].p.v !== 0 || me[14].p.k || me[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", ge)), (me[17].p.k || me[17].p.v !== 0 || me[18].p.k || me[18].p.v !== 1 || me[19].p.k || me[19].p.v !== 1 || me[20].p.k || me[20].p.v !== 0 || me[21].p.k || me[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", ge)), (me[24].p.k || me[24].p.v !== 0 || me[25].p.k || me[25].p.v !== 1 || me[26].p.k || me[26].p.v !== 1 || me[27].p.k || me[27].p.v !== 0 || me[28].p.k || me[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", ge)), (me[31].p.k || me[31].p.v !== 0 || me[32].p.k || me[32].p.v !== 1 || me[33].p.k || me[33].p.v !== 1 || me[34].p.k || me[34].p.v !== 0 || me[35].p.k || me[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", ge)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (ge.setAttribute("color-interpolation-filters", "sRGB"), L.appendChild(ge)), (me[3].p.k || me[3].p.v !== 0 || me[4].p.k || me[4].p.v !== 1 || me[5].p.k || me[5].p.v !== 1 || me[6].p.k || me[6].p.v !== 0 || me[7].p.k || me[7].p.v !== 1) && (ge = createNS("feComponentTransfer"), ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("result", pe), L.appendChild(ge), this.feFuncRComposed = this.createFeFunc("feFuncR", ge), this.feFuncGComposed = this.createFeFunc("feFuncG", ge), this.feFuncBComposed = this.createFeFunc("feFuncB", ge));
    }
    SVGProLevelsFilter.prototype.createFeFunc = function(L, ne) {
      var oe = createNS(L);
      return oe.setAttribute("type", "table"), ne.appendChild(oe), oe;
    }, SVGProLevelsFilter.prototype.getTableValue = function(L, ne, oe, pe, me) {
      for (var ge = 0, be = 256, Ie, Ae = Math.min(L, ne), rt = Math.max(L, ne), st = Array.call(null, {
        length: be
      }), dt, lt = 0, pt = me - pe, it = ne - L; ge <= 256; )
        Ie = ge / 256, Ie <= Ae ? dt = it < 0 ? me : pe : Ie >= rt ? dt = it < 0 ? pe : me : dt = pe + pt * Math.pow((Ie - L) / it, 1 / oe), st[lt] = dt, lt += 1, ge += 256 / (be - 1);
      return st.join(" ");
    }, SVGProLevelsFilter.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne, oe = this.filterManager.effectElements;
        this.feFuncRComposed && (L || oe[3].p._mdf || oe[4].p._mdf || oe[5].p._mdf || oe[6].p._mdf || oe[7].p._mdf) && (ne = this.getTableValue(oe[3].p.v, oe[4].p.v, oe[5].p.v, oe[6].p.v, oe[7].p.v), this.feFuncRComposed.setAttribute("tableValues", ne), this.feFuncGComposed.setAttribute("tableValues", ne), this.feFuncBComposed.setAttribute("tableValues", ne)), this.feFuncR && (L || oe[10].p._mdf || oe[11].p._mdf || oe[12].p._mdf || oe[13].p._mdf || oe[14].p._mdf) && (ne = this.getTableValue(oe[10].p.v, oe[11].p.v, oe[12].p.v, oe[13].p.v, oe[14].p.v), this.feFuncR.setAttribute("tableValues", ne)), this.feFuncG && (L || oe[17].p._mdf || oe[18].p._mdf || oe[19].p._mdf || oe[20].p._mdf || oe[21].p._mdf) && (ne = this.getTableValue(oe[17].p.v, oe[18].p.v, oe[19].p.v, oe[20].p.v, oe[21].p.v), this.feFuncG.setAttribute("tableValues", ne)), this.feFuncB && (L || oe[24].p._mdf || oe[25].p._mdf || oe[26].p._mdf || oe[27].p._mdf || oe[28].p._mdf) && (ne = this.getTableValue(oe[24].p.v, oe[25].p.v, oe[26].p.v, oe[27].p.v, oe[28].p.v), this.feFuncB.setAttribute("tableValues", ne)), this.feFuncA && (L || oe[31].p._mdf || oe[32].p._mdf || oe[33].p._mdf || oe[34].p._mdf || oe[35].p._mdf) && (ne = this.getTableValue(oe[31].p.v, oe[32].p.v, oe[33].p.v, oe[34].p.v, oe[35].p.v), this.feFuncA.setAttribute("tableValues", ne));
      }
    };
    function SVGDropShadowEffect(L, ne, oe, pe, me) {
      var ge = ne.container.globalData.renderConfig.filterSize, be = ne.data.fs || ge;
      L.setAttribute("x", be.x || ge.x), L.setAttribute("y", be.y || ge.y), L.setAttribute("width", be.width || ge.width), L.setAttribute("height", be.height || ge.height), this.filterManager = ne;
      var Ie = createNS("feGaussianBlur");
      Ie.setAttribute("in", "SourceAlpha"), Ie.setAttribute("result", pe + "_drop_shadow_1"), Ie.setAttribute("stdDeviation", "0"), this.feGaussianBlur = Ie, L.appendChild(Ie);
      var Ae = createNS("feOffset");
      Ae.setAttribute("dx", "25"), Ae.setAttribute("dy", "0"), Ae.setAttribute("in", pe + "_drop_shadow_1"), Ae.setAttribute("result", pe + "_drop_shadow_2"), this.feOffset = Ae, L.appendChild(Ae);
      var rt = createNS("feFlood");
      rt.setAttribute("flood-color", "#00ff00"), rt.setAttribute("flood-opacity", "1"), rt.setAttribute("result", pe + "_drop_shadow_3"), this.feFlood = rt, L.appendChild(rt);
      var st = createNS("feComposite");
      st.setAttribute("in", pe + "_drop_shadow_3"), st.setAttribute("in2", pe + "_drop_shadow_2"), st.setAttribute("operator", "in"), st.setAttribute("result", pe + "_drop_shadow_4"), L.appendChild(st);
      var dt = this.createMergeNode(pe, [pe + "_drop_shadow_4", me]);
      L.appendChild(dt);
    }
    extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        if ((L || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), L || this.filterManager.effectElements[0].p._mdf) {
          var ne = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(ne[0] * 255), Math.round(ne[1] * 255), Math.round(ne[2] * 255)));
        }
        if ((L || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), L || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var oe = this.filterManager.effectElements[3].p.v, pe = (this.filterManager.effectElements[2].p.v - 90) * degToRads, me = oe * Math.cos(pe), ge = oe * Math.sin(pe);
          this.feOffset.setAttribute("dx", me), this.feOffset.setAttribute("dy", ge);
        }
      }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(L, ne, oe) {
      this.initialized = !1, this.filterManager = ne, this.filterElem = L, this.elem = oe, oe.matteElement = createNS("g"), oe.matteElement.appendChild(oe.layerElement), oe.matteElement.appendChild(oe.transformedElement), oe.baseElement = oe.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function(L) {
      for (var ne = 0, oe = _svgMatteSymbols.length; ne < oe; ) {
        if (_svgMatteSymbols[ne] === L)
          return _svgMatteSymbols[ne];
        ne += 1;
      }
      return null;
    }, SVGMatte3Effect.prototype.replaceInParent = function(L, ne) {
      var oe = L.layerElement.parentNode;
      if (oe) {
        for (var pe = oe.children, me = 0, ge = pe.length; me < ge && pe[me] !== L.layerElement; )
          me += 1;
        var be;
        me <= ge - 2 && (be = pe[me + 1]);
        var Ie = createNS("use");
        Ie.setAttribute("href", "#" + ne), be ? oe.insertBefore(Ie, be) : oe.appendChild(Ie);
      }
    }, SVGMatte3Effect.prototype.setElementAsMask = function(L, ne) {
      if (!this.findSymbol(ne)) {
        var oe = createElementID(), pe = createNS("mask");
        pe.setAttribute("id", ne.layerId), pe.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(ne);
        var me = L.globalData.defs;
        me.appendChild(pe);
        var ge = createNS("symbol");
        ge.setAttribute("id", oe), this.replaceInParent(ne, oe), ge.appendChild(ne.layerElement), me.appendChild(ge);
        var be = createNS("use");
        be.setAttribute("href", "#" + oe), pe.appendChild(be), ne.data.hd = !1, ne.show();
      }
      L.setMatte(ne.layerId);
    }, SVGMatte3Effect.prototype.initialize = function() {
      for (var L = this.filterManager.effectElements[0].p.v, ne = this.elem.comp.elements, oe = 0, pe = ne.length; oe < pe; )
        ne[oe] && ne[oe].data.ind === L && this.setElementAsMask(this.elem, ne[oe]), oe += 1;
      this.initialized = !0;
    }, SVGMatte3Effect.prototype.renderFrame = function() {
      this.initialized || this.initialize();
    };
    function SVGGaussianBlurEffect(L, ne, oe, pe) {
      L.setAttribute("x", "-100%"), L.setAttribute("y", "-100%"), L.setAttribute("width", "300%"), L.setAttribute("height", "300%"), this.filterManager = ne;
      var me = createNS("feGaussianBlur");
      me.setAttribute("result", pe), L.appendChild(me), this.feGaussianBlur = me;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function(L) {
      if (L || this.filterManager._mdf) {
        var ne = 0.3, oe = this.filterManager.effectElements[0].p.v * ne, pe = this.filterManager.effectElements[1].p.v, me = pe == 3 ? 0 : oe, ge = pe == 2 ? 0 : oe;
        this.feGaussianBlur.setAttribute("stdDeviation", me + " " + ge);
        var be = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
        this.feGaussianBlur.setAttribute("edgeMode", be);
      }
    };
    function TransformEffect() {
    }
    TransformEffect.prototype.init = function(L) {
      this.effectsManager = L, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix(), this.opacity = -1, this._mdf = !1, this._opMdf = !1;
    }, TransformEffect.prototype.renderFrame = function(L) {
      if (this._opMdf = !1, this._mdf = !1, L || this.effectsManager._mdf) {
        var ne = this.effectsManager.effectElements, oe = ne[0].p.v, pe = ne[1].p.v, me = ne[2].p.v === 1, ge = ne[3].p.v, be = me ? ge : ne[4].p.v, Ie = ne[5].p.v, Ae = ne[6].p.v, rt = ne[7].p.v;
        this.matrix.reset(), this.matrix.translate(-oe[0], -oe[1], oe[2]), this.matrix.scale(be * 0.01, ge * 0.01, 1), this.matrix.rotate(-rt * degToRads), this.matrix.skewFromAxis(-Ie * degToRads, (Ae + 90) * degToRads), this.matrix.translate(pe[0], pe[1], 0), this._mdf = !0, this.opacity !== ne[8].p.v && (this.opacity = ne[8].p.v, this._opMdf = !0);
      }
    };
    function SVGTransformEffect(L, ne) {
      this.init(ne);
    }
    extendPrototype([TransformEffect], SVGTransformEffect);
    function CVTransformEffect(L) {
      this.init(L);
    }
    return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie;
  });
})(lottie, lottie.exports);
const MainNavbar = ({ NotificationPanel: L, ThreeBarsSVG: ne, systemName: oe, threeBarsOnClick: pe, notificationCondition: me }) => /* @__PURE__ */ React__default.createElement("header", { className: "w-full flex flex-1 flex-col  md:ml-20 fixed top-0 z-50 shadow-md" }, /* @__PURE__ */ React__default.createElement("div", { className: "relative z-10 flex h-16 flex-shrink-0 w-full border-b border-gray-200 bg-white shadow-sm " }, /* @__PURE__ */ React__default.createElement(
  "button",
  {
    type: "button",
    className: "border-r border-gray-200 px-4 text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500 md:hidden",
    onClick: pe
  },
  /* @__PURE__ */ React__default.createElement("span", { className: "sr-only" }, "Open sidebar"),
  /* @__PURE__ */ React__default.createElement(
    ne,
    {
      className: "h-6 w-6"
    }
  )
), /* @__PURE__ */ React__default.createElement("div", { className: "flex justify-between items-center lg:gap-x-16 px-4 sm:px-6 w-11/12" }, /* @__PURE__ */ React__default.createElement("div", { className: " text-sm font-bold leading-7 text-gray-700 sm:truncate sm:text-lg sm:tracking-tight mr-2" }, /* @__PURE__ */ React__default.createElement("span", { className: "text-goldd" }, "GOLD "), "TIGER", " ", oe), /* @__PURE__ */ React__default.createElement("div", { className: me }, /* @__PURE__ */ React__default.createElement(L, null))))), AccordionContext = createContext({
  accordionRef: null,
  items: {},
  setItems: (L) => {
  },
  transition: null,
  alwaysOpen: !1
}), Accordion = ({ children: L, as: ne = "div", className: oe = "", transition: pe = void 0, alwaysOpen: me = !1 }) => {
  const ge = useRef(null), [be, Ie] = useState({}), Ae = useMemo(() => ne || "div", [ne]), rt = useMemo(() => ({
    accordionRef: ge,
    items: be,
    setItems: Ie,
    transition: pe,
    alwaysOpen: me
  }), [me, be, pe]);
  return React__default.createElement(
    AccordionContext.Provider,
    { value: rt },
    React__default.createElement(Ae, { className: oe }, L)
  );
}, AccordionItemContext = createContext({
  accordionRef: null,
  active: !1,
  items: {},
  hash: "",
  transition: null,
  alwaysOpen: !1,
  toggle: () => {
  },
  isActive: !1
}), AccordionItem = ({ children: L, isActive: ne = !1 }) => {
  const { accordionRef: oe, items: pe, setItems: me, transition: ge, alwaysOpen: be } = useContext(AccordionContext), [Ie, Ae] = useState(!1), rt = useMemo(() => Math.random().toString(36).substring(2, 9), []);
  useEffect(() => {
    rt in pe || me({ ...pe, [rt]: Ae });
  }, [pe]);
  const st = useMemo(() => ({
    accordionRef: oe,
    active: Ie,
    toggle: () => Ae(!Ie),
    items: pe,
    hash: rt,
    transition: ge,
    alwaysOpen: be,
    isActive: ne
  }), [oe, Ie, be, rt, ne, pe, ge]);
  return React__default.createElement(AccordionItemContext.Provider, { value: st }, typeof L == "function" ? L({ open: Ie }) : L);
}, AccordionHeader = ({ children: L, as: ne = "button", className: oe = "", href: pe = "", onClick: me }) => {
  const { hash: ge, toggle: be, items: Ie, alwaysOpen: Ae, isActive: rt } = useContext(AccordionItemContext), st = useRef(null), dt = useMemo(() => ne || "button", [ne]);
  return useEffect(() => {
    if (rt && st && st.current) {
      be();
      const lt = st.current;
      lt.setAttribute("aria-expanded", "true");
      const pt = document.querySelector(`#${lt.getAttribute("aria-controls")}`);
      pt && (pt.style.maxHeight = "none");
    }
  }, []), useEffect(() => {
    const lt = (it) => {
      let ut = it.getAttribute("aria-expanded");
      it.setAttribute("aria-expanded", ut === "false" ? "true" : "false");
    }, pt = (it) => {
      if (it) {
        const ut = () => {
          it.style.maxHeight !== "0px" && (it.style.maxHeight = "none"), it.removeEventListener("transitionend", ut);
        };
        it.addEventListener("transitionend", ut), it.style.maxHeight === "0px" ? it.style.maxHeight = it.scrollHeight + "px" : (it.style.maxHeight = it.scrollHeight + "px", it.style.maxHeight = it.scrollHeight + "px", it.style.maxHeight = "0px");
      }
    };
    if (st && st.current) {
      const it = st == null ? void 0 : st.current, ut = (St) => {
        var ht;
        if (dt === "a" && St.preventDefault(), be(), !Ae) {
          const ft = (ht = it.parentNode) == null ? void 0 : ht.querySelectorAll(`:scope > ${dt}[aria-expanded='true']`);
          ft && ft.forEach((vt) => {
            if (vt && vt !== it) {
              const Ct = vt.id.split("-")[1];
              Ie[Ct](!1), lt(vt);
              const xt = document.querySelector(`#${vt.getAttribute("aria-controls")}`);
              xt && pt(xt);
            }
          });
        }
        lt(it);
        const ot = document.querySelector(`#${it.getAttribute("aria-controls")}`);
        pt(ot), me && me(St);
      };
      return it && it.addEventListener("click", ut), () => {
        it && it.removeEventListener("click", ut);
      };
    }
    return () => {
    };
  }, [dt, Ae, Ie, me, be]), dt === "a" ? React__default.createElement("a", { ref: st, id: `button-${ge}`, href: pe, "aria-expanded": "false", className: oe, "aria-controls": `content-${ge}` }, L) : React__default.createElement(dt, { ref: st, id: `button-${ge}`, "aria-expanded": "false", className: oe, "aria-controls": `content-${ge}` }, L);
}, AccordionBody = ({ children: L, as: ne = "div", className: oe = "" }) => {
  const { hash: pe, transition: me } = useContext(AccordionItemContext), ge = useMemo(() => ne || "div", [ne]), be = useMemo(() => {
    const Ie = {
      duration: "300ms",
      timingFunction: "cubic-bezier(0, 0, 0.2, 1)"
    };
    return me && "duration" in me && me.duration && (Ie.duration = me.duration), me && "timingFunction" in me && me.timingFunction && (Ie.timingFunction = me.timingFunction), Ie;
  }, [me]);
  return React__default.createElement(ge, { id: `content-${pe}`, "aria-labelledby": `button-${pe}`, className: oe, style: {
    maxHeight: "0px",
    transitionProperty: "max-height",
    overflow: "hidden",
    transitionDuration: be.duration,
    transitionTimingFunction: be.timingFunction
  } }, L);
};
var reactDom = { exports: {} }, reactDom_development = {}, scheduler = { exports: {} }, scheduler_development = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_development;
function requireScheduler_development() {
  return hasRequiredScheduler_development || (hasRequiredScheduler_development = 1, function(L) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ne = !1, oe = !1, pe = 5;
      function me(mr, Fr) {
        var Kr = mr.length;
        mr.push(Fr), Ie(mr, Fr, Kr);
      }
      function ge(mr) {
        return mr.length === 0 ? null : mr[0];
      }
      function be(mr) {
        if (mr.length === 0)
          return null;
        var Fr = mr[0], Kr = mr.pop();
        return Kr !== Fr && (mr[0] = Kr, Ae(mr, Kr, 0)), Fr;
      }
      function Ie(mr, Fr, Kr) {
        for (var pn = Kr; pn > 0; ) {
          var Rn = pn - 1 >>> 1, Ei = mr[Rn];
          if (rt(Ei, Fr) > 0)
            mr[Rn] = Fr, mr[pn] = Ei, pn = Rn;
          else
            return;
        }
      }
      function Ae(mr, Fr, Kr) {
        for (var pn = Kr, Rn = mr.length, Ei = Rn >>> 1; pn < Ei; ) {
          var ti = (pn + 1) * 2 - 1, Ea = mr[ti], mn = ti + 1, Va = mr[mn];
          if (rt(Ea, Fr) < 0)
            mn < Rn && rt(Va, Ea) < 0 ? (mr[pn] = Va, mr[mn] = Fr, pn = mn) : (mr[pn] = Ea, mr[ti] = Fr, pn = ti);
          else if (mn < Rn && rt(Va, Fr) < 0)
            mr[pn] = Va, mr[mn] = Fr, pn = mn;
          else
            return;
        }
      }
      function rt(mr, Fr) {
        var Kr = mr.sortIndex - Fr.sortIndex;
        return Kr !== 0 ? Kr : mr.id - Fr.id;
      }
      var st = 1, dt = 2, lt = 3, pt = 4, it = 5;
      function ut(mr, Fr) {
      }
      var St = typeof performance == "object" && typeof performance.now == "function";
      if (St) {
        var ot = performance;
        L.unstable_now = function() {
          return ot.now();
        };
      } else {
        var ht = Date, ft = ht.now();
        L.unstable_now = function() {
          return ht.now() - ft;
        };
      }
      var vt = 1073741823, Ct = -1, xt = 250, At = 5e3, kt = 1e4, Vt = vt, ir = [], er = [], Yt = 1, Jt = null, rr = lt, Qt = !1, wt = !1, Ft = !1, yt = typeof setTimeout == "function" ? setTimeout : null, Et = typeof clearTimeout == "function" ? clearTimeout : null, Dt = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ot(mr) {
        for (var Fr = ge(er); Fr !== null; ) {
          if (Fr.callback === null)
            be(er);
          else if (Fr.startTime <= mr)
            be(er), Fr.sortIndex = Fr.expirationTime, me(ir, Fr);
          else
            return;
          Fr = ge(er);
        }
      }
      function nr(mr) {
        if (Ft = !1, Ot(mr), !wt)
          if (ge(ir) !== null)
            wt = !0, ei(vr);
          else {
            var Fr = ge(er);
            Fr !== null && Tn(nr, Fr.startTime - mr);
          }
      }
      function vr(mr, Fr) {
        wt = !1, Ft && (Ft = !1, hi()), Qt = !0;
        var Kr = rr;
        try {
          var pn;
          if (!oe)
            return pr(mr, Fr);
        } finally {
          Jt = null, rr = Kr, Qt = !1;
        }
      }
      function pr(mr, Fr) {
        var Kr = Fr;
        for (Ot(Kr), Jt = ge(ir); Jt !== null && !ne && !(Jt.expirationTime > Kr && (!mr || Ri())); ) {
          var pn = Jt.callback;
          if (typeof pn == "function") {
            Jt.callback = null, rr = Jt.priorityLevel;
            var Rn = Jt.expirationTime <= Kr, Ei = pn(Rn);
            Kr = L.unstable_now(), typeof Ei == "function" ? Jt.callback = Ei : Jt === ge(ir) && be(ir), Ot(Kr);
          } else
            be(ir);
          Jt = ge(ir);
        }
        if (Jt !== null)
          return !0;
        var ti = ge(er);
        return ti !== null && Tn(nr, ti.startTime - Kr), !1;
      }
      function xr(mr, Fr) {
        switch (mr) {
          case st:
          case dt:
          case lt:
          case pt:
          case it:
            break;
          default:
            mr = lt;
        }
        var Kr = rr;
        rr = mr;
        try {
          return Fr();
        } finally {
          rr = Kr;
        }
      }
      function Ir(mr) {
        var Fr;
        switch (rr) {
          case st:
          case dt:
          case lt:
            Fr = lt;
            break;
          default:
            Fr = rr;
            break;
        }
        var Kr = rr;
        rr = Fr;
        try {
          return mr();
        } finally {
          rr = Kr;
        }
      }
      function fn(mr) {
        var Fr = rr;
        return function() {
          var Kr = rr;
          rr = Fr;
          try {
            return mr.apply(this, arguments);
          } finally {
            rr = Kr;
          }
        };
      }
      function Zr(mr, Fr, Kr) {
        var pn = L.unstable_now(), Rn;
        if (typeof Kr == "object" && Kr !== null) {
          var Ei = Kr.delay;
          typeof Ei == "number" && Ei > 0 ? Rn = pn + Ei : Rn = pn;
        } else
          Rn = pn;
        var ti;
        switch (mr) {
          case st:
            ti = Ct;
            break;
          case dt:
            ti = xt;
            break;
          case it:
            ti = Vt;
            break;
          case pt:
            ti = kt;
            break;
          case lt:
          default:
            ti = At;
            break;
        }
        var Ea = Rn + ti, mn = {
          id: Yt++,
          callback: Fr,
          priorityLevel: mr,
          startTime: Rn,
          expirationTime: Ea,
          sortIndex: -1
        };
        return Rn > pn ? (mn.sortIndex = Rn, me(er, mn), ge(ir) === null && mn === ge(er) && (Ft ? hi() : Ft = !0, Tn(nr, Rn - pn))) : (mn.sortIndex = Ea, me(ir, mn), !wt && !Qt && (wt = !0, ei(vr))), mn;
      }
      function xn() {
      }
      function kn() {
        !wt && !Qt && (wt = !0, ei(vr));
      }
      function Lr() {
        return ge(ir);
      }
      function en(mr) {
        mr.callback = null;
      }
      function Rr() {
        return rr;
      }
      var cr = !1, Nn = null, Xn = -1, Mn = pe, Kn = -1;
      function Ri() {
        var mr = L.unstable_now() - Kn;
        return !(mr < Mn);
      }
      function Si() {
      }
      function Fn(mr) {
        if (mr < 0 || mr > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        mr > 0 ? Mn = Math.floor(1e3 / mr) : Mn = pe;
      }
      var ki = function() {
        if (Nn !== null) {
          var mr = L.unstable_now();
          Kn = mr;
          var Fr = !0, Kr = !0;
          try {
            Kr = Nn(Fr, mr);
          } finally {
            Kr ? Jn() : (cr = !1, Nn = null);
          }
        } else
          cr = !1;
      }, Jn;
      if (typeof Dt == "function")
        Jn = function() {
          Dt(ki);
        };
      else if (typeof MessageChannel < "u") {
        var Zn = new MessageChannel(), ui = Zn.port2;
        Zn.port1.onmessage = ki, Jn = function() {
          ui.postMessage(null);
        };
      } else
        Jn = function() {
          yt(ki, 0);
        };
      function ei(mr) {
        Nn = mr, cr || (cr = !0, Jn());
      }
      function Tn(mr, Fr) {
        Xn = yt(function() {
          mr(L.unstable_now());
        }, Fr);
      }
      function hi() {
        Et(Xn), Xn = -1;
      }
      var za = Si, zn = null;
      L.unstable_IdlePriority = it, L.unstable_ImmediatePriority = st, L.unstable_LowPriority = pt, L.unstable_NormalPriority = lt, L.unstable_Profiling = zn, L.unstable_UserBlockingPriority = dt, L.unstable_cancelCallback = en, L.unstable_continueExecution = kn, L.unstable_forceFrameRate = Fn, L.unstable_getCurrentPriorityLevel = Rr, L.unstable_getFirstCallbackNode = Lr, L.unstable_next = Ir, L.unstable_pauseExecution = xn, L.unstable_requestPaint = za, L.unstable_runWithPriority = xr, L.unstable_scheduleCallback = Zr, L.unstable_shouldYield = Ri, L.unstable_wrapCallback = fn, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(scheduler_development)), scheduler_development;
}
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function(L) {
    function ne(yt, Et) {
      var Dt = yt.length;
      yt.push(Et);
      e:
        for (; 0 < Dt; ) {
          var Ot = Dt - 1 >>> 1, nr = yt[Ot];
          if (0 < me(nr, Et))
            yt[Ot] = Et, yt[Dt] = nr, Dt = Ot;
          else
            break e;
        }
    }
    function oe(yt) {
      return yt.length === 0 ? null : yt[0];
    }
    function pe(yt) {
      if (yt.length === 0)
        return null;
      var Et = yt[0], Dt = yt.pop();
      if (Dt !== Et) {
        yt[0] = Dt;
        e:
          for (var Ot = 0, nr = yt.length, vr = nr >>> 1; Ot < vr; ) {
            var pr = 2 * (Ot + 1) - 1, xr = yt[pr], Ir = pr + 1, fn = yt[Ir];
            if (0 > me(xr, Dt))
              Ir < nr && 0 > me(fn, xr) ? (yt[Ot] = fn, yt[Ir] = Dt, Ot = Ir) : (yt[Ot] = xr, yt[pr] = Dt, Ot = pr);
            else if (Ir < nr && 0 > me(fn, Dt))
              yt[Ot] = fn, yt[Ir] = Dt, Ot = Ir;
            else
              break e;
          }
      }
      return Et;
    }
    function me(yt, Et) {
      var Dt = yt.sortIndex - Et.sortIndex;
      return Dt !== 0 ? Dt : yt.id - Et.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var ge = performance;
      L.unstable_now = function() {
        return ge.now();
      };
    } else {
      var be = Date, Ie = be.now();
      L.unstable_now = function() {
        return be.now() - Ie;
      };
    }
    var Ae = [], rt = [], st = 1, dt = null, lt = 3, pt = !1, it = !1, ut = !1, St = typeof setTimeout == "function" ? setTimeout : null, ot = typeof clearTimeout == "function" ? clearTimeout : null, ht = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function ft(yt) {
      for (var Et = oe(rt); Et !== null; ) {
        if (Et.callback === null)
          pe(rt);
        else if (Et.startTime <= yt)
          pe(rt), Et.sortIndex = Et.expirationTime, ne(Ae, Et);
        else
          break;
        Et = oe(rt);
      }
    }
    function vt(yt) {
      if (ut = !1, ft(yt), !it)
        if (oe(Ae) !== null)
          it = !0, wt(Ct);
        else {
          var Et = oe(rt);
          Et !== null && Ft(vt, Et.startTime - yt);
        }
    }
    function Ct(yt, Et) {
      it = !1, ut && (ut = !1, ot(kt), kt = -1), pt = !0;
      var Dt = lt;
      try {
        for (ft(Et), dt = oe(Ae); dt !== null && (!(dt.expirationTime > Et) || yt && !er()); ) {
          var Ot = dt.callback;
          if (typeof Ot == "function") {
            dt.callback = null, lt = dt.priorityLevel;
            var nr = Ot(dt.expirationTime <= Et);
            Et = L.unstable_now(), typeof nr == "function" ? dt.callback = nr : dt === oe(Ae) && pe(Ae), ft(Et);
          } else
            pe(Ae);
          dt = oe(Ae);
        }
        if (dt !== null)
          var vr = !0;
        else {
          var pr = oe(rt);
          pr !== null && Ft(vt, pr.startTime - Et), vr = !1;
        }
        return vr;
      } finally {
        dt = null, lt = Dt, pt = !1;
      }
    }
    var xt = !1, At = null, kt = -1, Vt = 5, ir = -1;
    function er() {
      return !(L.unstable_now() - ir < Vt);
    }
    function Yt() {
      if (At !== null) {
        var yt = L.unstable_now();
        ir = yt;
        var Et = !0;
        try {
          Et = At(!0, yt);
        } finally {
          Et ? Jt() : (xt = !1, At = null);
        }
      } else
        xt = !1;
    }
    var Jt;
    if (typeof ht == "function")
      Jt = function() {
        ht(Yt);
      };
    else if (typeof MessageChannel < "u") {
      var rr = new MessageChannel(), Qt = rr.port2;
      rr.port1.onmessage = Yt, Jt = function() {
        Qt.postMessage(null);
      };
    } else
      Jt = function() {
        St(Yt, 0);
      };
    function wt(yt) {
      At = yt, xt || (xt = !0, Jt());
    }
    function Ft(yt, Et) {
      kt = St(function() {
        yt(L.unstable_now());
      }, Et);
    }
    L.unstable_IdlePriority = 5, L.unstable_ImmediatePriority = 1, L.unstable_LowPriority = 4, L.unstable_NormalPriority = 3, L.unstable_Profiling = null, L.unstable_UserBlockingPriority = 2, L.unstable_cancelCallback = function(yt) {
      yt.callback = null;
    }, L.unstable_continueExecution = function() {
      it || pt || (it = !0, wt(Ct));
    }, L.unstable_forceFrameRate = function(yt) {
      0 > yt || 125 < yt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Vt = 0 < yt ? Math.floor(1e3 / yt) : 5;
    }, L.unstable_getCurrentPriorityLevel = function() {
      return lt;
    }, L.unstable_getFirstCallbackNode = function() {
      return oe(Ae);
    }, L.unstable_next = function(yt) {
      switch (lt) {
        case 1:
        case 2:
        case 3:
          var Et = 3;
          break;
        default:
          Et = lt;
      }
      var Dt = lt;
      lt = Et;
      try {
        return yt();
      } finally {
        lt = Dt;
      }
    }, L.unstable_pauseExecution = function() {
    }, L.unstable_requestPaint = function() {
    }, L.unstable_runWithPriority = function(yt, Et) {
      switch (yt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          yt = 3;
      }
      var Dt = lt;
      lt = yt;
      try {
        return Et();
      } finally {
        lt = Dt;
      }
    }, L.unstable_scheduleCallback = function(yt, Et, Dt) {
      var Ot = L.unstable_now();
      switch (typeof Dt == "object" && Dt !== null ? (Dt = Dt.delay, Dt = typeof Dt == "number" && 0 < Dt ? Ot + Dt : Ot) : Dt = Ot, yt) {
        case 1:
          var nr = -1;
          break;
        case 2:
          nr = 250;
          break;
        case 5:
          nr = 1073741823;
          break;
        case 4:
          nr = 1e4;
          break;
        default:
          nr = 5e3;
      }
      return nr = Dt + nr, yt = { id: st++, callback: Et, priorityLevel: yt, startTime: Dt, expirationTime: nr, sortIndex: -1 }, Dt > Ot ? (yt.sortIndex = Dt, ne(rt, yt), oe(Ae) === null && yt === oe(rt) && (ut ? (ot(kt), kt = -1) : ut = !0, Ft(vt, Dt - Ot))) : (yt.sortIndex = nr, ne(Ae, yt), it || pt || (it = !0, wt(Ct))), yt;
    }, L.unstable_shouldYield = er, L.unstable_wrapCallback = function(yt) {
      var Et = lt;
      return function() {
        var Dt = lt;
        lt = Et;
        try {
          return yt.apply(this, arguments);
        } finally {
          lt = Dt;
        }
      };
    };
  }(scheduler_production_min)), scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  return hasRequiredScheduler || (hasRequiredScheduler = 1, process.env.NODE_ENV === "production" ? scheduler.exports = requireScheduler_production_min() : scheduler.exports = requireScheduler_development()), scheduler.exports;
}
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_development;
function requireReactDom_development() {
  return hasRequiredReactDom_development || (hasRequiredReactDom_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var L = React__default, ne = requireScheduler(), oe = L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, pe = !1;
    function me(re) {
      pe = re;
    }
    function ge(re) {
      if (!pe) {
        for (var ie = arguments.length, he = new Array(ie > 1 ? ie - 1 : 0), ve = 1; ve < ie; ve++)
          he[ve - 1] = arguments[ve];
        Ie("warn", re, he);
      }
    }
    function be(re) {
      if (!pe) {
        for (var ie = arguments.length, he = new Array(ie > 1 ? ie - 1 : 0), ve = 1; ve < ie; ve++)
          he[ve - 1] = arguments[ve];
        Ie("error", re, he);
      }
    }
    function Ie(re, ie, he) {
      {
        var ve = oe.ReactDebugCurrentFrame, Ce = ve.getStackAddendum();
        Ce !== "" && (ie += "%s", he = he.concat([Ce]));
        var ke = he.map(function(at) {
          return String(at);
        });
        ke.unshift("Warning: " + ie), Function.prototype.apply.call(console[re], console, ke);
      }
    }
    var Ae = 0, rt = 1, st = 2, dt = 3, lt = 4, pt = 5, it = 6, ut = 7, St = 8, ot = 9, ht = 10, ft = 11, vt = 12, Ct = 13, xt = 14, At = 15, kt = 16, Vt = 17, ir = 18, er = 19, Yt = 21, Jt = 22, rr = 23, Qt = 24, wt = 25, Ft = !0, yt = !1, Et = !1, Dt = !1, Ot = !1, nr = !0, vr = !1, pr = !1, xr = !0, Ir = !0, fn = !0, Zr = /* @__PURE__ */ new Set(), xn = {}, kn = {};
    function Lr(re, ie) {
      en(re, ie), en(re + "Capture", ie);
    }
    function en(re, ie) {
      xn[re] && be("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", re), xn[re] = ie;
      {
        var he = re.toLowerCase();
        kn[he] = re, re === "onDoubleClick" && (kn.ondblclick = re);
      }
      for (var ve = 0; ve < ie.length; ve++)
        Zr.add(ie[ve]);
    }
    var Rr = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", cr = Object.prototype.hasOwnProperty;
    function Nn(re) {
      {
        var ie = typeof Symbol == "function" && Symbol.toStringTag, he = ie && re[Symbol.toStringTag] || re.constructor.name || "Object";
        return he;
      }
    }
    function Xn(re) {
      try {
        return Mn(re), !1;
      } catch {
        return !0;
      }
    }
    function Mn(re) {
      return "" + re;
    }
    function Kn(re, ie) {
      if (Xn(re))
        return be("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, Nn(re)), Mn(re);
    }
    function Ri(re) {
      if (Xn(re))
        return be("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Nn(re)), Mn(re);
    }
    function Si(re, ie) {
      if (Xn(re))
        return be("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, Nn(re)), Mn(re);
    }
    function Fn(re, ie) {
      if (Xn(re))
        return be("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", ie, Nn(re)), Mn(re);
    }
    function ki(re) {
      if (Xn(re))
        return be("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Nn(re)), Mn(re);
    }
    function Jn(re) {
      if (Xn(re))
        return be("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Nn(re)), Mn(re);
    }
    var Zn = 0, ui = 1, ei = 2, Tn = 3, hi = 4, za = 5, zn = 6, mr = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Fr = mr + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Kr = new RegExp("^[" + mr + "][" + Fr + "]*$"), pn = {}, Rn = {};
    function Ei(re) {
      return cr.call(Rn, re) ? !0 : cr.call(pn, re) ? !1 : Kr.test(re) ? (Rn[re] = !0, !0) : (pn[re] = !0, be("Invalid attribute name: `%s`", re), !1);
    }
    function ti(re, ie, he) {
      return ie !== null ? ie.type === Zn : he ? !1 : re.length > 2 && (re[0] === "o" || re[0] === "O") && (re[1] === "n" || re[1] === "N");
    }
    function Ea(re, ie, he, ve) {
      if (he !== null && he.type === Zn)
        return !1;
      switch (typeof ie) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (ve)
            return !1;
          if (he !== null)
            return !he.acceptsBooleans;
          var Ce = re.toLowerCase().slice(0, 5);
          return Ce !== "data-" && Ce !== "aria-";
        }
        default:
          return !1;
      }
    }
    function mn(re, ie, he, ve) {
      if (ie === null || typeof ie > "u" || Ea(re, ie, he, ve))
        return !0;
      if (ve)
        return !1;
      if (he !== null)
        switch (he.type) {
          case Tn:
            return !ie;
          case hi:
            return ie === !1;
          case za:
            return isNaN(ie);
          case zn:
            return isNaN(ie) || ie < 1;
        }
      return !1;
    }
    function Va(re) {
      return Vn.hasOwnProperty(re) ? Vn[re] : null;
    }
    function ri(re, ie, he, ve, Ce, ke, at) {
      this.acceptsBooleans = ie === ei || ie === Tn || ie === hi, this.attributeName = ve, this.attributeNamespace = Ce, this.mustUseProperty = he, this.propertyName = re, this.type = ie, this.sanitizeURL = ke, this.removeEmptyString = at;
    }
    var Vn = {}, ou = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ou.forEach(function(re) {
      Vn[re] = new ri(
        re,
        Zn,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(re) {
      var ie = re[0], he = re[1];
      Vn[ie] = new ri(
        ie,
        ui,
        !1,
        // mustUseProperty
        he,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(re) {
      Vn[re] = new ri(
        re,
        ei,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(re) {
      Vn[re] = new ri(
        re,
        ei,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(re) {
      Vn[re] = new ri(
        re,
        Tn,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Vn[re] = new ri(
        re,
        Tn,
        !0,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Vn[re] = new ri(
        re,
        hi,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      Vn[re] = new ri(
        re,
        zn,
        !1,
        // mustUseProperty
        re,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(re) {
      Vn[re] = new ri(
        re,
        za,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Oo = /[\-\:]([a-z])/g, ks = function(re) {
      return re[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Oo, ks);
      Vn[ie] = new ri(
        ie,
        ui,
        !1,
        // mustUseProperty
        re,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Oo, ks);
      Vn[ie] = new ri(
        ie,
        ui,
        !1,
        // mustUseProperty
        re,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(re) {
      var ie = re.replace(Oo, ks);
      Vn[ie] = new ri(
        ie,
        ui,
        !1,
        // mustUseProperty
        re,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(re) {
      Vn[re] = new ri(
        re,
        ui,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var su = "xlinkHref";
    Vn[su] = new ri(
      "xlinkHref",
      ui,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(re) {
      Vn[re] = new ri(
        re,
        ui,
        !1,
        // mustUseProperty
        re.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var lu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Lo = !1;
    function cf(re) {
      !Lo && lu.test(re) && (Lo = !0, be("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(re)));
    }
    function dl(re, ie, he, ve) {
      if (ve.mustUseProperty) {
        var Ce = ve.propertyName;
        return re[Ce];
      } else {
        Kn(he, ie), ve.sanitizeURL && cf("" + he);
        var ke = ve.attributeName, at = null;
        if (ve.type === hi) {
          if (re.hasAttribute(ke)) {
            var mt = re.getAttribute(ke);
            return mt === "" ? !0 : mn(ie, he, ve, !1) ? mt : mt === "" + he ? he : mt;
          }
        } else if (re.hasAttribute(ke)) {
          if (mn(ie, he, ve, !1))
            return re.getAttribute(ke);
          if (ve.type === Tn)
            return he;
          at = re.getAttribute(ke);
        }
        return mn(ie, he, ve, !1) ? at === null ? he : at : at === "" + he ? he : at;
      }
    }
    function uu(re, ie, he, ve) {
      {
        if (!Ei(ie))
          return;
        if (!re.hasAttribute(ie))
          return he === void 0 ? void 0 : null;
        var Ce = re.getAttribute(ie);
        return Kn(he, ie), Ce === "" + he ? he : Ce;
      }
    }
    function es(re, ie, he, ve) {
      var Ce = Va(ie);
      if (!ti(ie, Ce, ve)) {
        if (mn(ie, he, Ce, ve) && (he = null), ve || Ce === null) {
          if (Ei(ie)) {
            var ke = ie;
            he === null ? re.removeAttribute(ke) : (Kn(he, ie), re.setAttribute(ke, "" + he));
          }
          return;
        }
        var at = Ce.mustUseProperty;
        if (at) {
          var mt = Ce.propertyName;
          if (he === null) {
            var gt = Ce.type;
            re[mt] = gt === Tn ? !1 : "";
          } else
            re[mt] = he;
          return;
        }
        var Tt = Ce.attributeName, Pt = Ce.attributeNamespace;
        if (he === null)
          re.removeAttribute(Tt);
        else {
          var Nt = Ce.type, $t;
          Nt === Tn || Nt === hi && he === !0 ? $t = "" : (Kn(he, Tt), $t = "" + he, Ce.sanitizeURL && cf($t.toString())), Pt ? re.setAttributeNS(Pt, Tt, $t) : re.setAttribute(Tt, $t);
        }
      }
    }
    var Ms = Symbol.for("react.element"), ba = Symbol.for("react.portal"), Ba = Symbol.for("react.fragment"), Ca = Symbol.for("react.strict_mode"), hl = Symbol.for("react.profiler"), df = Symbol.for("react.provider"), hf = Symbol.for("react.context"), Fs = Symbol.for("react.forward_ref"), to = Symbol.for("react.suspense"), oa = Symbol.for("react.suspense_list"), Ds = Symbol.for("react.memo"), Bi = Symbol.for("react.lazy"), gc = Symbol.for("react.scope"), Sc = Symbol.for("react.debug_trace_mode"), pf = Symbol.for("react.offscreen"), $o = Symbol.for("react.legacy_hidden"), fh = Symbol.for("react.cache"), ch = Symbol.for("react.tracing_marker"), Bn = Symbol.iterator, dh = "@@iterator";
    function To(re) {
      if (re === null || typeof re != "object")
        return null;
      var ie = Bn && re[Bn] || re[dh];
      return typeof ie == "function" ? ie : null;
    }
    var Xr = Object.assign, Io = 0, Ec, ro, pl, Ha, bc, xa, Cc;
    function xc() {
    }
    xc.__reactDisabledLog = !0;
    function fu() {
      {
        if (Io === 0) {
          Ec = console.log, ro = console.info, pl = console.warn, Ha = console.error, bc = console.group, xa = console.groupCollapsed, Cc = console.groupEnd;
          var re = {
            configurable: !0,
            enumerable: !0,
            value: xc,
            writable: !0
          };
          Object.defineProperties(console, {
            info: re,
            log: re,
            warn: re,
            error: re,
            group: re,
            groupCollapsed: re,
            groupEnd: re
          });
        }
        Io++;
      }
    }
    function cu() {
      {
        if (Io--, Io === 0) {
          var re = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Xr({}, re, {
              value: Ec
            }),
            info: Xr({}, re, {
              value: ro
            }),
            warn: Xr({}, re, {
              value: pl
            }),
            error: Xr({}, re, {
              value: Ha
            }),
            group: Xr({}, re, {
              value: bc
            }),
            groupCollapsed: Xr({}, re, {
              value: xa
            }),
            groupEnd: Xr({}, re, {
              value: Cc
            })
          });
        }
        Io < 0 && be("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var no = oe.ReactCurrentDispatcher, No;
    function Ta(re, ie, he) {
      {
        if (No === void 0)
          try {
            throw Error();
          } catch (Ce) {
            var ve = Ce.stack.trim().match(/\n( *(at )?)/);
            No = ve && ve[1] || "";
          }
        return `
` + No + re;
      }
    }
    var mf = !1, du;
    {
      var vf = typeof WeakMap == "function" ? WeakMap : Map;
      du = new vf();
    }
    function hu(re, ie) {
      if (!re || mf)
        return "";
      {
        var he = du.get(re);
        if (he !== void 0)
          return he;
      }
      var ve;
      mf = !0;
      var Ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ke;
      ke = no.current, no.current = null, fu();
      try {
        if (ie) {
          var at = function() {
            throw Error();
          };
          if (Object.defineProperty(at.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(at, []);
            } catch (Wt) {
              ve = Wt;
            }
            Reflect.construct(re, [], at);
          } else {
            try {
              at.call();
            } catch (Wt) {
              ve = Wt;
            }
            re.call(at.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Wt) {
            ve = Wt;
          }
          re();
        }
      } catch (Wt) {
        if (Wt && ve && typeof Wt.stack == "string") {
          for (var mt = Wt.stack.split(`
`), gt = ve.stack.split(`
`), Tt = mt.length - 1, Pt = gt.length - 1; Tt >= 1 && Pt >= 0 && mt[Tt] !== gt[Pt]; )
            Pt--;
          for (; Tt >= 1 && Pt >= 0; Tt--, Pt--)
            if (mt[Tt] !== gt[Pt]) {
              if (Tt !== 1 || Pt !== 1)
                do
                  if (Tt--, Pt--, Pt < 0 || mt[Tt] !== gt[Pt]) {
                    var Nt = `
` + mt[Tt].replace(" at new ", " at ");
                    return re.displayName && Nt.includes("<anonymous>") && (Nt = Nt.replace("<anonymous>", re.displayName)), typeof re == "function" && du.set(re, Nt), Nt;
                  }
                while (Tt >= 1 && Pt >= 0);
              break;
            }
        }
      } finally {
        mf = !1, no.current = ke, cu(), Error.prepareStackTrace = Ce;
      }
      var $t = re ? re.displayName || re.name : "", Gt = $t ? Ta($t) : "";
      return typeof re == "function" && du.set(re, Gt), Gt;
    }
    function pu(re, ie, he) {
      return hu(re, !0);
    }
    function ts(re, ie, he) {
      return hu(re, !1);
    }
    function hh(re) {
      var ie = re.prototype;
      return !!(ie && ie.isReactComponent);
    }
    function Os(re, ie, he) {
      if (re == null)
        return "";
      if (typeof re == "function")
        return hu(re, hh(re));
      if (typeof re == "string")
        return Ta(re);
      switch (re) {
        case to:
          return Ta("Suspense");
        case oa:
          return Ta("SuspenseList");
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case Fs:
            return ts(re.render);
          case Ds:
            return Os(re.type, ie, he);
          case Bi: {
            var ve = re, Ce = ve._payload, ke = ve._init;
            try {
              return Os(ke(Ce), ie, he);
            } catch {
            }
          }
        }
      return "";
    }
    function ln(re) {
      switch (re._debugOwner && re._debugOwner.type, re._debugSource, re.tag) {
        case pt:
          return Ta(re.type);
        case kt:
          return Ta("Lazy");
        case Ct:
          return Ta("Suspense");
        case er:
          return Ta("SuspenseList");
        case Ae:
        case st:
        case At:
          return ts(re.type);
        case ft:
          return ts(re.type.render);
        case rt:
          return pu(re.type);
        default:
          return "";
      }
    }
    function zo(re) {
      try {
        var ie = "", he = re;
        do
          ie += ln(he), he = he.return;
        while (he);
        return ie;
      } catch (ve) {
        return `
Error generating stack: ` + ve.message + `
` + ve.stack;
      }
    }
    function Tc(re, ie, he) {
      var ve = re.displayName;
      if (ve)
        return ve;
      var Ce = ie.displayName || ie.name || "";
      return Ce !== "" ? he + "(" + Ce + ")" : he;
    }
    function mu(re) {
      return re.displayName || "Context";
    }
    function nn(re) {
      if (re == null)
        return null;
      if (typeof re.tag == "number" && be("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof re == "function")
        return re.displayName || re.name || null;
      if (typeof re == "string")
        return re;
      switch (re) {
        case Ba:
          return "Fragment";
        case ba:
          return "Portal";
        case hl:
          return "Profiler";
        case Ca:
          return "StrictMode";
        case to:
          return "Suspense";
        case oa:
          return "SuspenseList";
      }
      if (typeof re == "object")
        switch (re.$$typeof) {
          case hf:
            var ie = re;
            return mu(ie) + ".Consumer";
          case df:
            var he = re;
            return mu(he._context) + ".Provider";
          case Fs:
            return Tc(re, re.render, "ForwardRef");
          case Ds:
            var ve = re.displayName || null;
            return ve !== null ? ve : nn(re.type) || "Memo";
          case Bi: {
            var Ce = re, ke = Ce._payload, at = Ce._init;
            try {
              return nn(at(ke));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function wc(re, ie, he) {
      var ve = ie.displayName || ie.name || "";
      return re.displayName || (ve !== "" ? he + "(" + ve + ")" : he);
    }
    function yf(re) {
      return re.displayName || "Context";
    }
    function Gr(re) {
      var ie = re.tag, he = re.type;
      switch (ie) {
        case Qt:
          return "Cache";
        case ot:
          var ve = he;
          return yf(ve) + ".Consumer";
        case ht:
          var Ce = he;
          return yf(Ce._context) + ".Provider";
        case ir:
          return "DehydratedFragment";
        case ft:
          return wc(he, he.render, "ForwardRef");
        case ut:
          return "Fragment";
        case pt:
          return he;
        case lt:
          return "Portal";
        case dt:
          return "Root";
        case it:
          return "Text";
        case kt:
          return nn(he);
        case St:
          return he === Ca ? "StrictMode" : "Mode";
        case Jt:
          return "Offscreen";
        case vt:
          return "Profiler";
        case Yt:
          return "Scope";
        case Ct:
          return "Suspense";
        case er:
          return "SuspenseList";
        case wt:
          return "TracingMarker";
        case rt:
        case Ae:
        case Vt:
        case st:
        case xt:
        case At:
          if (typeof he == "function")
            return he.displayName || he.name || null;
          if (typeof he == "string")
            return he;
          break;
      }
      return null;
    }
    var ml = oe.ReactDebugCurrentFrame, ni = null, pi = !1;
    function sa() {
      {
        if (ni === null)
          return null;
        var re = ni._debugOwner;
        if (re !== null && typeof re < "u")
          return Gr(re);
      }
      return null;
    }
    function vl() {
      return ni === null ? "" : zo(ni);
    }
    function Hn() {
      ml.getCurrentStack = null, ni = null, pi = !1;
    }
    function vn(re) {
      ml.getCurrentStack = re === null ? null : vl, ni = re, pi = !1;
    }
    function gf() {
      return ni;
    }
    function Ua(re) {
      pi = re;
    }
    function bi(re) {
      return "" + re;
    }
    function wo(re) {
      switch (typeof re) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return re;
        case "object":
          return Jn(re), re;
        default:
          return "";
      }
    }
    var Sf = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function io(re, ie) {
      Sf[ie.type] || ie.onChange || ie.onInput || ie.readOnly || ie.disabled || ie.value == null || be("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), ie.onChange || ie.readOnly || ie.disabled || ie.checked == null || be("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function vu(re) {
      var ie = re.type, he = re.nodeName;
      return he && he.toLowerCase() === "input" && (ie === "checkbox" || ie === "radio");
    }
    function _c(re) {
      return re._valueTracker;
    }
    function yl(re) {
      re._valueTracker = null;
    }
    function gl(re) {
      var ie = "";
      return re && (vu(re) ? ie = re.checked ? "true" : "false" : ie = re.value), ie;
    }
    function Rt(re) {
      var ie = vu(re) ? "checked" : "value", he = Object.getOwnPropertyDescriptor(re.constructor.prototype, ie);
      Jn(re[ie]);
      var ve = "" + re[ie];
      if (!(re.hasOwnProperty(ie) || typeof he > "u" || typeof he.get != "function" || typeof he.set != "function")) {
        var Ce = he.get, ke = he.set;
        Object.defineProperty(re, ie, {
          configurable: !0,
          get: function() {
            return Ce.call(this);
          },
          set: function(mt) {
            Jn(mt), ve = "" + mt, ke.call(this, mt);
          }
        }), Object.defineProperty(re, ie, {
          enumerable: he.enumerable
        });
        var at = {
          getValue: function() {
            return ve;
          },
          setValue: function(mt) {
            Jn(mt), ve = "" + mt;
          },
          stopTracking: function() {
            yl(re), delete re[ie];
          }
        };
        return at;
      }
    }
    function zt(re) {
      _c(re) || (re._valueTracker = Rt(re));
    }
    function ar(re) {
      if (!re)
        return !1;
      var ie = _c(re);
      if (!ie)
        return !0;
      var he = ie.getValue(), ve = gl(re);
      return ve !== he ? (ie.setValue(ve), !0) : !1;
    }
    function gr(re) {
      if (re = re || (typeof document < "u" ? document : void 0), typeof re > "u")
        return null;
      try {
        return re.activeElement || re.body;
      } catch {
        return re.body;
      }
    }
    var yn = !1, jr = !1, wn = !1, ii = !1;
    function _n(re) {
      var ie = re.type === "checkbox" || re.type === "radio";
      return ie ? re.checked != null : re.value != null;
    }
    function En(re, ie) {
      var he = re, ve = ie.checked, Ce = Xr({}, ie, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: ve ?? he._wrapperState.initialChecked
      });
      return Ce;
    }
    function Ci(re, ie) {
      io("input", ie), ie.checked !== void 0 && ie.defaultChecked !== void 0 && !jr && (be("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", sa() || "A component", ie.type), jr = !0), ie.value !== void 0 && ie.defaultValue !== void 0 && !yn && (be("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", sa() || "A component", ie.type), yn = !0);
      var he = re, ve = ie.defaultValue == null ? "" : ie.defaultValue;
      he._wrapperState = {
        initialChecked: ie.checked != null ? ie.checked : ie.defaultChecked,
        initialValue: wo(ie.value != null ? ie.value : ve),
        controlled: _n(ie)
      };
    }
    function la(re, ie) {
      var he = re, ve = ie.checked;
      ve != null && es(he, "checked", ve, !1);
    }
    function Gn(re, ie) {
      var he = re;
      {
        var ve = _n(ie);
        !he._wrapperState.controlled && ve && !ii && (be("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ii = !0), he._wrapperState.controlled && !ve && !wn && (be("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), wn = !0);
      }
      la(re, ie);
      var Ce = wo(ie.value), ke = ie.type;
      if (Ce != null)
        ke === "number" ? (Ce === 0 && he.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        he.value != Ce) && (he.value = bi(Ce)) : he.value !== bi(Ce) && (he.value = bi(Ce));
      else if (ke === "submit" || ke === "reset") {
        he.removeAttribute("value");
        return;
      }
      ie.hasOwnProperty("value") ? Fi(he, ie.type, Ce) : ie.hasOwnProperty("defaultValue") && Fi(he, ie.type, wo(ie.defaultValue)), ie.checked == null && ie.defaultChecked != null && (he.defaultChecked = !!ie.defaultChecked);
    }
    function Mi(re, ie, he) {
      var ve = re;
      if (ie.hasOwnProperty("value") || ie.hasOwnProperty("defaultValue")) {
        var Ce = ie.type, ke = Ce === "submit" || Ce === "reset";
        if (ke && (ie.value === void 0 || ie.value === null))
          return;
        var at = bi(ve._wrapperState.initialValue);
        he || at !== ve.value && (ve.value = at), ve.defaultValue = at;
      }
      var mt = ve.name;
      mt !== "" && (ve.name = ""), ve.defaultChecked = !ve.defaultChecked, ve.defaultChecked = !!ve._wrapperState.initialChecked, mt !== "" && (ve.name = mt);
    }
    function ua(re, ie) {
      var he = re;
      Gn(he, ie), ai(he, ie);
    }
    function ai(re, ie) {
      var he = ie.name;
      if (ie.type === "radio" && he != null) {
        for (var ve = re; ve.parentNode; )
          ve = ve.parentNode;
        Kn(he, "name");
        for (var Ce = ve.querySelectorAll("input[name=" + JSON.stringify("" + he) + '][type="radio"]'), ke = 0; ke < Ce.length; ke++) {
          var at = Ce[ke];
          if (!(at === re || at.form !== re.form)) {
            var mt = Qv(at);
            if (!mt)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            ar(at), Gn(at, mt);
          }
        }
      }
    }
    function Fi(re, ie, he) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (ie !== "number" || gr(re.ownerDocument) !== re) && (he == null ? re.defaultValue = bi(re._wrapperState.initialValue) : re.defaultValue !== bi(he) && (re.defaultValue = bi(he)));
    }
    var ao = !1, rs = !1, Sl = !1;
    function ns(re, ie) {
      ie.value == null && (typeof ie.children == "object" && ie.children !== null ? L.Children.forEach(ie.children, function(he) {
        he != null && (typeof he == "string" || typeof he == "number" || rs || (rs = !0, be("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : ie.dangerouslySetInnerHTML != null && (Sl || (Sl = !0, be("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), ie.selected != null && !ao && (be("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), ao = !0);
    }
    function ph(re, ie) {
      ie.value != null && re.setAttribute("value", bi(wo(ie.value)));
    }
    var Ef = Array.isArray;
    function Di(re) {
      return Ef(re);
    }
    var Ac;
    Ac = !1;
    function bm() {
      var re = sa();
      return re ? `

Check the render method of \`` + re + "`." : "";
    }
    var Cm = ["value", "defaultValue"];
    function ug(re) {
      {
        io("select", re);
        for (var ie = 0; ie < Cm.length; ie++) {
          var he = Cm[ie];
          if (re[he] != null) {
            var ve = Di(re[he]);
            re.multiple && !ve ? be("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", he, bm()) : !re.multiple && ve && be("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", he, bm());
          }
        }
      }
    }
    function Ls(re, ie, he, ve) {
      var Ce = re.options;
      if (ie) {
        for (var ke = he, at = {}, mt = 0; mt < ke.length; mt++)
          at["$" + ke[mt]] = !0;
        for (var gt = 0; gt < Ce.length; gt++) {
          var Tt = at.hasOwnProperty("$" + Ce[gt].value);
          Ce[gt].selected !== Tt && (Ce[gt].selected = Tt), Tt && ve && (Ce[gt].defaultSelected = !0);
        }
      } else {
        for (var Pt = bi(wo(he)), Nt = null, $t = 0; $t < Ce.length; $t++) {
          if (Ce[$t].value === Pt) {
            Ce[$t].selected = !0, ve && (Ce[$t].defaultSelected = !0);
            return;
          }
          Nt === null && !Ce[$t].disabled && (Nt = Ce[$t]);
        }
        Nt !== null && (Nt.selected = !0);
      }
    }
    function mh(re, ie) {
      return Xr({}, ie, {
        value: void 0
      });
    }
    function xm(re, ie) {
      var he = re;
      ug(ie), he._wrapperState = {
        wasMultiple: !!ie.multiple
      }, ie.value !== void 0 && ie.defaultValue !== void 0 && !Ac && (be("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ac = !0);
    }
    function fg(re, ie) {
      var he = re;
      he.multiple = !!ie.multiple;
      var ve = ie.value;
      ve != null ? Ls(he, !!ie.multiple, ve, !1) : ie.defaultValue != null && Ls(he, !!ie.multiple, ie.defaultValue, !0);
    }
    function cg(re, ie) {
      var he = re, ve = he._wrapperState.wasMultiple;
      he._wrapperState.wasMultiple = !!ie.multiple;
      var Ce = ie.value;
      Ce != null ? Ls(he, !!ie.multiple, Ce, !1) : ve !== !!ie.multiple && (ie.defaultValue != null ? Ls(he, !!ie.multiple, ie.defaultValue, !0) : Ls(he, !!ie.multiple, ie.multiple ? [] : "", !1));
    }
    function dg(re, ie) {
      var he = re, ve = ie.value;
      ve != null && Ls(he, !!ie.multiple, ve, !1);
    }
    var vh = !1;
    function yh(re, ie) {
      var he = re;
      if (ie.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var ve = Xr({}, ie, {
        value: void 0,
        defaultValue: void 0,
        children: bi(he._wrapperState.initialValue)
      });
      return ve;
    }
    function Tm(re, ie) {
      var he = re;
      io("textarea", ie), ie.value !== void 0 && ie.defaultValue !== void 0 && !vh && (be("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", sa() || "A component"), vh = !0);
      var ve = ie.value;
      if (ve == null) {
        var Ce = ie.children, ke = ie.defaultValue;
        if (Ce != null) {
          be("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (ke != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Di(Ce)) {
              if (Ce.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              Ce = Ce[0];
            }
            ke = Ce;
          }
        }
        ke == null && (ke = ""), ve = ke;
      }
      he._wrapperState = {
        initialValue: wo(ve)
      };
    }
    function wm(re, ie) {
      var he = re, ve = wo(ie.value), Ce = wo(ie.defaultValue);
      if (ve != null) {
        var ke = bi(ve);
        ke !== he.value && (he.value = ke), ie.defaultValue == null && he.defaultValue !== ke && (he.defaultValue = ke);
      }
      Ce != null && (he.defaultValue = bi(Ce));
    }
    function _m(re, ie) {
      var he = re, ve = he.textContent;
      ve === he._wrapperState.initialValue && ve !== "" && ve !== null && (he.value = ve);
    }
    function gh(re, ie) {
      wm(re, ie);
    }
    var is = "http://www.w3.org/1999/xhtml", hg = "http://www.w3.org/1998/Math/MathML", Sh = "http://www.w3.org/2000/svg";
    function Pc(re) {
      switch (re) {
        case "svg":
          return Sh;
        case "math":
          return hg;
        default:
          return is;
      }
    }
    function Eh(re, ie) {
      return re == null || re === is ? Pc(ie) : re === Sh && ie === "foreignObject" ? is : re;
    }
    var pg = function(re) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ie, he, ve, Ce) {
        MSApp.execUnsafeLocalFunction(function() {
          return re(ie, he, ve, Ce);
        });
      } : re;
    }, Rc, Am = pg(function(re, ie) {
      if (re.namespaceURI === Sh && !("innerHTML" in re)) {
        Rc = Rc || document.createElement("div"), Rc.innerHTML = "<svg>" + ie.valueOf().toString() + "</svg>";
        for (var he = Rc.firstChild; re.firstChild; )
          re.removeChild(re.firstChild);
        for (; he.firstChild; )
          re.appendChild(he.firstChild);
        return;
      }
      re.innerHTML = ie;
    }), wa = 1, as = 3, mi = 8, _o = 9, El = 11, kc = function(re, ie) {
      if (ie) {
        var he = re.firstChild;
        if (he && he === re.lastChild && he.nodeType === as) {
          he.nodeValue = ie;
          return;
        }
      }
      re.textContent = ie;
    }, Pm = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, yu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Rm(re, ie) {
      return re + ie.charAt(0).toUpperCase() + ie.substring(1);
    }
    var km = ["Webkit", "ms", "Moz", "O"];
    Object.keys(yu).forEach(function(re) {
      km.forEach(function(ie) {
        yu[Rm(ie, re)] = yu[re];
      });
    });
    function Mc(re, ie, he) {
      var ve = ie == null || typeof ie == "boolean" || ie === "";
      return ve ? "" : !he && typeof ie == "number" && ie !== 0 && !(yu.hasOwnProperty(re) && yu[re]) ? ie + "px" : (Fn(ie, re), ("" + ie).trim());
    }
    var gu = /([A-Z])/g, mg = /^ms-/;
    function vg(re) {
      return re.replace(gu, "-$1").toLowerCase().replace(mg, "-ms-");
    }
    var Mm = function() {
    };
    {
      var Fm = /^(?:webkit|moz|o)[A-Z]/, Dm = /^-ms-/, bf = /-(.)/g, Su = /;\s*$/, Eu = {}, bu = {}, Om = !1, bh = !1, Ch = function(re) {
        return re.replace(bf, function(ie, he) {
          return he.toUpperCase();
        });
      }, xh = function(re) {
        Eu.hasOwnProperty(re) && Eu[re] || (Eu[re] = !0, be(
          "Unsupported style property %s. Did you mean %s?",
          re,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Ch(re.replace(Dm, "ms-"))
        ));
      }, Lm = function(re) {
        Eu.hasOwnProperty(re) && Eu[re] || (Eu[re] = !0, be("Unsupported vendor-prefixed style property %s. Did you mean %s?", re, re.charAt(0).toUpperCase() + re.slice(1)));
      }, $m = function(re, ie) {
        bu.hasOwnProperty(ie) && bu[ie] || (bu[ie] = !0, be(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, re, ie.replace(Su, "")));
      }, Im = function(re, ie) {
        Om || (Om = !0, be("`NaN` is an invalid value for the `%s` css style property.", re));
      }, yg = function(re, ie) {
        bh || (bh = !0, be("`Infinity` is an invalid value for the `%s` css style property.", re));
      };
      Mm = function(re, ie) {
        re.indexOf("-") > -1 ? xh(re) : Fm.test(re) ? Lm(re) : Su.test(ie) && $m(re, ie), typeof ie == "number" && (isNaN(ie) ? Im(re, ie) : isFinite(ie) || yg(re, ie));
      };
    }
    var gg = Mm;
    function Sg(re) {
      {
        var ie = "", he = "";
        for (var ve in re)
          if (re.hasOwnProperty(ve)) {
            var Ce = re[ve];
            if (Ce != null) {
              var ke = ve.indexOf("--") === 0;
              ie += he + (ke ? ve : vg(ve)) + ":", ie += Mc(ve, Ce, ke), he = ";";
            }
          }
        return ie || null;
      }
    }
    function Nm(re, ie) {
      var he = re.style;
      for (var ve in ie)
        if (ie.hasOwnProperty(ve)) {
          var Ce = ve.indexOf("--") === 0;
          Ce || gg(ve, ie[ve]);
          var ke = Mc(ve, ie[ve], Ce);
          ve === "float" && (ve = "cssFloat"), Ce ? he.setProperty(ve, ke) : he[ve] = ke;
        }
    }
    function Eg(re) {
      return re == null || typeof re == "boolean" || re === "";
    }
    function oo(re) {
      var ie = {};
      for (var he in re)
        for (var ve = Pm[he] || [he], Ce = 0; Ce < ve.length; Ce++)
          ie[ve[Ce]] = he;
      return ie;
    }
    function Cf(re, ie) {
      {
        if (!ie)
          return;
        var he = oo(re), ve = oo(ie), Ce = {};
        for (var ke in he) {
          var at = he[ke], mt = ve[ke];
          if (mt && at !== mt) {
            var gt = at + "," + mt;
            if (Ce[gt])
              continue;
            Ce[gt] = !0, be("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Eg(re[at]) ? "Removing" : "Updating", at, mt);
          }
        }
      }
    }
    var zm = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Vm = Xr({
      menuitem: !0
    }, zm), Bm = "__html";
    function Fc(re, ie) {
      if (ie) {
        if (Vm[re] && (ie.children != null || ie.dangerouslySetInnerHTML != null))
          throw new Error(re + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (ie.dangerouslySetInnerHTML != null) {
          if (ie.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof ie.dangerouslySetInnerHTML != "object" || !(Bm in ie.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!ie.suppressContentEditableWarning && ie.contentEditable && ie.children != null && be("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), ie.style != null && typeof ie.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function os(re, ie) {
      if (re.indexOf("-") === -1)
        return typeof ie.is == "string";
      switch (re) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Dc = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Hm = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ao = {}, Th = new RegExp("^(aria)-[" + Fr + "]*$"), xf = new RegExp("^(aria)[A-Z][" + Fr + "]*$");
    function wh(re, ie) {
      {
        if (cr.call(Ao, ie) && Ao[ie])
          return !0;
        if (xf.test(ie)) {
          var he = "aria-" + ie.slice(4).toLowerCase(), ve = Hm.hasOwnProperty(he) ? he : null;
          if (ve == null)
            return be("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", ie), Ao[ie] = !0, !0;
          if (ie !== ve)
            return be("Invalid ARIA attribute `%s`. Did you mean `%s`?", ie, ve), Ao[ie] = !0, !0;
        }
        if (Th.test(ie)) {
          var Ce = ie.toLowerCase(), ke = Hm.hasOwnProperty(Ce) ? Ce : null;
          if (ke == null)
            return Ao[ie] = !0, !1;
          if (ie !== ke)
            return be("Unknown ARIA attribute `%s`. Did you mean `%s`?", ie, ke), Ao[ie] = !0, !0;
        }
      }
      return !0;
    }
    function Um(re, ie) {
      {
        var he = [];
        for (var ve in ie) {
          var Ce = wh(re, ve);
          Ce || he.push(ve);
        }
        var ke = he.map(function(at) {
          return "`" + at + "`";
        }).join(", ");
        he.length === 1 ? be("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ke, re) : he.length > 1 && be("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", ke, re);
      }
    }
    function Oc(re, ie) {
      os(re, ie) || Um(re, ie);
    }
    var bl = !1;
    function _h(re, ie) {
      {
        if (re !== "input" && re !== "textarea" && re !== "select")
          return;
        ie != null && ie.value === null && !bl && (bl = !0, re === "select" && ie.multiple ? be("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", re) : be("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", re));
      }
    }
    var Ah = function() {
    };
    {
      var Oi = {}, Ph = /^on./, jm = /^on[^A-Z]/, Gm = new RegExp("^(aria)-[" + Fr + "]*$"), Wm = new RegExp("^(aria)[A-Z][" + Fr + "]*$");
      Ah = function(re, ie, he, ve) {
        if (cr.call(Oi, ie) && Oi[ie])
          return !0;
        var Ce = ie.toLowerCase();
        if (Ce === "onfocusin" || Ce === "onfocusout")
          return be("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Oi[ie] = !0, !0;
        if (ve != null) {
          var ke = ve.registrationNameDependencies, at = ve.possibleRegistrationNames;
          if (ke.hasOwnProperty(ie))
            return !0;
          var mt = at.hasOwnProperty(Ce) ? at[Ce] : null;
          if (mt != null)
            return be("Invalid event handler property `%s`. Did you mean `%s`?", ie, mt), Oi[ie] = !0, !0;
          if (Ph.test(ie))
            return be("Unknown event handler property `%s`. It will be ignored.", ie), Oi[ie] = !0, !0;
        } else if (Ph.test(ie))
          return jm.test(ie) && be("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", ie), Oi[ie] = !0, !0;
        if (Gm.test(ie) || Wm.test(ie))
          return !0;
        if (Ce === "innerhtml")
          return be("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Oi[ie] = !0, !0;
        if (Ce === "aria")
          return be("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Oi[ie] = !0, !0;
        if (Ce === "is" && he !== null && he !== void 0 && typeof he != "string")
          return be("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof he), Oi[ie] = !0, !0;
        if (typeof he == "number" && isNaN(he))
          return be("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", ie), Oi[ie] = !0, !0;
        var gt = Va(ie), Tt = gt !== null && gt.type === Zn;
        if (Dc.hasOwnProperty(Ce)) {
          var Pt = Dc[Ce];
          if (Pt !== ie)
            return be("Invalid DOM property `%s`. Did you mean `%s`?", ie, Pt), Oi[ie] = !0, !0;
        } else if (!Tt && ie !== Ce)
          return be("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", ie, Ce), Oi[ie] = !0, !0;
        return typeof he == "boolean" && Ea(ie, he, gt, !1) ? (he ? be('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', he, ie, ie, he, ie) : be('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', he, ie, ie, he, ie, ie, ie), Oi[ie] = !0, !0) : Tt ? !0 : Ea(ie, he, gt, !1) ? (Oi[ie] = !0, !1) : ((he === "false" || he === "true") && gt !== null && gt.type === Tn && (be("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", he, ie, he === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', ie, he), Oi[ie] = !0), !0);
      };
    }
    var qm = function(re, ie, he) {
      {
        var ve = [];
        for (var Ce in ie) {
          var ke = Ah(re, Ce, ie[Ce], he);
          ke || ve.push(Ce);
        }
        var at = ve.map(function(mt) {
          return "`" + mt + "`";
        }).join(", ");
        ve.length === 1 ? be("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", at, re) : ve.length > 1 && be("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", at, re);
      }
    };
    function Ym(re, ie, he) {
      os(re, ie) || qm(re, ie, he);
    }
    var ss = 1, Tf = 2, Cl = 4, bg = ss | Tf | Cl, wf = null;
    function _f(re) {
      wf !== null && be("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), wf = re;
    }
    function Cg() {
      wf === null && be("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), wf = null;
    }
    function Qm(re) {
      return re === wf;
    }
    function Lc(re) {
      var ie = re.target || re.srcElement || window;
      return ie.correspondingUseElement && (ie = ie.correspondingUseElement), ie.nodeType === as ? ie.parentNode : ie;
    }
    var An = null, $s = null, ls = null;
    function Cu(re) {
      var ie = Yu(re);
      if (ie) {
        if (typeof An != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var he = ie.stateNode;
        if (he) {
          var ve = Qv(he);
          An(ie.stateNode, ie.type, ve);
        }
      }
    }
    function Xm(re) {
      An = re;
    }
    function $c(re) {
      $s ? ls ? ls.push(re) : ls = [re] : $s = re;
    }
    function Af() {
      return $s !== null || ls !== null;
    }
    function Pf() {
      if ($s) {
        var re = $s, ie = ls;
        if ($s = null, ls = null, Cu(re), ie)
          for (var he = 0; he < ie.length; he++)
            Cu(ie[he]);
      }
    }
    var xl = function(re, ie) {
      return re(ie);
    }, Rh = function() {
    }, kh = !1;
    function xg() {
      var re = Af();
      re && (Rh(), Pf());
    }
    function Mh(re, ie, he) {
      if (kh)
        return re(ie, he);
      kh = !0;
      try {
        return xl(re, ie, he);
      } finally {
        kh = !1, xg();
      }
    }
    function Ic(re, ie, he) {
      xl = re, Rh = he;
    }
    function Nc(re) {
      return re === "button" || re === "input" || re === "select" || re === "textarea";
    }
    function Fh(re, ie, he) {
      switch (re) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(he.disabled && Nc(ie));
        default:
          return !1;
      }
    }
    function Tl(re, ie) {
      var he = re.stateNode;
      if (he === null)
        return null;
      var ve = Qv(he);
      if (ve === null)
        return null;
      var Ce = ve[ie];
      if (Fh(ie, re.type, ve))
        return null;
      if (Ce && typeof Ce != "function")
        throw new Error("Expected `" + ie + "` listener to be a function, instead got a value of `" + typeof Ce + "` type.");
      return Ce;
    }
    var Rf = !1;
    if (Rr)
      try {
        var wl = {};
        Object.defineProperty(wl, "passive", {
          get: function() {
            Rf = !0;
          }
        }), window.addEventListener("test", wl, wl), window.removeEventListener("test", wl, wl);
      } catch {
        Rf = !1;
      }
    function Km(re, ie, he, ve, Ce, ke, at, mt, gt) {
      var Tt = Array.prototype.slice.call(arguments, 3);
      try {
        ie.apply(he, Tt);
      } catch (Pt) {
        this.onError(Pt);
      }
    }
    var Dh = Km;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Oh = document.createElement("react");
      Dh = function(ie, he, ve, Ce, ke, at, mt, gt, Tt) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Pt = document.createEvent("Event"), Nt = !1, $t = !0, Gt = window.event, Wt = Object.getOwnPropertyDescriptor(window, "event");
        function Xt() {
          Oh.removeEventListener(Kt, $r, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Gt);
        }
        var br = Array.prototype.slice.call(arguments, 3);
        function $r() {
          Nt = !0, Xt(), he.apply(ve, br), $t = !1;
        }
        var Mr, sn = !1, rn = !1;
        function Ht(Ut) {
          if (Mr = Ut.error, sn = !0, Mr === null && Ut.colno === 0 && Ut.lineno === 0 && (rn = !0), Ut.defaultPrevented && Mr != null && typeof Mr == "object")
            try {
              Mr._suppressLogging = !0;
            } catch {
            }
        }
        var Kt = "react-" + (ie || "invokeguardedcallback");
        if (window.addEventListener("error", Ht), Oh.addEventListener(Kt, $r, !1), Pt.initEvent(Kt, !1, !1), Oh.dispatchEvent(Pt), Wt && Object.defineProperty(window, "event", Wt), Nt && $t && (sn ? rn && (Mr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Mr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Mr)), window.removeEventListener("error", Ht), !Nt)
          return Xt(), Km.apply(this, arguments);
      };
    }
    var Tg = Dh, Is = !1, Po = null, kf = !1, Ns = null, Vo = {
      onError: function(re) {
        Is = !0, Po = re;
      }
    };
    function _l(re, ie, he, ve, Ce, ke, at, mt, gt) {
      Is = !1, Po = null, Tg.apply(Vo, arguments);
    }
    function us(re, ie, he, ve, Ce, ke, at, mt, gt) {
      if (_l.apply(this, arguments), Is) {
        var Tt = $h();
        kf || (kf = !0, Ns = Tt);
      }
    }
    function Lh() {
      if (kf) {
        var re = Ns;
        throw kf = !1, Ns = null, re;
      }
    }
    function wg() {
      return Is;
    }
    function $h() {
      if (Is) {
        var re = Po;
        return Is = !1, Po = null, re;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function so(re) {
      return re._reactInternals;
    }
    function Mf(re) {
      return re._reactInternals !== void 0;
    }
    function xu(re, ie) {
      re._reactInternals = ie;
    }
    var Or = (
      /*                      */
      0
    ), zs = (
      /*                */
      1
    ), Dn = (
      /*                    */
      2
    ), Yr = (
      /*                       */
      4
    ), hn = (
      /*                */
      16
    ), gn = (
      /*                 */
      32
    ), Bo = (
      /*                     */
      64
    ), Hr = (
      /*                   */
      128
    ), oi = (
      /*            */
      256
    ), _a = (
      /*                          */
      512
    ), lo = (
      /*                     */
      1024
    ), Un = (
      /*                      */
      2048
    ), uo = (
      /*                    */
      4096
    ), Vs = (
      /*                   */
      8192
    ), Ff = (
      /*             */
      16384
    ), zc = Un | Yr | Bo | _a | lo | Ff, Jm = (
      /*               */
      32767
    ), ja = (
      /*                   */
      32768
    ), Li = (
      /*                */
      65536
    ), Df = (
      /* */
      131072
    ), Ih = (
      /*                       */
      1048576
    ), Nh = (
      /*                    */
      2097152
    ), Aa = (
      /*                 */
      4194304
    ), Bs = (
      /*                */
      8388608
    ), Pa = (
      /*               */
      16777216
    ), Al = (
      /*              */
      33554432
    ), Tu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Yr | lo | 0
    ), Ra = Dn | Yr | hn | gn | _a | uo | Vs, Zi = Yr | Bo | _a | Vs, fo = Un | hn, Hi = Aa | Bs | Nh, fs = oe.ReactCurrentOwner;
    function Ga(re) {
      var ie = re, he = re;
      if (re.alternate)
        for (; ie.return; )
          ie = ie.return;
      else {
        var ve = ie;
        do
          ie = ve, (ie.flags & (Dn | uo)) !== Or && (he = ie.return), ve = ie.return;
        while (ve);
      }
      return ie.tag === dt ? he : null;
    }
    function zh(re) {
      if (re.tag === Ct) {
        var ie = re.memoizedState;
        if (ie === null) {
          var he = re.alternate;
          he !== null && (ie = he.memoizedState);
        }
        if (ie !== null)
          return ie.dehydrated;
      }
      return null;
    }
    function Vc(re) {
      return re.tag === dt ? re.stateNode.containerInfo : null;
    }
    function Vh(re) {
      return Ga(re) === re;
    }
    function Wa(re) {
      {
        var ie = fs.current;
        if (ie !== null && ie.tag === rt) {
          var he = ie, ve = he.stateNode;
          ve._warnedAboutRefsInRender || be("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Gr(he) || "A component"), ve._warnedAboutRefsInRender = !0;
        }
      }
      var Ce = so(re);
      return Ce ? Ga(Ce) === Ce : !1;
    }
    function ka(re) {
      if (Ga(re) !== re)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function On(re) {
      var ie = re.alternate;
      if (!ie) {
        var he = Ga(re);
        if (he === null)
          throw new Error("Unable to find node on an unmounted component.");
        return he !== re ? null : re;
      }
      for (var ve = re, Ce = ie; ; ) {
        var ke = ve.return;
        if (ke === null)
          break;
        var at = ke.alternate;
        if (at === null) {
          var mt = ke.return;
          if (mt !== null) {
            ve = Ce = mt;
            continue;
          }
          break;
        }
        if (ke.child === at.child) {
          for (var gt = ke.child; gt; ) {
            if (gt === ve)
              return ka(ke), re;
            if (gt === Ce)
              return ka(ke), ie;
            gt = gt.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (ve.return !== Ce.return)
          ve = ke, Ce = at;
        else {
          for (var Tt = !1, Pt = ke.child; Pt; ) {
            if (Pt === ve) {
              Tt = !0, ve = ke, Ce = at;
              break;
            }
            if (Pt === Ce) {
              Tt = !0, Ce = ke, ve = at;
              break;
            }
            Pt = Pt.sibling;
          }
          if (!Tt) {
            for (Pt = at.child; Pt; ) {
              if (Pt === ve) {
                Tt = !0, ve = at, Ce = ke;
                break;
              }
              if (Pt === Ce) {
                Tt = !0, Ce = at, ve = ke;
                break;
              }
              Pt = Pt.sibling;
            }
            if (!Tt)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (ve.alternate !== Ce)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (ve.tag !== dt)
        throw new Error("Unable to find node on an unmounted component.");
      return ve.stateNode.current === ve ? re : ie;
    }
    function co(re) {
      var ie = On(re);
      return ie !== null ? Bh(ie) : null;
    }
    function Bh(re) {
      if (re.tag === pt || re.tag === it)
        return re;
      for (var ie = re.child; ie !== null; ) {
        var he = Bh(ie);
        if (he !== null)
          return he;
        ie = ie.sibling;
      }
      return null;
    }
    function Zm(re) {
      var ie = On(re);
      return ie !== null ? Bc(ie) : null;
    }
    function Bc(re) {
      if (re.tag === pt || re.tag === it)
        return re;
      for (var ie = re.child; ie !== null; ) {
        if (ie.tag !== lt) {
          var he = Bc(ie);
          if (he !== null)
            return he;
        }
        ie = ie.sibling;
      }
      return null;
    }
    var Hc = ne.unstable_scheduleCallback, ev = ne.unstable_cancelCallback, Uc = ne.unstable_shouldYield, tv = ne.unstable_requestPaint, Wn = ne.unstable_now, Hh = ne.unstable_getCurrentPriorityLevel, jc = ne.unstable_ImmediatePriority, qa = ne.unstable_UserBlockingPriority, Ho = ne.unstable_NormalPriority, Gc = ne.unstable_LowPriority, Hs = ne.unstable_IdlePriority, Uh = ne.unstable_yieldValue, jh = ne.unstable_setDisableYieldValue, Us = null, $i = null, dr = null, fi = !1, Ui = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Gh(re) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var ie = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (ie.isDisabled)
        return !0;
      if (!ie.supportsFiber)
        return be("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        xr && (re = Xr({}, re, {
          getLaneLabelMap: Gs,
          injectProfilingHooks: ds
        })), Us = ie.inject(re), $i = ie;
      } catch (he) {
        be("React instrumentation encountered an error: %s.", he);
      }
      return !!ie.checkDCE;
    }
    function rv(re, ie) {
      if ($i && typeof $i.onScheduleFiberRoot == "function")
        try {
          $i.onScheduleFiberRoot(Us, re, ie);
        } catch (he) {
          fi || (fi = !0, be("React instrumentation encountered an error: %s", he));
        }
    }
    function cs(re, ie) {
      if ($i && typeof $i.onCommitFiberRoot == "function")
        try {
          var he = (re.current.flags & Hr) === Hr;
          if (Ir) {
            var ve;
            switch (ie) {
              case ea:
                ve = jc;
                break;
              case ji:
                ve = qa;
                break;
              case ps:
                ve = Ho;
                break;
              case Hf:
                ve = Hs;
                break;
              default:
                ve = Ho;
                break;
            }
            $i.onCommitFiberRoot(Us, re, ve, he);
          }
        } catch (Ce) {
          fi || (fi = !0, be("React instrumentation encountered an error: %s", Ce));
        }
    }
    function js(re) {
      if ($i && typeof $i.onPostCommitFiberRoot == "function")
        try {
          $i.onPostCommitFiberRoot(Us, re);
        } catch (ie) {
          fi || (fi = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function Wh(re) {
      if ($i && typeof $i.onCommitFiberUnmount == "function")
        try {
          $i.onCommitFiberUnmount(Us, re);
        } catch (ie) {
          fi || (fi = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function xi(re) {
      if (typeof Uh == "function" && (jh(re), me(re)), $i && typeof $i.setStrictMode == "function")
        try {
          $i.setStrictMode(Us, re);
        } catch (ie) {
          fi || (fi = !0, be("React instrumentation encountered an error: %s", ie));
        }
    }
    function ds(re) {
      dr = re;
    }
    function Gs() {
      {
        for (var re = /* @__PURE__ */ new Map(), ie = 1, he = 0; he < Ln; he++) {
          var ve = _g(ie);
          re.set(ie, ve), ie *= 2;
        }
        return re;
      }
    }
    function Wc(re) {
      dr !== null && typeof dr.markCommitStarted == "function" && dr.markCommitStarted(re);
    }
    function qh() {
      dr !== null && typeof dr.markCommitStopped == "function" && dr.markCommitStopped();
    }
    function Ws(re) {
      dr !== null && typeof dr.markComponentRenderStarted == "function" && dr.markComponentRenderStarted(re);
    }
    function Pl() {
      dr !== null && typeof dr.markComponentRenderStopped == "function" && dr.markComponentRenderStopped();
    }
    function nv(re) {
      dr !== null && typeof dr.markComponentPassiveEffectMountStarted == "function" && dr.markComponentPassiveEffectMountStarted(re);
    }
    function Yh() {
      dr !== null && typeof dr.markComponentPassiveEffectMountStopped == "function" && dr.markComponentPassiveEffectMountStopped();
    }
    function qc(re) {
      dr !== null && typeof dr.markComponentPassiveEffectUnmountStarted == "function" && dr.markComponentPassiveEffectUnmountStarted(re);
    }
    function iv() {
      dr !== null && typeof dr.markComponentPassiveEffectUnmountStopped == "function" && dr.markComponentPassiveEffectUnmountStopped();
    }
    function av(re) {
      dr !== null && typeof dr.markComponentLayoutEffectMountStarted == "function" && dr.markComponentLayoutEffectMountStarted(re);
    }
    function ov() {
      dr !== null && typeof dr.markComponentLayoutEffectMountStopped == "function" && dr.markComponentLayoutEffectMountStopped();
    }
    function Yc(re) {
      dr !== null && typeof dr.markComponentLayoutEffectUnmountStarted == "function" && dr.markComponentLayoutEffectUnmountStarted(re);
    }
    function wu() {
      dr !== null && typeof dr.markComponentLayoutEffectUnmountStopped == "function" && dr.markComponentLayoutEffectUnmountStopped();
    }
    function Qc(re, ie, he) {
      dr !== null && typeof dr.markComponentErrored == "function" && dr.markComponentErrored(re, ie, he);
    }
    function sv(re, ie, he) {
      dr !== null && typeof dr.markComponentSuspended == "function" && dr.markComponentSuspended(re, ie, he);
    }
    function lv(re) {
      dr !== null && typeof dr.markLayoutEffectsStarted == "function" && dr.markLayoutEffectsStarted(re);
    }
    function _u() {
      dr !== null && typeof dr.markLayoutEffectsStopped == "function" && dr.markLayoutEffectsStopped();
    }
    function uv(re) {
      dr !== null && typeof dr.markPassiveEffectsStarted == "function" && dr.markPassiveEffectsStarted(re);
    }
    function Of() {
      dr !== null && typeof dr.markPassiveEffectsStopped == "function" && dr.markPassiveEffectsStopped();
    }
    function Ro(re) {
      dr !== null && typeof dr.markRenderStarted == "function" && dr.markRenderStarted(re);
    }
    function Lf() {
      dr !== null && typeof dr.markRenderYielded == "function" && dr.markRenderYielded();
    }
    function Au() {
      dr !== null && typeof dr.markRenderStopped == "function" && dr.markRenderStopped();
    }
    function Rl(re) {
      dr !== null && typeof dr.markRenderScheduled == "function" && dr.markRenderScheduled(re);
    }
    function Qh(re, ie) {
      dr !== null && typeof dr.markForceUpdateScheduled == "function" && dr.markForceUpdateScheduled(re, ie);
    }
    function qs(re, ie) {
      dr !== null && typeof dr.markStateUpdateScheduled == "function" && dr.markStateUpdateScheduled(re, ie);
    }
    var Nr = (
      /*                         */
      0
    ), Jr = (
      /*                 */
      1
    ), zr = (
      /*                    */
      2
    ), qn = (
      /*               */
      8
    ), ho = (
      /*              */
      16
    ), Xc = Math.clz32 ? Math.clz32 : kl, Kc = Math.log, Xh = Math.LN2;
    function kl(re) {
      var ie = re >>> 0;
      return ie === 0 ? 32 : 31 - (Kc(ie) / Xh | 0) | 0;
    }
    var Ln = 31, Zt = (
      /*                        */
      0
    ), an = (
      /*                          */
      0
    ), Vr = (
      /*                        */
      1
    ), Uo = (
      /*    */
      2
    ), Ya = (
      /*             */
      4
    ), Ml = (
      /*            */
      8
    ), $n = (
      /*                     */
      16
    ), Fl = (
      /*                */
      32
    ), Ys = (
      /*                       */
      4194240
    ), Dl = (
      /*                        */
      64
    ), po = (
      /*                        */
      128
    ), Ma = (
      /*                        */
      256
    ), Ol = (
      /*                        */
      512
    ), $f = (
      /*                        */
      1024
    ), If = (
      /*                        */
      2048
    ), Jc = (
      /*                        */
      4096
    ), Zc = (
      /*                        */
      8192
    ), ed = (
      /*                        */
      16384
    ), td = (
      /*                       */
      32768
    ), rd = (
      /*                       */
      65536
    ), nd = (
      /*                       */
      131072
    ), id = (
      /*                       */
      262144
    ), ad = (
      /*                       */
      524288
    ), Ll = (
      /*                       */
      1048576
    ), od = (
      /*                       */
      2097152
    ), $l = (
      /*                            */
      130023424
    ), hs = (
      /*                             */
      4194304
    ), sd = (
      /*                             */
      8388608
    ), Nf = (
      /*                             */
      16777216
    ), ld = (
      /*                             */
      33554432
    ), ud = (
      /*                             */
      67108864
    ), Kh = hs, Pu = (
      /*          */
      134217728
    ), fd = (
      /*                          */
      268435455
    ), Ru = (
      /*               */
      268435456
    ), Qs = (
      /*                        */
      536870912
    ), Fa = (
      /*                   */
      1073741824
    );
    function _g(re) {
      {
        if (re & Vr)
          return "Sync";
        if (re & Uo)
          return "InputContinuousHydration";
        if (re & Ya)
          return "InputContinuous";
        if (re & Ml)
          return "DefaultHydration";
        if (re & $n)
          return "Default";
        if (re & Fl)
          return "TransitionHydration";
        if (re & Ys)
          return "Transition";
        if (re & $l)
          return "Retry";
        if (re & Pu)
          return "SelectiveHydration";
        if (re & Ru)
          return "IdleHydration";
        if (re & Qs)
          return "Idle";
        if (re & Fa)
          return "Offscreen";
      }
    }
    var Pn = -1, cd = Dl, dd = hs;
    function ku(re) {
      switch (vi(re)) {
        case Vr:
          return Vr;
        case Uo:
          return Uo;
        case Ya:
          return Ya;
        case Ml:
          return Ml;
        case $n:
          return $n;
        case Fl:
          return Fl;
        case Dl:
        case po:
        case Ma:
        case Ol:
        case $f:
        case If:
        case Jc:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case Ll:
        case od:
          return re & Ys;
        case hs:
        case sd:
        case Nf:
        case ld:
        case ud:
          return re & $l;
        case Pu:
          return Pu;
        case Ru:
          return Ru;
        case Qs:
          return Qs;
        case Fa:
          return Fa;
        default:
          return be("Should have found matching lanes. This is a bug in React."), re;
      }
    }
    function zf(re, ie) {
      var he = re.pendingLanes;
      if (he === Zt)
        return Zt;
      var ve = Zt, Ce = re.suspendedLanes, ke = re.pingedLanes, at = he & fd;
      if (at !== Zt) {
        var mt = at & ~Ce;
        if (mt !== Zt)
          ve = ku(mt);
        else {
          var gt = at & ke;
          gt !== Zt && (ve = ku(gt));
        }
      } else {
        var Tt = he & ~Ce;
        Tt !== Zt ? ve = ku(Tt) : ke !== Zt && (ve = ku(ke));
      }
      if (ve === Zt)
        return Zt;
      if (ie !== Zt && ie !== ve && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (ie & Ce) === Zt) {
        var Pt = vi(ve), Nt = vi(ie);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          Pt >= Nt || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          Pt === $n && (Nt & Ys) !== Zt
        )
          return ie;
      }
      (ve & Ya) !== Zt && (ve |= he & $n);
      var $t = re.entangledLanes;
      if ($t !== Zt)
        for (var Gt = re.entanglements, Wt = ve & $t; Wt > 0; ) {
          var Xt = Xs(Wt), br = 1 << Xt;
          ve |= Gt[Xt], Wt &= ~br;
        }
      return ve;
    }
    function fv(re, ie) {
      for (var he = re.eventTimes, ve = Pn; ie > 0; ) {
        var Ce = Xs(ie), ke = 1 << Ce, at = he[Ce];
        at > ve && (ve = at), ie &= ~ke;
      }
      return ve;
    }
    function hd(re, ie) {
      switch (re) {
        case Vr:
        case Uo:
        case Ya:
          return ie + 250;
        case Ml:
        case $n:
        case Fl:
        case Dl:
        case po:
        case Ma:
        case Ol:
        case $f:
        case If:
        case Jc:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case Ll:
        case od:
          return ie + 5e3;
        case hs:
        case sd:
        case Nf:
        case ld:
        case ud:
          return Pn;
        case Pu:
        case Ru:
        case Qs:
        case Fa:
          return Pn;
        default:
          return be("Should have found matching lanes. This is a bug in React."), Pn;
      }
    }
    function Ag(re, ie) {
      for (var he = re.pendingLanes, ve = re.suspendedLanes, Ce = re.pingedLanes, ke = re.expirationTimes, at = he; at > 0; ) {
        var mt = Xs(at), gt = 1 << mt, Tt = ke[mt];
        Tt === Pn ? ((gt & ve) === Zt || (gt & Ce) !== Zt) && (ke[mt] = hd(gt, ie)) : Tt <= ie && (re.expiredLanes |= gt), at &= ~gt;
      }
    }
    function Pg(re) {
      return ku(re.pendingLanes);
    }
    function Jh(re) {
      var ie = re.pendingLanes & ~Fa;
      return ie !== Zt ? ie : ie & Fa ? Fa : Zt;
    }
    function Mu(re) {
      return (re & Vr) !== Zt;
    }
    function Vf(re) {
      return (re & fd) !== Zt;
    }
    function pd(re) {
      return (re & $l) === re;
    }
    function Rg(re) {
      var ie = Vr | Ya | $n;
      return (re & ie) === Zt;
    }
    function cv(re) {
      return (re & Ys) === re;
    }
    function Bf(re, ie) {
      var he = Uo | Ya | Ml | $n;
      return (ie & he) !== Zt;
    }
    function dv(re, ie) {
      return (ie & re.expiredLanes) !== Zt;
    }
    function Zh(re) {
      return (re & Ys) !== Zt;
    }
    function ep() {
      var re = cd;
      return cd <<= 1, (cd & Ys) === Zt && (cd = Dl), re;
    }
    function kg() {
      var re = dd;
      return dd <<= 1, (dd & $l) === Zt && (dd = hs), re;
    }
    function vi(re) {
      return re & -re;
    }
    function Ti(re) {
      return vi(re);
    }
    function Xs(re) {
      return 31 - Xc(re);
    }
    function md(re) {
      return Xs(re);
    }
    function Da(re, ie) {
      return (re & ie) !== Zt;
    }
    function Il(re, ie) {
      return (re & ie) === ie;
    }
    function Qr(re, ie) {
      return re | ie;
    }
    function Fu(re, ie) {
      return re & ~ie;
    }
    function tp(re, ie) {
      return re & ie;
    }
    function hv(re) {
      return re;
    }
    function pv(re, ie) {
      return re !== an && re < ie ? re : ie;
    }
    function vd(re) {
      for (var ie = [], he = 0; he < Ln; he++)
        ie.push(re);
      return ie;
    }
    function Nl(re, ie, he) {
      re.pendingLanes |= ie, ie !== Qs && (re.suspendedLanes = Zt, re.pingedLanes = Zt);
      var ve = re.eventTimes, Ce = md(ie);
      ve[Ce] = he;
    }
    function rp(re, ie) {
      re.suspendedLanes |= ie, re.pingedLanes &= ~ie;
      for (var he = re.expirationTimes, ve = ie; ve > 0; ) {
        var Ce = Xs(ve), ke = 1 << Ce;
        he[Ce] = Pn, ve &= ~ke;
      }
    }
    function np(re, ie, he) {
      re.pingedLanes |= re.suspendedLanes & ie;
    }
    function ip(re, ie) {
      var he = re.pendingLanes & ~ie;
      re.pendingLanes = ie, re.suspendedLanes = Zt, re.pingedLanes = Zt, re.expiredLanes &= ie, re.mutableReadLanes &= ie, re.entangledLanes &= ie;
      for (var ve = re.entanglements, Ce = re.eventTimes, ke = re.expirationTimes, at = he; at > 0; ) {
        var mt = Xs(at), gt = 1 << mt;
        ve[mt] = Zt, Ce[mt] = Pn, ke[mt] = Pn, at &= ~gt;
      }
    }
    function Du(re, ie) {
      for (var he = re.entangledLanes |= ie, ve = re.entanglements, Ce = he; Ce; ) {
        var ke = Xs(Ce), at = 1 << ke;
        // Is this one of the newly entangled lanes?
        at & ie | // Is this lane transitively entangled with the newly entangled lanes?
        ve[ke] & ie && (ve[ke] |= ie), Ce &= ~at;
      }
    }
    function Mg(re, ie) {
      var he = vi(ie), ve;
      switch (he) {
        case Ya:
          ve = Uo;
          break;
        case $n:
          ve = Ml;
          break;
        case Dl:
        case po:
        case Ma:
        case Ol:
        case $f:
        case If:
        case Jc:
        case Zc:
        case ed:
        case td:
        case rd:
        case nd:
        case id:
        case ad:
        case Ll:
        case od:
        case hs:
        case sd:
        case Nf:
        case ld:
        case ud:
          ve = Fl;
          break;
        case Qs:
          ve = Ru;
          break;
        default:
          ve = an;
          break;
      }
      return (ve & (re.suspendedLanes | ie)) !== an ? an : ve;
    }
    function ap(re, ie, he) {
      if (Ui)
        for (var ve = re.pendingUpdatersLaneMap; he > 0; ) {
          var Ce = md(he), ke = 1 << Ce, at = ve[Ce];
          at.add(ie), he &= ~ke;
        }
    }
    function yd(re, ie) {
      if (Ui)
        for (var he = re.pendingUpdatersLaneMap, ve = re.memoizedUpdaters; ie > 0; ) {
          var Ce = md(ie), ke = 1 << Ce, at = he[Ce];
          at.size > 0 && (at.forEach(function(mt) {
            var gt = mt.alternate;
            (gt === null || !ve.has(gt)) && ve.add(mt);
          }), at.clear()), ie &= ~ke;
        }
    }
    function op(re, ie) {
      return null;
    }
    var ea = Vr, ji = Ya, ps = $n, Hf = Qs, zl = an;
    function mo() {
      return zl;
    }
    function wi(re) {
      zl = re;
    }
    function Uf(re, ie) {
      var he = zl;
      try {
        return zl = re, ie();
      } finally {
        zl = he;
      }
    }
    function ta(re, ie) {
      return re !== 0 && re < ie ? re : ie;
    }
    function Fg(re, ie) {
      return re === 0 || re > ie ? re : ie;
    }
    function sp(re, ie) {
      return re !== 0 && re < ie;
    }
    function jf(re) {
      var ie = vi(re);
      return sp(ea, ie) ? sp(ji, ie) ? Vf(ie) ? ps : Hf : ji : ea;
    }
    function _i(re) {
      var ie = re.current.memoizedState;
      return ie.isDehydrated;
    }
    var mv;
    function Tr(re) {
      mv = re;
    }
    function Ou(re) {
      mv(re);
    }
    var Gf;
    function vv(re) {
      Gf = re;
    }
    var yv;
    function Wf(re) {
      yv = re;
    }
    var qf;
    function lp(re) {
      qf = re;
    }
    var up;
    function gv(re) {
      up = re;
    }
    var gd = !1, Lu = [], jo = null, jn = null, Ii = null, vo = /* @__PURE__ */ new Map(), $u = /* @__PURE__ */ new Map(), ms = [], ko = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Sv(re) {
      return ko.indexOf(re) > -1;
    }
    function Go(re, ie, he, ve, Ce) {
      return {
        blockedOn: re,
        domEventName: ie,
        eventSystemFlags: he,
        nativeEvent: Ce,
        targetContainers: [ve]
      };
    }
    function Ev(re, ie) {
      switch (re) {
        case "focusin":
        case "focusout":
          jo = null;
          break;
        case "dragenter":
        case "dragleave":
          jn = null;
          break;
        case "mouseover":
        case "mouseout":
          Ii = null;
          break;
        case "pointerover":
        case "pointerout": {
          var he = ie.pointerId;
          vo.delete(he);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var ve = ie.pointerId;
          $u.delete(ve);
          break;
        }
      }
    }
    function Iu(re, ie, he, ve, Ce, ke) {
      if (re === null || re.nativeEvent !== ke) {
        var at = Go(ie, he, ve, Ce, ke);
        if (ie !== null) {
          var mt = Yu(ie);
          mt !== null && Gf(mt);
        }
        return at;
      }
      re.eventSystemFlags |= ve;
      var gt = re.targetContainers;
      return Ce !== null && gt.indexOf(Ce) === -1 && gt.push(Ce), re;
    }
    function bv(re, ie, he, ve, Ce) {
      switch (ie) {
        case "focusin": {
          var ke = Ce;
          return jo = Iu(jo, re, ie, he, ve, ke), !0;
        }
        case "dragenter": {
          var at = Ce;
          return jn = Iu(jn, re, ie, he, ve, at), !0;
        }
        case "mouseover": {
          var mt = Ce;
          return Ii = Iu(Ii, re, ie, he, ve, mt), !0;
        }
        case "pointerover": {
          var gt = Ce, Tt = gt.pointerId;
          return vo.set(Tt, Iu(vo.get(Tt) || null, re, ie, he, ve, gt)), !0;
        }
        case "gotpointercapture": {
          var Pt = Ce, Nt = Pt.pointerId;
          return $u.set(Nt, Iu($u.get(Nt) || null, re, ie, he, ve, Pt)), !0;
        }
      }
      return !1;
    }
    function fp(re) {
      var ie = rc(re.target);
      if (ie !== null) {
        var he = Ga(ie);
        if (he !== null) {
          var ve = he.tag;
          if (ve === Ct) {
            var Ce = zh(he);
            if (Ce !== null) {
              re.blockedOn = Ce, up(re.priority, function() {
                yv(he);
              });
              return;
            }
          } else if (ve === dt) {
            var ke = he.stateNode;
            if (_i(ke)) {
              re.blockedOn = Vc(he);
              return;
            }
          }
        }
      }
      re.blockedOn = null;
    }
    function Cv(re) {
      for (var ie = qf(), he = {
        blockedOn: null,
        target: re,
        priority: ie
      }, ve = 0; ve < ms.length && sp(ie, ms[ve].priority); ve++)
        ;
      ms.splice(ve, 0, he), ve === 0 && fp(he);
    }
    function Sd(re) {
      if (re.blockedOn !== null)
        return !1;
      for (var ie = re.targetContainers; ie.length > 0; ) {
        var he = ie[0], ve = Vl(re.domEventName, re.eventSystemFlags, he, re.nativeEvent);
        if (ve === null) {
          var Ce = re.nativeEvent, ke = new Ce.constructor(Ce.type, Ce);
          _f(ke), Ce.target.dispatchEvent(ke), Cg();
        } else {
          var at = Yu(ve);
          return at !== null && Gf(at), re.blockedOn = ve, !1;
        }
        ie.shift();
      }
      return !0;
    }
    function Yf(re, ie, he) {
      Sd(re) && he.delete(ie);
    }
    function cp() {
      gd = !1, jo !== null && Sd(jo) && (jo = null), jn !== null && Sd(jn) && (jn = null), Ii !== null && Sd(Ii) && (Ii = null), vo.forEach(Yf), $u.forEach(Yf);
    }
    function ra(re, ie) {
      re.blockedOn === ie && (re.blockedOn = null, gd || (gd = !0, ne.unstable_scheduleCallback(ne.unstable_NormalPriority, cp)));
    }
    function tn(re) {
      if (Lu.length > 0) {
        ra(Lu[0], re);
        for (var ie = 1; ie < Lu.length; ie++) {
          var he = Lu[ie];
          he.blockedOn === re && (he.blockedOn = null);
        }
      }
      jo !== null && ra(jo, re), jn !== null && ra(jn, re), Ii !== null && ra(Ii, re);
      var ve = function(mt) {
        return ra(mt, re);
      };
      vo.forEach(ve), $u.forEach(ve);
      for (var Ce = 0; Ce < ms.length; Ce++) {
        var ke = ms[Ce];
        ke.blockedOn === re && (ke.blockedOn = null);
      }
      for (; ms.length > 0; ) {
        var at = ms[0];
        if (at.blockedOn !== null)
          break;
        fp(at), at.blockedOn === null && ms.shift();
      }
    }
    var Yn = oe.ReactCurrentBatchConfig, si = !0;
    function Ni(re) {
      si = !!re;
    }
    function Qa() {
      return si;
    }
    function Nu(re, ie, he) {
      var ve = fa(ie), Ce;
      switch (ve) {
        case ea:
          Ce = Ai;
          break;
        case ji:
          Ce = Qf;
          break;
        case ps:
        default:
          Ce = vs;
          break;
      }
      return Ce.bind(null, ie, he, re);
    }
    function Ai(re, ie, he, ve) {
      var Ce = mo(), ke = Yn.transition;
      Yn.transition = null;
      try {
        wi(ea), vs(re, ie, he, ve);
      } finally {
        wi(Ce), Yn.transition = ke;
      }
    }
    function Qf(re, ie, he, ve) {
      var Ce = mo(), ke = Yn.transition;
      Yn.transition = null;
      try {
        wi(ji), vs(re, ie, he, ve);
      } finally {
        wi(Ce), Yn.transition = ke;
      }
    }
    function vs(re, ie, he, ve) {
      si && Ed(re, ie, he, ve);
    }
    function Ed(re, ie, he, ve) {
      var Ce = Vl(re, ie, he, ve);
      if (Ce === null) {
        Jg(re, ie, ve, zu, he), Ev(re, ve);
        return;
      }
      if (bv(Ce, re, ie, he, ve)) {
        ve.stopPropagation();
        return;
      }
      if (Ev(re, ve), ie & Cl && Sv(re)) {
        for (; Ce !== null; ) {
          var ke = Yu(Ce);
          ke !== null && Ou(ke);
          var at = Vl(re, ie, he, ve);
          if (at === null && Jg(re, ie, ve, zu, he), at === Ce)
            break;
          Ce = at;
        }
        Ce !== null && ve.stopPropagation();
        return;
      }
      Jg(re, ie, ve, null, he);
    }
    var zu = null;
    function Vl(re, ie, he, ve) {
      zu = null;
      var Ce = Lc(ve), ke = rc(Ce);
      if (ke !== null) {
        var at = Ga(ke);
        if (at === null)
          ke = null;
        else {
          var mt = at.tag;
          if (mt === Ct) {
            var gt = zh(at);
            if (gt !== null)
              return gt;
            ke = null;
          } else if (mt === dt) {
            var Tt = at.stateNode;
            if (_i(Tt))
              return Vc(at);
            ke = null;
          } else
            at !== ke && (ke = null);
        }
      }
      return zu = ke, null;
    }
    function fa(re) {
      switch (re) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ea;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ji;
        case "message": {
          var ie = Hh();
          switch (ie) {
            case jc:
              return ea;
            case qa:
              return ji;
            case Ho:
            case Gc:
              return ps;
            case Hs:
              return Hf;
            default:
              return ps;
          }
        }
        default:
          return ps;
      }
    }
    function dp(re, ie, he) {
      return re.addEventListener(ie, he, !1), he;
    }
    function Vu(re, ie, he) {
      return re.addEventListener(ie, he, !0), he;
    }
    function ys(re, ie, he, ve) {
      return re.addEventListener(ie, he, {
        capture: !0,
        passive: ve
      }), he;
    }
    function bd(re, ie, he, ve) {
      return re.addEventListener(ie, he, {
        passive: ve
      }), he;
    }
    var Bl = null, Wo = null, Ks = null;
    function Js(re) {
      return Bl = re, Wo = xd(), !0;
    }
    function Cd() {
      Bl = null, Wo = null, Ks = null;
    }
    function Bu() {
      if (Ks)
        return Ks;
      var re, ie = Wo, he = ie.length, ve, Ce = xd(), ke = Ce.length;
      for (re = 0; re < he && ie[re] === Ce[re]; re++)
        ;
      var at = he - re;
      for (ve = 1; ve <= at && ie[he - ve] === Ce[ke - ve]; ve++)
        ;
      var mt = ve > 1 ? 1 - ve : void 0;
      return Ks = Ce.slice(re, mt), Ks;
    }
    function xd() {
      return "value" in Bl ? Bl.value : Bl.textContent;
    }
    function Hl(re) {
      var ie, he = re.keyCode;
      return "charCode" in re ? (ie = re.charCode, ie === 0 && he === 13 && (ie = 13)) : ie = he, ie === 10 && (ie = 13), ie >= 32 || ie === 13 ? ie : 0;
    }
    function Ul() {
      return !0;
    }
    function na() {
      return !1;
    }
    function yi(re) {
      function ie(he, ve, Ce, ke, at) {
        this._reactName = he, this._targetInst = Ce, this.type = ve, this.nativeEvent = ke, this.target = at, this.currentTarget = null;
        for (var mt in re)
          if (re.hasOwnProperty(mt)) {
            var gt = re[mt];
            gt ? this[mt] = gt(ke) : this[mt] = ke[mt];
          }
        var Tt = ke.defaultPrevented != null ? ke.defaultPrevented : ke.returnValue === !1;
        return Tt ? this.isDefaultPrevented = Ul : this.isDefaultPrevented = na, this.isPropagationStopped = na, this;
      }
      return Xr(ie.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var he = this.nativeEvent;
          he && (he.preventDefault ? he.preventDefault() : typeof he.returnValue != "unknown" && (he.returnValue = !1), this.isDefaultPrevented = Ul);
        },
        stopPropagation: function() {
          var he = this.nativeEvent;
          he && (he.stopPropagation ? he.stopPropagation() : typeof he.cancelBubble != "unknown" && (he.cancelBubble = !0), this.isPropagationStopped = Ul);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Ul
      }), ie;
    }
    var ia = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(re) {
        return re.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, aa = yi(ia), Hu = Xr({}, ia, {
      view: 0,
      detail: 0
    }), hp = yi(Hu), Xf, pp, yo;
    function xv(re) {
      re !== yo && (yo && re.type === "mousemove" ? (Xf = re.screenX - yo.screenX, pp = re.screenY - yo.screenY) : (Xf = 0, pp = 0), yo = re);
    }
    var Uu = Xr({}, Hu, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: _d,
      button: 0,
      buttons: 0,
      relatedTarget: function(re) {
        return re.relatedTarget === void 0 ? re.fromElement === re.srcElement ? re.toElement : re.fromElement : re.relatedTarget;
      },
      movementX: function(re) {
        return "movementX" in re ? re.movementX : (xv(re), Xf);
      },
      movementY: function(re) {
        return "movementY" in re ? re.movementY : pp;
      }
    }), Zs = yi(Uu), mp = Xr({}, Uu, {
      dataTransfer: 0
    }), jl = yi(mp), Tv = Xr({}, Hu, {
      relatedTarget: 0
    }), Td = yi(Tv), vp = Xr({}, ia, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), wd = yi(vp), Dg = Xr({}, ia, {
      clipboardData: function(re) {
        return "clipboardData" in re ? re.clipboardData : window.clipboardData;
      }
    }), Og = yi(Dg), wv = Xr({}, ia, {
      data: 0
    }), yp = yi(wv), Gl = yp, Lg = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, ju = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function _v(re) {
      if (re.key) {
        var ie = Lg[re.key] || re.key;
        if (ie !== "Unidentified")
          return ie;
      }
      if (re.type === "keypress") {
        var he = Hl(re);
        return he === 13 ? "Enter" : String.fromCharCode(he);
      }
      return re.type === "keydown" || re.type === "keyup" ? ju[re.keyCode] || "Unidentified" : "";
    }
    var li = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function $g(re) {
      var ie = this, he = ie.nativeEvent;
      if (he.getModifierState)
        return he.getModifierState(re);
      var ve = li[re];
      return ve ? !!he[ve] : !1;
    }
    function _d(re) {
      return $g;
    }
    var Ig = Xr({}, Hu, {
      key: _v,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: _d,
      // Legacy Interface
      charCode: function(re) {
        return re.type === "keypress" ? Hl(re) : 0;
      },
      keyCode: function(re) {
        return re.type === "keydown" || re.type === "keyup" ? re.keyCode : 0;
      },
      which: function(re) {
        return re.type === "keypress" ? Hl(re) : re.type === "keydown" || re.type === "keyup" ? re.keyCode : 0;
      }
    }), Ng = yi(Ig), Av = Xr({}, Uu, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), gp = yi(Av), zg = Xr({}, Hu, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: _d
    }), go = yi(zg), Sp = Xr({}, ia, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Vg = yi(Sp), el = Xr({}, Uu, {
      deltaX: function(re) {
        return "deltaX" in re ? re.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in re ? -re.wheelDeltaX : 0
        );
      },
      deltaY: function(re) {
        return "deltaY" in re ? re.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in re ? -re.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in re ? -re.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Ad = yi(el), Wl = [9, 13, 27, 32], Kf = 229, Jf = Rr && "CompositionEvent" in window, ql = null;
    Rr && "documentMode" in document && (ql = document.documentMode);
    var Bg = Rr && "TextEvent" in window && !ql, Pd = Rr && (!Jf || ql && ql > 8 && ql <= 11), Pv = 32, Ep = String.fromCharCode(Pv);
    function Rv() {
      Lr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Lr("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Lr("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Lr("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Zf = !1;
    function Rd(re) {
      return (re.ctrlKey || re.altKey || re.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(re.ctrlKey && re.altKey);
    }
    function kv(re) {
      switch (re) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function bp(re, ie) {
      return re === "keydown" && ie.keyCode === Kf;
    }
    function Mv(re, ie) {
      switch (re) {
        case "keyup":
          return Wl.indexOf(ie.keyCode) !== -1;
        case "keydown":
          return ie.keyCode !== Kf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Cp(re) {
      var ie = re.detail;
      return typeof ie == "object" && "data" in ie ? ie.data : null;
    }
    function kd(re) {
      return re.locale === "ko";
    }
    var gs = !1;
    function xp(re, ie, he, ve, Ce) {
      var ke, at;
      if (Jf ? ke = kv(ie) : gs ? Mv(ie, ve) && (ke = "onCompositionEnd") : bp(ie, ve) && (ke = "onCompositionStart"), !ke)
        return null;
      Pd && !kd(ve) && (!gs && ke === "onCompositionStart" ? gs = Js(Ce) : ke === "onCompositionEnd" && gs && (at = Bu()));
      var mt = $v(he, ke);
      if (mt.length > 0) {
        var gt = new yp(ke, ie, null, ve, Ce);
        if (re.push({
          event: gt,
          listeners: mt
        }), at)
          gt.data = at;
        else {
          var Tt = Cp(ve);
          Tt !== null && (gt.data = Tt);
        }
      }
    }
    function Md(re, ie) {
      switch (re) {
        case "compositionend":
          return Cp(ie);
        case "keypress":
          var he = ie.which;
          return he !== Pv ? null : (Zf = !0, Ep);
        case "textInput":
          var ve = ie.data;
          return ve === Ep && Zf ? null : ve;
        default:
          return null;
      }
    }
    function Fv(re, ie) {
      if (gs) {
        if (re === "compositionend" || !Jf && Mv(re, ie)) {
          var he = Bu();
          return Cd(), gs = !1, he;
        }
        return null;
      }
      switch (re) {
        case "paste":
          return null;
        case "keypress":
          if (!Rd(ie)) {
            if (ie.char && ie.char.length > 1)
              return ie.char;
            if (ie.which)
              return String.fromCharCode(ie.which);
          }
          return null;
        case "compositionend":
          return Pd && !kd(ie) ? null : ie.data;
        default:
          return null;
      }
    }
    function Hg(re, ie, he, ve, Ce) {
      var ke;
      if (Bg ? ke = Md(ie, ve) : ke = Fv(ie, ve), !ke)
        return null;
      var at = $v(he, "onBeforeInput");
      if (at.length > 0) {
        var mt = new Gl("onBeforeInput", "beforeinput", null, ve, Ce);
        re.push({
          event: mt,
          listeners: at
        }), mt.data = ke;
      }
    }
    function Fd(re, ie, he, ve, Ce, ke, at) {
      xp(re, ie, he, ve, Ce), Hg(re, ie, he, ve, Ce);
    }
    var Ug = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Gu(re) {
      var ie = re && re.nodeName && re.nodeName.toLowerCase();
      return ie === "input" ? !!Ug[re.type] : ie === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function jg(re) {
      if (!Rr)
        return !1;
      var ie = "on" + re, he = ie in document;
      if (!he) {
        var ve = document.createElement("div");
        ve.setAttribute(ie, "return;"), he = typeof ve[ie] == "function";
      }
      return he;
    }
    function Dd() {
      Lr("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function fe(re, ie, he, ve) {
      $c(ve);
      var Ce = $v(ie, "onChange");
      if (Ce.length > 0) {
        var ke = new aa("onChange", "change", null, he, ve);
        re.push({
          event: ke,
          listeners: Ce
        });
      }
    }
    var ce = null, Ee = null;
    function Te(re) {
      var ie = re.nodeName && re.nodeName.toLowerCase();
      return ie === "select" || ie === "input" && re.type === "file";
    }
    function nt(re) {
      var ie = [];
      fe(ie, Ee, re, Lc(re)), Mh(ct, ie);
    }
    function ct(re) {
      YS(re, 0);
    }
    function bt(re) {
      var ie = zd(re);
      if (ar(ie))
        return re;
    }
    function Mt(re, ie) {
      if (re === "change")
        return ie;
    }
    var Lt = !1;
    Rr && (Lt = jg("input") && (!document.documentMode || document.documentMode > 9));
    function qt(re, ie) {
      ce = re, Ee = ie, ce.attachEvent("onpropertychange", lr);
    }
    function sr() {
      ce && (ce.detachEvent("onpropertychange", lr), ce = null, Ee = null);
    }
    function lr(re) {
      re.propertyName === "value" && bt(Ee) && nt(re);
    }
    function or(re, ie, he) {
      re === "focusin" ? (sr(), qt(ie, he)) : re === "focusout" && sr();
    }
    function Sr(re, ie) {
      if (re === "selectionchange" || re === "keyup" || re === "keydown")
        return bt(Ee);
    }
    function wr(re) {
      var ie = re.nodeName;
      return ie && ie.toLowerCase() === "input" && (re.type === "checkbox" || re.type === "radio");
    }
    function Pr(re, ie) {
      if (re === "click")
        return bt(ie);
    }
    function ci(re, ie) {
      if (re === "input" || re === "change")
        return bt(ie);
    }
    function Bt(re) {
      var ie = re._wrapperState;
      !ie || !ie.controlled || re.type !== "number" || Fi(re, "number", re.value);
    }
    function It(re, ie, he, ve, Ce, ke, at) {
      var mt = he ? zd(he) : window, gt, Tt;
      if (Te(mt) ? gt = Mt : Gu(mt) ? Lt ? gt = ci : (gt = Sr, Tt = or) : wr(mt) && (gt = Pr), gt) {
        var Pt = gt(ie, he);
        if (Pt) {
          fe(re, Pt, ve, Ce);
          return;
        }
      }
      Tt && Tt(ie, mt, he), ie === "focusout" && Bt(mt);
    }
    function jt() {
      en("onMouseEnter", ["mouseout", "mouseover"]), en("onMouseLeave", ["mouseout", "mouseover"]), en("onPointerEnter", ["pointerout", "pointerover"]), en("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function fr(re, ie, he, ve, Ce, ke, at) {
      var mt = ie === "mouseover" || ie === "pointerover", gt = ie === "mouseout" || ie === "pointerout";
      if (mt && !Qm(ve)) {
        var Tt = ve.relatedTarget || ve.fromElement;
        if (Tt && (rc(Tt) || Ip(Tt)))
          return;
      }
      if (!(!gt && !mt)) {
        var Pt;
        if (Ce.window === Ce)
          Pt = Ce;
        else {
          var Nt = Ce.ownerDocument;
          Nt ? Pt = Nt.defaultView || Nt.parentWindow : Pt = window;
        }
        var $t, Gt;
        if (gt) {
          var Wt = ve.relatedTarget || ve.toElement;
          if ($t = he, Gt = Wt ? rc(Wt) : null, Gt !== null) {
            var Xt = Ga(Gt);
            (Gt !== Xt || Gt.tag !== pt && Gt.tag !== it) && (Gt = null);
          }
        } else
          $t = null, Gt = he;
        if ($t !== Gt) {
          var br = Zs, $r = "onMouseLeave", Mr = "onMouseEnter", sn = "mouse";
          (ie === "pointerout" || ie === "pointerover") && (br = gp, $r = "onPointerLeave", Mr = "onPointerEnter", sn = "pointer");
          var rn = $t == null ? Pt : zd($t), Ht = Gt == null ? Pt : zd(Gt), Kt = new br($r, sn + "leave", $t, ve, Ce);
          Kt.target = rn, Kt.relatedTarget = Ht;
          var Ut = null, ur = rc(Ce);
          if (ur === he) {
            var Cr = new br(Mr, sn + "enter", Gt, ve, Ce);
            Cr.target = Ht, Cr.relatedTarget = rn, Ut = Cr;
          }
          $x(re, Kt, Ut, $t, Gt);
        }
      }
    }
    function kr(re, ie) {
      return re === ie && (re !== 0 || 1 / re === 1 / ie) || re !== re && ie !== ie;
    }
    var _r = typeof Object.is == "function" ? Object.is : kr;
    function Dr(re, ie) {
      if (_r(re, ie))
        return !0;
      if (typeof re != "object" || re === null || typeof ie != "object" || ie === null)
        return !1;
      var he = Object.keys(re), ve = Object.keys(ie);
      if (he.length !== ve.length)
        return !1;
      for (var Ce = 0; Ce < he.length; Ce++) {
        var ke = he[Ce];
        if (!cr.call(ie, ke) || !_r(re[ke], ie[ke]))
          return !1;
      }
      return !0;
    }
    function Ur(re) {
      for (; re && re.firstChild; )
        re = re.firstChild;
      return re;
    }
    function zi(re) {
      for (; re; ) {
        if (re.nextSibling)
          return re.nextSibling;
        re = re.parentNode;
      }
    }
    function un(re, ie) {
      for (var he = Ur(re), ve = 0, Ce = 0; he; ) {
        if (he.nodeType === as) {
          if (Ce = ve + he.textContent.length, ve <= ie && Ce >= ie)
            return {
              node: he,
              offset: ie - ve
            };
          ve = Ce;
        }
        he = Ur(zi(he));
      }
    }
    function tl(re) {
      var ie = re.ownerDocument, he = ie && ie.defaultView || window, ve = he.getSelection && he.getSelection();
      if (!ve || ve.rangeCount === 0)
        return null;
      var Ce = ve.anchorNode, ke = ve.anchorOffset, at = ve.focusNode, mt = ve.focusOffset;
      try {
        Ce.nodeType, at.nodeType;
      } catch {
        return null;
      }
      return Gg(re, Ce, ke, at, mt);
    }
    function Gg(re, ie, he, ve, Ce) {
      var ke = 0, at = -1, mt = -1, gt = 0, Tt = 0, Pt = re, Nt = null;
      e:
        for (; ; ) {
          for (var $t = null; Pt === ie && (he === 0 || Pt.nodeType === as) && (at = ke + he), Pt === ve && (Ce === 0 || Pt.nodeType === as) && (mt = ke + Ce), Pt.nodeType === as && (ke += Pt.nodeValue.length), ($t = Pt.firstChild) !== null; )
            Nt = Pt, Pt = $t;
          for (; ; ) {
            if (Pt === re)
              break e;
            if (Nt === ie && ++gt === he && (at = ke), Nt === ve && ++Tt === Ce && (mt = ke), ($t = Pt.nextSibling) !== null)
              break;
            Pt = Nt, Nt = Pt.parentNode;
          }
          Pt = $t;
        }
      return at === -1 || mt === -1 ? null : {
        start: at,
        end: mt
      };
    }
    function yx(re, ie) {
      var he = re.ownerDocument || document, ve = he && he.defaultView || window;
      if (ve.getSelection) {
        var Ce = ve.getSelection(), ke = re.textContent.length, at = Math.min(ie.start, ke), mt = ie.end === void 0 ? at : Math.min(ie.end, ke);
        if (!Ce.extend && at > mt) {
          var gt = mt;
          mt = at, at = gt;
        }
        var Tt = un(re, at), Pt = un(re, mt);
        if (Tt && Pt) {
          if (Ce.rangeCount === 1 && Ce.anchorNode === Tt.node && Ce.anchorOffset === Tt.offset && Ce.focusNode === Pt.node && Ce.focusOffset === Pt.offset)
            return;
          var Nt = he.createRange();
          Nt.setStart(Tt.node, Tt.offset), Ce.removeAllRanges(), at > mt ? (Ce.addRange(Nt), Ce.extend(Pt.node, Pt.offset)) : (Nt.setEnd(Pt.node, Pt.offset), Ce.addRange(Nt));
        }
      }
    }
    function $S(re) {
      return re && re.nodeType === as;
    }
    function IS(re, ie) {
      return !re || !ie ? !1 : re === ie ? !0 : $S(re) ? !1 : $S(ie) ? IS(re, ie.parentNode) : "contains" in re ? re.contains(ie) : re.compareDocumentPosition ? !!(re.compareDocumentPosition(ie) & 16) : !1;
    }
    function gx(re) {
      return re && re.ownerDocument && IS(re.ownerDocument.documentElement, re);
    }
    function Sx(re) {
      try {
        return typeof re.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function NS() {
      for (var re = window, ie = gr(); ie instanceof re.HTMLIFrameElement; ) {
        if (Sx(ie))
          re = ie.contentWindow;
        else
          return ie;
        ie = gr(re.document);
      }
      return ie;
    }
    function Wg(re) {
      var ie = re && re.nodeName && re.nodeName.toLowerCase();
      return ie && (ie === "input" && (re.type === "text" || re.type === "search" || re.type === "tel" || re.type === "url" || re.type === "password") || ie === "textarea" || re.contentEditable === "true");
    }
    function Ex() {
      var re = NS();
      return {
        focusedElem: re,
        selectionRange: Wg(re) ? Cx(re) : null
      };
    }
    function bx(re) {
      var ie = NS(), he = re.focusedElem, ve = re.selectionRange;
      if (ie !== he && gx(he)) {
        ve !== null && Wg(he) && xx(he, ve);
        for (var Ce = [], ke = he; ke = ke.parentNode; )
          ke.nodeType === wa && Ce.push({
            element: ke,
            left: ke.scrollLeft,
            top: ke.scrollTop
          });
        typeof he.focus == "function" && he.focus();
        for (var at = 0; at < Ce.length; at++) {
          var mt = Ce[at];
          mt.element.scrollLeft = mt.left, mt.element.scrollTop = mt.top;
        }
      }
    }
    function Cx(re) {
      var ie;
      return "selectionStart" in re ? ie = {
        start: re.selectionStart,
        end: re.selectionEnd
      } : ie = tl(re), ie || {
        start: 0,
        end: 0
      };
    }
    function xx(re, ie) {
      var he = ie.start, ve = ie.end;
      ve === void 0 && (ve = he), "selectionStart" in re ? (re.selectionStart = he, re.selectionEnd = Math.min(ve, re.value.length)) : yx(re, ie);
    }
    var Tx = Rr && "documentMode" in document && document.documentMode <= 11;
    function wx() {
      Lr("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Od = null, qg = null, Tp = null, Yg = !1;
    function _x(re) {
      if ("selectionStart" in re && Wg(re))
        return {
          start: re.selectionStart,
          end: re.selectionEnd
        };
      var ie = re.ownerDocument && re.ownerDocument.defaultView || window, he = ie.getSelection();
      return {
        anchorNode: he.anchorNode,
        anchorOffset: he.anchorOffset,
        focusNode: he.focusNode,
        focusOffset: he.focusOffset
      };
    }
    function Ax(re) {
      return re.window === re ? re.document : re.nodeType === _o ? re : re.ownerDocument;
    }
    function zS(re, ie, he) {
      var ve = Ax(he);
      if (!(Yg || Od == null || Od !== gr(ve))) {
        var Ce = _x(Od);
        if (!Tp || !Dr(Tp, Ce)) {
          Tp = Ce;
          var ke = $v(qg, "onSelect");
          if (ke.length > 0) {
            var at = new aa("onSelect", "select", null, ie, he);
            re.push({
              event: at,
              listeners: ke
            }), at.target = Od;
          }
        }
      }
    }
    function Px(re, ie, he, ve, Ce, ke, at) {
      var mt = he ? zd(he) : window;
      switch (ie) {
        case "focusin":
          (Gu(mt) || mt.contentEditable === "true") && (Od = mt, qg = he, Tp = null);
          break;
        case "focusout":
          Od = null, qg = null, Tp = null;
          break;
        case "mousedown":
          Yg = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Yg = !1, zS(re, ve, Ce);
          break;
        case "selectionchange":
          if (Tx)
            break;
        case "keydown":
        case "keyup":
          zS(re, ve, Ce);
      }
    }
    function Dv(re, ie) {
      var he = {};
      return he[re.toLowerCase()] = ie.toLowerCase(), he["Webkit" + re] = "webkit" + ie, he["Moz" + re] = "moz" + ie, he;
    }
    var Ld = {
      animationend: Dv("Animation", "AnimationEnd"),
      animationiteration: Dv("Animation", "AnimationIteration"),
      animationstart: Dv("Animation", "AnimationStart"),
      transitionend: Dv("Transition", "TransitionEnd")
    }, Qg = {}, VS = {};
    Rr && (VS = document.createElement("div").style, "AnimationEvent" in window || (delete Ld.animationend.animation, delete Ld.animationiteration.animation, delete Ld.animationstart.animation), "TransitionEvent" in window || delete Ld.transitionend.transition);
    function Ov(re) {
      if (Qg[re])
        return Qg[re];
      if (!Ld[re])
        return re;
      var ie = Ld[re];
      for (var he in ie)
        if (ie.hasOwnProperty(he) && he in VS)
          return Qg[re] = ie[he];
      return re;
    }
    var BS = Ov("animationend"), HS = Ov("animationiteration"), US = Ov("animationstart"), jS = Ov("transitionend"), GS = /* @__PURE__ */ new Map(), WS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Wu(re, ie) {
      GS.set(re, ie), Lr(ie, [re]);
    }
    function Rx() {
      for (var re = 0; re < WS.length; re++) {
        var ie = WS[re], he = ie.toLowerCase(), ve = ie[0].toUpperCase() + ie.slice(1);
        Wu(he, "on" + ve);
      }
      Wu(BS, "onAnimationEnd"), Wu(HS, "onAnimationIteration"), Wu(US, "onAnimationStart"), Wu("dblclick", "onDoubleClick"), Wu("focusin", "onFocus"), Wu("focusout", "onBlur"), Wu(jS, "onTransitionEnd");
    }
    function kx(re, ie, he, ve, Ce, ke, at) {
      var mt = GS.get(ie);
      if (mt !== void 0) {
        var gt = aa, Tt = ie;
        switch (ie) {
          case "keypress":
            if (Hl(ve) === 0)
              return;
          case "keydown":
          case "keyup":
            gt = Ng;
            break;
          case "focusin":
            Tt = "focus", gt = Td;
            break;
          case "focusout":
            Tt = "blur", gt = Td;
            break;
          case "beforeblur":
          case "afterblur":
            gt = Td;
            break;
          case "click":
            if (ve.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            gt = Zs;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            gt = jl;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            gt = go;
            break;
          case BS:
          case HS:
          case US:
            gt = wd;
            break;
          case jS:
            gt = Vg;
            break;
          case "scroll":
            gt = hp;
            break;
          case "wheel":
            gt = Ad;
            break;
          case "copy":
          case "cut":
          case "paste":
            gt = Og;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            gt = gp;
            break;
        }
        var Pt = (ke & Cl) !== 0;
        {
          var Nt = !Pt && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          ie === "scroll", $t = Ox(he, mt, ve.type, Pt, Nt);
          if ($t.length > 0) {
            var Gt = new gt(mt, Tt, null, ve, Ce);
            re.push({
              event: Gt,
              listeners: $t
            });
          }
        }
      }
    }
    Rx(), jt(), Dd(), wx(), Rv();
    function Mx(re, ie, he, ve, Ce, ke, at) {
      kx(re, ie, he, ve, Ce, ke);
      var mt = (ke & bg) === 0;
      mt && (fr(re, ie, he, ve, Ce), It(re, ie, he, ve, Ce), Px(re, ie, he, ve, Ce), Fd(re, ie, he, ve, Ce));
    }
    var wp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Xg = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(wp));
    function qS(re, ie, he) {
      var ve = re.type || "unknown-event";
      re.currentTarget = he, us(ve, ie, void 0, re), re.currentTarget = null;
    }
    function Fx(re, ie, he) {
      var ve;
      if (he)
        for (var Ce = ie.length - 1; Ce >= 0; Ce--) {
          var ke = ie[Ce], at = ke.instance, mt = ke.currentTarget, gt = ke.listener;
          if (at !== ve && re.isPropagationStopped())
            return;
          qS(re, gt, mt), ve = at;
        }
      else
        for (var Tt = 0; Tt < ie.length; Tt++) {
          var Pt = ie[Tt], Nt = Pt.instance, $t = Pt.currentTarget, Gt = Pt.listener;
          if (Nt !== ve && re.isPropagationStopped())
            return;
          qS(re, Gt, $t), ve = Nt;
        }
    }
    function YS(re, ie) {
      for (var he = (ie & Cl) !== 0, ve = 0; ve < re.length; ve++) {
        var Ce = re[ve], ke = Ce.event, at = Ce.listeners;
        Fx(ke, at, he);
      }
      Lh();
    }
    function Dx(re, ie, he, ve, Ce) {
      var ke = Lc(he), at = [];
      Mx(at, re, ve, he, ke, ie), YS(at, ie);
    }
    function Qn(re, ie) {
      Xg.has(re) || be('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', re);
      var he = !1, ve = uw(ie), Ce = Ix(re, he);
      ve.has(Ce) || (QS(ie, re, Tf, he), ve.add(Ce));
    }
    function Kg(re, ie, he) {
      Xg.has(re) && !ie && be('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', re);
      var ve = 0;
      ie && (ve |= Cl), QS(he, re, ve, ie);
    }
    var Lv = "_reactListening" + Math.random().toString(36).slice(2);
    function _p(re) {
      if (!re[Lv]) {
        re[Lv] = !0, Zr.forEach(function(he) {
          he !== "selectionchange" && (Xg.has(he) || Kg(he, !1, re), Kg(he, !0, re));
        });
        var ie = re.nodeType === _o ? re : re.ownerDocument;
        ie !== null && (ie[Lv] || (ie[Lv] = !0, Kg("selectionchange", !1, ie)));
      }
    }
    function QS(re, ie, he, ve, Ce) {
      var ke = Nu(re, ie, he), at = void 0;
      Rf && (ie === "touchstart" || ie === "touchmove" || ie === "wheel") && (at = !0), re = re, ve ? at !== void 0 ? ys(re, ie, ke, at) : Vu(re, ie, ke) : at !== void 0 ? bd(re, ie, ke, at) : dp(re, ie, ke);
    }
    function XS(re, ie) {
      return re === ie || re.nodeType === mi && re.parentNode === ie;
    }
    function Jg(re, ie, he, ve, Ce) {
      var ke = ve;
      if (!(ie & ss) && !(ie & Tf)) {
        var at = Ce;
        if (ve !== null) {
          var mt = ve;
          e:
            for (; ; ) {
              if (mt === null)
                return;
              var gt = mt.tag;
              if (gt === dt || gt === lt) {
                var Tt = mt.stateNode.containerInfo;
                if (XS(Tt, at))
                  break;
                if (gt === lt)
                  for (var Pt = mt.return; Pt !== null; ) {
                    var Nt = Pt.tag;
                    if (Nt === dt || Nt === lt) {
                      var $t = Pt.stateNode.containerInfo;
                      if (XS($t, at))
                        return;
                    }
                    Pt = Pt.return;
                  }
                for (; Tt !== null; ) {
                  var Gt = rc(Tt);
                  if (Gt === null)
                    return;
                  var Wt = Gt.tag;
                  if (Wt === pt || Wt === it) {
                    mt = ke = Gt;
                    continue e;
                  }
                  Tt = Tt.parentNode;
                }
              }
              mt = mt.return;
            }
        }
      }
      Mh(function() {
        return Dx(re, ie, he, ke);
      });
    }
    function Ap(re, ie, he) {
      return {
        instance: re,
        listener: ie,
        currentTarget: he
      };
    }
    function Ox(re, ie, he, ve, Ce, ke) {
      for (var at = ie !== null ? ie + "Capture" : null, mt = ve ? at : ie, gt = [], Tt = re, Pt = null; Tt !== null; ) {
        var Nt = Tt, $t = Nt.stateNode, Gt = Nt.tag;
        if (Gt === pt && $t !== null && (Pt = $t, mt !== null)) {
          var Wt = Tl(Tt, mt);
          Wt != null && gt.push(Ap(Tt, Wt, Pt));
        }
        if (Ce)
          break;
        Tt = Tt.return;
      }
      return gt;
    }
    function $v(re, ie) {
      for (var he = ie + "Capture", ve = [], Ce = re; Ce !== null; ) {
        var ke = Ce, at = ke.stateNode, mt = ke.tag;
        if (mt === pt && at !== null) {
          var gt = at, Tt = Tl(Ce, he);
          Tt != null && ve.unshift(Ap(Ce, Tt, gt));
          var Pt = Tl(Ce, ie);
          Pt != null && ve.push(Ap(Ce, Pt, gt));
        }
        Ce = Ce.return;
      }
      return ve;
    }
    function $d(re) {
      if (re === null)
        return null;
      do
        re = re.return;
      while (re && re.tag !== pt);
      return re || null;
    }
    function Lx(re, ie) {
      for (var he = re, ve = ie, Ce = 0, ke = he; ke; ke = $d(ke))
        Ce++;
      for (var at = 0, mt = ve; mt; mt = $d(mt))
        at++;
      for (; Ce - at > 0; )
        he = $d(he), Ce--;
      for (; at - Ce > 0; )
        ve = $d(ve), at--;
      for (var gt = Ce; gt--; ) {
        if (he === ve || ve !== null && he === ve.alternate)
          return he;
        he = $d(he), ve = $d(ve);
      }
      return null;
    }
    function KS(re, ie, he, ve, Ce) {
      for (var ke = ie._reactName, at = [], mt = he; mt !== null && mt !== ve; ) {
        var gt = mt, Tt = gt.alternate, Pt = gt.stateNode, Nt = gt.tag;
        if (Tt !== null && Tt === ve)
          break;
        if (Nt === pt && Pt !== null) {
          var $t = Pt;
          if (Ce) {
            var Gt = Tl(mt, ke);
            Gt != null && at.unshift(Ap(mt, Gt, $t));
          } else if (!Ce) {
            var Wt = Tl(mt, ke);
            Wt != null && at.push(Ap(mt, Wt, $t));
          }
        }
        mt = mt.return;
      }
      at.length !== 0 && re.push({
        event: ie,
        listeners: at
      });
    }
    function $x(re, ie, he, ve, Ce) {
      var ke = ve && Ce ? Lx(ve, Ce) : null;
      ve !== null && KS(re, ie, ve, ke, !1), Ce !== null && he !== null && KS(re, he, Ce, ke, !0);
    }
    function Ix(re, ie) {
      return re + "__" + (ie ? "capture" : "bubble");
    }
    var So = !1, Pp = "dangerouslySetInnerHTML", Iv = "suppressContentEditableWarning", qu = "suppressHydrationWarning", JS = "autoFocus", ec = "children", tc = "style", Nv = "__html", Zg, zv, Rp, ZS, Vv, eE, tE;
    Zg = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, zv = function(re, ie) {
      Oc(re, ie), _h(re, ie), Ym(re, ie, {
        registrationNameDependencies: xn,
        possibleRegistrationNames: kn
      });
    }, eE = Rr && !document.documentMode, Rp = function(re, ie, he) {
      if (!So) {
        var ve = Bv(he), Ce = Bv(ie);
        Ce !== ve && (So = !0, be("Prop `%s` did not match. Server: %s Client: %s", re, JSON.stringify(Ce), JSON.stringify(ve)));
      }
    }, ZS = function(re) {
      if (!So) {
        So = !0;
        var ie = [];
        re.forEach(function(he) {
          ie.push(he);
        }), be("Extra attributes from the server: %s", ie);
      }
    }, Vv = function(re, ie) {
      ie === !1 ? be("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", re, re, re) : be("Expected `%s` listener to be a function, instead got a value of `%s` type.", re, typeof ie);
    }, tE = function(re, ie) {
      var he = re.namespaceURI === is ? re.ownerDocument.createElement(re.tagName) : re.ownerDocument.createElementNS(re.namespaceURI, re.tagName);
      return he.innerHTML = ie, he.innerHTML;
    };
    var Nx = /\r\n?/g, zx = /\u0000|\uFFFD/g;
    function Bv(re) {
      ki(re);
      var ie = typeof re == "string" ? re : "" + re;
      return ie.replace(Nx, `
`).replace(zx, "");
    }
    function Hv(re, ie, he, ve) {
      var Ce = Bv(ie), ke = Bv(re);
      if (ke !== Ce && (ve && (So || (So = !0, be('Text content did not match. Server: "%s" Client: "%s"', ke, Ce))), he && Ft))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function rE(re) {
      return re.nodeType === _o ? re : re.ownerDocument;
    }
    function Vx() {
    }
    function Uv(re) {
      re.onclick = Vx;
    }
    function Bx(re, ie, he, ve, Ce) {
      for (var ke in ve)
        if (ve.hasOwnProperty(ke)) {
          var at = ve[ke];
          if (ke === tc)
            at && Object.freeze(at), Nm(ie, at);
          else if (ke === Pp) {
            var mt = at ? at[Nv] : void 0;
            mt != null && Am(ie, mt);
          } else if (ke === ec)
            if (typeof at == "string") {
              var gt = re !== "textarea" || at !== "";
              gt && kc(ie, at);
            } else
              typeof at == "number" && kc(ie, "" + at);
          else
            ke === Iv || ke === qu || ke === JS || (xn.hasOwnProperty(ke) ? at != null && (typeof at != "function" && Vv(ke, at), ke === "onScroll" && Qn("scroll", ie)) : at != null && es(ie, ke, at, Ce));
        }
    }
    function Hx(re, ie, he, ve) {
      for (var Ce = 0; Ce < ie.length; Ce += 2) {
        var ke = ie[Ce], at = ie[Ce + 1];
        ke === tc ? Nm(re, at) : ke === Pp ? Am(re, at) : ke === ec ? kc(re, at) : es(re, ke, at, ve);
      }
    }
    function Ux(re, ie, he, ve) {
      var Ce, ke = rE(he), at, mt = ve;
      if (mt === is && (mt = Pc(re)), mt === is) {
        if (Ce = os(re, ie), !Ce && re !== re.toLowerCase() && be("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", re), re === "script") {
          var gt = ke.createElement("div");
          gt.innerHTML = "<script><\/script>";
          var Tt = gt.firstChild;
          at = gt.removeChild(Tt);
        } else if (typeof ie.is == "string")
          at = ke.createElement(re, {
            is: ie.is
          });
        else if (at = ke.createElement(re), re === "select") {
          var Pt = at;
          ie.multiple ? Pt.multiple = !0 : ie.size && (Pt.size = ie.size);
        }
      } else
        at = ke.createElementNS(mt, re);
      return mt === is && !Ce && Object.prototype.toString.call(at) === "[object HTMLUnknownElement]" && !cr.call(Zg, re) && (Zg[re] = !0, be("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", re)), at;
    }
    function jx(re, ie) {
      return rE(ie).createTextNode(re);
    }
    function Gx(re, ie, he, ve) {
      var Ce = os(ie, he);
      zv(ie, he);
      var ke;
      switch (ie) {
        case "dialog":
          Qn("cancel", re), Qn("close", re), ke = he;
          break;
        case "iframe":
        case "object":
        case "embed":
          Qn("load", re), ke = he;
          break;
        case "video":
        case "audio":
          for (var at = 0; at < wp.length; at++)
            Qn(wp[at], re);
          ke = he;
          break;
        case "source":
          Qn("error", re), ke = he;
          break;
        case "img":
        case "image":
        case "link":
          Qn("error", re), Qn("load", re), ke = he;
          break;
        case "details":
          Qn("toggle", re), ke = he;
          break;
        case "input":
          Ci(re, he), ke = En(re, he), Qn("invalid", re);
          break;
        case "option":
          ns(re, he), ke = he;
          break;
        case "select":
          xm(re, he), ke = mh(re, he), Qn("invalid", re);
          break;
        case "textarea":
          Tm(re, he), ke = yh(re, he), Qn("invalid", re);
          break;
        default:
          ke = he;
      }
      switch (Fc(ie, ke), Bx(ie, re, ve, ke, Ce), ie) {
        case "input":
          zt(re), Mi(re, he, !1);
          break;
        case "textarea":
          zt(re), _m(re);
          break;
        case "option":
          ph(re, he);
          break;
        case "select":
          fg(re, he);
          break;
        default:
          typeof ke.onClick == "function" && Uv(re);
          break;
      }
    }
    function Wx(re, ie, he, ve, Ce) {
      zv(ie, ve);
      var ke = null, at, mt;
      switch (ie) {
        case "input":
          at = En(re, he), mt = En(re, ve), ke = [];
          break;
        case "select":
          at = mh(re, he), mt = mh(re, ve), ke = [];
          break;
        case "textarea":
          at = yh(re, he), mt = yh(re, ve), ke = [];
          break;
        default:
          at = he, mt = ve, typeof at.onClick != "function" && typeof mt.onClick == "function" && Uv(re);
          break;
      }
      Fc(ie, mt);
      var gt, Tt, Pt = null;
      for (gt in at)
        if (!(mt.hasOwnProperty(gt) || !at.hasOwnProperty(gt) || at[gt] == null))
          if (gt === tc) {
            var Nt = at[gt];
            for (Tt in Nt)
              Nt.hasOwnProperty(Tt) && (Pt || (Pt = {}), Pt[Tt] = "");
          } else
            gt === Pp || gt === ec || gt === Iv || gt === qu || gt === JS || (xn.hasOwnProperty(gt) ? ke || (ke = []) : (ke = ke || []).push(gt, null));
      for (gt in mt) {
        var $t = mt[gt], Gt = at != null ? at[gt] : void 0;
        if (!(!mt.hasOwnProperty(gt) || $t === Gt || $t == null && Gt == null))
          if (gt === tc)
            if ($t && Object.freeze($t), Gt) {
              for (Tt in Gt)
                Gt.hasOwnProperty(Tt) && (!$t || !$t.hasOwnProperty(Tt)) && (Pt || (Pt = {}), Pt[Tt] = "");
              for (Tt in $t)
                $t.hasOwnProperty(Tt) && Gt[Tt] !== $t[Tt] && (Pt || (Pt = {}), Pt[Tt] = $t[Tt]);
            } else
              Pt || (ke || (ke = []), ke.push(gt, Pt)), Pt = $t;
          else if (gt === Pp) {
            var Wt = $t ? $t[Nv] : void 0, Xt = Gt ? Gt[Nv] : void 0;
            Wt != null && Xt !== Wt && (ke = ke || []).push(gt, Wt);
          } else
            gt === ec ? (typeof $t == "string" || typeof $t == "number") && (ke = ke || []).push(gt, "" + $t) : gt === Iv || gt === qu || (xn.hasOwnProperty(gt) ? ($t != null && (typeof $t != "function" && Vv(gt, $t), gt === "onScroll" && Qn("scroll", re)), !ke && Gt !== $t && (ke = [])) : (ke = ke || []).push(gt, $t));
      }
      return Pt && (Cf(Pt, mt[tc]), (ke = ke || []).push(tc, Pt)), ke;
    }
    function qx(re, ie, he, ve, Ce) {
      he === "input" && Ce.type === "radio" && Ce.name != null && la(re, Ce);
      var ke = os(he, ve), at = os(he, Ce);
      switch (Hx(re, ie, ke, at), he) {
        case "input":
          Gn(re, Ce);
          break;
        case "textarea":
          wm(re, Ce);
          break;
        case "select":
          cg(re, Ce);
          break;
      }
    }
    function Yx(re) {
      {
        var ie = re.toLowerCase();
        return Dc.hasOwnProperty(ie) && Dc[ie] || null;
      }
    }
    function Qx(re, ie, he, ve, Ce, ke, at) {
      var mt, gt;
      switch (mt = os(ie, he), zv(ie, he), ie) {
        case "dialog":
          Qn("cancel", re), Qn("close", re);
          break;
        case "iframe":
        case "object":
        case "embed":
          Qn("load", re);
          break;
        case "video":
        case "audio":
          for (var Tt = 0; Tt < wp.length; Tt++)
            Qn(wp[Tt], re);
          break;
        case "source":
          Qn("error", re);
          break;
        case "img":
        case "image":
        case "link":
          Qn("error", re), Qn("load", re);
          break;
        case "details":
          Qn("toggle", re);
          break;
        case "input":
          Ci(re, he), Qn("invalid", re);
          break;
        case "option":
          ns(re, he);
          break;
        case "select":
          xm(re, he), Qn("invalid", re);
          break;
        case "textarea":
          Tm(re, he), Qn("invalid", re);
          break;
      }
      Fc(ie, he);
      {
        gt = /* @__PURE__ */ new Set();
        for (var Pt = re.attributes, Nt = 0; Nt < Pt.length; Nt++) {
          var $t = Pt[Nt].name.toLowerCase();
          switch ($t) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              gt.add(Pt[Nt].name);
          }
        }
      }
      var Gt = null;
      for (var Wt in he)
        if (he.hasOwnProperty(Wt)) {
          var Xt = he[Wt];
          if (Wt === ec)
            typeof Xt == "string" ? re.textContent !== Xt && (he[qu] !== !0 && Hv(re.textContent, Xt, ke, at), Gt = [ec, Xt]) : typeof Xt == "number" && re.textContent !== "" + Xt && (he[qu] !== !0 && Hv(re.textContent, Xt, ke, at), Gt = [ec, "" + Xt]);
          else if (xn.hasOwnProperty(Wt))
            Xt != null && (typeof Xt != "function" && Vv(Wt, Xt), Wt === "onScroll" && Qn("scroll", re));
          else if (at && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof mt == "boolean") {
            var br = void 0, $r = mt && vr ? null : Va(Wt);
            if (he[qu] !== !0) {
              if (!(Wt === Iv || Wt === qu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Wt === "value" || Wt === "checked" || Wt === "selected")) {
                if (Wt === Pp) {
                  var Mr = re.innerHTML, sn = Xt ? Xt[Nv] : void 0;
                  if (sn != null) {
                    var rn = tE(re, sn);
                    rn !== Mr && Rp(Wt, Mr, rn);
                  }
                } else if (Wt === tc) {
                  if (gt.delete(Wt), eE) {
                    var Ht = Sg(Xt);
                    br = re.getAttribute("style"), Ht !== br && Rp(Wt, br, Ht);
                  }
                } else if (mt && !vr)
                  gt.delete(Wt.toLowerCase()), br = uu(re, Wt, Xt), Xt !== br && Rp(Wt, br, Xt);
                else if (!ti(Wt, $r, mt) && !mn(Wt, Xt, $r, mt)) {
                  var Kt = !1;
                  if ($r !== null)
                    gt.delete($r.attributeName), br = dl(re, Wt, Xt, $r);
                  else {
                    var Ut = ve;
                    if (Ut === is && (Ut = Pc(ie)), Ut === is)
                      gt.delete(Wt.toLowerCase());
                    else {
                      var ur = Yx(Wt);
                      ur !== null && ur !== Wt && (Kt = !0, gt.delete(ur)), gt.delete(Wt);
                    }
                    br = uu(re, Wt, Xt);
                  }
                  var Cr = vr;
                  !Cr && Xt !== br && !Kt && Rp(Wt, br, Xt);
                }
              }
            }
          }
        }
      switch (at && // $FlowFixMe - Should be inferred as not undefined.
      gt.size > 0 && he[qu] !== !0 && ZS(gt), ie) {
        case "input":
          zt(re), Mi(re, he, !0);
          break;
        case "textarea":
          zt(re), _m(re);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof he.onClick == "function" && Uv(re);
          break;
      }
      return Gt;
    }
    function Xx(re, ie, he) {
      var ve = re.nodeValue !== ie;
      return ve;
    }
    function e0(re, ie) {
      {
        if (So)
          return;
        So = !0, be("Did not expect server HTML to contain a <%s> in <%s>.", ie.nodeName.toLowerCase(), re.nodeName.toLowerCase());
      }
    }
    function t0(re, ie) {
      {
        if (So)
          return;
        So = !0, be('Did not expect server HTML to contain the text node "%s" in <%s>.', ie.nodeValue, re.nodeName.toLowerCase());
      }
    }
    function r0(re, ie, he) {
      {
        if (So)
          return;
        So = !0, be("Expected server HTML to contain a matching <%s> in <%s>.", ie, re.nodeName.toLowerCase());
      }
    }
    function n0(re, ie) {
      {
        if (ie === "" || So)
          return;
        So = !0, be('Expected server HTML to contain a matching text node for "%s" in <%s>.', ie, re.nodeName.toLowerCase());
      }
    }
    function Kx(re, ie, he) {
      switch (ie) {
        case "input":
          ua(re, he);
          return;
        case "textarea":
          gh(re, he);
          return;
        case "select":
          dg(re, he);
          return;
      }
    }
    var kp = function() {
    }, Mp = function() {
    };
    {
      var Jx = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], nE = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], Zx = nE.concat(["button"]), eT = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], iE = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Mp = function(re, ie) {
        var he = Xr({}, re || iE), ve = {
          tag: ie
        };
        return nE.indexOf(ie) !== -1 && (he.aTagInScope = null, he.buttonTagInScope = null, he.nobrTagInScope = null), Zx.indexOf(ie) !== -1 && (he.pTagInButtonScope = null), Jx.indexOf(ie) !== -1 && ie !== "address" && ie !== "div" && ie !== "p" && (he.listItemTagAutoclosing = null, he.dlItemTagAutoclosing = null), he.current = ve, ie === "form" && (he.formTag = ve), ie === "a" && (he.aTagInScope = ve), ie === "button" && (he.buttonTagInScope = ve), ie === "nobr" && (he.nobrTagInScope = ve), ie === "p" && (he.pTagInButtonScope = ve), ie === "li" && (he.listItemTagAutoclosing = ve), (ie === "dd" || ie === "dt") && (he.dlItemTagAutoclosing = ve), he;
      };
      var tT = function(re, ie) {
        switch (ie) {
          case "select":
            return re === "option" || re === "optgroup" || re === "#text";
          case "optgroup":
            return re === "option" || re === "#text";
          case "option":
            return re === "#text";
          case "tr":
            return re === "th" || re === "td" || re === "style" || re === "script" || re === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return re === "tr" || re === "style" || re === "script" || re === "template";
          case "colgroup":
            return re === "col" || re === "template";
          case "table":
            return re === "caption" || re === "colgroup" || re === "tbody" || re === "tfoot" || re === "thead" || re === "style" || re === "script" || re === "template";
          case "head":
            return re === "base" || re === "basefont" || re === "bgsound" || re === "link" || re === "meta" || re === "title" || re === "noscript" || re === "noframes" || re === "style" || re === "script" || re === "template";
          case "html":
            return re === "head" || re === "body" || re === "frameset";
          case "frameset":
            return re === "frame";
          case "#document":
            return re === "html";
        }
        switch (re) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ie !== "h1" && ie !== "h2" && ie !== "h3" && ie !== "h4" && ie !== "h5" && ie !== "h6";
          case "rp":
          case "rt":
            return eT.indexOf(ie) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return ie == null;
        }
        return !0;
      }, rT = function(re, ie) {
        switch (re) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ie.pTagInButtonScope;
          case "form":
            return ie.formTag || ie.pTagInButtonScope;
          case "li":
            return ie.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ie.dlItemTagAutoclosing;
          case "button":
            return ie.buttonTagInScope;
          case "a":
            return ie.aTagInScope;
          case "nobr":
            return ie.nobrTagInScope;
        }
        return null;
      }, aE = {};
      kp = function(re, ie, he) {
        he = he || iE;
        var ve = he.current, Ce = ve && ve.tag;
        ie != null && (re != null && be("validateDOMNesting: when childText is passed, childTag should be null"), re = "#text");
        var ke = tT(re, Ce) ? null : ve, at = ke ? null : rT(re, he), mt = ke || at;
        if (mt) {
          var gt = mt.tag, Tt = !!ke + "|" + re + "|" + gt;
          if (!aE[Tt]) {
            aE[Tt] = !0;
            var Pt = re, Nt = "";
            if (re === "#text" ? /\S/.test(ie) ? Pt = "Text nodes" : (Pt = "Whitespace text nodes", Nt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Pt = "<" + re + ">", ke) {
              var $t = "";
              gt === "table" && re === "tr" && ($t += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), be("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Pt, gt, Nt, $t);
            } else
              be("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Pt, gt);
          }
        }
      };
    }
    var jv = "suppressHydrationWarning", Gv = "$", Wv = "/$", Fp = "$?", Dp = "$!", nT = "style", i0 = null, a0 = null;
    function iT(re) {
      var ie, he, ve = re.nodeType;
      switch (ve) {
        case _o:
        case El: {
          ie = ve === _o ? "#document" : "#fragment";
          var Ce = re.documentElement;
          he = Ce ? Ce.namespaceURI : Eh(null, "");
          break;
        }
        default: {
          var ke = ve === mi ? re.parentNode : re, at = ke.namespaceURI || null;
          ie = ke.tagName, he = Eh(at, ie);
          break;
        }
      }
      {
        var mt = ie.toLowerCase(), gt = Mp(null, mt);
        return {
          namespace: he,
          ancestorInfo: gt
        };
      }
    }
    function aT(re, ie, he) {
      {
        var ve = re, Ce = Eh(ve.namespace, ie), ke = Mp(ve.ancestorInfo, ie);
        return {
          namespace: Ce,
          ancestorInfo: ke
        };
      }
    }
    function nR(re) {
      return re;
    }
    function oT(re) {
      i0 = Qa(), a0 = Ex();
      var ie = null;
      return Ni(!1), ie;
    }
    function sT(re) {
      bx(a0), Ni(i0), i0 = null, a0 = null;
    }
    function lT(re, ie, he, ve, Ce) {
      var ke;
      {
        var at = ve;
        if (kp(re, null, at.ancestorInfo), typeof ie.children == "string" || typeof ie.children == "number") {
          var mt = "" + ie.children, gt = Mp(at.ancestorInfo, re);
          kp(null, mt, gt);
        }
        ke = at.namespace;
      }
      var Tt = Ux(re, ie, he, ke);
      return $p(Ce, Tt), h0(Tt, ie), Tt;
    }
    function uT(re, ie) {
      re.appendChild(ie);
    }
    function fT(re, ie, he, ve, Ce) {
      switch (Gx(re, ie, he, ve), ie) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!he.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function cT(re, ie, he, ve, Ce, ke) {
      {
        var at = ke;
        if (typeof ve.children != typeof he.children && (typeof ve.children == "string" || typeof ve.children == "number")) {
          var mt = "" + ve.children, gt = Mp(at.ancestorInfo, ie);
          kp(null, mt, gt);
        }
      }
      return Wx(re, ie, he, ve);
    }
    function o0(re, ie) {
      return re === "textarea" || re === "noscript" || typeof ie.children == "string" || typeof ie.children == "number" || typeof ie.dangerouslySetInnerHTML == "object" && ie.dangerouslySetInnerHTML !== null && ie.dangerouslySetInnerHTML.__html != null;
    }
    function dT(re, ie, he, ve) {
      {
        var Ce = he;
        kp(null, re, Ce.ancestorInfo);
      }
      var ke = jx(re, ie);
      return $p(ve, ke), ke;
    }
    function hT() {
      var re = window.event;
      return re === void 0 ? ps : fa(re.type);
    }
    var s0 = typeof setTimeout == "function" ? setTimeout : void 0, pT = typeof clearTimeout == "function" ? clearTimeout : void 0, l0 = -1, oE = typeof Promise == "function" ? Promise : void 0, mT = typeof queueMicrotask == "function" ? queueMicrotask : typeof oE < "u" ? function(re) {
      return oE.resolve(null).then(re).catch(vT);
    } : s0;
    function vT(re) {
      setTimeout(function() {
        throw re;
      });
    }
    function yT(re, ie, he, ve) {
      switch (ie) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          he.autoFocus && re.focus();
          return;
        case "img": {
          he.src && (re.src = he.src);
          return;
        }
      }
    }
    function gT(re, ie, he, ve, Ce, ke) {
      qx(re, ie, he, ve, Ce), h0(re, Ce);
    }
    function sE(re) {
      kc(re, "");
    }
    function ST(re, ie, he) {
      re.nodeValue = he;
    }
    function ET(re, ie) {
      re.appendChild(ie);
    }
    function bT(re, ie) {
      var he;
      re.nodeType === mi ? (he = re.parentNode, he.insertBefore(ie, re)) : (he = re, he.appendChild(ie));
      var ve = re._reactRootContainer;
      ve == null && he.onclick === null && Uv(he);
    }
    function CT(re, ie, he) {
      re.insertBefore(ie, he);
    }
    function xT(re, ie, he) {
      re.nodeType === mi ? re.parentNode.insertBefore(ie, he) : re.insertBefore(ie, he);
    }
    function TT(re, ie) {
      re.removeChild(ie);
    }
    function wT(re, ie) {
      re.nodeType === mi ? re.parentNode.removeChild(ie) : re.removeChild(ie);
    }
    function u0(re, ie) {
      var he = ie, ve = 0;
      do {
        var Ce = he.nextSibling;
        if (re.removeChild(he), Ce && Ce.nodeType === mi) {
          var ke = Ce.data;
          if (ke === Wv)
            if (ve === 0) {
              re.removeChild(Ce), tn(ie);
              return;
            } else
              ve--;
          else
            (ke === Gv || ke === Fp || ke === Dp) && ve++;
        }
        he = Ce;
      } while (he);
      tn(ie);
    }
    function _T(re, ie) {
      re.nodeType === mi ? u0(re.parentNode, ie) : re.nodeType === wa && u0(re, ie), tn(re);
    }
    function AT(re) {
      re = re;
      var ie = re.style;
      typeof ie.setProperty == "function" ? ie.setProperty("display", "none", "important") : ie.display = "none";
    }
    function PT(re) {
      re.nodeValue = "";
    }
    function RT(re, ie) {
      re = re;
      var he = ie[nT], ve = he != null && he.hasOwnProperty("display") ? he.display : null;
      re.style.display = Mc("display", ve);
    }
    function kT(re, ie) {
      re.nodeValue = ie;
    }
    function MT(re) {
      re.nodeType === wa ? re.textContent = "" : re.nodeType === _o && re.documentElement && re.removeChild(re.documentElement);
    }
    function FT(re, ie, he) {
      return re.nodeType !== wa || ie.toLowerCase() !== re.nodeName.toLowerCase() ? null : re;
    }
    function DT(re, ie) {
      return ie === "" || re.nodeType !== as ? null : re;
    }
    function OT(re) {
      return re.nodeType !== mi ? null : re;
    }
    function lE(re) {
      return re.data === Fp;
    }
    function f0(re) {
      return re.data === Dp;
    }
    function LT(re) {
      var ie = re.nextSibling && re.nextSibling.dataset, he, ve, Ce;
      return ie && (he = ie.dgst, ve = ie.msg, Ce = ie.stck), {
        message: ve,
        digest: he,
        stack: Ce
      };
    }
    function $T(re, ie) {
      re._reactRetry = ie;
    }
    function qv(re) {
      for (; re != null; re = re.nextSibling) {
        var ie = re.nodeType;
        if (ie === wa || ie === as)
          break;
        if (ie === mi) {
          var he = re.data;
          if (he === Gv || he === Dp || he === Fp)
            break;
          if (he === Wv)
            return null;
        }
      }
      return re;
    }
    function Op(re) {
      return qv(re.nextSibling);
    }
    function IT(re) {
      return qv(re.firstChild);
    }
    function NT(re) {
      return qv(re.firstChild);
    }
    function zT(re) {
      return qv(re.nextSibling);
    }
    function VT(re, ie, he, ve, Ce, ke, at) {
      $p(ke, re), h0(re, he);
      var mt;
      {
        var gt = Ce;
        mt = gt.namespace;
      }
      var Tt = (ke.mode & Jr) !== Nr;
      return Qx(re, ie, he, mt, ve, Tt, at);
    }
    function BT(re, ie, he, ve) {
      return $p(he, re), he.mode & Jr, Xx(re, ie);
    }
    function HT(re, ie) {
      $p(ie, re);
    }
    function UT(re) {
      for (var ie = re.nextSibling, he = 0; ie; ) {
        if (ie.nodeType === mi) {
          var ve = ie.data;
          if (ve === Wv) {
            if (he === 0)
              return Op(ie);
            he--;
          } else
            (ve === Gv || ve === Dp || ve === Fp) && he++;
        }
        ie = ie.nextSibling;
      }
      return null;
    }
    function uE(re) {
      for (var ie = re.previousSibling, he = 0; ie; ) {
        if (ie.nodeType === mi) {
          var ve = ie.data;
          if (ve === Gv || ve === Dp || ve === Fp) {
            if (he === 0)
              return ie;
            he--;
          } else
            ve === Wv && he++;
        }
        ie = ie.previousSibling;
      }
      return null;
    }
    function jT(re) {
      tn(re);
    }
    function GT(re) {
      tn(re);
    }
    function WT(re) {
      return re !== "head" && re !== "body";
    }
    function qT(re, ie, he, ve) {
      var Ce = !0;
      Hv(ie.nodeValue, he, ve, Ce);
    }
    function YT(re, ie, he, ve, Ce, ke) {
      if (ie[jv] !== !0) {
        var at = !0;
        Hv(ve.nodeValue, Ce, ke, at);
      }
    }
    function QT(re, ie) {
      ie.nodeType === wa ? e0(re, ie) : ie.nodeType === mi || t0(re, ie);
    }
    function XT(re, ie) {
      {
        var he = re.parentNode;
        he !== null && (ie.nodeType === wa ? e0(he, ie) : ie.nodeType === mi || t0(he, ie));
      }
    }
    function KT(re, ie, he, ve, Ce) {
      (Ce || ie[jv] !== !0) && (ve.nodeType === wa ? e0(he, ve) : ve.nodeType === mi || t0(he, ve));
    }
    function JT(re, ie, he) {
      r0(re, ie);
    }
    function ZT(re, ie) {
      n0(re, ie);
    }
    function ew(re, ie, he) {
      {
        var ve = re.parentNode;
        ve !== null && r0(ve, ie);
      }
    }
    function tw(re, ie) {
      {
        var he = re.parentNode;
        he !== null && n0(he, ie);
      }
    }
    function rw(re, ie, he, ve, Ce, ke) {
      (ke || ie[jv] !== !0) && r0(he, ve);
    }
    function nw(re, ie, he, ve, Ce) {
      (Ce || ie[jv] !== !0) && n0(he, ve);
    }
    function iw(re) {
      be("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", re.nodeName.toLowerCase());
    }
    function aw(re) {
      _p(re);
    }
    var Id = Math.random().toString(36).slice(2), Nd = "__reactFiber$" + Id, c0 = "__reactProps$" + Id, Lp = "__reactContainer$" + Id, d0 = "__reactEvents$" + Id, ow = "__reactListeners$" + Id, sw = "__reactHandles$" + Id;
    function lw(re) {
      delete re[Nd], delete re[c0], delete re[d0], delete re[ow], delete re[sw];
    }
    function $p(re, ie) {
      ie[Nd] = re;
    }
    function Yv(re, ie) {
      ie[Lp] = re;
    }
    function fE(re) {
      re[Lp] = null;
    }
    function Ip(re) {
      return !!re[Lp];
    }
    function rc(re) {
      var ie = re[Nd];
      if (ie)
        return ie;
      for (var he = re.parentNode; he; ) {
        if (ie = he[Lp] || he[Nd], ie) {
          var ve = ie.alternate;
          if (ie.child !== null || ve !== null && ve.child !== null)
            for (var Ce = uE(re); Ce !== null; ) {
              var ke = Ce[Nd];
              if (ke)
                return ke;
              Ce = uE(Ce);
            }
          return ie;
        }
        re = he, he = re.parentNode;
      }
      return null;
    }
    function Yu(re) {
      var ie = re[Nd] || re[Lp];
      return ie && (ie.tag === pt || ie.tag === it || ie.tag === Ct || ie.tag === dt) ? ie : null;
    }
    function zd(re) {
      if (re.tag === pt || re.tag === it)
        return re.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Qv(re) {
      return re[c0] || null;
    }
    function h0(re, ie) {
      re[c0] = ie;
    }
    function uw(re) {
      var ie = re[d0];
      return ie === void 0 && (ie = re[d0] = /* @__PURE__ */ new Set()), ie;
    }
    var cE = {}, dE = oe.ReactDebugCurrentFrame;
    function Xv(re) {
      if (re) {
        var ie = re._owner, he = Os(re.type, re._source, ie ? ie.type : null);
        dE.setExtraStackFrame(he);
      } else
        dE.setExtraStackFrame(null);
    }
    function Ss(re, ie, he, ve, Ce) {
      {
        var ke = Function.call.bind(cr);
        for (var at in re)
          if (ke(re, at)) {
            var mt = void 0;
            try {
              if (typeof re[at] != "function") {
                var gt = Error((ve || "React class") + ": " + he + " type `" + at + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof re[at] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw gt.name = "Invariant Violation", gt;
              }
              mt = re[at](ie, at, ve, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Tt) {
              mt = Tt;
            }
            mt && !(mt instanceof Error) && (Xv(Ce), be("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ve || "React class", he, at, typeof mt), Xv(null)), mt instanceof Error && !(mt.message in cE) && (cE[mt.message] = !0, Xv(Ce), be("Failed %s type: %s", he, mt.message), Xv(null));
          }
      }
    }
    var p0 = [], Kv;
    Kv = [];
    var Yl = -1;
    function Qu(re) {
      return {
        current: re
      };
    }
    function Oa(re, ie) {
      if (Yl < 0) {
        be("Unexpected pop.");
        return;
      }
      ie !== Kv[Yl] && be("Unexpected Fiber popped."), re.current = p0[Yl], p0[Yl] = null, Kv[Yl] = null, Yl--;
    }
    function La(re, ie, he) {
      Yl++, p0[Yl] = re.current, Kv[Yl] = he, re.current = ie;
    }
    var m0;
    m0 = {};
    var Mo = {};
    Object.freeze(Mo);
    var Ql = Qu(Mo), rl = Qu(!1), v0 = Mo;
    function Vd(re, ie, he) {
      return he && nl(ie) ? v0 : Ql.current;
    }
    function hE(re, ie, he) {
      {
        var ve = re.stateNode;
        ve.__reactInternalMemoizedUnmaskedChildContext = ie, ve.__reactInternalMemoizedMaskedChildContext = he;
      }
    }
    function Bd(re, ie) {
      {
        var he = re.type, ve = he.contextTypes;
        if (!ve)
          return Mo;
        var Ce = re.stateNode;
        if (Ce && Ce.__reactInternalMemoizedUnmaskedChildContext === ie)
          return Ce.__reactInternalMemoizedMaskedChildContext;
        var ke = {};
        for (var at in ve)
          ke[at] = ie[at];
        {
          var mt = Gr(re) || "Unknown";
          Ss(ve, ke, "context", mt);
        }
        return Ce && hE(re, ie, ke), ke;
      }
    }
    function Jv() {
      return rl.current;
    }
    function nl(re) {
      {
        var ie = re.childContextTypes;
        return ie != null;
      }
    }
    function Zv(re) {
      Oa(rl, re), Oa(Ql, re);
    }
    function y0(re) {
      Oa(rl, re), Oa(Ql, re);
    }
    function pE(re, ie, he) {
      {
        if (Ql.current !== Mo)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        La(Ql, ie, re), La(rl, he, re);
      }
    }
    function mE(re, ie, he) {
      {
        var ve = re.stateNode, Ce = ie.childContextTypes;
        if (typeof ve.getChildContext != "function") {
          {
            var ke = Gr(re) || "Unknown";
            m0[ke] || (m0[ke] = !0, be("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", ke, ke));
          }
          return he;
        }
        var at = ve.getChildContext();
        for (var mt in at)
          if (!(mt in Ce))
            throw new Error((Gr(re) || "Unknown") + '.getChildContext(): key "' + mt + '" is not defined in childContextTypes.');
        {
          var gt = Gr(re) || "Unknown";
          Ss(Ce, at, "child context", gt);
        }
        return Xr({}, he, at);
      }
    }
    function ey(re) {
      {
        var ie = re.stateNode, he = ie && ie.__reactInternalMemoizedMergedChildContext || Mo;
        return v0 = Ql.current, La(Ql, he, re), La(rl, rl.current, re), !0;
      }
    }
    function vE(re, ie, he) {
      {
        var ve = re.stateNode;
        if (!ve)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (he) {
          var Ce = mE(re, ie, v0);
          ve.__reactInternalMemoizedMergedChildContext = Ce, Oa(rl, re), Oa(Ql, re), La(Ql, Ce, re), La(rl, he, re);
        } else
          Oa(rl, re), La(rl, he, re);
      }
    }
    function fw(re) {
      {
        if (!Vh(re) || re.tag !== rt)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var ie = re;
        do {
          switch (ie.tag) {
            case dt:
              return ie.stateNode.context;
            case rt: {
              var he = ie.type;
              if (nl(he))
                return ie.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          ie = ie.return;
        } while (ie !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Xu = 0, ty = 1, Xl = null, g0 = !1, S0 = !1;
    function yE(re) {
      Xl === null ? Xl = [re] : Xl.push(re);
    }
    function cw(re) {
      g0 = !0, yE(re);
    }
    function gE() {
      g0 && Ku();
    }
    function Ku() {
      if (!S0 && Xl !== null) {
        S0 = !0;
        var re = 0, ie = mo();
        try {
          var he = !0, ve = Xl;
          for (wi(ea); re < ve.length; re++) {
            var Ce = ve[re];
            do
              Ce = Ce(he);
            while (Ce !== null);
          }
          Xl = null, g0 = !1;
        } catch (ke) {
          throw Xl !== null && (Xl = Xl.slice(re + 1)), Hc(jc, Ku), ke;
        } finally {
          wi(ie), S0 = !1;
        }
      }
      return null;
    }
    var Hd = [], Ud = 0, ry = null, ny = 0, qo = [], Yo = 0, nc = null, Kl = 1, Jl = "";
    function dw(re) {
      return ac(), (re.flags & Ih) !== Or;
    }
    function hw(re) {
      return ac(), ny;
    }
    function pw() {
      var re = Jl, ie = Kl, he = ie & ~mw(ie);
      return he.toString(32) + re;
    }
    function ic(re, ie) {
      ac(), Hd[Ud++] = ny, Hd[Ud++] = ry, ry = re, ny = ie;
    }
    function SE(re, ie, he) {
      ac(), qo[Yo++] = Kl, qo[Yo++] = Jl, qo[Yo++] = nc, nc = re;
      var ve = Kl, Ce = Jl, ke = iy(ve) - 1, at = ve & ~(1 << ke), mt = he + 1, gt = iy(ie) + ke;
      if (gt > 30) {
        var Tt = ke - ke % 5, Pt = (1 << Tt) - 1, Nt = (at & Pt).toString(32), $t = at >> Tt, Gt = ke - Tt, Wt = iy(ie) + Gt, Xt = mt << Gt, br = Xt | $t, $r = Nt + Ce;
        Kl = 1 << Wt | br, Jl = $r;
      } else {
        var Mr = mt << ke, sn = Mr | at, rn = Ce;
        Kl = 1 << gt | sn, Jl = rn;
      }
    }
    function E0(re) {
      ac();
      var ie = re.return;
      if (ie !== null) {
        var he = 1, ve = 0;
        ic(re, he), SE(re, he, ve);
      }
    }
    function iy(re) {
      return 32 - Xc(re);
    }
    function mw(re) {
      return 1 << iy(re) - 1;
    }
    function b0(re) {
      for (; re === ry; )
        ry = Hd[--Ud], Hd[Ud] = null, ny = Hd[--Ud], Hd[Ud] = null;
      for (; re === nc; )
        nc = qo[--Yo], qo[Yo] = null, Jl = qo[--Yo], qo[Yo] = null, Kl = qo[--Yo], qo[Yo] = null;
    }
    function vw() {
      return ac(), nc !== null ? {
        id: Kl,
        overflow: Jl
      } : null;
    }
    function yw(re, ie) {
      ac(), qo[Yo++] = Kl, qo[Yo++] = Jl, qo[Yo++] = nc, Kl = ie.id, Jl = ie.overflow, nc = re;
    }
    function ac() {
      da() || be("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var ca = null, Qo = null, Es = !1, oc = !1, Ju = null;
    function gw() {
      Es && be("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function EE() {
      oc = !0;
    }
    function Sw() {
      return oc;
    }
    function Ew(re) {
      var ie = re.stateNode.containerInfo;
      return Qo = NT(ie), ca = re, Es = !0, Ju = null, oc = !1, !0;
    }
    function bw(re, ie, he) {
      return Qo = zT(ie), ca = re, Es = !0, Ju = null, oc = !1, he !== null && yw(re, he), !0;
    }
    function bE(re, ie) {
      switch (re.tag) {
        case dt: {
          QT(re.stateNode.containerInfo, ie);
          break;
        }
        case pt: {
          var he = (re.mode & Jr) !== Nr;
          KT(
            re.type,
            re.memoizedProps,
            re.stateNode,
            ie,
            // TODO: Delete this argument when we remove the legacy root API.
            he
          );
          break;
        }
        case Ct: {
          var ve = re.memoizedState;
          ve.dehydrated !== null && XT(ve.dehydrated, ie);
          break;
        }
      }
    }
    function CE(re, ie) {
      bE(re, ie);
      var he = TP();
      he.stateNode = ie, he.return = re;
      var ve = re.deletions;
      ve === null ? (re.deletions = [he], re.flags |= hn) : ve.push(he);
    }
    function C0(re, ie) {
      {
        if (oc)
          return;
        switch (re.tag) {
          case dt: {
            var he = re.stateNode.containerInfo;
            switch (ie.tag) {
              case pt:
                var ve = ie.type;
                ie.pendingProps, JT(he, ve);
                break;
              case it:
                var Ce = ie.pendingProps;
                ZT(he, Ce);
                break;
            }
            break;
          }
          case pt: {
            var ke = re.type, at = re.memoizedProps, mt = re.stateNode;
            switch (ie.tag) {
              case pt: {
                var gt = ie.type, Tt = ie.pendingProps, Pt = (re.mode & Jr) !== Nr;
                rw(
                  ke,
                  at,
                  mt,
                  gt,
                  Tt,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Pt
                );
                break;
              }
              case it: {
                var Nt = ie.pendingProps, $t = (re.mode & Jr) !== Nr;
                nw(
                  ke,
                  at,
                  mt,
                  Nt,
                  // TODO: Delete this argument when we remove the legacy root API.
                  $t
                );
                break;
              }
            }
            break;
          }
          case Ct: {
            var Gt = re.memoizedState, Wt = Gt.dehydrated;
            if (Wt !== null)
              switch (ie.tag) {
                case pt:
                  var Xt = ie.type;
                  ie.pendingProps, ew(Wt, Xt);
                  break;
                case it:
                  var br = ie.pendingProps;
                  tw(Wt, br);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function xE(re, ie) {
      ie.flags = ie.flags & ~uo | Dn, C0(re, ie);
    }
    function TE(re, ie) {
      switch (re.tag) {
        case pt: {
          var he = re.type;
          re.pendingProps;
          var ve = FT(ie, he);
          return ve !== null ? (re.stateNode = ve, ca = re, Qo = IT(ve), !0) : !1;
        }
        case it: {
          var Ce = re.pendingProps, ke = DT(ie, Ce);
          return ke !== null ? (re.stateNode = ke, ca = re, Qo = null, !0) : !1;
        }
        case Ct: {
          var at = OT(ie);
          if (at !== null) {
            var mt = {
              dehydrated: at,
              treeContext: vw(),
              retryLane: Fa
            };
            re.memoizedState = mt;
            var gt = wP(at);
            return gt.return = re, re.child = gt, ca = re, Qo = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function x0(re) {
      return (re.mode & Jr) !== Nr && (re.flags & Hr) === Or;
    }
    function T0(re) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function w0(re) {
      if (Es) {
        var ie = Qo;
        if (!ie) {
          x0(re) && (C0(ca, re), T0()), xE(ca, re), Es = !1, ca = re;
          return;
        }
        var he = ie;
        if (!TE(re, ie)) {
          x0(re) && (C0(ca, re), T0()), ie = Op(he);
          var ve = ca;
          if (!ie || !TE(re, ie)) {
            xE(ca, re), Es = !1, ca = re;
            return;
          }
          CE(ve, he);
        }
      }
    }
    function Cw(re, ie, he) {
      var ve = re.stateNode, Ce = !oc, ke = VT(ve, re.type, re.memoizedProps, ie, he, re, Ce);
      return re.updateQueue = ke, ke !== null;
    }
    function xw(re) {
      var ie = re.stateNode, he = re.memoizedProps, ve = BT(ie, he, re);
      if (ve) {
        var Ce = ca;
        if (Ce !== null)
          switch (Ce.tag) {
            case dt: {
              var ke = Ce.stateNode.containerInfo, at = (Ce.mode & Jr) !== Nr;
              qT(
                ke,
                ie,
                he,
                // TODO: Delete this argument when we remove the legacy root API.
                at
              );
              break;
            }
            case pt: {
              var mt = Ce.type, gt = Ce.memoizedProps, Tt = Ce.stateNode, Pt = (Ce.mode & Jr) !== Nr;
              YT(
                mt,
                gt,
                Tt,
                ie,
                he,
                // TODO: Delete this argument when we remove the legacy root API.
                Pt
              );
              break;
            }
          }
      }
      return ve;
    }
    function Tw(re) {
      var ie = re.memoizedState, he = ie !== null ? ie.dehydrated : null;
      if (!he)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      HT(he, re);
    }
    function ww(re) {
      var ie = re.memoizedState, he = ie !== null ? ie.dehydrated : null;
      if (!he)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return UT(he);
    }
    function wE(re) {
      for (var ie = re.return; ie !== null && ie.tag !== pt && ie.tag !== dt && ie.tag !== Ct; )
        ie = ie.return;
      ca = ie;
    }
    function ay(re) {
      if (re !== ca)
        return !1;
      if (!Es)
        return wE(re), Es = !0, !1;
      if (re.tag !== dt && (re.tag !== pt || WT(re.type) && !o0(re.type, re.memoizedProps))) {
        var ie = Qo;
        if (ie)
          if (x0(re))
            _E(re), T0();
          else
            for (; ie; )
              CE(re, ie), ie = Op(ie);
      }
      return wE(re), re.tag === Ct ? Qo = ww(re) : Qo = ca ? Op(re.stateNode) : null, !0;
    }
    function _w() {
      return Es && Qo !== null;
    }
    function _E(re) {
      for (var ie = Qo; ie; )
        bE(re, ie), ie = Op(ie);
    }
    function jd() {
      ca = null, Qo = null, Es = !1, oc = !1;
    }
    function AE() {
      Ju !== null && (CC(Ju), Ju = null);
    }
    function da() {
      return Es;
    }
    function _0(re) {
      Ju === null ? Ju = [re] : Ju.push(re);
    }
    var Aw = oe.ReactCurrentBatchConfig, Pw = null;
    function Rw() {
      return Aw.transition;
    }
    var bs = {
      recordUnsafeLifecycleWarnings: function(re, ie) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(re, ie) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var kw = function(re) {
        for (var ie = null, he = re; he !== null; )
          he.mode & qn && (ie = he), he = he.return;
        return ie;
      }, sc = function(re) {
        var ie = [];
        return re.forEach(function(he) {
          ie.push(he);
        }), ie.sort().join(", ");
      }, Np = [], zp = [], Vp = [], Bp = [], Hp = [], Up = [], lc = /* @__PURE__ */ new Set();
      bs.recordUnsafeLifecycleWarnings = function(re, ie) {
        lc.has(re.type) || (typeof ie.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        ie.componentWillMount.__suppressDeprecationWarning !== !0 && Np.push(re), re.mode & qn && typeof ie.UNSAFE_componentWillMount == "function" && zp.push(re), typeof ie.componentWillReceiveProps == "function" && ie.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Vp.push(re), re.mode & qn && typeof ie.UNSAFE_componentWillReceiveProps == "function" && Bp.push(re), typeof ie.componentWillUpdate == "function" && ie.componentWillUpdate.__suppressDeprecationWarning !== !0 && Hp.push(re), re.mode & qn && typeof ie.UNSAFE_componentWillUpdate == "function" && Up.push(re));
      }, bs.flushPendingUnsafeLifecycleWarnings = function() {
        var re = /* @__PURE__ */ new Set();
        Np.length > 0 && (Np.forEach(function($t) {
          re.add(Gr($t) || "Component"), lc.add($t.type);
        }), Np = []);
        var ie = /* @__PURE__ */ new Set();
        zp.length > 0 && (zp.forEach(function($t) {
          ie.add(Gr($t) || "Component"), lc.add($t.type);
        }), zp = []);
        var he = /* @__PURE__ */ new Set();
        Vp.length > 0 && (Vp.forEach(function($t) {
          he.add(Gr($t) || "Component"), lc.add($t.type);
        }), Vp = []);
        var ve = /* @__PURE__ */ new Set();
        Bp.length > 0 && (Bp.forEach(function($t) {
          ve.add(Gr($t) || "Component"), lc.add($t.type);
        }), Bp = []);
        var Ce = /* @__PURE__ */ new Set();
        Hp.length > 0 && (Hp.forEach(function($t) {
          Ce.add(Gr($t) || "Component"), lc.add($t.type);
        }), Hp = []);
        var ke = /* @__PURE__ */ new Set();
        if (Up.length > 0 && (Up.forEach(function($t) {
          ke.add(Gr($t) || "Component"), lc.add($t.type);
        }), Up = []), ie.size > 0) {
          var at = sc(ie);
          be(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, at);
        }
        if (ve.size > 0) {
          var mt = sc(ve);
          be(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, mt);
        }
        if (ke.size > 0) {
          var gt = sc(ke);
          be(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, gt);
        }
        if (re.size > 0) {
          var Tt = sc(re);
          ge(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Tt);
        }
        if (he.size > 0) {
          var Pt = sc(he);
          ge(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Pt);
        }
        if (Ce.size > 0) {
          var Nt = sc(Ce);
          ge(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Nt);
        }
      };
      var oy = /* @__PURE__ */ new Map(), PE = /* @__PURE__ */ new Set();
      bs.recordLegacyContextWarning = function(re, ie) {
        var he = kw(re);
        if (he === null) {
          be("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!PE.has(re.type)) {
          var ve = oy.get(he);
          (re.type.contextTypes != null || re.type.childContextTypes != null || ie !== null && typeof ie.getChildContext == "function") && (ve === void 0 && (ve = [], oy.set(he, ve)), ve.push(re));
        }
      }, bs.flushLegacyContextWarning = function() {
        oy.forEach(function(re, ie) {
          if (re.length !== 0) {
            var he = re[0], ve = /* @__PURE__ */ new Set();
            re.forEach(function(ke) {
              ve.add(Gr(ke) || "Component"), PE.add(ke.type);
            });
            var Ce = sc(ve);
            try {
              vn(he), be(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, Ce);
            } finally {
              Hn();
            }
          }
        });
      }, bs.discardPendingWarnings = function() {
        Np = [], zp = [], Vp = [], Bp = [], Hp = [], Up = [], oy = /* @__PURE__ */ new Map();
      };
    }
    function Cs(re, ie) {
      if (re && re.defaultProps) {
        var he = Xr({}, ie), ve = re.defaultProps;
        for (var Ce in ve)
          he[Ce] === void 0 && (he[Ce] = ve[Ce]);
        return he;
      }
      return ie;
    }
    var A0 = Qu(null), P0;
    P0 = {};
    var sy = null, Gd = null, R0 = null, ly = !1;
    function uy() {
      sy = null, Gd = null, R0 = null, ly = !1;
    }
    function RE() {
      ly = !0;
    }
    function kE() {
      ly = !1;
    }
    function ME(re, ie, he) {
      La(A0, ie._currentValue, re), ie._currentValue = he, ie._currentRenderer !== void 0 && ie._currentRenderer !== null && ie._currentRenderer !== P0 && be("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), ie._currentRenderer = P0;
    }
    function k0(re, ie) {
      var he = A0.current;
      Oa(A0, ie), re._currentValue = he;
    }
    function M0(re, ie, he) {
      for (var ve = re; ve !== null; ) {
        var Ce = ve.alternate;
        if (Il(ve.childLanes, ie) ? Ce !== null && !Il(Ce.childLanes, ie) && (Ce.childLanes = Qr(Ce.childLanes, ie)) : (ve.childLanes = Qr(ve.childLanes, ie), Ce !== null && (Ce.childLanes = Qr(Ce.childLanes, ie))), ve === he)
          break;
        ve = ve.return;
      }
      ve !== he && be("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Mw(re, ie, he) {
      Fw(re, ie, he);
    }
    function Fw(re, ie, he) {
      var ve = re.child;
      for (ve !== null && (ve.return = re); ve !== null; ) {
        var Ce = void 0, ke = ve.dependencies;
        if (ke !== null) {
          Ce = ve.child;
          for (var at = ke.firstContext; at !== null; ) {
            if (at.context === ie) {
              if (ve.tag === rt) {
                var mt = Ti(he), gt = Zl(Pn, mt);
                gt.tag = cy;
                var Tt = ve.updateQueue;
                if (Tt !== null) {
                  var Pt = Tt.shared, Nt = Pt.pending;
                  Nt === null ? gt.next = gt : (gt.next = Nt.next, Nt.next = gt), Pt.pending = gt;
                }
              }
              ve.lanes = Qr(ve.lanes, he);
              var $t = ve.alternate;
              $t !== null && ($t.lanes = Qr($t.lanes, he)), M0(ve.return, he, re), ke.lanes = Qr(ke.lanes, he);
              break;
            }
            at = at.next;
          }
        } else if (ve.tag === ht)
          Ce = ve.type === re.type ? null : ve.child;
        else if (ve.tag === ir) {
          var Gt = ve.return;
          if (Gt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Gt.lanes = Qr(Gt.lanes, he);
          var Wt = Gt.alternate;
          Wt !== null && (Wt.lanes = Qr(Wt.lanes, he)), M0(Gt, he, re), Ce = ve.sibling;
        } else
          Ce = ve.child;
        if (Ce !== null)
          Ce.return = ve;
        else
          for (Ce = ve; Ce !== null; ) {
            if (Ce === re) {
              Ce = null;
              break;
            }
            var Xt = Ce.sibling;
            if (Xt !== null) {
              Xt.return = Ce.return, Ce = Xt;
              break;
            }
            Ce = Ce.return;
          }
        ve = Ce;
      }
    }
    function Wd(re, ie) {
      sy = re, Gd = null, R0 = null;
      var he = re.dependencies;
      if (he !== null) {
        var ve = he.firstContext;
        ve !== null && (Da(he.lanes, ie) && nm(), he.firstContext = null);
      }
    }
    function Vi(re) {
      ly && be("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var ie = re._currentValue;
      if (R0 !== re) {
        var he = {
          context: re,
          memoizedValue: ie,
          next: null
        };
        if (Gd === null) {
          if (sy === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Gd = he, sy.dependencies = {
            lanes: Zt,
            firstContext: he
          };
        } else
          Gd = Gd.next = he;
      }
      return ie;
    }
    var uc = null;
    function F0(re) {
      uc === null ? uc = [re] : uc.push(re);
    }
    function Dw() {
      if (uc !== null) {
        for (var re = 0; re < uc.length; re++) {
          var ie = uc[re], he = ie.interleaved;
          if (he !== null) {
            ie.interleaved = null;
            var ve = he.next, Ce = ie.pending;
            if (Ce !== null) {
              var ke = Ce.next;
              Ce.next = ve, he.next = ke;
            }
            ie.pending = he;
          }
        }
        uc = null;
      }
    }
    function FE(re, ie, he, ve) {
      var Ce = ie.interleaved;
      return Ce === null ? (he.next = he, F0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he, fy(re, ve);
    }
    function Ow(re, ie, he, ve) {
      var Ce = ie.interleaved;
      Ce === null ? (he.next = he, F0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he;
    }
    function Lw(re, ie, he, ve) {
      var Ce = ie.interleaved;
      return Ce === null ? (he.next = he, F0(ie)) : (he.next = Ce.next, Ce.next = he), ie.interleaved = he, fy(re, ve);
    }
    function Eo(re, ie) {
      return fy(re, ie);
    }
    var $w = fy;
    function fy(re, ie) {
      re.lanes = Qr(re.lanes, ie);
      var he = re.alternate;
      he !== null && (he.lanes = Qr(he.lanes, ie)), he === null && (re.flags & (Dn | uo)) !== Or && OC(re);
      for (var ve = re, Ce = re.return; Ce !== null; )
        Ce.childLanes = Qr(Ce.childLanes, ie), he = Ce.alternate, he !== null ? he.childLanes = Qr(he.childLanes, ie) : (Ce.flags & (Dn | uo)) !== Or && OC(re), ve = Ce, Ce = Ce.return;
      if (ve.tag === dt) {
        var ke = ve.stateNode;
        return ke;
      } else
        return null;
    }
    var DE = 0, OE = 1, cy = 2, D0 = 3, dy = !1, O0, hy;
    O0 = !1, hy = null;
    function L0(re) {
      var ie = {
        baseState: re.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Zt
        },
        effects: null
      };
      re.updateQueue = ie;
    }
    function LE(re, ie) {
      var he = ie.updateQueue, ve = re.updateQueue;
      if (he === ve) {
        var Ce = {
          baseState: ve.baseState,
          firstBaseUpdate: ve.firstBaseUpdate,
          lastBaseUpdate: ve.lastBaseUpdate,
          shared: ve.shared,
          effects: ve.effects
        };
        ie.updateQueue = Ce;
      }
    }
    function Zl(re, ie) {
      var he = {
        eventTime: re,
        lane: ie,
        tag: DE,
        payload: null,
        callback: null,
        next: null
      };
      return he;
    }
    function Zu(re, ie, he) {
      var ve = re.updateQueue;
      if (ve === null)
        return null;
      var Ce = ve.shared;
      if (hy === Ce && !O0 && (be("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), O0 = !0), $A()) {
        var ke = Ce.pending;
        return ke === null ? ie.next = ie : (ie.next = ke.next, ke.next = ie), Ce.pending = ie, $w(re, he);
      } else
        return Lw(re, Ce, ie, he);
    }
    function py(re, ie, he) {
      var ve = ie.updateQueue;
      if (ve !== null) {
        var Ce = ve.shared;
        if (Zh(he)) {
          var ke = Ce.lanes;
          ke = tp(ke, re.pendingLanes);
          var at = Qr(ke, he);
          Ce.lanes = at, Du(re, at);
        }
      }
    }
    function $0(re, ie) {
      var he = re.updateQueue, ve = re.alternate;
      if (ve !== null) {
        var Ce = ve.updateQueue;
        if (he === Ce) {
          var ke = null, at = null, mt = he.firstBaseUpdate;
          if (mt !== null) {
            var gt = mt;
            do {
              var Tt = {
                eventTime: gt.eventTime,
                lane: gt.lane,
                tag: gt.tag,
                payload: gt.payload,
                callback: gt.callback,
                next: null
              };
              at === null ? ke = at = Tt : (at.next = Tt, at = Tt), gt = gt.next;
            } while (gt !== null);
            at === null ? ke = at = ie : (at.next = ie, at = ie);
          } else
            ke = at = ie;
          he = {
            baseState: Ce.baseState,
            firstBaseUpdate: ke,
            lastBaseUpdate: at,
            shared: Ce.shared,
            effects: Ce.effects
          }, re.updateQueue = he;
          return;
        }
      }
      var Pt = he.lastBaseUpdate;
      Pt === null ? he.firstBaseUpdate = ie : Pt.next = ie, he.lastBaseUpdate = ie;
    }
    function Iw(re, ie, he, ve, Ce, ke) {
      switch (he.tag) {
        case OE: {
          var at = he.payload;
          if (typeof at == "function") {
            RE();
            var mt = at.call(ke, ve, Ce);
            {
              if (re.mode & qn) {
                xi(!0);
                try {
                  at.call(ke, ve, Ce);
                } finally {
                  xi(!1);
                }
              }
              kE();
            }
            return mt;
          }
          return at;
        }
        case D0:
          re.flags = re.flags & ~Li | Hr;
        case DE: {
          var gt = he.payload, Tt;
          if (typeof gt == "function") {
            RE(), Tt = gt.call(ke, ve, Ce);
            {
              if (re.mode & qn) {
                xi(!0);
                try {
                  gt.call(ke, ve, Ce);
                } finally {
                  xi(!1);
                }
              }
              kE();
            }
          } else
            Tt = gt;
          return Tt == null ? ve : Xr({}, ve, Tt);
        }
        case cy:
          return dy = !0, ve;
      }
      return ve;
    }
    function my(re, ie, he, ve) {
      var Ce = re.updateQueue;
      dy = !1, hy = Ce.shared;
      var ke = Ce.firstBaseUpdate, at = Ce.lastBaseUpdate, mt = Ce.shared.pending;
      if (mt !== null) {
        Ce.shared.pending = null;
        var gt = mt, Tt = gt.next;
        gt.next = null, at === null ? ke = Tt : at.next = Tt, at = gt;
        var Pt = re.alternate;
        if (Pt !== null) {
          var Nt = Pt.updateQueue, $t = Nt.lastBaseUpdate;
          $t !== at && ($t === null ? Nt.firstBaseUpdate = Tt : $t.next = Tt, Nt.lastBaseUpdate = gt);
        }
      }
      if (ke !== null) {
        var Gt = Ce.baseState, Wt = Zt, Xt = null, br = null, $r = null, Mr = ke;
        do {
          var sn = Mr.lane, rn = Mr.eventTime;
          if (Il(ve, sn)) {
            if ($r !== null) {
              var Kt = {
                eventTime: rn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: an,
                tag: Mr.tag,
                payload: Mr.payload,
                callback: Mr.callback,
                next: null
              };
              $r = $r.next = Kt;
            }
            Gt = Iw(re, Ce, Mr, Gt, ie, he);
            var Ut = Mr.callback;
            if (Ut !== null && // If the update was already committed, we should not queue its
            // callback again.
            Mr.lane !== an) {
              re.flags |= Bo;
              var ur = Ce.effects;
              ur === null ? Ce.effects = [Mr] : ur.push(Mr);
            }
          } else {
            var Ht = {
              eventTime: rn,
              lane: sn,
              tag: Mr.tag,
              payload: Mr.payload,
              callback: Mr.callback,
              next: null
            };
            $r === null ? (br = $r = Ht, Xt = Gt) : $r = $r.next = Ht, Wt = Qr(Wt, sn);
          }
          if (Mr = Mr.next, Mr === null) {
            if (mt = Ce.shared.pending, mt === null)
              break;
            var Cr = mt, yr = Cr.next;
            Cr.next = null, Mr = yr, Ce.lastBaseUpdate = Cr, Ce.shared.pending = null;
          }
        } while (!0);
        $r === null && (Xt = Gt), Ce.baseState = Xt, Ce.firstBaseUpdate = br, Ce.lastBaseUpdate = $r;
        var Br = Ce.shared.interleaved;
        if (Br !== null) {
          var qr = Br;
          do
            Wt = Qr(Wt, qr.lane), qr = qr.next;
          while (qr !== Br);
        } else
          ke === null && (Ce.shared.lanes = Zt);
        mm(Wt), re.lanes = Wt, re.memoizedState = Gt;
      }
      hy = null;
    }
    function Nw(re, ie) {
      if (typeof re != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + re));
      re.call(ie);
    }
    function $E() {
      dy = !1;
    }
    function vy() {
      return dy;
    }
    function IE(re, ie, he) {
      var ve = ie.effects;
      if (ie.effects = null, ve !== null)
        for (var Ce = 0; Ce < ve.length; Ce++) {
          var ke = ve[Ce], at = ke.callback;
          at !== null && (ke.callback = null, Nw(at, he));
        }
    }
    var I0 = {}, NE = new L.Component().refs, N0, z0, V0, B0, H0, zE, yy, U0, j0, G0;
    {
      N0 = /* @__PURE__ */ new Set(), z0 = /* @__PURE__ */ new Set(), V0 = /* @__PURE__ */ new Set(), B0 = /* @__PURE__ */ new Set(), U0 = /* @__PURE__ */ new Set(), H0 = /* @__PURE__ */ new Set(), j0 = /* @__PURE__ */ new Set(), G0 = /* @__PURE__ */ new Set();
      var VE = /* @__PURE__ */ new Set();
      yy = function(re, ie) {
        if (!(re === null || typeof re == "function")) {
          var he = ie + "_" + re;
          VE.has(he) || (VE.add(he), be("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ie, re));
        }
      }, zE = function(re, ie) {
        if (ie === void 0) {
          var he = nn(re) || "Component";
          H0.has(he) || (H0.add(he), be("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", he));
        }
      }, Object.defineProperty(I0, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(I0);
    }
    function W0(re, ie, he, ve) {
      var Ce = re.memoizedState, ke = he(ve, Ce);
      {
        if (re.mode & qn) {
          xi(!0);
          try {
            ke = he(ve, Ce);
          } finally {
            xi(!1);
          }
        }
        zE(ie, ke);
      }
      var at = ke == null ? Ce : Xr({}, Ce, ke);
      if (re.memoizedState = at, re.lanes === Zt) {
        var mt = re.updateQueue;
        mt.baseState = at;
      }
    }
    var q0 = {
      isMounted: Wa,
      enqueueSetState: function(re, ie, he) {
        var ve = so(re), Ce = Ja(), ke = lf(ve), at = Zl(Ce, ke);
        at.payload = ie, he != null && (yy(he, "setState"), at.callback = he);
        var mt = Zu(ve, at, ke);
        mt !== null && (Ji(mt, ve, ke, Ce), py(mt, ve, ke)), qs(ve, ke);
      },
      enqueueReplaceState: function(re, ie, he) {
        var ve = so(re), Ce = Ja(), ke = lf(ve), at = Zl(Ce, ke);
        at.tag = OE, at.payload = ie, he != null && (yy(he, "replaceState"), at.callback = he);
        var mt = Zu(ve, at, ke);
        mt !== null && (Ji(mt, ve, ke, Ce), py(mt, ve, ke)), qs(ve, ke);
      },
      enqueueForceUpdate: function(re, ie) {
        var he = so(re), ve = Ja(), Ce = lf(he), ke = Zl(ve, Ce);
        ke.tag = cy, ie != null && (yy(ie, "forceUpdate"), ke.callback = ie);
        var at = Zu(he, ke, Ce);
        at !== null && (Ji(at, he, Ce, ve), py(at, he, Ce)), Qh(he, Ce);
      }
    };
    function BE(re, ie, he, ve, Ce, ke, at) {
      var mt = re.stateNode;
      if (typeof mt.shouldComponentUpdate == "function") {
        var gt = mt.shouldComponentUpdate(ve, ke, at);
        {
          if (re.mode & qn) {
            xi(!0);
            try {
              gt = mt.shouldComponentUpdate(ve, ke, at);
            } finally {
              xi(!1);
            }
          }
          gt === void 0 && be("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", nn(ie) || "Component");
        }
        return gt;
      }
      return ie.prototype && ie.prototype.isPureReactComponent ? !Dr(he, ve) || !Dr(Ce, ke) : !0;
    }
    function zw(re, ie, he) {
      var ve = re.stateNode;
      {
        var Ce = nn(ie) || "Component", ke = ve.render;
        ke || (ie.prototype && typeof ie.prototype.render == "function" ? be("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", Ce) : be("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", Ce)), ve.getInitialState && !ve.getInitialState.isReactClassApproved && !ve.state && be("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", Ce), ve.getDefaultProps && !ve.getDefaultProps.isReactClassApproved && be("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", Ce), ve.propTypes && be("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", Ce), ve.contextType && be("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", Ce), ve.contextTypes && be("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", Ce), ie.contextType && ie.contextTypes && !j0.has(ie) && (j0.add(ie), be("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", Ce)), typeof ve.componentShouldUpdate == "function" && be("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", Ce), ie.prototype && ie.prototype.isPureReactComponent && typeof ve.shouldComponentUpdate < "u" && be("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", nn(ie) || "A pure component"), typeof ve.componentDidUnmount == "function" && be("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", Ce), typeof ve.componentDidReceiveProps == "function" && be("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", Ce), typeof ve.componentWillRecieveProps == "function" && be("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", Ce), typeof ve.UNSAFE_componentWillRecieveProps == "function" && be("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", Ce);
        var at = ve.props !== he;
        ve.props !== void 0 && at && be("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", Ce, Ce), ve.defaultProps && be("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", Ce, Ce), typeof ve.getSnapshotBeforeUpdate == "function" && typeof ve.componentDidUpdate != "function" && !V0.has(ie) && (V0.add(ie), be("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", nn(ie))), typeof ve.getDerivedStateFromProps == "function" && be("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Ce), typeof ve.getDerivedStateFromError == "function" && be("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", Ce), typeof ie.getSnapshotBeforeUpdate == "function" && be("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", Ce);
        var mt = ve.state;
        mt && (typeof mt != "object" || Di(mt)) && be("%s.state: must be set to an object or null", Ce), typeof ve.getChildContext == "function" && typeof ie.childContextTypes != "object" && be("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", Ce);
      }
    }
    function HE(re, ie) {
      ie.updater = q0, re.stateNode = ie, xu(ie, re), ie._reactInternalInstance = I0;
    }
    function UE(re, ie, he) {
      var ve = !1, Ce = Mo, ke = Mo, at = ie.contextType;
      if ("contextType" in ie) {
        var mt = (
          // Allow null for conditional declaration
          at === null || at !== void 0 && at.$$typeof === hf && at._context === void 0
        );
        if (!mt && !G0.has(ie)) {
          G0.add(ie);
          var gt = "";
          at === void 0 ? gt = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof at != "object" ? gt = " However, it is set to a " + typeof at + "." : at.$$typeof === df ? gt = " Did you accidentally pass the Context.Provider instead?" : at._context !== void 0 ? gt = " Did you accidentally pass the Context.Consumer instead?" : gt = " However, it is set to an object with keys {" + Object.keys(at).join(", ") + "}.", be("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", nn(ie) || "Component", gt);
        }
      }
      if (typeof at == "object" && at !== null)
        ke = Vi(at);
      else {
        Ce = Vd(re, ie, !0);
        var Tt = ie.contextTypes;
        ve = Tt != null, ke = ve ? Bd(re, Ce) : Mo;
      }
      var Pt = new ie(he, ke);
      if (re.mode & qn) {
        xi(!0);
        try {
          Pt = new ie(he, ke);
        } finally {
          xi(!1);
        }
      }
      var Nt = re.memoizedState = Pt.state !== null && Pt.state !== void 0 ? Pt.state : null;
      HE(re, Pt);
      {
        if (typeof ie.getDerivedStateFromProps == "function" && Nt === null) {
          var $t = nn(ie) || "Component";
          z0.has($t) || (z0.add($t), be("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $t, Pt.state === null ? "null" : "undefined", $t));
        }
        if (typeof ie.getDerivedStateFromProps == "function" || typeof Pt.getSnapshotBeforeUpdate == "function") {
          var Gt = null, Wt = null, Xt = null;
          if (typeof Pt.componentWillMount == "function" && Pt.componentWillMount.__suppressDeprecationWarning !== !0 ? Gt = "componentWillMount" : typeof Pt.UNSAFE_componentWillMount == "function" && (Gt = "UNSAFE_componentWillMount"), typeof Pt.componentWillReceiveProps == "function" && Pt.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Wt = "componentWillReceiveProps" : typeof Pt.UNSAFE_componentWillReceiveProps == "function" && (Wt = "UNSAFE_componentWillReceiveProps"), typeof Pt.componentWillUpdate == "function" && Pt.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Xt = "componentWillUpdate" : typeof Pt.UNSAFE_componentWillUpdate == "function" && (Xt = "UNSAFE_componentWillUpdate"), Gt !== null || Wt !== null || Xt !== null) {
            var br = nn(ie) || "Component", $r = typeof ie.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            B0.has(br) || (B0.add(br), be(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, br, $r, Gt !== null ? `
  ` + Gt : "", Wt !== null ? `
  ` + Wt : "", Xt !== null ? `
  ` + Xt : ""));
          }
        }
      }
      return ve && hE(re, Ce, ke), Pt;
    }
    function Vw(re, ie) {
      var he = ie.state;
      typeof ie.componentWillMount == "function" && ie.componentWillMount(), typeof ie.UNSAFE_componentWillMount == "function" && ie.UNSAFE_componentWillMount(), he !== ie.state && (be("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Gr(re) || "Component"), q0.enqueueReplaceState(ie, ie.state, null));
    }
    function jE(re, ie, he, ve) {
      var Ce = ie.state;
      if (typeof ie.componentWillReceiveProps == "function" && ie.componentWillReceiveProps(he, ve), typeof ie.UNSAFE_componentWillReceiveProps == "function" && ie.UNSAFE_componentWillReceiveProps(he, ve), ie.state !== Ce) {
        {
          var ke = Gr(re) || "Component";
          N0.has(ke) || (N0.add(ke), be("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", ke));
        }
        q0.enqueueReplaceState(ie, ie.state, null);
      }
    }
    function Y0(re, ie, he, ve) {
      zw(re, ie, he);
      var Ce = re.stateNode;
      Ce.props = he, Ce.state = re.memoizedState, Ce.refs = NE, L0(re);
      var ke = ie.contextType;
      if (typeof ke == "object" && ke !== null)
        Ce.context = Vi(ke);
      else {
        var at = Vd(re, ie, !0);
        Ce.context = Bd(re, at);
      }
      {
        if (Ce.state === he) {
          var mt = nn(ie) || "Component";
          U0.has(mt) || (U0.add(mt), be("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", mt));
        }
        re.mode & qn && bs.recordLegacyContextWarning(re, Ce), bs.recordUnsafeLifecycleWarnings(re, Ce);
      }
      Ce.state = re.memoizedState;
      var gt = ie.getDerivedStateFromProps;
      if (typeof gt == "function" && (W0(re, ie, gt, he), Ce.state = re.memoizedState), typeof ie.getDerivedStateFromProps != "function" && typeof Ce.getSnapshotBeforeUpdate != "function" && (typeof Ce.UNSAFE_componentWillMount == "function" || typeof Ce.componentWillMount == "function") && (Vw(re, Ce), my(re, he, Ce, ve), Ce.state = re.memoizedState), typeof Ce.componentDidMount == "function") {
        var Tt = Yr;
        Tt |= Aa, (re.mode & ho) !== Nr && (Tt |= Pa), re.flags |= Tt;
      }
    }
    function Bw(re, ie, he, ve) {
      var Ce = re.stateNode, ke = re.memoizedProps;
      Ce.props = ke;
      var at = Ce.context, mt = ie.contextType, gt = Mo;
      if (typeof mt == "object" && mt !== null)
        gt = Vi(mt);
      else {
        var Tt = Vd(re, ie, !0);
        gt = Bd(re, Tt);
      }
      var Pt = ie.getDerivedStateFromProps, Nt = typeof Pt == "function" || typeof Ce.getSnapshotBeforeUpdate == "function";
      !Nt && (typeof Ce.UNSAFE_componentWillReceiveProps == "function" || typeof Ce.componentWillReceiveProps == "function") && (ke !== he || at !== gt) && jE(re, Ce, he, gt), $E();
      var $t = re.memoizedState, Gt = Ce.state = $t;
      if (my(re, he, Ce, ve), Gt = re.memoizedState, ke === he && $t === Gt && !Jv() && !vy()) {
        if (typeof Ce.componentDidMount == "function") {
          var Wt = Yr;
          Wt |= Aa, (re.mode & ho) !== Nr && (Wt |= Pa), re.flags |= Wt;
        }
        return !1;
      }
      typeof Pt == "function" && (W0(re, ie, Pt, he), Gt = re.memoizedState);
      var Xt = vy() || BE(re, ie, ke, he, $t, Gt, gt);
      if (Xt) {
        if (!Nt && (typeof Ce.UNSAFE_componentWillMount == "function" || typeof Ce.componentWillMount == "function") && (typeof Ce.componentWillMount == "function" && Ce.componentWillMount(), typeof Ce.UNSAFE_componentWillMount == "function" && Ce.UNSAFE_componentWillMount()), typeof Ce.componentDidMount == "function") {
          var br = Yr;
          br |= Aa, (re.mode & ho) !== Nr && (br |= Pa), re.flags |= br;
        }
      } else {
        if (typeof Ce.componentDidMount == "function") {
          var $r = Yr;
          $r |= Aa, (re.mode & ho) !== Nr && ($r |= Pa), re.flags |= $r;
        }
        re.memoizedProps = he, re.memoizedState = Gt;
      }
      return Ce.props = he, Ce.state = Gt, Ce.context = gt, Xt;
    }
    function Hw(re, ie, he, ve, Ce) {
      var ke = ie.stateNode;
      LE(re, ie);
      var at = ie.memoizedProps, mt = ie.type === ie.elementType ? at : Cs(ie.type, at);
      ke.props = mt;
      var gt = ie.pendingProps, Tt = ke.context, Pt = he.contextType, Nt = Mo;
      if (typeof Pt == "object" && Pt !== null)
        Nt = Vi(Pt);
      else {
        var $t = Vd(ie, he, !0);
        Nt = Bd(ie, $t);
      }
      var Gt = he.getDerivedStateFromProps, Wt = typeof Gt == "function" || typeof ke.getSnapshotBeforeUpdate == "function";
      !Wt && (typeof ke.UNSAFE_componentWillReceiveProps == "function" || typeof ke.componentWillReceiveProps == "function") && (at !== gt || Tt !== Nt) && jE(ie, ke, ve, Nt), $E();
      var Xt = ie.memoizedState, br = ke.state = Xt;
      if (my(ie, ve, ke, Ce), br = ie.memoizedState, at === gt && Xt === br && !Jv() && !vy() && !Et)
        return typeof ke.componentDidUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= Yr), typeof ke.getSnapshotBeforeUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= lo), !1;
      typeof Gt == "function" && (W0(ie, he, Gt, ve), br = ie.memoizedState);
      var $r = vy() || BE(ie, he, mt, ve, Xt, br, Nt) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Et;
      return $r ? (!Wt && (typeof ke.UNSAFE_componentWillUpdate == "function" || typeof ke.componentWillUpdate == "function") && (typeof ke.componentWillUpdate == "function" && ke.componentWillUpdate(ve, br, Nt), typeof ke.UNSAFE_componentWillUpdate == "function" && ke.UNSAFE_componentWillUpdate(ve, br, Nt)), typeof ke.componentDidUpdate == "function" && (ie.flags |= Yr), typeof ke.getSnapshotBeforeUpdate == "function" && (ie.flags |= lo)) : (typeof ke.componentDidUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= Yr), typeof ke.getSnapshotBeforeUpdate == "function" && (at !== re.memoizedProps || Xt !== re.memoizedState) && (ie.flags |= lo), ie.memoizedProps = ve, ie.memoizedState = br), ke.props = ve, ke.state = br, ke.context = Nt, $r;
    }
    var Q0, X0, K0, J0, Z0, GE = function(re, ie) {
    };
    Q0 = !1, X0 = !1, K0 = {}, J0 = {}, Z0 = {}, GE = function(re, ie) {
      if (!(re === null || typeof re != "object") && !(!re._store || re._store.validated || re.key != null)) {
        if (typeof re._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        re._store.validated = !0;
        var he = Gr(ie) || "Component";
        J0[he] || (J0[he] = !0, be('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function jp(re, ie, he) {
      var ve = he.ref;
      if (ve !== null && typeof ve != "function" && typeof ve != "object") {
        if ((re.mode & qn || pr) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(he._owner && he._self && he._owner.stateNode !== he._self)) {
          var Ce = Gr(re) || "Component";
          K0[Ce] || (be('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ve), K0[Ce] = !0);
        }
        if (he._owner) {
          var ke = he._owner, at;
          if (ke) {
            var mt = ke;
            if (mt.tag !== rt)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            at = mt.stateNode;
          }
          if (!at)
            throw new Error("Missing owner for string ref " + ve + ". This error is likely caused by a bug in React. Please file an issue.");
          var gt = at;
          Si(ve, "ref");
          var Tt = "" + ve;
          if (ie !== null && ie.ref !== null && typeof ie.ref == "function" && ie.ref._stringRef === Tt)
            return ie.ref;
          var Pt = function(Nt) {
            var $t = gt.refs;
            $t === NE && ($t = gt.refs = {}), Nt === null ? delete $t[Tt] : $t[Tt] = Nt;
          };
          return Pt._stringRef = Tt, Pt;
        } else {
          if (typeof ve != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!he._owner)
            throw new Error("Element ref was specified as a string (" + ve + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return ve;
    }
    function gy(re, ie) {
      var he = Object.prototype.toString.call(ie);
      throw new Error("Objects are not valid as a React child (found: " + (he === "[object Object]" ? "object with keys {" + Object.keys(ie).join(", ") + "}" : he) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Sy(re) {
      {
        var ie = Gr(re) || "Component";
        if (Z0[ie])
          return;
        Z0[ie] = !0, be("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function WE(re) {
      var ie = re._payload, he = re._init;
      return he(ie);
    }
    function qE(re) {
      function ie(Ht, Kt) {
        if (re) {
          var Ut = Ht.deletions;
          Ut === null ? (Ht.deletions = [Kt], Ht.flags |= hn) : Ut.push(Kt);
        }
      }
      function he(Ht, Kt) {
        if (!re)
          return null;
        for (var Ut = Kt; Ut !== null; )
          ie(Ht, Ut), Ut = Ut.sibling;
        return null;
      }
      function ve(Ht, Kt) {
        for (var Ut = /* @__PURE__ */ new Map(), ur = Kt; ur !== null; )
          ur.key !== null ? Ut.set(ur.key, ur) : Ut.set(ur.index, ur), ur = ur.sibling;
        return Ut;
      }
      function Ce(Ht, Kt) {
        var Ut = yc(Ht, Kt);
        return Ut.index = 0, Ut.sibling = null, Ut;
      }
      function ke(Ht, Kt, Ut) {
        if (Ht.index = Ut, !re)
          return Ht.flags |= Ih, Kt;
        var ur = Ht.alternate;
        if (ur !== null) {
          var Cr = ur.index;
          return Cr < Kt ? (Ht.flags |= Dn, Kt) : Cr;
        } else
          return Ht.flags |= Dn, Kt;
      }
      function at(Ht) {
        return re && Ht.alternate === null && (Ht.flags |= Dn), Ht;
      }
      function mt(Ht, Kt, Ut, ur) {
        if (Kt === null || Kt.tag !== it) {
          var Cr = _S(Ut, Ht.mode, ur);
          return Cr.return = Ht, Cr;
        } else {
          var yr = Ce(Kt, Ut);
          return yr.return = Ht, yr;
        }
      }
      function gt(Ht, Kt, Ut, ur) {
        var Cr = Ut.type;
        if (Cr === Ba)
          return Pt(Ht, Kt, Ut.props.children, ur, Ut.key);
        if (Kt !== null && (Kt.elementType === Cr || // Keep this check inline so it only runs on the false path:
        NC(Kt, Ut) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Cr == "object" && Cr !== null && Cr.$$typeof === Bi && WE(Cr) === Kt.type)) {
          var yr = Ce(Kt, Ut.props);
          return yr.ref = jp(Ht, Kt, Ut), yr.return = Ht, yr._debugSource = Ut._source, yr._debugOwner = Ut._owner, yr;
        }
        var Br = wS(Ut, Ht.mode, ur);
        return Br.ref = jp(Ht, Kt, Ut), Br.return = Ht, Br;
      }
      function Tt(Ht, Kt, Ut, ur) {
        if (Kt === null || Kt.tag !== lt || Kt.stateNode.containerInfo !== Ut.containerInfo || Kt.stateNode.implementation !== Ut.implementation) {
          var Cr = AS(Ut, Ht.mode, ur);
          return Cr.return = Ht, Cr;
        } else {
          var yr = Ce(Kt, Ut.children || []);
          return yr.return = Ht, yr;
        }
      }
      function Pt(Ht, Kt, Ut, ur, Cr) {
        if (Kt === null || Kt.tag !== ut) {
          var yr = ff(Ut, Ht.mode, ur, Cr);
          return yr.return = Ht, yr;
        } else {
          var Br = Ce(Kt, Ut);
          return Br.return = Ht, Br;
        }
      }
      function Nt(Ht, Kt, Ut) {
        if (typeof Kt == "string" && Kt !== "" || typeof Kt == "number") {
          var ur = _S("" + Kt, Ht.mode, Ut);
          return ur.return = Ht, ur;
        }
        if (typeof Kt == "object" && Kt !== null) {
          switch (Kt.$$typeof) {
            case Ms: {
              var Cr = wS(Kt, Ht.mode, Ut);
              return Cr.ref = jp(Ht, null, Kt), Cr.return = Ht, Cr;
            }
            case ba: {
              var yr = AS(Kt, Ht.mode, Ut);
              return yr.return = Ht, yr;
            }
            case Bi: {
              var Br = Kt._payload, qr = Kt._init;
              return Nt(Ht, qr(Br), Ut);
            }
          }
          if (Di(Kt) || To(Kt)) {
            var Cn = ff(Kt, Ht.mode, Ut, null);
            return Cn.return = Ht, Cn;
          }
          gy(Ht, Kt);
        }
        return typeof Kt == "function" && Sy(Ht), null;
      }
      function $t(Ht, Kt, Ut, ur) {
        var Cr = Kt !== null ? Kt.key : null;
        if (typeof Ut == "string" && Ut !== "" || typeof Ut == "number")
          return Cr !== null ? null : mt(Ht, Kt, "" + Ut, ur);
        if (typeof Ut == "object" && Ut !== null) {
          switch (Ut.$$typeof) {
            case Ms:
              return Ut.key === Cr ? gt(Ht, Kt, Ut, ur) : null;
            case ba:
              return Ut.key === Cr ? Tt(Ht, Kt, Ut, ur) : null;
            case Bi: {
              var yr = Ut._payload, Br = Ut._init;
              return $t(Ht, Kt, Br(yr), ur);
            }
          }
          if (Di(Ut) || To(Ut))
            return Cr !== null ? null : Pt(Ht, Kt, Ut, ur, null);
          gy(Ht, Ut);
        }
        return typeof Ut == "function" && Sy(Ht), null;
      }
      function Gt(Ht, Kt, Ut, ur, Cr) {
        if (typeof ur == "string" && ur !== "" || typeof ur == "number") {
          var yr = Ht.get(Ut) || null;
          return mt(Kt, yr, "" + ur, Cr);
        }
        if (typeof ur == "object" && ur !== null) {
          switch (ur.$$typeof) {
            case Ms: {
              var Br = Ht.get(ur.key === null ? Ut : ur.key) || null;
              return gt(Kt, Br, ur, Cr);
            }
            case ba: {
              var qr = Ht.get(ur.key === null ? Ut : ur.key) || null;
              return Tt(Kt, qr, ur, Cr);
            }
            case Bi:
              var Cn = ur._payload, cn = ur._init;
              return Gt(Ht, Kt, Ut, cn(Cn), Cr);
          }
          if (Di(ur) || To(ur)) {
            var Pi = Ht.get(Ut) || null;
            return Pt(Kt, Pi, ur, Cr, null);
          }
          gy(Kt, ur);
        }
        return typeof ur == "function" && Sy(Kt), null;
      }
      function Wt(Ht, Kt, Ut) {
        {
          if (typeof Ht != "object" || Ht === null)
            return Kt;
          switch (Ht.$$typeof) {
            case Ms:
            case ba:
              GE(Ht, Ut);
              var ur = Ht.key;
              if (typeof ur != "string")
                break;
              if (Kt === null) {
                Kt = /* @__PURE__ */ new Set(), Kt.add(ur);
                break;
              }
              if (!Kt.has(ur)) {
                Kt.add(ur);
                break;
              }
              be("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", ur);
              break;
            case Bi:
              var Cr = Ht._payload, yr = Ht._init;
              Wt(yr(Cr), Kt, Ut);
              break;
          }
        }
        return Kt;
      }
      function Xt(Ht, Kt, Ut, ur) {
        for (var Cr = null, yr = 0; yr < Ut.length; yr++) {
          var Br = Ut[yr];
          Cr = Wt(Br, Cr, Ht);
        }
        for (var qr = null, Cn = null, cn = Kt, Pi = 0, dn = 0, gi = null; cn !== null && dn < Ut.length; dn++) {
          cn.index > dn ? (gi = cn, cn = null) : gi = cn.sibling;
          var Ia = $t(Ht, cn, Ut[dn], ur);
          if (Ia === null) {
            cn === null && (cn = gi);
            break;
          }
          re && cn && Ia.alternate === null && ie(Ht, cn), Pi = ke(Ia, Pi, dn), Cn === null ? qr = Ia : Cn.sibling = Ia, Cn = Ia, cn = gi;
        }
        if (dn === Ut.length) {
          if (he(Ht, cn), da()) {
            var Sa = dn;
            ic(Ht, Sa);
          }
          return qr;
        }
        if (cn === null) {
          for (; dn < Ut.length; dn++) {
            var Do = Nt(Ht, Ut[dn], ur);
            Do !== null && (Pi = ke(Do, Pi, dn), Cn === null ? qr = Do : Cn.sibling = Do, Cn = Do);
          }
          if (da()) {
            var Za = dn;
            ic(Ht, Za);
          }
          return qr;
        }
        for (var eo = ve(Ht, cn); dn < Ut.length; dn++) {
          var Na = Gt(eo, Ht, dn, Ut[dn], ur);
          Na !== null && (re && Na.alternate !== null && eo.delete(Na.key === null ? dn : Na.key), Pi = ke(Na, Pi, dn), Cn === null ? qr = Na : Cn.sibling = Na, Cn = Na);
        }
        if (re && eo.forEach(function(uh) {
          return ie(Ht, uh);
        }), da()) {
          var au = dn;
          ic(Ht, au);
        }
        return qr;
      }
      function br(Ht, Kt, Ut, ur) {
        var Cr = To(Ut);
        if (typeof Cr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ut[Symbol.toStringTag] === "Generator" && (X0 || be("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), X0 = !0), Ut.entries === Cr && (Q0 || be("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Q0 = !0);
          var yr = Cr.call(Ut);
          if (yr)
            for (var Br = null, qr = yr.next(); !qr.done; qr = yr.next()) {
              var Cn = qr.value;
              Br = Wt(Cn, Br, Ht);
            }
        }
        var cn = Cr.call(Ut);
        if (cn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Pi = null, dn = null, gi = Kt, Ia = 0, Sa = 0, Do = null, Za = cn.next(); gi !== null && !Za.done; Sa++, Za = cn.next()) {
          gi.index > Sa ? (Do = gi, gi = null) : Do = gi.sibling;
          var eo = $t(Ht, gi, Za.value, ur);
          if (eo === null) {
            gi === null && (gi = Do);
            break;
          }
          re && gi && eo.alternate === null && ie(Ht, gi), Ia = ke(eo, Ia, Sa), dn === null ? Pi = eo : dn.sibling = eo, dn = eo, gi = Do;
        }
        if (Za.done) {
          if (he(Ht, gi), da()) {
            var Na = Sa;
            ic(Ht, Na);
          }
          return Pi;
        }
        if (gi === null) {
          for (; !Za.done; Sa++, Za = cn.next()) {
            var au = Nt(Ht, Za.value, ur);
            au !== null && (Ia = ke(au, Ia, Sa), dn === null ? Pi = au : dn.sibling = au, dn = au);
          }
          if (da()) {
            var uh = Sa;
            ic(Ht, uh);
          }
          return Pi;
        }
        for (var Em = ve(Ht, gi); !Za.done; Sa++, Za = cn.next()) {
          var cl = Gt(Em, Ht, Sa, Za.value, ur);
          cl !== null && (re && cl.alternate !== null && Em.delete(cl.key === null ? Sa : cl.key), Ia = ke(cl, Ia, Sa), dn === null ? Pi = cl : dn.sibling = cl, dn = cl);
        }
        if (re && Em.forEach(function(rR) {
          return ie(Ht, rR);
        }), da()) {
          var tR = Sa;
          ic(Ht, tR);
        }
        return Pi;
      }
      function $r(Ht, Kt, Ut, ur) {
        if (Kt !== null && Kt.tag === it) {
          he(Ht, Kt.sibling);
          var Cr = Ce(Kt, Ut);
          return Cr.return = Ht, Cr;
        }
        he(Ht, Kt);
        var yr = _S(Ut, Ht.mode, ur);
        return yr.return = Ht, yr;
      }
      function Mr(Ht, Kt, Ut, ur) {
        for (var Cr = Ut.key, yr = Kt; yr !== null; ) {
          if (yr.key === Cr) {
            var Br = Ut.type;
            if (Br === Ba) {
              if (yr.tag === ut) {
                he(Ht, yr.sibling);
                var qr = Ce(yr, Ut.props.children);
                return qr.return = Ht, qr._debugSource = Ut._source, qr._debugOwner = Ut._owner, qr;
              }
            } else if (yr.elementType === Br || // Keep this check inline so it only runs on the false path:
            NC(yr, Ut) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Br == "object" && Br !== null && Br.$$typeof === Bi && WE(Br) === yr.type) {
              he(Ht, yr.sibling);
              var Cn = Ce(yr, Ut.props);
              return Cn.ref = jp(Ht, yr, Ut), Cn.return = Ht, Cn._debugSource = Ut._source, Cn._debugOwner = Ut._owner, Cn;
            }
            he(Ht, yr);
            break;
          } else
            ie(Ht, yr);
          yr = yr.sibling;
        }
        if (Ut.type === Ba) {
          var cn = ff(Ut.props.children, Ht.mode, ur, Ut.key);
          return cn.return = Ht, cn;
        } else {
          var Pi = wS(Ut, Ht.mode, ur);
          return Pi.ref = jp(Ht, Kt, Ut), Pi.return = Ht, Pi;
        }
      }
      function sn(Ht, Kt, Ut, ur) {
        for (var Cr = Ut.key, yr = Kt; yr !== null; ) {
          if (yr.key === Cr)
            if (yr.tag === lt && yr.stateNode.containerInfo === Ut.containerInfo && yr.stateNode.implementation === Ut.implementation) {
              he(Ht, yr.sibling);
              var Br = Ce(yr, Ut.children || []);
              return Br.return = Ht, Br;
            } else {
              he(Ht, yr);
              break;
            }
          else
            ie(Ht, yr);
          yr = yr.sibling;
        }
        var qr = AS(Ut, Ht.mode, ur);
        return qr.return = Ht, qr;
      }
      function rn(Ht, Kt, Ut, ur) {
        var Cr = typeof Ut == "object" && Ut !== null && Ut.type === Ba && Ut.key === null;
        if (Cr && (Ut = Ut.props.children), typeof Ut == "object" && Ut !== null) {
          switch (Ut.$$typeof) {
            case Ms:
              return at(Mr(Ht, Kt, Ut, ur));
            case ba:
              return at(sn(Ht, Kt, Ut, ur));
            case Bi:
              var yr = Ut._payload, Br = Ut._init;
              return rn(Ht, Kt, Br(yr), ur);
          }
          if (Di(Ut))
            return Xt(Ht, Kt, Ut, ur);
          if (To(Ut))
            return br(Ht, Kt, Ut, ur);
          gy(Ht, Ut);
        }
        return typeof Ut == "string" && Ut !== "" || typeof Ut == "number" ? at($r(Ht, Kt, "" + Ut, ur)) : (typeof Ut == "function" && Sy(Ht), he(Ht, Kt));
      }
      return rn;
    }
    var qd = qE(!0), YE = qE(!1);
    function Uw(re, ie) {
      if (re !== null && ie.child !== re.child)
        throw new Error("Resuming work not yet implemented.");
      if (ie.child !== null) {
        var he = ie.child, ve = yc(he, he.pendingProps);
        for (ie.child = ve, ve.return = ie; he.sibling !== null; )
          he = he.sibling, ve = ve.sibling = yc(he, he.pendingProps), ve.return = ie;
        ve.sibling = null;
      }
    }
    function jw(re, ie) {
      for (var he = re.child; he !== null; )
        SP(he, ie), he = he.sibling;
    }
    var Gp = {}, ef = Qu(Gp), Wp = Qu(Gp), Ey = Qu(Gp);
    function by(re) {
      if (re === Gp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return re;
    }
    function QE() {
      var re = by(Ey.current);
      return re;
    }
    function e1(re, ie) {
      La(Ey, ie, re), La(Wp, re, re), La(ef, Gp, re);
      var he = iT(ie);
      Oa(ef, re), La(ef, he, re);
    }
    function Yd(re) {
      Oa(ef, re), Oa(Wp, re), Oa(Ey, re);
    }
    function t1() {
      var re = by(ef.current);
      return re;
    }
    function XE(re) {
      by(Ey.current);
      var ie = by(ef.current), he = aT(ie, re.type);
      ie !== he && (La(Wp, re, re), La(ef, he, re));
    }
    function r1(re) {
      Wp.current === re && (Oa(ef, re), Oa(Wp, re));
    }
    var Gw = 0, KE = 1, JE = 1, qp = 2, xs = Qu(Gw);
    function n1(re, ie) {
      return (re & ie) !== 0;
    }
    function Qd(re) {
      return re & KE;
    }
    function i1(re, ie) {
      return re & KE | ie;
    }
    function Ww(re, ie) {
      return re | ie;
    }
    function tf(re, ie) {
      La(xs, ie, re);
    }
    function Xd(re) {
      Oa(xs, re);
    }
    function qw(re, ie) {
      var he = re.memoizedState;
      return he !== null ? he.dehydrated !== null : (re.memoizedProps, !0);
    }
    function Cy(re) {
      for (var ie = re; ie !== null; ) {
        if (ie.tag === Ct) {
          var he = ie.memoizedState;
          if (he !== null) {
            var ve = he.dehydrated;
            if (ve === null || lE(ve) || f0(ve))
              return ie;
          }
        } else if (ie.tag === er && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        ie.memoizedProps.revealOrder !== void 0) {
          var Ce = (ie.flags & Hr) !== Or;
          if (Ce)
            return ie;
        } else if (ie.child !== null) {
          ie.child.return = ie, ie = ie.child;
          continue;
        }
        if (ie === re)
          return null;
        for (; ie.sibling === null; ) {
          if (ie.return === null || ie.return === re)
            return null;
          ie = ie.return;
        }
        ie.sibling.return = ie.return, ie = ie.sibling;
      }
      return null;
    }
    var bo = (
      /*   */
      0
    ), Gi = (
      /* */
      1
    ), il = (
      /*  */
      2
    ), Wi = (
      /*    */
      4
    ), ha = (
      /*   */
      8
    ), a1 = [];
    function o1() {
      for (var re = 0; re < a1.length; re++) {
        var ie = a1[re];
        ie._workInProgressVersionPrimary = null;
      }
      a1.length = 0;
    }
    function Yw(re, ie) {
      var he = ie._getVersion, ve = he(ie._source);
      re.mutableSourceEagerHydrationData == null ? re.mutableSourceEagerHydrationData = [ie, ve] : re.mutableSourceEagerHydrationData.push(ie, ve);
    }
    var Er = oe.ReactCurrentDispatcher, Yp = oe.ReactCurrentBatchConfig, s1, Kd;
    s1 = /* @__PURE__ */ new Set();
    var fc = Zt, bn = null, qi = null, Yi = null, xy = !1, Qp = !1, Xp = 0, Qw = 0, Xw = 25, tr = null, Xo = null, rf = -1, l1 = !1;
    function Sn() {
      {
        var re = tr;
        Xo === null ? Xo = [re] : Xo.push(re);
      }
    }
    function hr() {
      {
        var re = tr;
        Xo !== null && (rf++, Xo[rf] !== re && Kw(re));
      }
    }
    function Jd(re) {
      re != null && !Di(re) && be("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", tr, typeof re);
    }
    function Kw(re) {
      {
        var ie = Gr(bn);
        if (!s1.has(ie) && (s1.add(ie), Xo !== null)) {
          for (var he = "", ve = 30, Ce = 0; Ce <= rf; Ce++) {
            for (var ke = Xo[Ce], at = Ce === rf ? re : ke, mt = Ce + 1 + ". " + ke; mt.length < ve; )
              mt += " ";
            mt += at + `
`, he += mt;
          }
          be(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, ie, he);
        }
      }
    }
    function $a() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function u1(re, ie) {
      if (l1)
        return !1;
      if (ie === null)
        return be("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", tr), !1;
      re.length !== ie.length && be(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, tr, "[" + ie.join(", ") + "]", "[" + re.join(", ") + "]");
      for (var he = 0; he < ie.length && he < re.length; he++)
        if (!_r(re[he], ie[he]))
          return !1;
      return !0;
    }
    function Zd(re, ie, he, ve, Ce, ke) {
      fc = ke, bn = ie, Xo = re !== null ? re._debugHookTypes : null, rf = -1, l1 = re !== null && re.type !== ie.type, ie.memoizedState = null, ie.updateQueue = null, ie.lanes = Zt, re !== null && re.memoizedState !== null ? Er.current = bb : Xo !== null ? Er.current = Eb : Er.current = Sb;
      var at = he(ve, Ce);
      if (Qp) {
        var mt = 0;
        do {
          if (Qp = !1, Xp = 0, mt >= Xw)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          mt += 1, l1 = !1, qi = null, Yi = null, ie.updateQueue = null, rf = -1, Er.current = Cb, at = he(ve, Ce);
        } while (Qp);
      }
      Er.current = $y, ie._debugHookTypes = Xo;
      var gt = qi !== null && qi.next !== null;
      if (fc = Zt, bn = null, qi = null, Yi = null, tr = null, Xo = null, rf = -1, re !== null && (re.flags & Hi) !== (ie.flags & Hi) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (re.mode & Jr) !== Nr && be("Internal React error: Expected static flag was missing. Please notify the React team."), xy = !1, gt)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return at;
    }
    function eh() {
      var re = Xp !== 0;
      return Xp = 0, re;
    }
    function ZE(re, ie, he) {
      ie.updateQueue = re.updateQueue, (ie.mode & ho) !== Nr ? ie.flags &= ~(Al | Pa | Un | Yr) : ie.flags &= ~(Un | Yr), re.lanes = Fu(re.lanes, he);
    }
    function eb() {
      if (Er.current = $y, xy) {
        for (var re = bn.memoizedState; re !== null; ) {
          var ie = re.queue;
          ie !== null && (ie.pending = null), re = re.next;
        }
        xy = !1;
      }
      fc = Zt, bn = null, qi = null, Yi = null, Xo = null, rf = -1, tr = null, pb = !1, Qp = !1, Xp = 0;
    }
    function al() {
      var re = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Yi === null ? bn.memoizedState = Yi = re : Yi = Yi.next = re, Yi;
    }
    function Ko() {
      var re;
      if (qi === null) {
        var ie = bn.alternate;
        ie !== null ? re = ie.memoizedState : re = null;
      } else
        re = qi.next;
      var he;
      if (Yi === null ? he = bn.memoizedState : he = Yi.next, he !== null)
        Yi = he, he = Yi.next, qi = re;
      else {
        if (re === null)
          throw new Error("Rendered more hooks than during the previous render.");
        qi = re;
        var ve = {
          memoizedState: qi.memoizedState,
          baseState: qi.baseState,
          baseQueue: qi.baseQueue,
          queue: qi.queue,
          next: null
        };
        Yi === null ? bn.memoizedState = Yi = ve : Yi = Yi.next = ve;
      }
      return Yi;
    }
    function tb() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function f1(re, ie) {
      return typeof ie == "function" ? ie(re) : ie;
    }
    function c1(re, ie, he) {
      var ve = al(), Ce;
      he !== void 0 ? Ce = he(ie) : Ce = ie, ve.memoizedState = ve.baseState = Ce;
      var ke = {
        pending: null,
        interleaved: null,
        lanes: Zt,
        dispatch: null,
        lastRenderedReducer: re,
        lastRenderedState: Ce
      };
      ve.queue = ke;
      var at = ke.dispatch = t_.bind(null, bn, ke);
      return [ve.memoizedState, at];
    }
    function d1(re, ie, he) {
      var ve = Ko(), Ce = ve.queue;
      if (Ce === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Ce.lastRenderedReducer = re;
      var ke = qi, at = ke.baseQueue, mt = Ce.pending;
      if (mt !== null) {
        if (at !== null) {
          var gt = at.next, Tt = mt.next;
          at.next = Tt, mt.next = gt;
        }
        ke.baseQueue !== at && be("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), ke.baseQueue = at = mt, Ce.pending = null;
      }
      if (at !== null) {
        var Pt = at.next, Nt = ke.baseState, $t = null, Gt = null, Wt = null, Xt = Pt;
        do {
          var br = Xt.lane;
          if (Il(fc, br)) {
            if (Wt !== null) {
              var Mr = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: an,
                action: Xt.action,
                hasEagerState: Xt.hasEagerState,
                eagerState: Xt.eagerState,
                next: null
              };
              Wt = Wt.next = Mr;
            }
            if (Xt.hasEagerState)
              Nt = Xt.eagerState;
            else {
              var sn = Xt.action;
              Nt = re(Nt, sn);
            }
          } else {
            var $r = {
              lane: br,
              action: Xt.action,
              hasEagerState: Xt.hasEagerState,
              eagerState: Xt.eagerState,
              next: null
            };
            Wt === null ? (Gt = Wt = $r, $t = Nt) : Wt = Wt.next = $r, bn.lanes = Qr(bn.lanes, br), mm(br);
          }
          Xt = Xt.next;
        } while (Xt !== null && Xt !== Pt);
        Wt === null ? $t = Nt : Wt.next = Gt, _r(Nt, ve.memoizedState) || nm(), ve.memoizedState = Nt, ve.baseState = $t, ve.baseQueue = Wt, Ce.lastRenderedState = Nt;
      }
      var rn = Ce.interleaved;
      if (rn !== null) {
        var Ht = rn;
        do {
          var Kt = Ht.lane;
          bn.lanes = Qr(bn.lanes, Kt), mm(Kt), Ht = Ht.next;
        } while (Ht !== rn);
      } else
        at === null && (Ce.lanes = Zt);
      var Ut = Ce.dispatch;
      return [ve.memoizedState, Ut];
    }
    function h1(re, ie, he) {
      var ve = Ko(), Ce = ve.queue;
      if (Ce === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      Ce.lastRenderedReducer = re;
      var ke = Ce.dispatch, at = Ce.pending, mt = ve.memoizedState;
      if (at !== null) {
        Ce.pending = null;
        var gt = at.next, Tt = gt;
        do {
          var Pt = Tt.action;
          mt = re(mt, Pt), Tt = Tt.next;
        } while (Tt !== gt);
        _r(mt, ve.memoizedState) || nm(), ve.memoizedState = mt, ve.baseQueue === null && (ve.baseState = mt), Ce.lastRenderedState = mt;
      }
      return [mt, ke];
    }
    function iR(re, ie, he) {
    }
    function aR(re, ie, he) {
    }
    function p1(re, ie, he) {
      var ve = bn, Ce = al(), ke, at = da();
      if (at) {
        if (he === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        ke = he(), Kd || ke !== he() && (be("The result of getServerSnapshot should be cached to avoid an infinite loop"), Kd = !0);
      } else {
        if (ke = ie(), !Kd) {
          var mt = ie();
          _r(ke, mt) || (be("The result of getSnapshot should be cached to avoid an infinite loop"), Kd = !0);
        }
        var gt = eg();
        if (gt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Bf(gt, fc) || rb(ve, ie, ke);
      }
      Ce.memoizedState = ke;
      var Tt = {
        value: ke,
        getSnapshot: ie
      };
      return Ce.queue = Tt, Py(ib.bind(null, ve, Tt, re), [re]), ve.flags |= Un, Kp(Gi | ha, nb.bind(null, ve, Tt, ke, ie), void 0, null), ke;
    }
    function Ty(re, ie, he) {
      var ve = bn, Ce = Ko(), ke = ie();
      if (!Kd) {
        var at = ie();
        _r(ke, at) || (be("The result of getSnapshot should be cached to avoid an infinite loop"), Kd = !0);
      }
      var mt = Ce.memoizedState, gt = !_r(mt, ke);
      gt && (Ce.memoizedState = ke, nm());
      var Tt = Ce.queue;
      if (Zp(ib.bind(null, ve, Tt, re), [re]), Tt.getSnapshot !== ie || gt || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Yi !== null && Yi.memoizedState.tag & Gi) {
        ve.flags |= Un, Kp(Gi | ha, nb.bind(null, ve, Tt, ke, ie), void 0, null);
        var Pt = eg();
        if (Pt === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Bf(Pt, fc) || rb(ve, ie, ke);
      }
      return ke;
    }
    function rb(re, ie, he) {
      re.flags |= Ff;
      var ve = {
        getSnapshot: ie,
        value: he
      }, Ce = bn.updateQueue;
      if (Ce === null)
        Ce = tb(), bn.updateQueue = Ce, Ce.stores = [ve];
      else {
        var ke = Ce.stores;
        ke === null ? Ce.stores = [ve] : ke.push(ve);
      }
    }
    function nb(re, ie, he, ve) {
      ie.value = he, ie.getSnapshot = ve, ab(ie) && sb(re);
    }
    function ib(re, ie, he) {
      var ve = function() {
        ab(ie) && sb(re);
      };
      return he(ve);
    }
    function ab(re) {
      var ie = re.getSnapshot, he = re.value;
      try {
        var ve = ie();
        return !_r(he, ve);
      } catch {
        return !0;
      }
    }
    function sb(re) {
      var ie = Eo(re, Vr);
      ie !== null && Ji(ie, re, Vr, Pn);
    }
    function wy(re) {
      var ie = al();
      typeof re == "function" && (re = re()), ie.memoizedState = ie.baseState = re;
      var he = {
        pending: null,
        interleaved: null,
        lanes: Zt,
        dispatch: null,
        lastRenderedReducer: f1,
        lastRenderedState: re
      };
      ie.queue = he;
      var ve = he.dispatch = r_.bind(null, bn, he);
      return [ie.memoizedState, ve];
    }
    function m1(re) {
      return d1(f1);
    }
    function v1(re) {
      return h1(f1);
    }
    function Kp(re, ie, he, ve) {
      var Ce = {
        tag: re,
        create: ie,
        destroy: he,
        deps: ve,
        // Circular
        next: null
      }, ke = bn.updateQueue;
      if (ke === null)
        ke = tb(), bn.updateQueue = ke, ke.lastEffect = Ce.next = Ce;
      else {
        var at = ke.lastEffect;
        if (at === null)
          ke.lastEffect = Ce.next = Ce;
        else {
          var mt = at.next;
          at.next = Ce, Ce.next = mt, ke.lastEffect = Ce;
        }
      }
      return Ce;
    }
    function y1(re) {
      var ie = al();
      {
        var he = {
          current: re
        };
        return ie.memoizedState = he, he;
      }
    }
    function _y(re) {
      var ie = Ko();
      return ie.memoizedState;
    }
    function Jp(re, ie, he, ve) {
      var Ce = al(), ke = ve === void 0 ? null : ve;
      bn.flags |= re, Ce.memoizedState = Kp(Gi | ie, he, void 0, ke);
    }
    function Ay(re, ie, he, ve) {
      var Ce = Ko(), ke = ve === void 0 ? null : ve, at = void 0;
      if (qi !== null) {
        var mt = qi.memoizedState;
        if (at = mt.destroy, ke !== null) {
          var gt = mt.deps;
          if (u1(ke, gt)) {
            Ce.memoizedState = Kp(ie, he, at, ke);
            return;
          }
        }
      }
      bn.flags |= re, Ce.memoizedState = Kp(Gi | ie, he, at, ke);
    }
    function Py(re, ie) {
      return (bn.mode & ho) !== Nr ? Jp(Al | Un | Bs, ha, re, ie) : Jp(Un | Bs, ha, re, ie);
    }
    function Zp(re, ie) {
      return Ay(Un, ha, re, ie);
    }
    function g1(re, ie) {
      return Jp(Yr, il, re, ie);
    }
    function Ry(re, ie) {
      return Ay(Yr, il, re, ie);
    }
    function S1(re, ie) {
      var he = Yr;
      return he |= Aa, (bn.mode & ho) !== Nr && (he |= Pa), Jp(he, Wi, re, ie);
    }
    function ky(re, ie) {
      return Ay(Yr, Wi, re, ie);
    }
    function lb(re, ie) {
      if (typeof ie == "function") {
        var he = ie, ve = re();
        return he(ve), function() {
          he(null);
        };
      } else if (ie != null) {
        var Ce = ie;
        Ce.hasOwnProperty("current") || be("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(Ce).join(", ") + "}");
        var ke = re();
        return Ce.current = ke, function() {
          Ce.current = null;
        };
      }
    }
    function E1(re, ie, he) {
      typeof ie != "function" && be("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ie !== null ? typeof ie : "null");
      var ve = he != null ? he.concat([re]) : null, Ce = Yr;
      return Ce |= Aa, (bn.mode & ho) !== Nr && (Ce |= Pa), Jp(Ce, Wi, lb.bind(null, ie, re), ve);
    }
    function My(re, ie, he) {
      typeof ie != "function" && be("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", ie !== null ? typeof ie : "null");
      var ve = he != null ? he.concat([re]) : null;
      return Ay(Yr, Wi, lb.bind(null, ie, re), ve);
    }
    function Jw(re, ie) {
    }
    var Fy = Jw;
    function b1(re, ie) {
      var he = al(), ve = ie === void 0 ? null : ie;
      return he.memoizedState = [re, ve], re;
    }
    function Dy(re, ie) {
      var he = Ko(), ve = ie === void 0 ? null : ie, Ce = he.memoizedState;
      if (Ce !== null && ve !== null) {
        var ke = Ce[1];
        if (u1(ve, ke))
          return Ce[0];
      }
      return he.memoizedState = [re, ve], re;
    }
    function C1(re, ie) {
      var he = al(), ve = ie === void 0 ? null : ie, Ce = re();
      return he.memoizedState = [Ce, ve], Ce;
    }
    function Oy(re, ie) {
      var he = Ko(), ve = ie === void 0 ? null : ie, Ce = he.memoizedState;
      if (Ce !== null && ve !== null) {
        var ke = Ce[1];
        if (u1(ve, ke))
          return Ce[0];
      }
      var at = re();
      return he.memoizedState = [at, ve], at;
    }
    function x1(re) {
      var ie = al();
      return ie.memoizedState = re, re;
    }
    function ub(re) {
      var ie = Ko(), he = qi, ve = he.memoizedState;
      return cb(ie, ve, re);
    }
    function fb(re) {
      var ie = Ko();
      if (qi === null)
        return ie.memoizedState = re, re;
      var he = qi.memoizedState;
      return cb(ie, he, re);
    }
    function cb(re, ie, he) {
      var ve = !Rg(fc);
      if (ve) {
        if (!_r(he, ie)) {
          var Ce = ep();
          bn.lanes = Qr(bn.lanes, Ce), mm(Ce), re.baseState = !0;
        }
        return ie;
      } else
        return re.baseState && (re.baseState = !1, nm()), re.memoizedState = he, he;
    }
    function Zw(re, ie, he) {
      var ve = mo();
      wi(ta(ve, ji)), re(!0);
      var Ce = Yp.transition;
      Yp.transition = {};
      var ke = Yp.transition;
      Yp.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        re(!1), ie();
      } finally {
        if (wi(ve), Yp.transition = Ce, Ce === null && ke._updatedFibers) {
          var at = ke._updatedFibers.size;
          at > 10 && ge("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ke._updatedFibers.clear();
        }
      }
    }
    function T1() {
      var re = wy(!1), ie = re[0], he = re[1], ve = Zw.bind(null, he), Ce = al();
      return Ce.memoizedState = ve, [ie, ve];
    }
    function db() {
      var re = m1(), ie = re[0], he = Ko(), ve = he.memoizedState;
      return [ie, ve];
    }
    function hb() {
      var re = v1(), ie = re[0], he = Ko(), ve = he.memoizedState;
      return [ie, ve];
    }
    var pb = !1;
    function e_() {
      return pb;
    }
    function w1() {
      var re = al(), ie = eg(), he = ie.identifierPrefix, ve;
      if (da()) {
        var Ce = pw();
        ve = ":" + he + "R" + Ce;
        var ke = Xp++;
        ke > 0 && (ve += "H" + ke.toString(32)), ve += ":";
      } else {
        var at = Qw++;
        ve = ":" + he + "r" + at.toString(32) + ":";
      }
      return re.memoizedState = ve, ve;
    }
    function Ly() {
      var re = Ko(), ie = re.memoizedState;
      return ie;
    }
    function t_(re, ie, he) {
      typeof arguments[3] == "function" && be("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var ve = lf(re), Ce = {
        lane: ve,
        action: he,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (mb(re))
        vb(ie, Ce);
      else {
        var ke = FE(re, ie, Ce, ve);
        if (ke !== null) {
          var at = Ja();
          Ji(ke, re, ve, at), yb(ke, ie, ve);
        }
      }
      gb(re, ve);
    }
    function r_(re, ie, he) {
      typeof arguments[3] == "function" && be("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var ve = lf(re), Ce = {
        lane: ve,
        action: he,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (mb(re))
        vb(ie, Ce);
      else {
        var ke = re.alternate;
        if (re.lanes === Zt && (ke === null || ke.lanes === Zt)) {
          var at = ie.lastRenderedReducer;
          if (at !== null) {
            var mt;
            mt = Er.current, Er.current = Ts;
            try {
              var gt = ie.lastRenderedState, Tt = at(gt, he);
              if (Ce.hasEagerState = !0, Ce.eagerState = Tt, _r(Tt, gt)) {
                Ow(re, ie, Ce, ve);
                return;
              }
            } catch {
            } finally {
              Er.current = mt;
            }
          }
        }
        var Pt = FE(re, ie, Ce, ve);
        if (Pt !== null) {
          var Nt = Ja();
          Ji(Pt, re, ve, Nt), yb(Pt, ie, ve);
        }
      }
      gb(re, ve);
    }
    function mb(re) {
      var ie = re.alternate;
      return re === bn || ie !== null && ie === bn;
    }
    function vb(re, ie) {
      Qp = xy = !0;
      var he = re.pending;
      he === null ? ie.next = ie : (ie.next = he.next, he.next = ie), re.pending = ie;
    }
    function yb(re, ie, he) {
      if (Zh(he)) {
        var ve = ie.lanes;
        ve = tp(ve, re.pendingLanes);
        var Ce = Qr(ve, he);
        ie.lanes = Ce, Du(re, Ce);
      }
    }
    function gb(re, ie, he) {
      qs(re, ie);
    }
    var $y = {
      readContext: Vi,
      useCallback: $a,
      useContext: $a,
      useEffect: $a,
      useImperativeHandle: $a,
      useInsertionEffect: $a,
      useLayoutEffect: $a,
      useMemo: $a,
      useReducer: $a,
      useRef: $a,
      useState: $a,
      useDebugValue: $a,
      useDeferredValue: $a,
      useTransition: $a,
      useMutableSource: $a,
      useSyncExternalStore: $a,
      useId: $a,
      unstable_isNewReconciler: yt
    }, Sb = null, Eb = null, bb = null, Cb = null, ol = null, Ts = null, Iy = null;
    {
      var _1 = function() {
        be("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Wr = function() {
        be("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Sb = {
        readContext: function(re) {
          return Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", Sn(), Jd(ie), b1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", Sn(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", Sn(), Jd(ie), Py(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", Sn(), Jd(he), E1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", Sn(), Jd(ie), g1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", Sn(), Jd(ie), S1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", Sn(), Jd(ie);
          var he = Er.current;
          Er.current = ol;
          try {
            return C1(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", Sn();
          var ve = Er.current;
          Er.current = ol;
          try {
            return c1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", Sn(), y1(re);
        },
        useState: function(re) {
          tr = "useState", Sn();
          var ie = Er.current;
          Er.current = ol;
          try {
            return wy(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", Sn(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", Sn(), x1(re);
        },
        useTransition: function() {
          return tr = "useTransition", Sn(), T1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", Sn(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", Sn(), p1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", Sn(), w1();
        },
        unstable_isNewReconciler: yt
      }, Eb = {
        readContext: function(re) {
          return Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", hr(), b1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", hr(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", hr(), Py(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", hr(), E1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", hr(), g1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", hr(), S1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", hr();
          var he = Er.current;
          Er.current = ol;
          try {
            return C1(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", hr();
          var ve = Er.current;
          Er.current = ol;
          try {
            return c1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", hr(), y1(re);
        },
        useState: function(re) {
          tr = "useState", hr();
          var ie = Er.current;
          Er.current = ol;
          try {
            return wy(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", hr(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", hr(), x1(re);
        },
        useTransition: function() {
          return tr = "useTransition", hr(), T1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", hr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", hr(), p1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", hr(), w1();
        },
        unstable_isNewReconciler: yt
      }, bb = {
        readContext: function(re) {
          return Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", hr(), Dy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", hr(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", hr(), Zp(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", hr(), My(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", hr(), Ry(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", hr(), ky(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", hr();
          var he = Er.current;
          Er.current = Ts;
          try {
            return Oy(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", hr();
          var ve = Er.current;
          Er.current = Ts;
          try {
            return d1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", hr(), _y();
        },
        useState: function(re) {
          tr = "useState", hr();
          var ie = Er.current;
          Er.current = Ts;
          try {
            return m1(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", hr(), Fy();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", hr(), ub(re);
        },
        useTransition: function() {
          return tr = "useTransition", hr(), db();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", hr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", hr(), Ty(re, ie);
        },
        useId: function() {
          return tr = "useId", hr(), Ly();
        },
        unstable_isNewReconciler: yt
      }, Cb = {
        readContext: function(re) {
          return Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", hr(), Dy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", hr(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", hr(), Zp(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", hr(), My(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", hr(), Ry(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", hr(), ky(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", hr();
          var he = Er.current;
          Er.current = Iy;
          try {
            return Oy(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", hr();
          var ve = Er.current;
          Er.current = Iy;
          try {
            return h1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", hr(), _y();
        },
        useState: function(re) {
          tr = "useState", hr();
          var ie = Er.current;
          Er.current = Iy;
          try {
            return v1(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", hr(), Fy();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", hr(), fb(re);
        },
        useTransition: function() {
          return tr = "useTransition", hr(), hb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", hr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", hr(), Ty(re, ie);
        },
        useId: function() {
          return tr = "useId", hr(), Ly();
        },
        unstable_isNewReconciler: yt
      }, ol = {
        readContext: function(re) {
          return _1(), Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", Wr(), Sn(), b1(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", Wr(), Sn(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", Wr(), Sn(), Py(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", Wr(), Sn(), E1(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", Wr(), Sn(), g1(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", Wr(), Sn(), S1(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", Wr(), Sn();
          var he = Er.current;
          Er.current = ol;
          try {
            return C1(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", Wr(), Sn();
          var ve = Er.current;
          Er.current = ol;
          try {
            return c1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", Wr(), Sn(), y1(re);
        },
        useState: function(re) {
          tr = "useState", Wr(), Sn();
          var ie = Er.current;
          Er.current = ol;
          try {
            return wy(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", Wr(), Sn(), void 0;
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", Wr(), Sn(), x1(re);
        },
        useTransition: function() {
          return tr = "useTransition", Wr(), Sn(), T1();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", Wr(), Sn(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", Wr(), Sn(), p1(re, ie, he);
        },
        useId: function() {
          return tr = "useId", Wr(), Sn(), w1();
        },
        unstable_isNewReconciler: yt
      }, Ts = {
        readContext: function(re) {
          return _1(), Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", Wr(), hr(), Dy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", Wr(), hr(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", Wr(), hr(), Zp(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", Wr(), hr(), My(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", Wr(), hr(), Ry(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", Wr(), hr(), ky(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", Wr(), hr();
          var he = Er.current;
          Er.current = Ts;
          try {
            return Oy(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", Wr(), hr();
          var ve = Er.current;
          Er.current = Ts;
          try {
            return d1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", Wr(), hr(), _y();
        },
        useState: function(re) {
          tr = "useState", Wr(), hr();
          var ie = Er.current;
          Er.current = Ts;
          try {
            return m1(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", Wr(), hr(), Fy();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", Wr(), hr(), ub(re);
        },
        useTransition: function() {
          return tr = "useTransition", Wr(), hr(), db();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", Wr(), hr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", Wr(), hr(), Ty(re, ie);
        },
        useId: function() {
          return tr = "useId", Wr(), hr(), Ly();
        },
        unstable_isNewReconciler: yt
      }, Iy = {
        readContext: function(re) {
          return _1(), Vi(re);
        },
        useCallback: function(re, ie) {
          return tr = "useCallback", Wr(), hr(), Dy(re, ie);
        },
        useContext: function(re) {
          return tr = "useContext", Wr(), hr(), Vi(re);
        },
        useEffect: function(re, ie) {
          return tr = "useEffect", Wr(), hr(), Zp(re, ie);
        },
        useImperativeHandle: function(re, ie, he) {
          return tr = "useImperativeHandle", Wr(), hr(), My(re, ie, he);
        },
        useInsertionEffect: function(re, ie) {
          return tr = "useInsertionEffect", Wr(), hr(), Ry(re, ie);
        },
        useLayoutEffect: function(re, ie) {
          return tr = "useLayoutEffect", Wr(), hr(), ky(re, ie);
        },
        useMemo: function(re, ie) {
          tr = "useMemo", Wr(), hr();
          var he = Er.current;
          Er.current = Ts;
          try {
            return Oy(re, ie);
          } finally {
            Er.current = he;
          }
        },
        useReducer: function(re, ie, he) {
          tr = "useReducer", Wr(), hr();
          var ve = Er.current;
          Er.current = Ts;
          try {
            return h1(re, ie, he);
          } finally {
            Er.current = ve;
          }
        },
        useRef: function(re) {
          return tr = "useRef", Wr(), hr(), _y();
        },
        useState: function(re) {
          tr = "useState", Wr(), hr();
          var ie = Er.current;
          Er.current = Ts;
          try {
            return v1(re);
          } finally {
            Er.current = ie;
          }
        },
        useDebugValue: function(re, ie) {
          return tr = "useDebugValue", Wr(), hr(), Fy();
        },
        useDeferredValue: function(re) {
          return tr = "useDeferredValue", Wr(), hr(), fb(re);
        },
        useTransition: function() {
          return tr = "useTransition", Wr(), hr(), hb();
        },
        useMutableSource: function(re, ie, he) {
          return tr = "useMutableSource", Wr(), hr(), void 0;
        },
        useSyncExternalStore: function(re, ie, he) {
          return tr = "useSyncExternalStore", Wr(), hr(), Ty(re, ie);
        },
        useId: function() {
          return tr = "useId", Wr(), hr(), Ly();
        },
        unstable_isNewReconciler: yt
      };
    }
    var nf = ne.unstable_now, xb = 0, Ny = -1, em = -1, zy = -1, A1 = !1, Vy = !1;
    function Tb() {
      return A1;
    }
    function n_() {
      Vy = !0;
    }
    function i_() {
      A1 = !1, Vy = !1;
    }
    function a_() {
      A1 = Vy, Vy = !1;
    }
    function wb() {
      return xb;
    }
    function _b() {
      xb = nf();
    }
    function P1(re) {
      em = nf(), re.actualStartTime < 0 && (re.actualStartTime = nf());
    }
    function Ab(re) {
      em = -1;
    }
    function By(re, ie) {
      if (em >= 0) {
        var he = nf() - em;
        re.actualDuration += he, ie && (re.selfBaseDuration = he), em = -1;
      }
    }
    function sl(re) {
      if (Ny >= 0) {
        var ie = nf() - Ny;
        Ny = -1;
        for (var he = re.return; he !== null; ) {
          switch (he.tag) {
            case dt:
              var ve = he.stateNode;
              ve.effectDuration += ie;
              return;
            case vt:
              var Ce = he.stateNode;
              Ce.effectDuration += ie;
              return;
          }
          he = he.return;
        }
      }
    }
    function R1(re) {
      if (zy >= 0) {
        var ie = nf() - zy;
        zy = -1;
        for (var he = re.return; he !== null; ) {
          switch (he.tag) {
            case dt:
              var ve = he.stateNode;
              ve !== null && (ve.passiveEffectDuration += ie);
              return;
            case vt:
              var Ce = he.stateNode;
              Ce !== null && (Ce.passiveEffectDuration += ie);
              return;
          }
          he = he.return;
        }
      }
    }
    function ll() {
      Ny = nf();
    }
    function k1() {
      zy = nf();
    }
    function M1(re) {
      for (var ie = re.child; ie; )
        re.actualDuration += ie.actualDuration, ie = ie.sibling;
    }
    function cc(re, ie) {
      return {
        value: re,
        source: ie,
        stack: zo(ie),
        digest: null
      };
    }
    function F1(re, ie, he) {
      return {
        value: re,
        source: null,
        stack: he ?? null,
        digest: ie ?? null
      };
    }
    function o_(re, ie) {
      return !0;
    }
    function D1(re, ie) {
      try {
        var he = o_(re, ie);
        if (he === !1)
          return;
        var ve = ie.value, Ce = ie.source, ke = ie.stack, at = ke !== null ? ke : "";
        if (ve != null && ve._suppressLogging) {
          if (re.tag === rt)
            return;
          console.error(ve);
        }
        var mt = Ce ? Gr(Ce) : null, gt = mt ? "The above error occurred in the <" + mt + "> component:" : "The above error occurred in one of your React components:", Tt;
        if (re.tag === dt)
          Tt = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Pt = Gr(re) || "Anonymous";
          Tt = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Pt + ".");
        }
        var Nt = gt + `
` + at + `

` + ("" + Tt);
        console.error(Nt);
      } catch ($t) {
        setTimeout(function() {
          throw $t;
        });
      }
    }
    var s_ = typeof WeakMap == "function" ? WeakMap : Map;
    function Pb(re, ie, he) {
      var ve = Zl(Pn, he);
      ve.tag = D0, ve.payload = {
        element: null
      };
      var Ce = ie.value;
      return ve.callback = function() {
        ZA(Ce), D1(re, ie);
      }, ve;
    }
    function O1(re, ie, he) {
      var ve = Zl(Pn, he);
      ve.tag = D0;
      var Ce = re.type.getDerivedStateFromError;
      if (typeof Ce == "function") {
        var ke = ie.value;
        ve.payload = function() {
          return Ce(ke);
        }, ve.callback = function() {
          zC(re), D1(re, ie);
        };
      }
      var at = re.stateNode;
      return at !== null && typeof at.componentDidCatch == "function" && (ve.callback = function() {
        zC(re), D1(re, ie), typeof Ce != "function" && KA(this);
        var gt = ie.value, Tt = ie.stack;
        this.componentDidCatch(gt, {
          componentStack: Tt !== null ? Tt : ""
        }), typeof Ce != "function" && (Da(re.lanes, Vr) || be("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Gr(re) || "Unknown"));
      }), ve;
    }
    function Rb(re, ie, he) {
      var ve = re.pingCache, Ce;
      if (ve === null ? (ve = re.pingCache = new s_(), Ce = /* @__PURE__ */ new Set(), ve.set(ie, Ce)) : (Ce = ve.get(ie), Ce === void 0 && (Ce = /* @__PURE__ */ new Set(), ve.set(ie, Ce))), !Ce.has(he)) {
        Ce.add(he);
        var ke = eP.bind(null, re, ie, he);
        Ui && vm(re, he), ie.then(ke, ke);
      }
    }
    function l_(re, ie, he, ve) {
      var Ce = re.updateQueue;
      if (Ce === null) {
        var ke = /* @__PURE__ */ new Set();
        ke.add(he), re.updateQueue = ke;
      } else
        Ce.add(he);
    }
    function u_(re, ie) {
      var he = re.tag;
      if ((re.mode & Jr) === Nr && (he === Ae || he === ft || he === At)) {
        var ve = re.alternate;
        ve ? (re.updateQueue = ve.updateQueue, re.memoizedState = ve.memoizedState, re.lanes = ve.lanes) : (re.updateQueue = null, re.memoizedState = null);
      }
    }
    function kb(re) {
      var ie = re;
      do {
        if (ie.tag === Ct && qw(ie))
          return ie;
        ie = ie.return;
      } while (ie !== null);
      return null;
    }
    function Mb(re, ie, he, ve, Ce) {
      if ((re.mode & Jr) === Nr) {
        if (re === ie)
          re.flags |= Li;
        else {
          if (re.flags |= Hr, he.flags |= Df, he.flags &= ~(zc | ja), he.tag === rt) {
            var ke = he.alternate;
            if (ke === null)
              he.tag = Vt;
            else {
              var at = Zl(Pn, Vr);
              at.tag = cy, Zu(he, at, Vr);
            }
          }
          he.lanes = Qr(he.lanes, Vr);
        }
        return re;
      }
      return re.flags |= Li, re.lanes = Ce, re;
    }
    function f_(re, ie, he, ve, Ce) {
      if (he.flags |= ja, Ui && vm(re, Ce), ve !== null && typeof ve == "object" && typeof ve.then == "function") {
        var ke = ve;
        u_(he), da() && he.mode & Jr && EE();
        var at = kb(ie);
        if (at !== null) {
          at.flags &= ~oi, Mb(at, ie, he, re, Ce), at.mode & Jr && Rb(re, ke, Ce), l_(at, re, ke);
          return;
        } else {
          if (!Mu(Ce)) {
            Rb(re, ke, Ce), hS();
            return;
          }
          var mt = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          ve = mt;
        }
      } else if (da() && he.mode & Jr) {
        EE();
        var gt = kb(ie);
        if (gt !== null) {
          (gt.flags & Li) === Or && (gt.flags |= oi), Mb(gt, ie, he, re, Ce), _0(cc(ve, he));
          return;
        }
      }
      ve = cc(ve, he), UA(ve);
      var Tt = ie;
      do {
        switch (Tt.tag) {
          case dt: {
            var Pt = ve;
            Tt.flags |= Li;
            var Nt = Ti(Ce);
            Tt.lanes = Qr(Tt.lanes, Nt);
            var $t = Pb(Tt, Pt, Nt);
            $0(Tt, $t);
            return;
          }
          case rt:
            var Gt = ve, Wt = Tt.type, Xt = Tt.stateNode;
            if ((Tt.flags & Hr) === Or && (typeof Wt.getDerivedStateFromError == "function" || Xt !== null && typeof Xt.componentDidCatch == "function" && !kC(Xt))) {
              Tt.flags |= Li;
              var br = Ti(Ce);
              Tt.lanes = Qr(Tt.lanes, br);
              var $r = O1(Tt, Gt, br);
              $0(Tt, $r);
              return;
            }
            break;
        }
        Tt = Tt.return;
      } while (Tt !== null);
    }
    function c_() {
      return null;
    }
    var tm = oe.ReactCurrentOwner, ws = !1, L1, rm, $1, I1, N1, dc, z1, Hy;
    L1 = {}, rm = {}, $1 = {}, I1 = {}, N1 = {}, dc = !1, z1 = {}, Hy = {};
    function Xa(re, ie, he, ve) {
      re === null ? ie.child = YE(ie, null, he, ve) : ie.child = qd(ie, re.child, he, ve);
    }
    function d_(re, ie, he, ve) {
      ie.child = qd(ie, re.child, null, ve), ie.child = qd(ie, null, he, ve);
    }
    function Fb(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = he.propTypes;
        ke && Ss(
          ke,
          ve,
          // Resolved props
          "prop",
          nn(he)
        );
      }
      var at = he.render, mt = ie.ref, gt, Tt;
      Wd(ie, Ce), Ws(ie);
      {
        if (tm.current = ie, Ua(!0), gt = Zd(re, ie, at, ve, mt, Ce), Tt = eh(), ie.mode & qn) {
          xi(!0);
          try {
            gt = Zd(re, ie, at, ve, mt, Ce), Tt = eh();
          } finally {
            xi(!1);
          }
        }
        Ua(!1);
      }
      return Pl(), re !== null && !ws ? (ZE(re, ie, Ce), eu(re, ie, Ce)) : (da() && Tt && E0(ie), ie.flags |= zs, Xa(re, ie, gt, Ce), ie.child);
    }
    function Db(re, ie, he, ve, Ce) {
      if (re === null) {
        var ke = he.type;
        if (yP(ke) && he.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        he.defaultProps === void 0) {
          var at = ke;
          return at = lh(ke), ie.tag = At, ie.type = at, H1(ie, ke), Ob(re, ie, at, ve, Ce);
        }
        {
          var mt = ke.propTypes;
          mt && Ss(
            mt,
            ve,
            // Resolved props
            "prop",
            nn(ke)
          );
        }
        var gt = TS(he.type, null, ve, ie, ie.mode, Ce);
        return gt.ref = ie.ref, gt.return = ie, ie.child = gt, gt;
      }
      {
        var Tt = he.type, Pt = Tt.propTypes;
        Pt && Ss(
          Pt,
          ve,
          // Resolved props
          "prop",
          nn(Tt)
        );
      }
      var Nt = re.child, $t = Y1(re, Ce);
      if (!$t) {
        var Gt = Nt.memoizedProps, Wt = he.compare;
        if (Wt = Wt !== null ? Wt : Dr, Wt(Gt, ve) && re.ref === ie.ref)
          return eu(re, ie, Ce);
      }
      ie.flags |= zs;
      var Xt = yc(Nt, ve);
      return Xt.ref = ie.ref, Xt.return = ie, ie.child = Xt, Xt;
    }
    function Ob(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = ie.elementType;
        if (ke.$$typeof === Bi) {
          var at = ke, mt = at._payload, gt = at._init;
          try {
            ke = gt(mt);
          } catch {
            ke = null;
          }
          var Tt = ke && ke.propTypes;
          Tt && Ss(
            Tt,
            ve,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            nn(ke)
          );
        }
      }
      if (re !== null) {
        var Pt = re.memoizedProps;
        if (Dr(Pt, ve) && re.ref === ie.ref && // Prevent bailout if the implementation changed due to hot reload.
        ie.type === re.type)
          if (ws = !1, ie.pendingProps = ve = Pt, Y1(re, Ce))
            (re.flags & Df) !== Or && (ws = !0);
          else
            return ie.lanes = re.lanes, eu(re, ie, Ce);
      }
      return V1(re, ie, he, ve, Ce);
    }
    function Lb(re, ie, he) {
      var ve = ie.pendingProps, Ce = ve.children, ke = re !== null ? re.memoizedState : null;
      if (ve.mode === "hidden" || Dt)
        if ((ie.mode & Jr) === Nr) {
          var at = {
            baseLanes: Zt,
            cachePool: null,
            transitions: null
          };
          ie.memoizedState = at, tg(ie, he);
        } else if (Da(he, Fa)) {
          var Nt = {
            baseLanes: Zt,
            cachePool: null,
            transitions: null
          };
          ie.memoizedState = Nt;
          var $t = ke !== null ? ke.baseLanes : he;
          tg(ie, $t);
        } else {
          var mt = null, gt;
          if (ke !== null) {
            var Tt = ke.baseLanes;
            gt = Qr(Tt, he);
          } else
            gt = he;
          ie.lanes = ie.childLanes = Fa;
          var Pt = {
            baseLanes: gt,
            cachePool: mt,
            transitions: null
          };
          return ie.memoizedState = Pt, ie.updateQueue = null, tg(ie, gt), null;
        }
      else {
        var Gt;
        ke !== null ? (Gt = Qr(ke.baseLanes, he), ie.memoizedState = null) : Gt = he, tg(ie, Gt);
      }
      return Xa(re, ie, Ce, he), ie.child;
    }
    function h_(re, ie, he) {
      var ve = ie.pendingProps;
      return Xa(re, ie, ve, he), ie.child;
    }
    function p_(re, ie, he) {
      var ve = ie.pendingProps.children;
      return Xa(re, ie, ve, he), ie.child;
    }
    function m_(re, ie, he) {
      {
        ie.flags |= Yr;
        {
          var ve = ie.stateNode;
          ve.effectDuration = 0, ve.passiveEffectDuration = 0;
        }
      }
      var Ce = ie.pendingProps, ke = Ce.children;
      return Xa(re, ie, ke, he), ie.child;
    }
    function $b(re, ie) {
      var he = ie.ref;
      (re === null && he !== null || re !== null && re.ref !== he) && (ie.flags |= _a, ie.flags |= Nh);
    }
    function V1(re, ie, he, ve, Ce) {
      if (ie.type !== ie.elementType) {
        var ke = he.propTypes;
        ke && Ss(
          ke,
          ve,
          // Resolved props
          "prop",
          nn(he)
        );
      }
      var at;
      {
        var mt = Vd(ie, he, !0);
        at = Bd(ie, mt);
      }
      var gt, Tt;
      Wd(ie, Ce), Ws(ie);
      {
        if (tm.current = ie, Ua(!0), gt = Zd(re, ie, he, ve, at, Ce), Tt = eh(), ie.mode & qn) {
          xi(!0);
          try {
            gt = Zd(re, ie, he, ve, at, Ce), Tt = eh();
          } finally {
            xi(!1);
          }
        }
        Ua(!1);
      }
      return Pl(), re !== null && !ws ? (ZE(re, ie, Ce), eu(re, ie, Ce)) : (da() && Tt && E0(ie), ie.flags |= zs, Xa(re, ie, gt, Ce), ie.child);
    }
    function Ib(re, ie, he, ve, Ce) {
      {
        switch (FP(ie)) {
          case !1: {
            var ke = ie.stateNode, at = ie.type, mt = new at(ie.memoizedProps, ke.context), gt = mt.state;
            ke.updater.enqueueSetState(ke, gt, null);
            break;
          }
          case !0: {
            ie.flags |= Hr, ie.flags |= Li;
            var Tt = new Error("Simulated error coming from DevTools"), Pt = Ti(Ce);
            ie.lanes = Qr(ie.lanes, Pt);
            var Nt = O1(ie, cc(Tt, ie), Pt);
            $0(ie, Nt);
            break;
          }
        }
        if (ie.type !== ie.elementType) {
          var $t = he.propTypes;
          $t && Ss(
            $t,
            ve,
            // Resolved props
            "prop",
            nn(he)
          );
        }
      }
      var Gt;
      nl(he) ? (Gt = !0, ey(ie)) : Gt = !1, Wd(ie, Ce);
      var Wt = ie.stateNode, Xt;
      Wt === null ? (jy(re, ie), UE(ie, he, ve), Y0(ie, he, ve, Ce), Xt = !0) : re === null ? Xt = Bw(ie, he, ve, Ce) : Xt = Hw(re, ie, he, ve, Ce);
      var br = B1(re, ie, he, Xt, Gt, Ce);
      {
        var $r = ie.stateNode;
        Xt && $r.props !== ve && (dc || be("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Gr(ie) || "a component"), dc = !0);
      }
      return br;
    }
    function B1(re, ie, he, ve, Ce, ke) {
      $b(re, ie);
      var at = (ie.flags & Hr) !== Or;
      if (!ve && !at)
        return Ce && vE(ie, he, !1), eu(re, ie, ke);
      var mt = ie.stateNode;
      tm.current = ie;
      var gt;
      if (at && typeof he.getDerivedStateFromError != "function")
        gt = null, Ab();
      else {
        Ws(ie);
        {
          if (Ua(!0), gt = mt.render(), ie.mode & qn) {
            xi(!0);
            try {
              mt.render();
            } finally {
              xi(!1);
            }
          }
          Ua(!1);
        }
        Pl();
      }
      return ie.flags |= zs, re !== null && at ? d_(re, ie, gt, ke) : Xa(re, ie, gt, ke), ie.memoizedState = mt.state, Ce && vE(ie, he, !0), ie.child;
    }
    function Nb(re) {
      var ie = re.stateNode;
      ie.pendingContext ? pE(re, ie.pendingContext, ie.pendingContext !== ie.context) : ie.context && pE(re, ie.context, !1), e1(re, ie.containerInfo);
    }
    function v_(re, ie, he) {
      if (Nb(ie), re === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var ve = ie.pendingProps, Ce = ie.memoizedState, ke = Ce.element;
      LE(re, ie), my(ie, ve, null, he);
      var at = ie.memoizedState;
      ie.stateNode;
      var mt = at.element;
      if (Ce.isDehydrated) {
        var gt = {
          element: mt,
          isDehydrated: !1,
          cache: at.cache,
          pendingSuspenseBoundaries: at.pendingSuspenseBoundaries,
          transitions: at.transitions
        }, Tt = ie.updateQueue;
        if (Tt.baseState = gt, ie.memoizedState = gt, ie.flags & oi) {
          var Pt = cc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), ie);
          return zb(re, ie, mt, he, Pt);
        } else if (mt !== ke) {
          var Nt = cc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), ie);
          return zb(re, ie, mt, he, Nt);
        } else {
          Ew(ie);
          var $t = YE(ie, null, mt, he);
          ie.child = $t;
          for (var Gt = $t; Gt; )
            Gt.flags = Gt.flags & ~Dn | uo, Gt = Gt.sibling;
        }
      } else {
        if (jd(), mt === ke)
          return eu(re, ie, he);
        Xa(re, ie, mt, he);
      }
      return ie.child;
    }
    function zb(re, ie, he, ve, Ce) {
      return jd(), _0(Ce), ie.flags |= oi, Xa(re, ie, he, ve), ie.child;
    }
    function y_(re, ie, he) {
      XE(ie), re === null && w0(ie);
      var ve = ie.type, Ce = ie.pendingProps, ke = re !== null ? re.memoizedProps : null, at = Ce.children, mt = o0(ve, Ce);
      return mt ? at = null : ke !== null && o0(ve, ke) && (ie.flags |= gn), $b(re, ie), Xa(re, ie, at, he), ie.child;
    }
    function g_(re, ie) {
      return re === null && w0(ie), null;
    }
    function S_(re, ie, he, ve) {
      jy(re, ie);
      var Ce = ie.pendingProps, ke = he, at = ke._payload, mt = ke._init, gt = mt(at);
      ie.type = gt;
      var Tt = ie.tag = gP(gt), Pt = Cs(gt, Ce), Nt;
      switch (Tt) {
        case Ae:
          return H1(ie, gt), ie.type = gt = lh(gt), Nt = V1(null, ie, gt, Pt, ve), Nt;
        case rt:
          return ie.type = gt = gS(gt), Nt = Ib(null, ie, gt, Pt, ve), Nt;
        case ft:
          return ie.type = gt = SS(gt), Nt = Fb(null, ie, gt, Pt, ve), Nt;
        case xt: {
          if (ie.type !== ie.elementType) {
            var $t = gt.propTypes;
            $t && Ss(
              $t,
              Pt,
              // Resolved for outer only
              "prop",
              nn(gt)
            );
          }
          return Nt = Db(
            null,
            ie,
            gt,
            Cs(gt.type, Pt),
            // The inner type can have defaults too
            ve
          ), Nt;
        }
      }
      var Gt = "";
      throw gt !== null && typeof gt == "object" && gt.$$typeof === Bi && (Gt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + gt + ". " + ("Lazy element type must resolve to a class or function." + Gt));
    }
    function E_(re, ie, he, ve, Ce) {
      jy(re, ie), ie.tag = rt;
      var ke;
      return nl(he) ? (ke = !0, ey(ie)) : ke = !1, Wd(ie, Ce), UE(ie, he, ve), Y0(ie, he, ve, Ce), B1(null, ie, he, !0, ke, Ce);
    }
    function b_(re, ie, he, ve) {
      jy(re, ie);
      var Ce = ie.pendingProps, ke;
      {
        var at = Vd(ie, he, !1);
        ke = Bd(ie, at);
      }
      Wd(ie, ve);
      var mt, gt;
      Ws(ie);
      {
        if (he.prototype && typeof he.prototype.render == "function") {
          var Tt = nn(he) || "Unknown";
          L1[Tt] || (be("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Tt, Tt), L1[Tt] = !0);
        }
        ie.mode & qn && bs.recordLegacyContextWarning(ie, null), Ua(!0), tm.current = ie, mt = Zd(null, ie, he, Ce, ke, ve), gt = eh(), Ua(!1);
      }
      if (Pl(), ie.flags |= zs, typeof mt == "object" && mt !== null && typeof mt.render == "function" && mt.$$typeof === void 0) {
        var Pt = nn(he) || "Unknown";
        rm[Pt] || (be("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Pt, Pt, Pt), rm[Pt] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof mt == "object" && mt !== null && typeof mt.render == "function" && mt.$$typeof === void 0
      ) {
        {
          var Nt = nn(he) || "Unknown";
          rm[Nt] || (be("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Nt, Nt, Nt), rm[Nt] = !0);
        }
        ie.tag = rt, ie.memoizedState = null, ie.updateQueue = null;
        var $t = !1;
        return nl(he) ? ($t = !0, ey(ie)) : $t = !1, ie.memoizedState = mt.state !== null && mt.state !== void 0 ? mt.state : null, L0(ie), HE(ie, mt), Y0(ie, he, Ce, ve), B1(null, ie, he, !0, $t, ve);
      } else {
        if (ie.tag = Ae, ie.mode & qn) {
          xi(!0);
          try {
            mt = Zd(null, ie, he, Ce, ke, ve), gt = eh();
          } finally {
            xi(!1);
          }
        }
        return da() && gt && E0(ie), Xa(null, ie, mt, ve), H1(ie, he), ie.child;
      }
    }
    function H1(re, ie) {
      {
        if (ie && ie.childContextTypes && be("%s(...): childContextTypes cannot be defined on a function component.", ie.displayName || ie.name || "Component"), re.ref !== null) {
          var he = "", ve = sa();
          ve && (he += `

Check the render method of \`` + ve + "`.");
          var Ce = ve || "", ke = re._debugSource;
          ke && (Ce = ke.fileName + ":" + ke.lineNumber), N1[Ce] || (N1[Ce] = !0, be("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", he));
        }
        if (typeof ie.getDerivedStateFromProps == "function") {
          var at = nn(ie) || "Unknown";
          I1[at] || (be("%s: Function components do not support getDerivedStateFromProps.", at), I1[at] = !0);
        }
        if (typeof ie.contextType == "object" && ie.contextType !== null) {
          var mt = nn(ie) || "Unknown";
          $1[mt] || (be("%s: Function components do not support contextType.", mt), $1[mt] = !0);
        }
      }
    }
    var U1 = {
      dehydrated: null,
      treeContext: null,
      retryLane: an
    };
    function j1(re) {
      return {
        baseLanes: re,
        cachePool: c_(),
        transitions: null
      };
    }
    function C_(re, ie) {
      var he = null;
      return {
        baseLanes: Qr(re.baseLanes, ie),
        cachePool: he,
        transitions: re.transitions
      };
    }
    function x_(re, ie, he, ve) {
      if (ie !== null) {
        var Ce = ie.memoizedState;
        if (Ce === null)
          return !1;
      }
      return n1(re, qp);
    }
    function T_(re, ie) {
      return Fu(re.childLanes, ie);
    }
    function Vb(re, ie, he) {
      var ve = ie.pendingProps;
      DP(ie) && (ie.flags |= Hr);
      var Ce = xs.current, ke = !1, at = (ie.flags & Hr) !== Or;
      if (at || x_(Ce, re) ? (ke = !0, ie.flags &= ~Hr) : (re === null || re.memoizedState !== null) && (Ce = Ww(Ce, JE)), Ce = Qd(Ce), tf(ie, Ce), re === null) {
        w0(ie);
        var mt = ie.memoizedState;
        if (mt !== null) {
          var gt = mt.dehydrated;
          if (gt !== null)
            return R_(ie, gt);
        }
        var Tt = ve.children, Pt = ve.fallback;
        if (ke) {
          var Nt = w_(ie, Tt, Pt, he), $t = ie.child;
          return $t.memoizedState = j1(he), ie.memoizedState = U1, Nt;
        } else
          return G1(ie, Tt);
      } else {
        var Gt = re.memoizedState;
        if (Gt !== null) {
          var Wt = Gt.dehydrated;
          if (Wt !== null)
            return k_(re, ie, at, ve, Wt, Gt, he);
        }
        if (ke) {
          var Xt = ve.fallback, br = ve.children, $r = A_(re, ie, br, Xt, he), Mr = ie.child, sn = re.child.memoizedState;
          return Mr.memoizedState = sn === null ? j1(he) : C_(sn, he), Mr.childLanes = T_(re, he), ie.memoizedState = U1, $r;
        } else {
          var rn = ve.children, Ht = __(re, ie, rn, he);
          return ie.memoizedState = null, Ht;
        }
      }
    }
    function G1(re, ie, he) {
      var ve = re.mode, Ce = {
        mode: "visible",
        children: ie
      }, ke = W1(Ce, ve);
      return ke.return = re, re.child = ke, ke;
    }
    function w_(re, ie, he, ve) {
      var Ce = re.mode, ke = re.child, at = {
        mode: "hidden",
        children: ie
      }, mt, gt;
      return (Ce & Jr) === Nr && ke !== null ? (mt = ke, mt.childLanes = Zt, mt.pendingProps = at, re.mode & zr && (mt.actualDuration = 0, mt.actualStartTime = -1, mt.selfBaseDuration = 0, mt.treeBaseDuration = 0), gt = ff(he, Ce, ve, null)) : (mt = W1(at, Ce), gt = ff(he, Ce, ve, null)), mt.return = re, gt.return = re, mt.sibling = gt, re.child = mt, gt;
    }
    function W1(re, ie, he) {
      return BC(re, ie, Zt, null);
    }
    function Bb(re, ie) {
      return yc(re, ie);
    }
    function __(re, ie, he, ve) {
      var Ce = re.child, ke = Ce.sibling, at = Bb(Ce, {
        mode: "visible",
        children: he
      });
      if ((ie.mode & Jr) === Nr && (at.lanes = ve), at.return = ie, at.sibling = null, ke !== null) {
        var mt = ie.deletions;
        mt === null ? (ie.deletions = [ke], ie.flags |= hn) : mt.push(ke);
      }
      return ie.child = at, at;
    }
    function A_(re, ie, he, ve, Ce) {
      var ke = ie.mode, at = re.child, mt = at.sibling, gt = {
        mode: "hidden",
        children: he
      }, Tt;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (ke & Jr) === Nr && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        ie.child !== at
      ) {
        var Pt = ie.child;
        Tt = Pt, Tt.childLanes = Zt, Tt.pendingProps = gt, ie.mode & zr && (Tt.actualDuration = 0, Tt.actualStartTime = -1, Tt.selfBaseDuration = at.selfBaseDuration, Tt.treeBaseDuration = at.treeBaseDuration), ie.deletions = null;
      } else
        Tt = Bb(at, gt), Tt.subtreeFlags = at.subtreeFlags & Hi;
      var Nt;
      return mt !== null ? Nt = yc(mt, ve) : (Nt = ff(ve, ke, Ce, null), Nt.flags |= Dn), Nt.return = ie, Tt.return = ie, Tt.sibling = Nt, ie.child = Tt, Nt;
    }
    function Uy(re, ie, he, ve) {
      ve !== null && _0(ve), qd(ie, re.child, null, he);
      var Ce = ie.pendingProps, ke = Ce.children, at = G1(ie, ke);
      return at.flags |= Dn, ie.memoizedState = null, at;
    }
    function P_(re, ie, he, ve, Ce) {
      var ke = ie.mode, at = {
        mode: "visible",
        children: he
      }, mt = W1(at, ke), gt = ff(ve, ke, Ce, null);
      return gt.flags |= Dn, mt.return = ie, gt.return = ie, mt.sibling = gt, ie.child = mt, (ie.mode & Jr) !== Nr && qd(ie, re.child, null, Ce), gt;
    }
    function R_(re, ie, he) {
      return (re.mode & Jr) === Nr ? (be("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), re.lanes = Vr) : f0(ie) ? re.lanes = Ml : re.lanes = Fa, null;
    }
    function k_(re, ie, he, ve, Ce, ke, at) {
      if (he)
        if (ie.flags & oi) {
          ie.flags &= ~oi;
          var Ht = F1(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Uy(re, ie, at, Ht);
        } else {
          if (ie.memoizedState !== null)
            return ie.child = re.child, ie.flags |= Hr, null;
          var Kt = ve.children, Ut = ve.fallback, ur = P_(re, ie, Kt, Ut, at), Cr = ie.child;
          return Cr.memoizedState = j1(at), ie.memoizedState = U1, ur;
        }
      else {
        if (gw(), (ie.mode & Jr) === Nr)
          return Uy(
            re,
            ie,
            at,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (f0(Ce)) {
          var mt, gt, Tt;
          {
            var Pt = LT(Ce);
            mt = Pt.digest, gt = Pt.message, Tt = Pt.stack;
          }
          var Nt;
          gt ? Nt = new Error(gt) : Nt = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var $t = F1(Nt, mt, Tt);
          return Uy(re, ie, at, $t);
        }
        var Gt = Da(at, re.childLanes);
        if (ws || Gt) {
          var Wt = eg();
          if (Wt !== null) {
            var Xt = Mg(Wt, at);
            if (Xt !== an && Xt !== ke.retryLane) {
              ke.retryLane = Xt;
              var br = Pn;
              Eo(re, Xt), Ji(Wt, re, Xt, br);
            }
          }
          hS();
          var $r = F1(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Uy(re, ie, at, $r);
        } else if (lE(Ce)) {
          ie.flags |= Hr, ie.child = re.child;
          var Mr = tP.bind(null, re);
          return $T(Ce, Mr), null;
        } else {
          bw(ie, Ce, ke.treeContext);
          var sn = ve.children, rn = G1(ie, sn);
          return rn.flags |= uo, rn;
        }
      }
    }
    function Hb(re, ie, he) {
      re.lanes = Qr(re.lanes, ie);
      var ve = re.alternate;
      ve !== null && (ve.lanes = Qr(ve.lanes, ie)), M0(re.return, ie, he);
    }
    function M_(re, ie, he) {
      for (var ve = ie; ve !== null; ) {
        if (ve.tag === Ct) {
          var Ce = ve.memoizedState;
          Ce !== null && Hb(ve, he, re);
        } else if (ve.tag === er)
          Hb(ve, he, re);
        else if (ve.child !== null) {
          ve.child.return = ve, ve = ve.child;
          continue;
        }
        if (ve === re)
          return;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === re)
            return;
          ve = ve.return;
        }
        ve.sibling.return = ve.return, ve = ve.sibling;
      }
    }
    function F_(re) {
      for (var ie = re, he = null; ie !== null; ) {
        var ve = ie.alternate;
        ve !== null && Cy(ve) === null && (he = ie), ie = ie.sibling;
      }
      return he;
    }
    function D_(re) {
      if (re !== void 0 && re !== "forwards" && re !== "backwards" && re !== "together" && !z1[re])
        if (z1[re] = !0, typeof re == "string")
          switch (re.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              be('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', re, re.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              be('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', re, re.toLowerCase());
              break;
            }
            default:
              be('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', re);
              break;
          }
        else
          be('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', re);
    }
    function O_(re, ie) {
      re !== void 0 && !Hy[re] && (re !== "collapsed" && re !== "hidden" ? (Hy[re] = !0, be('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', re)) : ie !== "forwards" && ie !== "backwards" && (Hy[re] = !0, be('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', re)));
    }
    function Ub(re, ie) {
      {
        var he = Di(re), ve = !he && typeof To(re) == "function";
        if (he || ve) {
          var Ce = he ? "array" : "iterable";
          return be("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", Ce, ie, Ce), !1;
        }
      }
      return !0;
    }
    function L_(re, ie) {
      if ((ie === "forwards" || ie === "backwards") && re !== void 0 && re !== null && re !== !1)
        if (Di(re)) {
          for (var he = 0; he < re.length; he++)
            if (!Ub(re[he], he))
              return;
        } else {
          var ve = To(re);
          if (typeof ve == "function") {
            var Ce = ve.call(re);
            if (Ce)
              for (var ke = Ce.next(), at = 0; !ke.done; ke = Ce.next()) {
                if (!Ub(ke.value, at))
                  return;
                at++;
              }
          } else
            be('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', ie);
        }
    }
    function q1(re, ie, he, ve, Ce) {
      var ke = re.memoizedState;
      ke === null ? re.memoizedState = {
        isBackwards: ie,
        rendering: null,
        renderingStartTime: 0,
        last: ve,
        tail: he,
        tailMode: Ce
      } : (ke.isBackwards = ie, ke.rendering = null, ke.renderingStartTime = 0, ke.last = ve, ke.tail = he, ke.tailMode = Ce);
    }
    function jb(re, ie, he) {
      var ve = ie.pendingProps, Ce = ve.revealOrder, ke = ve.tail, at = ve.children;
      D_(Ce), O_(ke, Ce), L_(at, Ce), Xa(re, ie, at, he);
      var mt = xs.current, gt = n1(mt, qp);
      if (gt)
        mt = i1(mt, qp), ie.flags |= Hr;
      else {
        var Tt = re !== null && (re.flags & Hr) !== Or;
        Tt && M_(ie, ie.child, he), mt = Qd(mt);
      }
      if (tf(ie, mt), (ie.mode & Jr) === Nr)
        ie.memoizedState = null;
      else
        switch (Ce) {
          case "forwards": {
            var Pt = F_(ie.child), Nt;
            Pt === null ? (Nt = ie.child, ie.child = null) : (Nt = Pt.sibling, Pt.sibling = null), q1(
              ie,
              !1,
              // isBackwards
              Nt,
              Pt,
              ke
            );
            break;
          }
          case "backwards": {
            var $t = null, Gt = ie.child;
            for (ie.child = null; Gt !== null; ) {
              var Wt = Gt.alternate;
              if (Wt !== null && Cy(Wt) === null) {
                ie.child = Gt;
                break;
              }
              var Xt = Gt.sibling;
              Gt.sibling = $t, $t = Gt, Gt = Xt;
            }
            q1(
              ie,
              !0,
              // isBackwards
              $t,
              null,
              // last
              ke
            );
            break;
          }
          case "together": {
            q1(
              ie,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            ie.memoizedState = null;
        }
      return ie.child;
    }
    function $_(re, ie, he) {
      e1(ie, ie.stateNode.containerInfo);
      var ve = ie.pendingProps;
      return re === null ? ie.child = qd(ie, null, ve, he) : Xa(re, ie, ve, he), ie.child;
    }
    var Gb = !1;
    function I_(re, ie, he) {
      var ve = ie.type, Ce = ve._context, ke = ie.pendingProps, at = ie.memoizedProps, mt = ke.value;
      {
        "value" in ke || Gb || (Gb = !0, be("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var gt = ie.type.propTypes;
        gt && Ss(gt, ke, "prop", "Context.Provider");
      }
      if (ME(ie, Ce, mt), at !== null) {
        var Tt = at.value;
        if (_r(Tt, mt)) {
          if (at.children === ke.children && !Jv())
            return eu(re, ie, he);
        } else
          Mw(ie, Ce, he);
      }
      var Pt = ke.children;
      return Xa(re, ie, Pt, he), ie.child;
    }
    var Wb = !1;
    function N_(re, ie, he) {
      var ve = ie.type;
      ve._context === void 0 ? ve !== ve.Consumer && (Wb || (Wb = !0, be("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : ve = ve._context;
      var Ce = ie.pendingProps, ke = Ce.children;
      typeof ke != "function" && be("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Wd(ie, he);
      var at = Vi(ve);
      Ws(ie);
      var mt;
      return tm.current = ie, Ua(!0), mt = ke(at), Ua(!1), Pl(), ie.flags |= zs, Xa(re, ie, mt, he), ie.child;
    }
    function nm() {
      ws = !0;
    }
    function jy(re, ie) {
      (ie.mode & Jr) === Nr && re !== null && (re.alternate = null, ie.alternate = null, ie.flags |= Dn);
    }
    function eu(re, ie, he) {
      return re !== null && (ie.dependencies = re.dependencies), Ab(), mm(ie.lanes), Da(he, ie.childLanes) ? (Uw(re, ie), ie.child) : null;
    }
    function z_(re, ie, he) {
      {
        var ve = ie.return;
        if (ve === null)
          throw new Error("Cannot swap the root fiber.");
        if (re.alternate = null, ie.alternate = null, he.index = ie.index, he.sibling = ie.sibling, he.return = ie.return, he.ref = ie.ref, ie === ve.child)
          ve.child = he;
        else {
          var Ce = ve.child;
          if (Ce === null)
            throw new Error("Expected parent to have a child.");
          for (; Ce.sibling !== ie; )
            if (Ce = Ce.sibling, Ce === null)
              throw new Error("Expected to find the previous sibling.");
          Ce.sibling = he;
        }
        var ke = ve.deletions;
        return ke === null ? (ve.deletions = [re], ve.flags |= hn) : ke.push(re), he.flags |= Dn, he;
      }
    }
    function Y1(re, ie) {
      var he = re.lanes;
      return !!Da(he, ie);
    }
    function V_(re, ie, he) {
      switch (ie.tag) {
        case dt:
          Nb(ie), ie.stateNode, jd();
          break;
        case pt:
          XE(ie);
          break;
        case rt: {
          var ve = ie.type;
          nl(ve) && ey(ie);
          break;
        }
        case lt:
          e1(ie, ie.stateNode.containerInfo);
          break;
        case ht: {
          var Ce = ie.memoizedProps.value, ke = ie.type._context;
          ME(ie, ke, Ce);
          break;
        }
        case vt:
          {
            var at = Da(he, ie.childLanes);
            at && (ie.flags |= Yr);
            {
              var mt = ie.stateNode;
              mt.effectDuration = 0, mt.passiveEffectDuration = 0;
            }
          }
          break;
        case Ct: {
          var gt = ie.memoizedState;
          if (gt !== null) {
            if (gt.dehydrated !== null)
              return tf(ie, Qd(xs.current)), ie.flags |= Hr, null;
            var Tt = ie.child, Pt = Tt.childLanes;
            if (Da(he, Pt))
              return Vb(re, ie, he);
            tf(ie, Qd(xs.current));
            var Nt = eu(re, ie, he);
            return Nt !== null ? Nt.sibling : null;
          } else
            tf(ie, Qd(xs.current));
          break;
        }
        case er: {
          var $t = (re.flags & Hr) !== Or, Gt = Da(he, ie.childLanes);
          if ($t) {
            if (Gt)
              return jb(re, ie, he);
            ie.flags |= Hr;
          }
          var Wt = ie.memoizedState;
          if (Wt !== null && (Wt.rendering = null, Wt.tail = null, Wt.lastEffect = null), tf(ie, xs.current), Gt)
            break;
          return null;
        }
        case Jt:
        case rr:
          return ie.lanes = Zt, Lb(re, ie, he);
      }
      return eu(re, ie, he);
    }
    function qb(re, ie, he) {
      if (ie._debugNeedsRemount && re !== null)
        return z_(re, ie, TS(ie.type, ie.key, ie.pendingProps, ie._debugOwner || null, ie.mode, ie.lanes));
      if (re !== null) {
        var ve = re.memoizedProps, Ce = ie.pendingProps;
        if (ve !== Ce || Jv() || // Force a re-render if the implementation changed due to hot reload:
        ie.type !== re.type)
          ws = !0;
        else {
          var ke = Y1(re, he);
          if (!ke && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (ie.flags & Hr) === Or)
            return ws = !1, V_(re, ie, he);
          (re.flags & Df) !== Or ? ws = !0 : ws = !1;
        }
      } else if (ws = !1, da() && dw(ie)) {
        var at = ie.index, mt = hw();
        SE(ie, mt, at);
      }
      switch (ie.lanes = Zt, ie.tag) {
        case st:
          return b_(re, ie, ie.type, he);
        case kt: {
          var gt = ie.elementType;
          return S_(re, ie, gt, he);
        }
        case Ae: {
          var Tt = ie.type, Pt = ie.pendingProps, Nt = ie.elementType === Tt ? Pt : Cs(Tt, Pt);
          return V1(re, ie, Tt, Nt, he);
        }
        case rt: {
          var $t = ie.type, Gt = ie.pendingProps, Wt = ie.elementType === $t ? Gt : Cs($t, Gt);
          return Ib(re, ie, $t, Wt, he);
        }
        case dt:
          return v_(re, ie, he);
        case pt:
          return y_(re, ie, he);
        case it:
          return g_(re, ie);
        case Ct:
          return Vb(re, ie, he);
        case lt:
          return $_(re, ie, he);
        case ft: {
          var Xt = ie.type, br = ie.pendingProps, $r = ie.elementType === Xt ? br : Cs(Xt, br);
          return Fb(re, ie, Xt, $r, he);
        }
        case ut:
          return h_(re, ie, he);
        case St:
          return p_(re, ie, he);
        case vt:
          return m_(re, ie, he);
        case ht:
          return I_(re, ie, he);
        case ot:
          return N_(re, ie, he);
        case xt: {
          var Mr = ie.type, sn = ie.pendingProps, rn = Cs(Mr, sn);
          if (ie.type !== ie.elementType) {
            var Ht = Mr.propTypes;
            Ht && Ss(
              Ht,
              rn,
              // Resolved for outer only
              "prop",
              nn(Mr)
            );
          }
          return rn = Cs(Mr.type, rn), Db(re, ie, Mr, rn, he);
        }
        case At:
          return Ob(re, ie, ie.type, ie.pendingProps, he);
        case Vt: {
          var Kt = ie.type, Ut = ie.pendingProps, ur = ie.elementType === Kt ? Ut : Cs(Kt, Ut);
          return E_(re, ie, Kt, ur, he);
        }
        case er:
          return jb(re, ie, he);
        case Yt:
          break;
        case Jt:
          return Lb(re, ie, he);
      }
      throw new Error("Unknown unit of work tag (" + ie.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function th(re) {
      re.flags |= Yr;
    }
    function Yb(re) {
      re.flags |= _a, re.flags |= Nh;
    }
    var Qb, Q1, Xb, Kb;
    Qb = function(re, ie, he, ve) {
      for (var Ce = ie.child; Ce !== null; ) {
        if (Ce.tag === pt || Ce.tag === it)
          uT(re, Ce.stateNode);
        else if (Ce.tag !== lt) {
          if (Ce.child !== null) {
            Ce.child.return = Ce, Ce = Ce.child;
            continue;
          }
        }
        if (Ce === ie)
          return;
        for (; Ce.sibling === null; ) {
          if (Ce.return === null || Ce.return === ie)
            return;
          Ce = Ce.return;
        }
        Ce.sibling.return = Ce.return, Ce = Ce.sibling;
      }
    }, Q1 = function(re, ie) {
    }, Xb = function(re, ie, he, ve, Ce) {
      var ke = re.memoizedProps;
      if (ke !== ve) {
        var at = ie.stateNode, mt = t1(), gt = cT(at, he, ke, ve, Ce, mt);
        ie.updateQueue = gt, gt && th(ie);
      }
    }, Kb = function(re, ie, he, ve) {
      he !== ve && th(ie);
    };
    function im(re, ie) {
      if (!da())
        switch (re.tailMode) {
          case "hidden": {
            for (var he = re.tail, ve = null; he !== null; )
              he.alternate !== null && (ve = he), he = he.sibling;
            ve === null ? re.tail = null : ve.sibling = null;
            break;
          }
          case "collapsed": {
            for (var Ce = re.tail, ke = null; Ce !== null; )
              Ce.alternate !== null && (ke = Ce), Ce = Ce.sibling;
            ke === null ? !ie && re.tail !== null ? re.tail.sibling = null : re.tail = null : ke.sibling = null;
            break;
          }
        }
    }
    function pa(re) {
      var ie = re.alternate !== null && re.alternate.child === re.child, he = Zt, ve = Or;
      if (ie) {
        if ((re.mode & zr) !== Nr) {
          for (var gt = re.selfBaseDuration, Tt = re.child; Tt !== null; )
            he = Qr(he, Qr(Tt.lanes, Tt.childLanes)), ve |= Tt.subtreeFlags & Hi, ve |= Tt.flags & Hi, gt += Tt.treeBaseDuration, Tt = Tt.sibling;
          re.treeBaseDuration = gt;
        } else
          for (var Pt = re.child; Pt !== null; )
            he = Qr(he, Qr(Pt.lanes, Pt.childLanes)), ve |= Pt.subtreeFlags & Hi, ve |= Pt.flags & Hi, Pt.return = re, Pt = Pt.sibling;
        re.subtreeFlags |= ve;
      } else {
        if ((re.mode & zr) !== Nr) {
          for (var Ce = re.actualDuration, ke = re.selfBaseDuration, at = re.child; at !== null; )
            he = Qr(he, Qr(at.lanes, at.childLanes)), ve |= at.subtreeFlags, ve |= at.flags, Ce += at.actualDuration, ke += at.treeBaseDuration, at = at.sibling;
          re.actualDuration = Ce, re.treeBaseDuration = ke;
        } else
          for (var mt = re.child; mt !== null; )
            he = Qr(he, Qr(mt.lanes, mt.childLanes)), ve |= mt.subtreeFlags, ve |= mt.flags, mt.return = re, mt = mt.sibling;
        re.subtreeFlags |= ve;
      }
      return re.childLanes = he, ie;
    }
    function B_(re, ie, he) {
      if (_w() && (ie.mode & Jr) !== Nr && (ie.flags & Hr) === Or)
        return _E(ie), jd(), ie.flags |= oi | ja | Li, !1;
      var ve = ay(ie);
      if (he !== null && he.dehydrated !== null)
        if (re === null) {
          if (!ve)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (Tw(ie), pa(ie), (ie.mode & zr) !== Nr) {
            var Ce = he !== null;
            if (Ce) {
              var ke = ie.child;
              ke !== null && (ie.treeBaseDuration -= ke.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (jd(), (ie.flags & Hr) === Or && (ie.memoizedState = null), ie.flags |= Yr, pa(ie), (ie.mode & zr) !== Nr) {
            var at = he !== null;
            if (at) {
              var mt = ie.child;
              mt !== null && (ie.treeBaseDuration -= mt.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return AE(), !0;
    }
    function Jb(re, ie, he) {
      var ve = ie.pendingProps;
      switch (b0(ie), ie.tag) {
        case st:
        case kt:
        case At:
        case Ae:
        case ft:
        case ut:
        case St:
        case vt:
        case ot:
        case xt:
          return pa(ie), null;
        case rt: {
          var Ce = ie.type;
          return nl(Ce) && Zv(ie), pa(ie), null;
        }
        case dt: {
          var ke = ie.stateNode;
          if (Yd(ie), y0(ie), o1(), ke.pendingContext && (ke.context = ke.pendingContext, ke.pendingContext = null), re === null || re.child === null) {
            var at = ay(ie);
            if (at)
              th(ie);
            else if (re !== null) {
              var mt = re.memoizedState;
              // Check if this is a client root
              (!mt.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (ie.flags & oi) !== Or) && (ie.flags |= lo, AE());
            }
          }
          return Q1(re, ie), pa(ie), null;
        }
        case pt: {
          r1(ie);
          var gt = QE(), Tt = ie.type;
          if (re !== null && ie.stateNode != null)
            Xb(re, ie, Tt, ve, gt), re.ref !== ie.ref && Yb(ie);
          else {
            if (!ve) {
              if (ie.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return pa(ie), null;
            }
            var Pt = t1(), Nt = ay(ie);
            if (Nt)
              Cw(ie, gt, Pt) && th(ie);
            else {
              var $t = lT(Tt, ve, gt, Pt, ie);
              Qb($t, ie, !1, !1), ie.stateNode = $t, fT($t, Tt, ve, gt) && th(ie);
            }
            ie.ref !== null && Yb(ie);
          }
          return pa(ie), null;
        }
        case it: {
          var Gt = ve;
          if (re && ie.stateNode != null) {
            var Wt = re.memoizedProps;
            Kb(re, ie, Wt, Gt);
          } else {
            if (typeof Gt != "string" && ie.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Xt = QE(), br = t1(), $r = ay(ie);
            $r ? xw(ie) && th(ie) : ie.stateNode = dT(Gt, Xt, br, ie);
          }
          return pa(ie), null;
        }
        case Ct: {
          Xd(ie);
          var Mr = ie.memoizedState;
          if (re === null || re.memoizedState !== null && re.memoizedState.dehydrated !== null) {
            var sn = B_(re, ie, Mr);
            if (!sn)
              return ie.flags & Li ? ie : null;
          }
          if ((ie.flags & Hr) !== Or)
            return ie.lanes = he, (ie.mode & zr) !== Nr && M1(ie), ie;
          var rn = Mr !== null, Ht = re !== null && re.memoizedState !== null;
          if (rn !== Ht && rn) {
            var Kt = ie.child;
            if (Kt.flags |= Vs, (ie.mode & Jr) !== Nr) {
              var Ut = re === null && (ie.memoizedProps.unstable_avoidThisFallback !== !0 || !Ot);
              Ut || n1(xs.current, JE) ? HA() : hS();
            }
          }
          var ur = ie.updateQueue;
          if (ur !== null && (ie.flags |= Yr), pa(ie), (ie.mode & zr) !== Nr && rn) {
            var Cr = ie.child;
            Cr !== null && (ie.treeBaseDuration -= Cr.treeBaseDuration);
          }
          return null;
        }
        case lt:
          return Yd(ie), Q1(re, ie), re === null && aw(ie.stateNode.containerInfo), pa(ie), null;
        case ht:
          var yr = ie.type._context;
          return k0(yr, ie), pa(ie), null;
        case Vt: {
          var Br = ie.type;
          return nl(Br) && Zv(ie), pa(ie), null;
        }
        case er: {
          Xd(ie);
          var qr = ie.memoizedState;
          if (qr === null)
            return pa(ie), null;
          var Cn = (ie.flags & Hr) !== Or, cn = qr.rendering;
          if (cn === null)
            if (Cn)
              im(qr, !1);
            else {
              var Pi = jA() && (re === null || (re.flags & Hr) === Or);
              if (!Pi)
                for (var dn = ie.child; dn !== null; ) {
                  var gi = Cy(dn);
                  if (gi !== null) {
                    Cn = !0, ie.flags |= Hr, im(qr, !1);
                    var Ia = gi.updateQueue;
                    return Ia !== null && (ie.updateQueue = Ia, ie.flags |= Yr), ie.subtreeFlags = Or, jw(ie, he), tf(ie, i1(xs.current, qp)), ie.child;
                  }
                  dn = dn.sibling;
                }
              qr.tail !== null && Wn() > SC() && (ie.flags |= Hr, Cn = !0, im(qr, !1), ie.lanes = Kh);
            }
          else {
            if (!Cn) {
              var Sa = Cy(cn);
              if (Sa !== null) {
                ie.flags |= Hr, Cn = !0;
                var Do = Sa.updateQueue;
                if (Do !== null && (ie.updateQueue = Do, ie.flags |= Yr), im(qr, !0), qr.tail === null && qr.tailMode === "hidden" && !cn.alternate && !da())
                  return pa(ie), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Wn() * 2 - qr.renderingStartTime > SC() && he !== Fa && (ie.flags |= Hr, Cn = !0, im(qr, !1), ie.lanes = Kh);
            }
            if (qr.isBackwards)
              cn.sibling = ie.child, ie.child = cn;
            else {
              var Za = qr.last;
              Za !== null ? Za.sibling = cn : ie.child = cn, qr.last = cn;
            }
          }
          if (qr.tail !== null) {
            var eo = qr.tail;
            qr.rendering = eo, qr.tail = eo.sibling, qr.renderingStartTime = Wn(), eo.sibling = null;
            var Na = xs.current;
            return Cn ? Na = i1(Na, qp) : Na = Qd(Na), tf(ie, Na), eo;
          }
          return pa(ie), null;
        }
        case Yt:
          break;
        case Jt:
        case rr: {
          dS(ie);
          var au = ie.memoizedState, uh = au !== null;
          if (re !== null) {
            var Em = re.memoizedState, cl = Em !== null;
            cl !== uh && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !Dt && (ie.flags |= Vs);
          }
          return !uh || (ie.mode & Jr) === Nr ? pa(ie) : Da(fl, Fa) && (pa(ie), ie.subtreeFlags & (Dn | Yr) && (ie.flags |= Vs)), null;
        }
        case Qt:
          return null;
        case wt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + ie.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function H_(re, ie, he) {
      switch (b0(ie), ie.tag) {
        case rt: {
          var ve = ie.type;
          nl(ve) && Zv(ie);
          var Ce = ie.flags;
          return Ce & Li ? (ie.flags = Ce & ~Li | Hr, (ie.mode & zr) !== Nr && M1(ie), ie) : null;
        }
        case dt: {
          ie.stateNode, Yd(ie), y0(ie), o1();
          var ke = ie.flags;
          return (ke & Li) !== Or && (ke & Hr) === Or ? (ie.flags = ke & ~Li | Hr, ie) : null;
        }
        case pt:
          return r1(ie), null;
        case Ct: {
          Xd(ie);
          var at = ie.memoizedState;
          if (at !== null && at.dehydrated !== null) {
            if (ie.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            jd();
          }
          var mt = ie.flags;
          return mt & Li ? (ie.flags = mt & ~Li | Hr, (ie.mode & zr) !== Nr && M1(ie), ie) : null;
        }
        case er:
          return Xd(ie), null;
        case lt:
          return Yd(ie), null;
        case ht:
          var gt = ie.type._context;
          return k0(gt, ie), null;
        case Jt:
        case rr:
          return dS(ie), null;
        case Qt:
          return null;
        default:
          return null;
      }
    }
    function Zb(re, ie, he) {
      switch (b0(ie), ie.tag) {
        case rt: {
          var ve = ie.type.childContextTypes;
          ve != null && Zv(ie);
          break;
        }
        case dt: {
          ie.stateNode, Yd(ie), y0(ie), o1();
          break;
        }
        case pt: {
          r1(ie);
          break;
        }
        case lt:
          Yd(ie);
          break;
        case Ct:
          Xd(ie);
          break;
        case er:
          Xd(ie);
          break;
        case ht:
          var Ce = ie.type._context;
          k0(Ce, ie);
          break;
        case Jt:
        case rr:
          dS(ie);
          break;
      }
    }
    var eC = null;
    eC = /* @__PURE__ */ new Set();
    var Gy = !1, ma = !1, U_ = typeof WeakSet == "function" ? WeakSet : Set, Ar = null, rh = null, nh = null;
    function j_(re) {
      _l(null, function() {
        throw re;
      }), $h();
    }
    var G_ = function(re, ie) {
      if (ie.props = re.memoizedProps, ie.state = re.memoizedState, re.mode & zr)
        try {
          ll(), ie.componentWillUnmount();
        } finally {
          sl(re);
        }
      else
        ie.componentWillUnmount();
    };
    function tC(re, ie) {
      try {
        af(Wi, re);
      } catch (he) {
        In(re, ie, he);
      }
    }
    function X1(re, ie, he) {
      try {
        G_(re, he);
      } catch (ve) {
        In(re, ie, ve);
      }
    }
    function W_(re, ie, he) {
      try {
        he.componentDidMount();
      } catch (ve) {
        In(re, ie, ve);
      }
    }
    function rC(re, ie) {
      try {
        iC(re);
      } catch (he) {
        In(re, ie, he);
      }
    }
    function ih(re, ie) {
      var he = re.ref;
      if (he !== null)
        if (typeof he == "function") {
          var ve;
          try {
            if (Ir && fn && re.mode & zr)
              try {
                ll(), ve = he(null);
              } finally {
                sl(re);
              }
            else
              ve = he(null);
          } catch (Ce) {
            In(re, ie, Ce);
          }
          typeof ve == "function" && be("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Gr(re));
        } else
          he.current = null;
    }
    function Wy(re, ie, he) {
      try {
        he();
      } catch (ve) {
        In(re, ie, ve);
      }
    }
    var nC = !1;
    function q_(re, ie) {
      oT(re.containerInfo), Ar = ie, Y_();
      var he = nC;
      return nC = !1, he;
    }
    function Y_() {
      for (; Ar !== null; ) {
        var re = Ar, ie = re.child;
        (re.subtreeFlags & Tu) !== Or && ie !== null ? (ie.return = re, Ar = ie) : Q_();
      }
    }
    function Q_() {
      for (; Ar !== null; ) {
        var re = Ar;
        vn(re);
        try {
          X_(re);
        } catch (he) {
          In(re, re.return, he);
        }
        Hn();
        var ie = re.sibling;
        if (ie !== null) {
          ie.return = re.return, Ar = ie;
          return;
        }
        Ar = re.return;
      }
    }
    function X_(re) {
      var ie = re.alternate, he = re.flags;
      if ((he & lo) !== Or) {
        switch (vn(re), re.tag) {
          case Ae:
          case ft:
          case At:
            break;
          case rt: {
            if (ie !== null) {
              var ve = ie.memoizedProps, Ce = ie.memoizedState, ke = re.stateNode;
              re.type === re.elementType && !dc && (ke.props !== re.memoizedProps && be("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gr(re) || "instance"), ke.state !== re.memoizedState && be("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gr(re) || "instance"));
              var at = ke.getSnapshotBeforeUpdate(re.elementType === re.type ? ve : Cs(re.type, ve), Ce);
              {
                var mt = eC;
                at === void 0 && !mt.has(re.type) && (mt.add(re.type), be("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Gr(re)));
              }
              ke.__reactInternalSnapshotBeforeUpdate = at;
            }
            break;
          }
          case dt: {
            {
              var gt = re.stateNode;
              MT(gt.containerInfo);
            }
            break;
          }
          case pt:
          case it:
          case lt:
          case Vt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Hn();
      }
    }
    function _s(re, ie, he) {
      var ve = ie.updateQueue, Ce = ve !== null ? ve.lastEffect : null;
      if (Ce !== null) {
        var ke = Ce.next, at = ke;
        do {
          if ((at.tag & re) === re) {
            var mt = at.destroy;
            at.destroy = void 0, mt !== void 0 && ((re & ha) !== bo ? qc(ie) : (re & Wi) !== bo && Yc(ie), (re & il) !== bo && ym(!0), Wy(ie, he, mt), (re & il) !== bo && ym(!1), (re & ha) !== bo ? iv() : (re & Wi) !== bo && wu());
          }
          at = at.next;
        } while (at !== ke);
      }
    }
    function af(re, ie) {
      var he = ie.updateQueue, ve = he !== null ? he.lastEffect : null;
      if (ve !== null) {
        var Ce = ve.next, ke = Ce;
        do {
          if ((ke.tag & re) === re) {
            (re & ha) !== bo ? nv(ie) : (re & Wi) !== bo && av(ie);
            var at = ke.create;
            (re & il) !== bo && ym(!0), ke.destroy = at(), (re & il) !== bo && ym(!1), (re & ha) !== bo ? Yh() : (re & Wi) !== bo && ov();
            {
              var mt = ke.destroy;
              if (mt !== void 0 && typeof mt != "function") {
                var gt = void 0;
                (ke.tag & Wi) !== Or ? gt = "useLayoutEffect" : (ke.tag & il) !== Or ? gt = "useInsertionEffect" : gt = "useEffect";
                var Tt = void 0;
                mt === null ? Tt = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof mt.then == "function" ? Tt = `

It looks like you wrote ` + gt + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + gt + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Tt = " You returned: " + mt, be("%s must not return anything besides a function, which is used for clean-up.%s", gt, Tt);
              }
            }
          }
          ke = ke.next;
        } while (ke !== Ce);
      }
    }
    function K_(re, ie) {
      if ((ie.flags & Yr) !== Or)
        switch (ie.tag) {
          case vt: {
            var he = ie.stateNode.passiveEffectDuration, ve = ie.memoizedProps, Ce = ve.id, ke = ve.onPostCommit, at = wb(), mt = ie.alternate === null ? "mount" : "update";
            Tb() && (mt = "nested-update"), typeof ke == "function" && ke(Ce, mt, he, at);
            var gt = ie.return;
            e:
              for (; gt !== null; ) {
                switch (gt.tag) {
                  case dt:
                    var Tt = gt.stateNode;
                    Tt.passiveEffectDuration += he;
                    break e;
                  case vt:
                    var Pt = gt.stateNode;
                    Pt.passiveEffectDuration += he;
                    break e;
                }
                gt = gt.return;
              }
            break;
          }
        }
    }
    function J_(re, ie, he, ve) {
      if ((he.flags & Zi) !== Or)
        switch (he.tag) {
          case Ae:
          case ft:
          case At: {
            if (!ma)
              if (he.mode & zr)
                try {
                  ll(), af(Wi | Gi, he);
                } finally {
                  sl(he);
                }
              else
                af(Wi | Gi, he);
            break;
          }
          case rt: {
            var Ce = he.stateNode;
            if (he.flags & Yr && !ma)
              if (ie === null)
                if (he.type === he.elementType && !dc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gr(he) || "instance")), he.mode & zr)
                  try {
                    ll(), Ce.componentDidMount();
                  } finally {
                    sl(he);
                  }
                else
                  Ce.componentDidMount();
              else {
                var ke = he.elementType === he.type ? ie.memoizedProps : Cs(he.type, ie.memoizedProps), at = ie.memoizedState;
                if (he.type === he.elementType && !dc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gr(he) || "instance")), he.mode & zr)
                  try {
                    ll(), Ce.componentDidUpdate(ke, at, Ce.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    sl(he);
                  }
                else
                  Ce.componentDidUpdate(ke, at, Ce.__reactInternalSnapshotBeforeUpdate);
              }
            var mt = he.updateQueue;
            mt !== null && (he.type === he.elementType && !dc && (Ce.props !== he.memoizedProps && be("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Gr(he) || "instance"), Ce.state !== he.memoizedState && be("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Gr(he) || "instance")), IE(he, mt, Ce));
            break;
          }
          case dt: {
            var gt = he.updateQueue;
            if (gt !== null) {
              var Tt = null;
              if (he.child !== null)
                switch (he.child.tag) {
                  case pt:
                    Tt = he.child.stateNode;
                    break;
                  case rt:
                    Tt = he.child.stateNode;
                    break;
                }
              IE(he, gt, Tt);
            }
            break;
          }
          case pt: {
            var Pt = he.stateNode;
            if (ie === null && he.flags & Yr) {
              var Nt = he.type, $t = he.memoizedProps;
              yT(Pt, Nt, $t);
            }
            break;
          }
          case it:
            break;
          case lt:
            break;
          case vt: {
            {
              var Gt = he.memoizedProps, Wt = Gt.onCommit, Xt = Gt.onRender, br = he.stateNode.effectDuration, $r = wb(), Mr = ie === null ? "mount" : "update";
              Tb() && (Mr = "nested-update"), typeof Xt == "function" && Xt(he.memoizedProps.id, Mr, he.actualDuration, he.treeBaseDuration, he.actualStartTime, $r);
              {
                typeof Wt == "function" && Wt(he.memoizedProps.id, Mr, br, $r), QA(he);
                var sn = he.return;
                e:
                  for (; sn !== null; ) {
                    switch (sn.tag) {
                      case dt:
                        var rn = sn.stateNode;
                        rn.effectDuration += br;
                        break e;
                      case vt:
                        var Ht = sn.stateNode;
                        Ht.effectDuration += br;
                        break e;
                    }
                    sn = sn.return;
                  }
              }
            }
            break;
          }
          case Ct: {
            oA(re, he);
            break;
          }
          case er:
          case Vt:
          case Yt:
          case Jt:
          case rr:
          case wt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ma || he.flags & _a && iC(he);
    }
    function Z_(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          if (re.mode & zr)
            try {
              ll(), tC(re, re.return);
            } finally {
              sl(re);
            }
          else
            tC(re, re.return);
          break;
        }
        case rt: {
          var ie = re.stateNode;
          typeof ie.componentDidMount == "function" && W_(re, re.return, ie), rC(re, re.return);
          break;
        }
        case pt: {
          rC(re, re.return);
          break;
        }
      }
    }
    function eA(re, ie) {
      for (var he = null, ve = re; ; ) {
        if (ve.tag === pt) {
          if (he === null) {
            he = ve;
            try {
              var Ce = ve.stateNode;
              ie ? AT(Ce) : RT(ve.stateNode, ve.memoizedProps);
            } catch (at) {
              In(re, re.return, at);
            }
          }
        } else if (ve.tag === it) {
          if (he === null)
            try {
              var ke = ve.stateNode;
              ie ? PT(ke) : kT(ke, ve.memoizedProps);
            } catch (at) {
              In(re, re.return, at);
            }
        } else if (!((ve.tag === Jt || ve.tag === rr) && ve.memoizedState !== null && ve !== re)) {
          if (ve.child !== null) {
            ve.child.return = ve, ve = ve.child;
            continue;
          }
        }
        if (ve === re)
          return;
        for (; ve.sibling === null; ) {
          if (ve.return === null || ve.return === re)
            return;
          he === ve && (he = null), ve = ve.return;
        }
        he === ve && (he = null), ve.sibling.return = ve.return, ve = ve.sibling;
      }
    }
    function iC(re) {
      var ie = re.ref;
      if (ie !== null) {
        var he = re.stateNode, ve;
        switch (re.tag) {
          case pt:
            ve = he;
            break;
          default:
            ve = he;
        }
        if (typeof ie == "function") {
          var Ce;
          if (re.mode & zr)
            try {
              ll(), Ce = ie(ve);
            } finally {
              sl(re);
            }
          else
            Ce = ie(ve);
          typeof Ce == "function" && be("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Gr(re));
        } else
          ie.hasOwnProperty("current") || be("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Gr(re)), ie.current = ve;
      }
    }
    function tA(re) {
      var ie = re.alternate;
      ie !== null && (ie.return = null), re.return = null;
    }
    function aC(re) {
      var ie = re.alternate;
      ie !== null && (re.alternate = null, aC(ie));
      {
        if (re.child = null, re.deletions = null, re.sibling = null, re.tag === pt) {
          var he = re.stateNode;
          he !== null && lw(he);
        }
        re.stateNode = null, re._debugOwner = null, re.return = null, re.dependencies = null, re.memoizedProps = null, re.memoizedState = null, re.pendingProps = null, re.stateNode = null, re.updateQueue = null;
      }
    }
    function rA(re) {
      for (var ie = re.return; ie !== null; ) {
        if (oC(ie))
          return ie;
        ie = ie.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function oC(re) {
      return re.tag === pt || re.tag === dt || re.tag === lt;
    }
    function sC(re) {
      var ie = re;
      e:
        for (; ; ) {
          for (; ie.sibling === null; ) {
            if (ie.return === null || oC(ie.return))
              return null;
            ie = ie.return;
          }
          for (ie.sibling.return = ie.return, ie = ie.sibling; ie.tag !== pt && ie.tag !== it && ie.tag !== ir; ) {
            if (ie.flags & Dn || ie.child === null || ie.tag === lt)
              continue e;
            ie.child.return = ie, ie = ie.child;
          }
          if (!(ie.flags & Dn))
            return ie.stateNode;
        }
    }
    function nA(re) {
      var ie = rA(re);
      switch (ie.tag) {
        case pt: {
          var he = ie.stateNode;
          ie.flags & gn && (sE(he), ie.flags &= ~gn);
          var ve = sC(re);
          J1(re, ve, he);
          break;
        }
        case dt:
        case lt: {
          var Ce = ie.stateNode.containerInfo, ke = sC(re);
          K1(re, ke, Ce);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function K1(re, ie, he) {
      var ve = re.tag, Ce = ve === pt || ve === it;
      if (Ce) {
        var ke = re.stateNode;
        ie ? xT(he, ke, ie) : bT(he, ke);
      } else if (ve !== lt) {
        var at = re.child;
        if (at !== null) {
          K1(at, ie, he);
          for (var mt = at.sibling; mt !== null; )
            K1(mt, ie, he), mt = mt.sibling;
        }
      }
    }
    function J1(re, ie, he) {
      var ve = re.tag, Ce = ve === pt || ve === it;
      if (Ce) {
        var ke = re.stateNode;
        ie ? CT(he, ke, ie) : ET(he, ke);
      } else if (ve !== lt) {
        var at = re.child;
        if (at !== null) {
          J1(at, ie, he);
          for (var mt = at.sibling; mt !== null; )
            J1(mt, ie, he), mt = mt.sibling;
        }
      }
    }
    var va = null, As = !1;
    function iA(re, ie, he) {
      {
        var ve = ie;
        e:
          for (; ve !== null; ) {
            switch (ve.tag) {
              case pt: {
                va = ve.stateNode, As = !1;
                break e;
              }
              case dt: {
                va = ve.stateNode.containerInfo, As = !0;
                break e;
              }
              case lt: {
                va = ve.stateNode.containerInfo, As = !0;
                break e;
              }
            }
            ve = ve.return;
          }
        if (va === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        lC(re, ie, he), va = null, As = !1;
      }
      tA(he);
    }
    function of(re, ie, he) {
      for (var ve = he.child; ve !== null; )
        lC(re, ie, ve), ve = ve.sibling;
    }
    function lC(re, ie, he) {
      switch (Wh(he), he.tag) {
        case pt:
          ma || ih(he, ie);
        case it: {
          {
            var ve = va, Ce = As;
            va = null, of(re, ie, he), va = ve, As = Ce, va !== null && (As ? wT(va, he.stateNode) : TT(va, he.stateNode));
          }
          return;
        }
        case ir: {
          va !== null && (As ? _T(va, he.stateNode) : u0(va, he.stateNode));
          return;
        }
        case lt: {
          {
            var ke = va, at = As;
            va = he.stateNode.containerInfo, As = !0, of(re, ie, he), va = ke, As = at;
          }
          return;
        }
        case Ae:
        case ft:
        case xt:
        case At: {
          if (!ma) {
            var mt = he.updateQueue;
            if (mt !== null) {
              var gt = mt.lastEffect;
              if (gt !== null) {
                var Tt = gt.next, Pt = Tt;
                do {
                  var Nt = Pt, $t = Nt.destroy, Gt = Nt.tag;
                  $t !== void 0 && ((Gt & il) !== bo ? Wy(he, ie, $t) : (Gt & Wi) !== bo && (Yc(he), he.mode & zr ? (ll(), Wy(he, ie, $t), sl(he)) : Wy(he, ie, $t), wu())), Pt = Pt.next;
                } while (Pt !== Tt);
              }
            }
          }
          of(re, ie, he);
          return;
        }
        case rt: {
          if (!ma) {
            ih(he, ie);
            var Wt = he.stateNode;
            typeof Wt.componentWillUnmount == "function" && X1(he, ie, Wt);
          }
          of(re, ie, he);
          return;
        }
        case Yt: {
          of(re, ie, he);
          return;
        }
        case Jt: {
          if (
            // TODO: Remove this dead flag
            he.mode & Jr
          ) {
            var Xt = ma;
            ma = Xt || he.memoizedState !== null, of(re, ie, he), ma = Xt;
          } else
            of(re, ie, he);
          break;
        }
        default: {
          of(re, ie, he);
          return;
        }
      }
    }
    function aA(re) {
      re.memoizedState;
    }
    function oA(re, ie) {
      var he = ie.memoizedState;
      if (he === null) {
        var ve = ie.alternate;
        if (ve !== null) {
          var Ce = ve.memoizedState;
          if (Ce !== null) {
            var ke = Ce.dehydrated;
            ke !== null && GT(ke);
          }
        }
      }
    }
    function uC(re) {
      var ie = re.updateQueue;
      if (ie !== null) {
        re.updateQueue = null;
        var he = re.stateNode;
        he === null && (he = re.stateNode = new U_()), ie.forEach(function(ve) {
          var Ce = rP.bind(null, re, ve);
          if (!he.has(ve)) {
            if (he.add(ve), Ui)
              if (rh !== null && nh !== null)
                vm(nh, rh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            ve.then(Ce, Ce);
          }
        });
      }
    }
    function sA(re, ie, he) {
      rh = he, nh = re, vn(ie), fC(ie, re), vn(ie), rh = null, nh = null;
    }
    function Ps(re, ie, he) {
      var ve = ie.deletions;
      if (ve !== null)
        for (var Ce = 0; Ce < ve.length; Ce++) {
          var ke = ve[Ce];
          try {
            iA(re, ie, ke);
          } catch (gt) {
            In(ke, ie, gt);
          }
        }
      var at = gf();
      if (ie.subtreeFlags & Ra)
        for (var mt = ie.child; mt !== null; )
          vn(mt), fC(mt, re), mt = mt.sibling;
      vn(at);
    }
    function fC(re, ie, he) {
      var ve = re.alternate, Ce = re.flags;
      switch (re.tag) {
        case Ae:
        case ft:
        case xt:
        case At: {
          if (Ps(ie, re), ul(re), Ce & Yr) {
            try {
              _s(il | Gi, re, re.return), af(il | Gi, re);
            } catch (Br) {
              In(re, re.return, Br);
            }
            if (re.mode & zr) {
              try {
                ll(), _s(Wi | Gi, re, re.return);
              } catch (Br) {
                In(re, re.return, Br);
              }
              sl(re);
            } else
              try {
                _s(Wi | Gi, re, re.return);
              } catch (Br) {
                In(re, re.return, Br);
              }
          }
          return;
        }
        case rt: {
          Ps(ie, re), ul(re), Ce & _a && ve !== null && ih(ve, ve.return);
          return;
        }
        case pt: {
          Ps(ie, re), ul(re), Ce & _a && ve !== null && ih(ve, ve.return);
          {
            if (re.flags & gn) {
              var ke = re.stateNode;
              try {
                sE(ke);
              } catch (Br) {
                In(re, re.return, Br);
              }
            }
            if (Ce & Yr) {
              var at = re.stateNode;
              if (at != null) {
                var mt = re.memoizedProps, gt = ve !== null ? ve.memoizedProps : mt, Tt = re.type, Pt = re.updateQueue;
                if (re.updateQueue = null, Pt !== null)
                  try {
                    gT(at, Pt, Tt, gt, mt, re);
                  } catch (Br) {
                    In(re, re.return, Br);
                  }
              }
            }
          }
          return;
        }
        case it: {
          if (Ps(ie, re), ul(re), Ce & Yr) {
            if (re.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Nt = re.stateNode, $t = re.memoizedProps, Gt = ve !== null ? ve.memoizedProps : $t;
            try {
              ST(Nt, Gt, $t);
            } catch (Br) {
              In(re, re.return, Br);
            }
          }
          return;
        }
        case dt: {
          if (Ps(ie, re), ul(re), Ce & Yr && ve !== null) {
            var Wt = ve.memoizedState;
            if (Wt.isDehydrated)
              try {
                jT(ie.containerInfo);
              } catch (Br) {
                In(re, re.return, Br);
              }
          }
          return;
        }
        case lt: {
          Ps(ie, re), ul(re);
          return;
        }
        case Ct: {
          Ps(ie, re), ul(re);
          var Xt = re.child;
          if (Xt.flags & Vs) {
            var br = Xt.stateNode, $r = Xt.memoizedState, Mr = $r !== null;
            if (br.isHidden = Mr, Mr) {
              var sn = Xt.alternate !== null && Xt.alternate.memoizedState !== null;
              sn || BA();
            }
          }
          if (Ce & Yr) {
            try {
              aA(re);
            } catch (Br) {
              In(re, re.return, Br);
            }
            uC(re);
          }
          return;
        }
        case Jt: {
          var rn = ve !== null && ve.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            re.mode & Jr
          ) {
            var Ht = ma;
            ma = Ht || rn, Ps(ie, re), ma = Ht;
          } else
            Ps(ie, re);
          if (ul(re), Ce & Vs) {
            var Kt = re.stateNode, Ut = re.memoizedState, ur = Ut !== null, Cr = re;
            if (Kt.isHidden = ur, ur && !rn && (Cr.mode & Jr) !== Nr) {
              Ar = Cr;
              for (var yr = Cr.child; yr !== null; )
                Ar = yr, uA(yr), yr = yr.sibling;
            }
            eA(Cr, ur);
          }
          return;
        }
        case er: {
          Ps(ie, re), ul(re), Ce & Yr && uC(re);
          return;
        }
        case Yt:
          return;
        default: {
          Ps(ie, re), ul(re);
          return;
        }
      }
    }
    function ul(re) {
      var ie = re.flags;
      if (ie & Dn) {
        try {
          nA(re);
        } catch (he) {
          In(re, re.return, he);
        }
        re.flags &= ~Dn;
      }
      ie & uo && (re.flags &= ~uo);
    }
    function lA(re, ie, he) {
      rh = he, nh = ie, Ar = re, cC(re, ie, he), rh = null, nh = null;
    }
    function cC(re, ie, he) {
      for (var ve = (re.mode & Jr) !== Nr; Ar !== null; ) {
        var Ce = Ar, ke = Ce.child;
        if (Ce.tag === Jt && ve) {
          var at = Ce.memoizedState !== null, mt = at || Gy;
          if (mt) {
            Z1(re, ie, he);
            continue;
          } else {
            var gt = Ce.alternate, Tt = gt !== null && gt.memoizedState !== null, Pt = Tt || ma, Nt = Gy, $t = ma;
            Gy = mt, ma = Pt, ma && !$t && (Ar = Ce, fA(Ce));
            for (var Gt = ke; Gt !== null; )
              Ar = Gt, cC(
                Gt,
                // New root; bubble back up to here and stop.
                ie,
                he
              ), Gt = Gt.sibling;
            Ar = Ce, Gy = Nt, ma = $t, Z1(re, ie, he);
            continue;
          }
        }
        (Ce.subtreeFlags & Zi) !== Or && ke !== null ? (ke.return = Ce, Ar = ke) : Z1(re, ie, he);
      }
    }
    function Z1(re, ie, he) {
      for (; Ar !== null; ) {
        var ve = Ar;
        if ((ve.flags & Zi) !== Or) {
          var Ce = ve.alternate;
          vn(ve);
          try {
            J_(ie, Ce, ve, he);
          } catch (at) {
            In(ve, ve.return, at);
          }
          Hn();
        }
        if (ve === re) {
          Ar = null;
          return;
        }
        var ke = ve.sibling;
        if (ke !== null) {
          ke.return = ve.return, Ar = ke;
          return;
        }
        Ar = ve.return;
      }
    }
    function uA(re) {
      for (; Ar !== null; ) {
        var ie = Ar, he = ie.child;
        switch (ie.tag) {
          case Ae:
          case ft:
          case xt:
          case At: {
            if (ie.mode & zr)
              try {
                ll(), _s(Wi, ie, ie.return);
              } finally {
                sl(ie);
              }
            else
              _s(Wi, ie, ie.return);
            break;
          }
          case rt: {
            ih(ie, ie.return);
            var ve = ie.stateNode;
            typeof ve.componentWillUnmount == "function" && X1(ie, ie.return, ve);
            break;
          }
          case pt: {
            ih(ie, ie.return);
            break;
          }
          case Jt: {
            var Ce = ie.memoizedState !== null;
            if (Ce) {
              dC(re);
              continue;
            }
            break;
          }
        }
        he !== null ? (he.return = ie, Ar = he) : dC(re);
      }
    }
    function dC(re) {
      for (; Ar !== null; ) {
        var ie = Ar;
        if (ie === re) {
          Ar = null;
          return;
        }
        var he = ie.sibling;
        if (he !== null) {
          he.return = ie.return, Ar = he;
          return;
        }
        Ar = ie.return;
      }
    }
    function fA(re) {
      for (; Ar !== null; ) {
        var ie = Ar, he = ie.child;
        if (ie.tag === Jt) {
          var ve = ie.memoizedState !== null;
          if (ve) {
            hC(re);
            continue;
          }
        }
        he !== null ? (he.return = ie, Ar = he) : hC(re);
      }
    }
    function hC(re) {
      for (; Ar !== null; ) {
        var ie = Ar;
        vn(ie);
        try {
          Z_(ie);
        } catch (ve) {
          In(ie, ie.return, ve);
        }
        if (Hn(), ie === re) {
          Ar = null;
          return;
        }
        var he = ie.sibling;
        if (he !== null) {
          he.return = ie.return, Ar = he;
          return;
        }
        Ar = ie.return;
      }
    }
    function cA(re, ie, he, ve) {
      Ar = ie, dA(ie, re, he, ve);
    }
    function dA(re, ie, he, ve) {
      for (; Ar !== null; ) {
        var Ce = Ar, ke = Ce.child;
        (Ce.subtreeFlags & fo) !== Or && ke !== null ? (ke.return = Ce, Ar = ke) : hA(re, ie, he, ve);
      }
    }
    function hA(re, ie, he, ve) {
      for (; Ar !== null; ) {
        var Ce = Ar;
        if ((Ce.flags & Un) !== Or) {
          vn(Ce);
          try {
            pA(ie, Ce, he, ve);
          } catch (at) {
            In(Ce, Ce.return, at);
          }
          Hn();
        }
        if (Ce === re) {
          Ar = null;
          return;
        }
        var ke = Ce.sibling;
        if (ke !== null) {
          ke.return = Ce.return, Ar = ke;
          return;
        }
        Ar = Ce.return;
      }
    }
    function pA(re, ie, he, ve) {
      switch (ie.tag) {
        case Ae:
        case ft:
        case At: {
          if (ie.mode & zr) {
            k1();
            try {
              af(ha | Gi, ie);
            } finally {
              R1(ie);
            }
          } else
            af(ha | Gi, ie);
          break;
        }
      }
    }
    function mA(re) {
      Ar = re, vA();
    }
    function vA() {
      for (; Ar !== null; ) {
        var re = Ar, ie = re.child;
        if ((Ar.flags & hn) !== Or) {
          var he = re.deletions;
          if (he !== null) {
            for (var ve = 0; ve < he.length; ve++) {
              var Ce = he[ve];
              Ar = Ce, SA(Ce, re);
            }
            {
              var ke = re.alternate;
              if (ke !== null) {
                var at = ke.child;
                if (at !== null) {
                  ke.child = null;
                  do {
                    var mt = at.sibling;
                    at.sibling = null, at = mt;
                  } while (at !== null);
                }
              }
            }
            Ar = re;
          }
        }
        (re.subtreeFlags & fo) !== Or && ie !== null ? (ie.return = re, Ar = ie) : yA();
      }
    }
    function yA() {
      for (; Ar !== null; ) {
        var re = Ar;
        (re.flags & Un) !== Or && (vn(re), gA(re), Hn());
        var ie = re.sibling;
        if (ie !== null) {
          ie.return = re.return, Ar = ie;
          return;
        }
        Ar = re.return;
      }
    }
    function gA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          re.mode & zr ? (k1(), _s(ha | Gi, re, re.return), R1(re)) : _s(ha | Gi, re, re.return);
          break;
        }
      }
    }
    function SA(re, ie) {
      for (; Ar !== null; ) {
        var he = Ar;
        vn(he), bA(he, ie), Hn();
        var ve = he.child;
        ve !== null ? (ve.return = he, Ar = ve) : EA(re);
      }
    }
    function EA(re) {
      for (; Ar !== null; ) {
        var ie = Ar, he = ie.sibling, ve = ie.return;
        if (aC(ie), ie === re) {
          Ar = null;
          return;
        }
        if (he !== null) {
          he.return = ve, Ar = he;
          return;
        }
        Ar = ve;
      }
    }
    function bA(re, ie) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          re.mode & zr ? (k1(), _s(ha, re, ie), R1(re)) : _s(ha, re, ie);
          break;
        }
      }
    }
    function CA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            af(Wi | Gi, re);
          } catch (he) {
            In(re, re.return, he);
          }
          break;
        }
        case rt: {
          var ie = re.stateNode;
          try {
            ie.componentDidMount();
          } catch (he) {
            In(re, re.return, he);
          }
          break;
        }
      }
    }
    function xA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            af(ha | Gi, re);
          } catch (ie) {
            In(re, re.return, ie);
          }
          break;
        }
      }
    }
    function TA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At: {
          try {
            _s(Wi | Gi, re, re.return);
          } catch (he) {
            In(re, re.return, he);
          }
          break;
        }
        case rt: {
          var ie = re.stateNode;
          typeof ie.componentWillUnmount == "function" && X1(re, re.return, ie);
          break;
        }
      }
    }
    function wA(re) {
      switch (re.tag) {
        case Ae:
        case ft:
        case At:
          try {
            _s(ha | Gi, re, re.return);
          } catch (ie) {
            In(re, re.return, ie);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var am = Symbol.for;
      am("selector.component"), am("selector.has_pseudo_class"), am("selector.role"), am("selector.test_id"), am("selector.text");
    }
    var _A = [];
    function AA() {
      _A.forEach(function(re) {
        return re();
      });
    }
    var PA = oe.ReactCurrentActQueue;
    function RA(re) {
      {
        var ie = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), he = typeof jest < "u";
        return he && ie !== !1;
      }
    }
    function pC() {
      {
        var re = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !re && PA.current !== null && be("The current testing environment is not configured to support act(...)"), re;
      }
    }
    var kA = Math.ceil, eS = oe.ReactCurrentDispatcher, tS = oe.ReactCurrentOwner, ya = oe.ReactCurrentBatchConfig, Rs = oe.ReactCurrentActQueue, Qi = (
      /*             */
      0
    ), mC = (
      /*               */
      1
    ), ga = (
      /*                */
      2
    ), Jo = (
      /*                */
      4
    ), tu = 0, om = 1, hc = 2, qy = 3, sm = 4, vC = 5, rS = 6, on = Qi, Ka = null, di = null, Xi = Zt, fl = Zt, nS = Qu(Zt), Ki = tu, lm = null, Yy = Zt, um = Zt, Qy = Zt, fm = null, Co = null, iS = 0, yC = 500, gC = 1 / 0, MA = 500, ru = null;
    function cm() {
      gC = Wn() + MA;
    }
    function SC() {
      return gC;
    }
    var Xy = !1, aS = null, ah = null, pc = !1, sf = null, dm = Zt, oS = [], sS = null, FA = 50, hm = 0, lS = null, uS = !1, Ky = !1, DA = 50, oh = 0, Jy = null, pm = Pn, Zy = Zt, EC = !1;
    function eg() {
      return Ka;
    }
    function Ja() {
      return (on & (ga | Jo)) !== Qi ? Wn() : (pm !== Pn || (pm = Wn()), pm);
    }
    function lf(re) {
      var ie = re.mode;
      if ((ie & Jr) === Nr)
        return Vr;
      if ((on & ga) !== Qi && Xi !== Zt)
        return Ti(Xi);
      var he = Rw() !== Pw;
      if (he) {
        if (ya.transition !== null) {
          var ve = ya.transition;
          ve._updatedFibers || (ve._updatedFibers = /* @__PURE__ */ new Set()), ve._updatedFibers.add(re);
        }
        return Zy === an && (Zy = ep()), Zy;
      }
      var Ce = mo();
      if (Ce !== an)
        return Ce;
      var ke = hT();
      return ke;
    }
    function OA(re) {
      var ie = re.mode;
      return (ie & Jr) === Nr ? Vr : kg();
    }
    function Ji(re, ie, he, ve) {
      iP(), EC && be("useInsertionEffect must not schedule updates."), uS && (Ky = !0), Nl(re, he, ve), (on & ga) !== Zt && re === Ka ? sP(ie) : (Ui && ap(re, ie, he), lP(ie), re === Ka && ((on & ga) === Qi && (um = Qr(um, he)), Ki === sm && uf(re, Xi)), xo(re, ve), he === Vr && on === Qi && (ie.mode & Jr) === Nr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Rs.isBatchingLegacy && (cm(), gE()));
    }
    function LA(re, ie, he) {
      var ve = re.current;
      ve.lanes = ie, Nl(re, ie, he), xo(re, he);
    }
    function $A(re) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (on & ga) !== Qi
      );
    }
    function xo(re, ie) {
      var he = re.callbackNode;
      Ag(re, ie);
      var ve = zf(re, re === Ka ? Xi : Zt);
      if (ve === Zt) {
        he !== null && $C(he), re.callbackNode = null, re.callbackPriority = an;
        return;
      }
      var Ce = vi(ve), ke = re.callbackPriority;
      if (ke === Ce && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Rs.current !== null && he !== vS)) {
        he == null && ke !== Vr && be("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      he != null && $C(he);
      var at;
      if (Ce === Vr)
        re.tag === Xu ? (Rs.isBatchingLegacy !== null && (Rs.didScheduleLegacyUpdate = !0), cw(xC.bind(null, re))) : yE(xC.bind(null, re)), Rs.current !== null ? Rs.current.push(Ku) : mT(function() {
          (on & (ga | Jo)) === Qi && Ku();
        }), at = null;
      else {
        var mt;
        switch (jf(ve)) {
          case ea:
            mt = jc;
            break;
          case ji:
            mt = qa;
            break;
          case ps:
            mt = Ho;
            break;
          case Hf:
            mt = Hs;
            break;
          default:
            mt = Ho;
            break;
        }
        at = yS(mt, bC.bind(null, re));
      }
      re.callbackPriority = Ce, re.callbackNode = at;
    }
    function bC(re, ie) {
      if (i_(), pm = Pn, Zy = Zt, (on & (ga | Jo)) !== Qi)
        throw new Error("Should not already be working.");
      var he = re.callbackNode, ve = iu();
      if (ve && re.callbackNode !== he)
        return null;
      var Ce = zf(re, re === Ka ? Xi : Zt);
      if (Ce === Zt)
        return null;
      var ke = !Bf(re, Ce) && !dv(re, Ce) && !ie, at = ke ? WA(re, Ce) : rg(re, Ce);
      if (at !== tu) {
        if (at === hc) {
          var mt = Jh(re);
          mt !== Zt && (Ce = mt, at = fS(re, mt));
        }
        if (at === om) {
          var gt = lm;
          throw mc(re, Zt), uf(re, Ce), xo(re, Wn()), gt;
        }
        if (at === rS)
          uf(re, Ce);
        else {
          var Tt = !Bf(re, Ce), Pt = re.current.alternate;
          if (Tt && !NA(Pt)) {
            if (at = rg(re, Ce), at === hc) {
              var Nt = Jh(re);
              Nt !== Zt && (Ce = Nt, at = fS(re, Nt));
            }
            if (at === om) {
              var $t = lm;
              throw mc(re, Zt), uf(re, Ce), xo(re, Wn()), $t;
            }
          }
          re.finishedWork = Pt, re.finishedLanes = Ce, IA(re, at, Ce);
        }
      }
      return xo(re, Wn()), re.callbackNode === he ? bC.bind(null, re) : null;
    }
    function fS(re, ie) {
      var he = fm;
      if (_i(re)) {
        var ve = mc(re, ie);
        ve.flags |= oi, iw(re.containerInfo);
      }
      var Ce = rg(re, ie);
      if (Ce !== hc) {
        var ke = Co;
        Co = he, ke !== null && CC(ke);
      }
      return Ce;
    }
    function CC(re) {
      Co === null ? Co = re : Co.push.apply(Co, re);
    }
    function IA(re, ie, he) {
      switch (ie) {
        case tu:
        case om:
          throw new Error("Root did not complete. This is a bug in React.");
        case hc: {
          vc(re, Co, ru);
          break;
        }
        case qy: {
          if (uf(re, he), pd(he) && // do not delay if we're inside an act() scope
          !IC()) {
            var ve = iS + yC - Wn();
            if (ve > 10) {
              var Ce = zf(re, Zt);
              if (Ce !== Zt)
                break;
              var ke = re.suspendedLanes;
              if (!Il(ke, he)) {
                Ja(), np(re, ke);
                break;
              }
              re.timeoutHandle = s0(vc.bind(null, re, Co, ru), ve);
              break;
            }
          }
          vc(re, Co, ru);
          break;
        }
        case sm: {
          if (uf(re, he), cv(he))
            break;
          if (!IC()) {
            var at = fv(re, he), mt = at, gt = Wn() - mt, Tt = nP(gt) - gt;
            if (Tt > 10) {
              re.timeoutHandle = s0(vc.bind(null, re, Co, ru), Tt);
              break;
            }
          }
          vc(re, Co, ru);
          break;
        }
        case vC: {
          vc(re, Co, ru);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function NA(re) {
      for (var ie = re; ; ) {
        if (ie.flags & Ff) {
          var he = ie.updateQueue;
          if (he !== null) {
            var ve = he.stores;
            if (ve !== null)
              for (var Ce = 0; Ce < ve.length; Ce++) {
                var ke = ve[Ce], at = ke.getSnapshot, mt = ke.value;
                try {
                  if (!_r(at(), mt))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var gt = ie.child;
        if (ie.subtreeFlags & Ff && gt !== null) {
          gt.return = ie, ie = gt;
          continue;
        }
        if (ie === re)
          return !0;
        for (; ie.sibling === null; ) {
          if (ie.return === null || ie.return === re)
            return !0;
          ie = ie.return;
        }
        ie.sibling.return = ie.return, ie = ie.sibling;
      }
      return !0;
    }
    function uf(re, ie) {
      ie = Fu(ie, Qy), ie = Fu(ie, um), rp(re, ie);
    }
    function xC(re) {
      if (a_(), (on & (ga | Jo)) !== Qi)
        throw new Error("Should not already be working.");
      iu();
      var ie = zf(re, Zt);
      if (!Da(ie, Vr))
        return xo(re, Wn()), null;
      var he = rg(re, ie);
      if (re.tag !== Xu && he === hc) {
        var ve = Jh(re);
        ve !== Zt && (ie = ve, he = fS(re, ve));
      }
      if (he === om) {
        var Ce = lm;
        throw mc(re, Zt), uf(re, ie), xo(re, Wn()), Ce;
      }
      if (he === rS)
        throw new Error("Root did not complete. This is a bug in React.");
      var ke = re.current.alternate;
      return re.finishedWork = ke, re.finishedLanes = ie, vc(re, Co, ru), xo(re, Wn()), null;
    }
    function zA(re, ie) {
      ie !== Zt && (Du(re, Qr(ie, Vr)), xo(re, Wn()), (on & (ga | Jo)) === Qi && (cm(), Ku()));
    }
    function cS(re, ie) {
      var he = on;
      on |= mC;
      try {
        return re(ie);
      } finally {
        on = he, on === Qi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Rs.isBatchingLegacy && (cm(), gE());
      }
    }
    function VA(re, ie, he, ve, Ce) {
      var ke = mo(), at = ya.transition;
      try {
        return ya.transition = null, wi(ea), re(ie, he, ve, Ce);
      } finally {
        wi(ke), ya.transition = at, on === Qi && cm();
      }
    }
    function nu(re) {
      sf !== null && sf.tag === Xu && (on & (ga | Jo)) === Qi && iu();
      var ie = on;
      on |= mC;
      var he = ya.transition, ve = mo();
      try {
        return ya.transition = null, wi(ea), re ? re() : void 0;
      } finally {
        wi(ve), ya.transition = he, on = ie, (on & (ga | Jo)) === Qi && Ku();
      }
    }
    function TC() {
      return (on & (ga | Jo)) !== Qi;
    }
    function tg(re, ie) {
      La(nS, fl, re), fl = Qr(fl, ie);
    }
    function dS(re) {
      fl = nS.current, Oa(nS, re);
    }
    function mc(re, ie) {
      re.finishedWork = null, re.finishedLanes = Zt;
      var he = re.timeoutHandle;
      if (he !== l0 && (re.timeoutHandle = l0, pT(he)), di !== null)
        for (var ve = di.return; ve !== null; ) {
          var Ce = ve.alternate;
          Zb(Ce, ve), ve = ve.return;
        }
      Ka = re;
      var ke = yc(re.current, null);
      return di = ke, Xi = fl = ie, Ki = tu, lm = null, Yy = Zt, um = Zt, Qy = Zt, fm = null, Co = null, Dw(), bs.discardPendingWarnings(), ke;
    }
    function wC(re, ie) {
      do {
        var he = di;
        try {
          if (uy(), eb(), Hn(), tS.current = null, he === null || he.return === null) {
            Ki = om, lm = ie, di = null;
            return;
          }
          if (Ir && he.mode & zr && By(he, !0), xr)
            if (Pl(), ie !== null && typeof ie == "object" && typeof ie.then == "function") {
              var ve = ie;
              sv(he, ve, Xi);
            } else
              Qc(he, ie, Xi);
          f_(re, he.return, he, ie, Xi), RC(he);
        } catch (Ce) {
          ie = Ce, di === he && he !== null ? (he = he.return, di = he) : he = di;
          continue;
        }
        return;
      } while (!0);
    }
    function _C() {
      var re = eS.current;
      return eS.current = $y, re === null ? $y : re;
    }
    function AC(re) {
      eS.current = re;
    }
    function BA() {
      iS = Wn();
    }
    function mm(re) {
      Yy = Qr(re, Yy);
    }
    function HA() {
      Ki === tu && (Ki = qy);
    }
    function hS() {
      (Ki === tu || Ki === qy || Ki === hc) && (Ki = sm), Ka !== null && (Vf(Yy) || Vf(um)) && uf(Ka, Xi);
    }
    function UA(re) {
      Ki !== sm && (Ki = hc), fm === null ? fm = [re] : fm.push(re);
    }
    function jA() {
      return Ki === tu;
    }
    function rg(re, ie) {
      var he = on;
      on |= ga;
      var ve = _C();
      if (Ka !== re || Xi !== ie) {
        if (Ui) {
          var Ce = re.memoizedUpdaters;
          Ce.size > 0 && (vm(re, Xi), Ce.clear()), yd(re, ie);
        }
        ru = op(), mc(re, ie);
      }
      Ro(ie);
      do
        try {
          GA();
          break;
        } catch (ke) {
          wC(re, ke);
        }
      while (!0);
      if (uy(), on = he, AC(ve), di !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Au(), Ka = null, Xi = Zt, Ki;
    }
    function GA() {
      for (; di !== null; )
        PC(di);
    }
    function WA(re, ie) {
      var he = on;
      on |= ga;
      var ve = _C();
      if (Ka !== re || Xi !== ie) {
        if (Ui) {
          var Ce = re.memoizedUpdaters;
          Ce.size > 0 && (vm(re, Xi), Ce.clear()), yd(re, ie);
        }
        ru = op(), cm(), mc(re, ie);
      }
      Ro(ie);
      do
        try {
          qA();
          break;
        } catch (ke) {
          wC(re, ke);
        }
      while (!0);
      return uy(), AC(ve), on = he, di !== null ? (Lf(), tu) : (Au(), Ka = null, Xi = Zt, Ki);
    }
    function qA() {
      for (; di !== null && !Uc(); )
        PC(di);
    }
    function PC(re) {
      var ie = re.alternate;
      vn(re);
      var he;
      (re.mode & zr) !== Nr ? (P1(re), he = pS(ie, re, fl), By(re, !0)) : he = pS(ie, re, fl), Hn(), re.memoizedProps = re.pendingProps, he === null ? RC(re) : di = he, tS.current = null;
    }
    function RC(re) {
      var ie = re;
      do {
        var he = ie.alternate, ve = ie.return;
        if ((ie.flags & ja) === Or) {
          vn(ie);
          var Ce = void 0;
          if ((ie.mode & zr) === Nr ? Ce = Jb(he, ie, fl) : (P1(ie), Ce = Jb(he, ie, fl), By(ie, !1)), Hn(), Ce !== null) {
            di = Ce;
            return;
          }
        } else {
          var ke = H_(he, ie);
          if (ke !== null) {
            ke.flags &= Jm, di = ke;
            return;
          }
          if ((ie.mode & zr) !== Nr) {
            By(ie, !1);
            for (var at = ie.actualDuration, mt = ie.child; mt !== null; )
              at += mt.actualDuration, mt = mt.sibling;
            ie.actualDuration = at;
          }
          if (ve !== null)
            ve.flags |= ja, ve.subtreeFlags = Or, ve.deletions = null;
          else {
            Ki = rS, di = null;
            return;
          }
        }
        var gt = ie.sibling;
        if (gt !== null) {
          di = gt;
          return;
        }
        ie = ve, di = ie;
      } while (ie !== null);
      Ki === tu && (Ki = vC);
    }
    function vc(re, ie, he) {
      var ve = mo(), Ce = ya.transition;
      try {
        ya.transition = null, wi(ea), YA(re, ie, he, ve);
      } finally {
        ya.transition = Ce, wi(ve);
      }
      return null;
    }
    function YA(re, ie, he, ve) {
      do
        iu();
      while (sf !== null);
      if (aP(), (on & (ga | Jo)) !== Qi)
        throw new Error("Should not already be working.");
      var Ce = re.finishedWork, ke = re.finishedLanes;
      if (Wc(ke), Ce === null)
        return qh(), null;
      if (ke === Zt && be("root.finishedLanes should not be empty during a commit. This is a bug in React."), re.finishedWork = null, re.finishedLanes = Zt, Ce === re.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      re.callbackNode = null, re.callbackPriority = an;
      var at = Qr(Ce.lanes, Ce.childLanes);
      ip(re, at), re === Ka && (Ka = null, di = null, Xi = Zt), ((Ce.subtreeFlags & fo) !== Or || (Ce.flags & fo) !== Or) && (pc || (pc = !0, sS = he, yS(Ho, function() {
        return iu(), null;
      })));
      var mt = (Ce.subtreeFlags & (Tu | Ra | Zi | fo)) !== Or, gt = (Ce.flags & (Tu | Ra | Zi | fo)) !== Or;
      if (mt || gt) {
        var Tt = ya.transition;
        ya.transition = null;
        var Pt = mo();
        wi(ea);
        var Nt = on;
        on |= Jo, tS.current = null, q_(re, Ce), _b(), sA(re, Ce, ke), sT(re.containerInfo), re.current = Ce, lv(ke), lA(Ce, re, ke), _u(), tv(), on = Nt, wi(Pt), ya.transition = Tt;
      } else
        re.current = Ce, _b();
      var $t = pc;
      if (pc ? (pc = !1, sf = re, dm = ke) : (oh = 0, Jy = null), at = re.pendingLanes, at === Zt && (ah = null), $t || DC(re.current, !1), cs(Ce.stateNode, ve), Ui && re.memoizedUpdaters.clear(), AA(), xo(re, Wn()), ie !== null)
        for (var Gt = re.onRecoverableError, Wt = 0; Wt < ie.length; Wt++) {
          var Xt = ie[Wt], br = Xt.stack, $r = Xt.digest;
          Gt(Xt.value, {
            componentStack: br,
            digest: $r
          });
        }
      if (Xy) {
        Xy = !1;
        var Mr = aS;
        throw aS = null, Mr;
      }
      return Da(dm, Vr) && re.tag !== Xu && iu(), at = re.pendingLanes, Da(at, Vr) ? (n_(), re === lS ? hm++ : (hm = 0, lS = re)) : hm = 0, Ku(), qh(), null;
    }
    function iu() {
      if (sf !== null) {
        var re = jf(dm), ie = Fg(ps, re), he = ya.transition, ve = mo();
        try {
          return ya.transition = null, wi(ie), XA();
        } finally {
          wi(ve), ya.transition = he;
        }
      }
      return !1;
    }
    function QA(re) {
      oS.push(re), pc || (pc = !0, yS(Ho, function() {
        return iu(), null;
      }));
    }
    function XA() {
      if (sf === null)
        return !1;
      var re = sS;
      sS = null;
      var ie = sf, he = dm;
      if (sf = null, dm = Zt, (on & (ga | Jo)) !== Qi)
        throw new Error("Cannot flush passive effects while already rendering.");
      uS = !0, Ky = !1, uv(he);
      var ve = on;
      on |= Jo, mA(ie.current), cA(ie, ie.current, he, re);
      {
        var Ce = oS;
        oS = [];
        for (var ke = 0; ke < Ce.length; ke++) {
          var at = Ce[ke];
          K_(ie, at);
        }
      }
      Of(), DC(ie.current, !0), on = ve, Ku(), Ky ? ie === Jy ? oh++ : (oh = 0, Jy = ie) : oh = 0, uS = !1, Ky = !1, js(ie);
      {
        var mt = ie.current.stateNode;
        mt.effectDuration = 0, mt.passiveEffectDuration = 0;
      }
      return !0;
    }
    function kC(re) {
      return ah !== null && ah.has(re);
    }
    function KA(re) {
      ah === null ? ah = /* @__PURE__ */ new Set([re]) : ah.add(re);
    }
    function JA(re) {
      Xy || (Xy = !0, aS = re);
    }
    var ZA = JA;
    function MC(re, ie, he) {
      var ve = cc(he, ie), Ce = Pb(re, ve, Vr), ke = Zu(re, Ce, Vr), at = Ja();
      ke !== null && (Nl(ke, Vr, at), xo(ke, at));
    }
    function In(re, ie, he) {
      if (j_(he), ym(!1), re.tag === dt) {
        MC(re, re, he);
        return;
      }
      var ve = null;
      for (ve = ie; ve !== null; ) {
        if (ve.tag === dt) {
          MC(ve, re, he);
          return;
        } else if (ve.tag === rt) {
          var Ce = ve.type, ke = ve.stateNode;
          if (typeof Ce.getDerivedStateFromError == "function" || typeof ke.componentDidCatch == "function" && !kC(ke)) {
            var at = cc(he, re), mt = O1(ve, at, Vr), gt = Zu(ve, mt, Vr), Tt = Ja();
            gt !== null && (Nl(gt, Vr, Tt), xo(gt, Tt));
            return;
          }
        }
        ve = ve.return;
      }
      be(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, he);
    }
    function eP(re, ie, he) {
      var ve = re.pingCache;
      ve !== null && ve.delete(ie);
      var Ce = Ja();
      np(re, he), uP(re), Ka === re && Il(Xi, he) && (Ki === sm || Ki === qy && pd(Xi) && Wn() - iS < yC ? mc(re, Zt) : Qy = Qr(Qy, he)), xo(re, Ce);
    }
    function FC(re, ie) {
      ie === an && (ie = OA(re));
      var he = Ja(), ve = Eo(re, ie);
      ve !== null && (Nl(ve, ie, he), xo(ve, he));
    }
    function tP(re) {
      var ie = re.memoizedState, he = an;
      ie !== null && (he = ie.retryLane), FC(re, he);
    }
    function rP(re, ie) {
      var he = an, ve;
      switch (re.tag) {
        case Ct:
          ve = re.stateNode;
          var Ce = re.memoizedState;
          Ce !== null && (he = Ce.retryLane);
          break;
        case er:
          ve = re.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      ve !== null && ve.delete(ie), FC(re, he);
    }
    function nP(re) {
      return re < 120 ? 120 : re < 480 ? 480 : re < 1080 ? 1080 : re < 1920 ? 1920 : re < 3e3 ? 3e3 : re < 4320 ? 4320 : kA(re / 1960) * 1960;
    }
    function iP() {
      if (hm > FA)
        throw hm = 0, lS = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      oh > DA && (oh = 0, Jy = null, be("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function aP() {
      bs.flushLegacyContextWarning(), bs.flushPendingUnsafeLifecycleWarnings();
    }
    function DC(re, ie) {
      vn(re), ng(re, Pa, TA), ie && ng(re, Al, wA), ng(re, Pa, CA), ie && ng(re, Al, xA), Hn();
    }
    function ng(re, ie, he) {
      for (var ve = re, Ce = null; ve !== null; ) {
        var ke = ve.subtreeFlags & ie;
        ve !== Ce && ve.child !== null && ke !== Or ? ve = ve.child : ((ve.flags & ie) !== Or && he(ve), ve.sibling !== null ? ve = ve.sibling : ve = Ce = ve.return);
      }
    }
    var ig = null;
    function OC(re) {
      {
        if ((on & ga) !== Qi || !(re.mode & Jr))
          return;
        var ie = re.tag;
        if (ie !== st && ie !== dt && ie !== rt && ie !== Ae && ie !== ft && ie !== xt && ie !== At)
          return;
        var he = Gr(re) || "ReactComponent";
        if (ig !== null) {
          if (ig.has(he))
            return;
          ig.add(he);
        } else
          ig = /* @__PURE__ */ new Set([he]);
        var ve = ni;
        try {
          vn(re), be("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          ve ? vn(re) : Hn();
        }
      }
    }
    var pS;
    {
      var oP = null;
      pS = function(re, ie, he) {
        var ve = HC(oP, ie);
        try {
          return qb(re, ie, he);
        } catch (ke) {
          if (Sw() || ke !== null && typeof ke == "object" && typeof ke.then == "function")
            throw ke;
          if (uy(), eb(), Zb(re, ie), HC(ie, ve), ie.mode & zr && P1(ie), _l(null, qb, null, re, ie, he), wg()) {
            var Ce = $h();
            typeof Ce == "object" && Ce !== null && Ce._suppressLogging && typeof ke == "object" && ke !== null && !ke._suppressLogging && (ke._suppressLogging = !0);
          }
          throw ke;
        }
      };
    }
    var LC = !1, mS;
    mS = /* @__PURE__ */ new Set();
    function sP(re) {
      if (pi && !e_())
        switch (re.tag) {
          case Ae:
          case ft:
          case At: {
            var ie = di && Gr(di) || "Unknown", he = ie;
            if (!mS.has(he)) {
              mS.add(he);
              var ve = Gr(re) || "Unknown";
              be("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", ve, ie, ie);
            }
            break;
          }
          case rt: {
            LC || (be("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), LC = !0);
            break;
          }
        }
    }
    function vm(re, ie) {
      if (Ui) {
        var he = re.memoizedUpdaters;
        he.forEach(function(ve) {
          ap(re, ve, ie);
        });
      }
    }
    var vS = {};
    function yS(re, ie) {
      {
        var he = Rs.current;
        return he !== null ? (he.push(ie), vS) : Hc(re, ie);
      }
    }
    function $C(re) {
      if (re !== vS)
        return ev(re);
    }
    function IC() {
      return Rs.current !== null;
    }
    function lP(re) {
      {
        if (re.mode & Jr) {
          if (!pC())
            return;
        } else if (!RA() || on !== Qi || re.tag !== Ae && re.tag !== ft && re.tag !== At)
          return;
        if (Rs.current === null) {
          var ie = ni;
          try {
            vn(re), be(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Gr(re));
          } finally {
            ie ? vn(re) : Hn();
          }
        }
      }
    }
    function uP(re) {
      re.tag !== Xu && pC() && Rs.current === null && be(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function ym(re) {
      EC = re;
    }
    var Zo = null, sh = null, fP = function(re) {
      Zo = re;
    };
    function lh(re) {
      {
        if (Zo === null)
          return re;
        var ie = Zo(re);
        return ie === void 0 ? re : ie.current;
      }
    }
    function gS(re) {
      return lh(re);
    }
    function SS(re) {
      {
        if (Zo === null)
          return re;
        var ie = Zo(re);
        if (ie === void 0) {
          if (re != null && typeof re.render == "function") {
            var he = lh(re.render);
            if (re.render !== he) {
              var ve = {
                $$typeof: Fs,
                render: he
              };
              return re.displayName !== void 0 && (ve.displayName = re.displayName), ve;
            }
          }
          return re;
        }
        return ie.current;
      }
    }
    function NC(re, ie) {
      {
        if (Zo === null)
          return !1;
        var he = re.elementType, ve = ie.type, Ce = !1, ke = typeof ve == "object" && ve !== null ? ve.$$typeof : null;
        switch (re.tag) {
          case rt: {
            typeof ve == "function" && (Ce = !0);
            break;
          }
          case Ae: {
            (typeof ve == "function" || ke === Bi) && (Ce = !0);
            break;
          }
          case ft: {
            (ke === Fs || ke === Bi) && (Ce = !0);
            break;
          }
          case xt:
          case At: {
            (ke === Ds || ke === Bi) && (Ce = !0);
            break;
          }
          default:
            return !1;
        }
        if (Ce) {
          var at = Zo(he);
          if (at !== void 0 && at === Zo(ve))
            return !0;
        }
        return !1;
      }
    }
    function zC(re) {
      {
        if (Zo === null || typeof WeakSet != "function")
          return;
        sh === null && (sh = /* @__PURE__ */ new WeakSet()), sh.add(re);
      }
    }
    var cP = function(re, ie) {
      {
        if (Zo === null)
          return;
        var he = ie.staleFamilies, ve = ie.updatedFamilies;
        iu(), nu(function() {
          ES(re.current, ve, he);
        });
      }
    }, dP = function(re, ie) {
      {
        if (re.context !== Mo)
          return;
        iu(), nu(function() {
          gm(ie, re, null, null);
        });
      }
    };
    function ES(re, ie, he) {
      {
        var ve = re.alternate, Ce = re.child, ke = re.sibling, at = re.tag, mt = re.type, gt = null;
        switch (at) {
          case Ae:
          case At:
          case rt:
            gt = mt;
            break;
          case ft:
            gt = mt.render;
            break;
        }
        if (Zo === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Tt = !1, Pt = !1;
        if (gt !== null) {
          var Nt = Zo(gt);
          Nt !== void 0 && (he.has(Nt) ? Pt = !0 : ie.has(Nt) && (at === rt ? Pt = !0 : Tt = !0));
        }
        if (sh !== null && (sh.has(re) || ve !== null && sh.has(ve)) && (Pt = !0), Pt && (re._debugNeedsRemount = !0), Pt || Tt) {
          var $t = Eo(re, Vr);
          $t !== null && Ji($t, re, Vr, Pn);
        }
        Ce !== null && !Pt && ES(Ce, ie, he), ke !== null && ES(ke, ie, he);
      }
    }
    var hP = function(re, ie) {
      {
        var he = /* @__PURE__ */ new Set(), ve = new Set(ie.map(function(Ce) {
          return Ce.current;
        }));
        return bS(re.current, ve, he), he;
      }
    };
    function bS(re, ie, he) {
      {
        var ve = re.child, Ce = re.sibling, ke = re.tag, at = re.type, mt = null;
        switch (ke) {
          case Ae:
          case At:
          case rt:
            mt = at;
            break;
          case ft:
            mt = at.render;
            break;
        }
        var gt = !1;
        mt !== null && ie.has(mt) && (gt = !0), gt ? pP(re, he) : ve !== null && bS(ve, ie, he), Ce !== null && bS(Ce, ie, he);
      }
    }
    function pP(re, ie) {
      {
        var he = mP(re, ie);
        if (he)
          return;
        for (var ve = re; ; ) {
          switch (ve.tag) {
            case pt:
              ie.add(ve.stateNode);
              return;
            case lt:
              ie.add(ve.stateNode.containerInfo);
              return;
            case dt:
              ie.add(ve.stateNode.containerInfo);
              return;
          }
          if (ve.return === null)
            throw new Error("Expected to reach root first.");
          ve = ve.return;
        }
      }
    }
    function mP(re, ie) {
      for (var he = re, ve = !1; ; ) {
        if (he.tag === pt)
          ve = !0, ie.add(he.stateNode);
        else if (he.child !== null) {
          he.child.return = he, he = he.child;
          continue;
        }
        if (he === re)
          return ve;
        for (; he.sibling === null; ) {
          if (he.return === null || he.return === re)
            return ve;
          he = he.return;
        }
        he.sibling.return = he.return, he = he.sibling;
      }
      return !1;
    }
    var CS;
    {
      CS = !1;
      try {
        var VC = Object.preventExtensions({});
      } catch {
        CS = !0;
      }
    }
    function vP(re, ie, he, ve) {
      this.tag = re, this.key = he, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = ie, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = ve, this.flags = Or, this.subtreeFlags = Or, this.deletions = null, this.lanes = Zt, this.childLanes = Zt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !CS && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Fo = function(re, ie, he, ve) {
      return new vP(re, ie, he, ve);
    };
    function xS(re) {
      var ie = re.prototype;
      return !!(ie && ie.isReactComponent);
    }
    function yP(re) {
      return typeof re == "function" && !xS(re) && re.defaultProps === void 0;
    }
    function gP(re) {
      if (typeof re == "function")
        return xS(re) ? rt : Ae;
      if (re != null) {
        var ie = re.$$typeof;
        if (ie === Fs)
          return ft;
        if (ie === Ds)
          return xt;
      }
      return st;
    }
    function yc(re, ie) {
      var he = re.alternate;
      he === null ? (he = Fo(re.tag, ie, re.key, re.mode), he.elementType = re.elementType, he.type = re.type, he.stateNode = re.stateNode, he._debugSource = re._debugSource, he._debugOwner = re._debugOwner, he._debugHookTypes = re._debugHookTypes, he.alternate = re, re.alternate = he) : (he.pendingProps = ie, he.type = re.type, he.flags = Or, he.subtreeFlags = Or, he.deletions = null, he.actualDuration = 0, he.actualStartTime = -1), he.flags = re.flags & Hi, he.childLanes = re.childLanes, he.lanes = re.lanes, he.child = re.child, he.memoizedProps = re.memoizedProps, he.memoizedState = re.memoizedState, he.updateQueue = re.updateQueue;
      var ve = re.dependencies;
      switch (he.dependencies = ve === null ? null : {
        lanes: ve.lanes,
        firstContext: ve.firstContext
      }, he.sibling = re.sibling, he.index = re.index, he.ref = re.ref, he.selfBaseDuration = re.selfBaseDuration, he.treeBaseDuration = re.treeBaseDuration, he._debugNeedsRemount = re._debugNeedsRemount, he.tag) {
        case st:
        case Ae:
        case At:
          he.type = lh(re.type);
          break;
        case rt:
          he.type = gS(re.type);
          break;
        case ft:
          he.type = SS(re.type);
          break;
      }
      return he;
    }
    function SP(re, ie) {
      re.flags &= Hi | Dn;
      var he = re.alternate;
      if (he === null)
        re.childLanes = Zt, re.lanes = ie, re.child = null, re.subtreeFlags = Or, re.memoizedProps = null, re.memoizedState = null, re.updateQueue = null, re.dependencies = null, re.stateNode = null, re.selfBaseDuration = 0, re.treeBaseDuration = 0;
      else {
        re.childLanes = he.childLanes, re.lanes = he.lanes, re.child = he.child, re.subtreeFlags = Or, re.deletions = null, re.memoizedProps = he.memoizedProps, re.memoizedState = he.memoizedState, re.updateQueue = he.updateQueue, re.type = he.type;
        var ve = he.dependencies;
        re.dependencies = ve === null ? null : {
          lanes: ve.lanes,
          firstContext: ve.firstContext
        }, re.selfBaseDuration = he.selfBaseDuration, re.treeBaseDuration = he.treeBaseDuration;
      }
      return re;
    }
    function EP(re, ie, he) {
      var ve;
      return re === ty ? (ve = Jr, ie === !0 && (ve |= qn, ve |= ho)) : ve = Nr, Ui && (ve |= zr), Fo(dt, null, null, ve);
    }
    function TS(re, ie, he, ve, Ce, ke) {
      var at = st, mt = re;
      if (typeof re == "function")
        xS(re) ? (at = rt, mt = gS(mt)) : mt = lh(mt);
      else if (typeof re == "string")
        at = pt;
      else
        e:
          switch (re) {
            case Ba:
              return ff(he.children, Ce, ke, ie);
            case Ca:
              at = St, Ce |= qn, (Ce & Jr) !== Nr && (Ce |= ho);
              break;
            case hl:
              return bP(he, Ce, ke, ie);
            case to:
              return CP(he, Ce, ke, ie);
            case oa:
              return xP(he, Ce, ke, ie);
            case pf:
              return BC(he, Ce, ke, ie);
            case $o:
            case gc:
            case fh:
            case ch:
            case Sc:
            default: {
              if (typeof re == "object" && re !== null)
                switch (re.$$typeof) {
                  case df:
                    at = ht;
                    break e;
                  case hf:
                    at = ot;
                    break e;
                  case Fs:
                    at = ft, mt = SS(mt);
                    break e;
                  case Ds:
                    at = xt;
                    break e;
                  case Bi:
                    at = kt, mt = null;
                    break e;
                }
              var gt = "";
              {
                (re === void 0 || typeof re == "object" && re !== null && Object.keys(re).length === 0) && (gt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Tt = ve ? Gr(ve) : null;
                Tt && (gt += `

Check the render method of \`` + Tt + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (re == null ? re : typeof re) + "." + gt));
            }
          }
      var Pt = Fo(at, he, ie, Ce);
      return Pt.elementType = re, Pt.type = mt, Pt.lanes = ke, Pt._debugOwner = ve, Pt;
    }
    function wS(re, ie, he) {
      var ve = null;
      ve = re._owner;
      var Ce = re.type, ke = re.key, at = re.props, mt = TS(Ce, ke, at, ve, ie, he);
      return mt._debugSource = re._source, mt._debugOwner = re._owner, mt;
    }
    function ff(re, ie, he, ve) {
      var Ce = Fo(ut, re, ve, ie);
      return Ce.lanes = he, Ce;
    }
    function bP(re, ie, he, ve) {
      typeof re.id != "string" && be('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof re.id);
      var Ce = Fo(vt, re, ve, ie | zr);
      return Ce.elementType = hl, Ce.lanes = he, Ce.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, Ce;
    }
    function CP(re, ie, he, ve) {
      var Ce = Fo(Ct, re, ve, ie);
      return Ce.elementType = to, Ce.lanes = he, Ce;
    }
    function xP(re, ie, he, ve) {
      var Ce = Fo(er, re, ve, ie);
      return Ce.elementType = oa, Ce.lanes = he, Ce;
    }
    function BC(re, ie, he, ve) {
      var Ce = Fo(Jt, re, ve, ie);
      Ce.elementType = pf, Ce.lanes = he;
      var ke = {
        isHidden: !1
      };
      return Ce.stateNode = ke, Ce;
    }
    function _S(re, ie, he) {
      var ve = Fo(it, re, null, ie);
      return ve.lanes = he, ve;
    }
    function TP() {
      var re = Fo(pt, null, null, Nr);
      return re.elementType = "DELETED", re;
    }
    function wP(re) {
      var ie = Fo(ir, null, null, Nr);
      return ie.stateNode = re, ie;
    }
    function AS(re, ie, he) {
      var ve = re.children !== null ? re.children : [], Ce = Fo(lt, ve, re.key, ie);
      return Ce.lanes = he, Ce.stateNode = {
        containerInfo: re.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: re.implementation
      }, Ce;
    }
    function HC(re, ie) {
      return re === null && (re = Fo(st, null, null, Nr)), re.tag = ie.tag, re.key = ie.key, re.elementType = ie.elementType, re.type = ie.type, re.stateNode = ie.stateNode, re.return = ie.return, re.child = ie.child, re.sibling = ie.sibling, re.index = ie.index, re.ref = ie.ref, re.pendingProps = ie.pendingProps, re.memoizedProps = ie.memoizedProps, re.updateQueue = ie.updateQueue, re.memoizedState = ie.memoizedState, re.dependencies = ie.dependencies, re.mode = ie.mode, re.flags = ie.flags, re.subtreeFlags = ie.subtreeFlags, re.deletions = ie.deletions, re.lanes = ie.lanes, re.childLanes = ie.childLanes, re.alternate = ie.alternate, re.actualDuration = ie.actualDuration, re.actualStartTime = ie.actualStartTime, re.selfBaseDuration = ie.selfBaseDuration, re.treeBaseDuration = ie.treeBaseDuration, re._debugSource = ie._debugSource, re._debugOwner = ie._debugOwner, re._debugNeedsRemount = ie._debugNeedsRemount, re._debugHookTypes = ie._debugHookTypes, re;
    }
    function _P(re, ie, he, ve, Ce) {
      this.tag = ie, this.containerInfo = re, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = l0, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = an, this.eventTimes = vd(Zt), this.expirationTimes = vd(Pn), this.pendingLanes = Zt, this.suspendedLanes = Zt, this.pingedLanes = Zt, this.expiredLanes = Zt, this.mutableReadLanes = Zt, this.finishedLanes = Zt, this.entangledLanes = Zt, this.entanglements = vd(Zt), this.identifierPrefix = ve, this.onRecoverableError = Ce, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var ke = this.pendingUpdatersLaneMap = [], at = 0; at < Ln; at++)
          ke.push(/* @__PURE__ */ new Set());
      }
      switch (ie) {
        case ty:
          this._debugRootType = he ? "hydrateRoot()" : "createRoot()";
          break;
        case Xu:
          this._debugRootType = he ? "hydrate()" : "render()";
          break;
      }
    }
    function UC(re, ie, he, ve, Ce, ke, at, mt, gt, Tt) {
      var Pt = new _P(re, ie, he, mt, gt), Nt = EP(ie, ke);
      Pt.current = Nt, Nt.stateNode = Pt;
      {
        var $t = {
          element: ve,
          isDehydrated: he,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Nt.memoizedState = $t;
      }
      return L0(Nt), Pt;
    }
    var PS = "18.2.0";
    function AP(re, ie, he) {
      var ve = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Ri(ve), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: ba,
        key: ve == null ? null : "" + ve,
        children: re,
        containerInfo: ie,
        implementation: he
      };
    }
    var RS, kS;
    RS = !1, kS = {};
    function jC(re) {
      if (!re)
        return Mo;
      var ie = so(re), he = fw(ie);
      if (ie.tag === rt) {
        var ve = ie.type;
        if (nl(ve))
          return mE(ie, ve, he);
      }
      return he;
    }
    function PP(re, ie) {
      {
        var he = so(re);
        if (he === void 0) {
          if (typeof re.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var ve = Object.keys(re).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + ve);
        }
        var Ce = co(he);
        if (Ce === null)
          return null;
        if (Ce.mode & qn) {
          var ke = Gr(he) || "Component";
          if (!kS[ke]) {
            kS[ke] = !0;
            var at = ni;
            try {
              vn(Ce), he.mode & qn ? be("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ie, ie, ke) : be("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", ie, ie, ke);
            } finally {
              at ? vn(at) : Hn();
            }
          }
        }
        return Ce.stateNode;
      }
    }
    function GC(re, ie, he, ve, Ce, ke, at, mt) {
      var gt = !1, Tt = null;
      return UC(re, ie, gt, Tt, he, ve, Ce, ke, at);
    }
    function WC(re, ie, he, ve, Ce, ke, at, mt, gt, Tt) {
      var Pt = !0, Nt = UC(he, ve, Pt, re, Ce, ke, at, mt, gt);
      Nt.context = jC(null);
      var $t = Nt.current, Gt = Ja(), Wt = lf($t), Xt = Zl(Gt, Wt);
      return Xt.callback = ie ?? null, Zu($t, Xt, Wt), LA(Nt, Wt, Gt), Nt;
    }
    function gm(re, ie, he, ve) {
      rv(ie, re);
      var Ce = ie.current, ke = Ja(), at = lf(Ce);
      Rl(at);
      var mt = jC(he);
      ie.context === null ? ie.context = mt : ie.pendingContext = mt, pi && ni !== null && !RS && (RS = !0, be(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Gr(ni) || "Unknown"));
      var gt = Zl(ke, at);
      gt.payload = {
        element: re
      }, ve = ve === void 0 ? null : ve, ve !== null && (typeof ve != "function" && be("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ve), gt.callback = ve);
      var Tt = Zu(Ce, gt, at);
      return Tt !== null && (Ji(Tt, Ce, at, ke), py(Tt, Ce, at)), at;
    }
    function ag(re) {
      var ie = re.current;
      if (!ie.child)
        return null;
      switch (ie.child.tag) {
        case pt:
          return ie.child.stateNode;
        default:
          return ie.child.stateNode;
      }
    }
    function RP(re) {
      switch (re.tag) {
        case dt: {
          var ie = re.stateNode;
          if (_i(ie)) {
            var he = Pg(ie);
            zA(ie, he);
          }
          break;
        }
        case Ct: {
          nu(function() {
            var Ce = Eo(re, Vr);
            if (Ce !== null) {
              var ke = Ja();
              Ji(Ce, re, Vr, ke);
            }
          });
          var ve = Vr;
          MS(re, ve);
          break;
        }
      }
    }
    function qC(re, ie) {
      var he = re.memoizedState;
      he !== null && he.dehydrated !== null && (he.retryLane = pv(he.retryLane, ie));
    }
    function MS(re, ie) {
      qC(re, ie);
      var he = re.alternate;
      he && qC(he, ie);
    }
    function kP(re) {
      if (re.tag === Ct) {
        var ie = Pu, he = Eo(re, ie);
        if (he !== null) {
          var ve = Ja();
          Ji(he, re, ie, ve);
        }
        MS(re, ie);
      }
    }
    function MP(re) {
      if (re.tag === Ct) {
        var ie = lf(re), he = Eo(re, ie);
        if (he !== null) {
          var ve = Ja();
          Ji(he, re, ie, ve);
        }
        MS(re, ie);
      }
    }
    function YC(re) {
      var ie = Zm(re);
      return ie === null ? null : ie.stateNode;
    }
    var QC = function(re) {
      return null;
    };
    function FP(re) {
      return QC(re);
    }
    var XC = function(re) {
      return !1;
    };
    function DP(re) {
      return XC(re);
    }
    var KC = null, JC = null, ZC = null, ex = null, tx = null, rx = null, nx = null, ix = null, ax = null;
    {
      var ox = function(re, ie, he) {
        var ve = ie[he], Ce = Di(re) ? re.slice() : Xr({}, re);
        return he + 1 === ie.length ? (Di(Ce) ? Ce.splice(ve, 1) : delete Ce[ve], Ce) : (Ce[ve] = ox(re[ve], ie, he + 1), Ce);
      }, sx = function(re, ie) {
        return ox(re, ie, 0);
      }, lx = function(re, ie, he, ve) {
        var Ce = ie[ve], ke = Di(re) ? re.slice() : Xr({}, re);
        if (ve + 1 === ie.length) {
          var at = he[ve];
          ke[at] = ke[Ce], Di(ke) ? ke.splice(Ce, 1) : delete ke[Ce];
        } else
          ke[Ce] = lx(
            // $FlowFixMe number or string is fine here
            re[Ce],
            ie,
            he,
            ve + 1
          );
        return ke;
      }, ux = function(re, ie, he) {
        if (ie.length !== he.length) {
          ge("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var ve = 0; ve < he.length - 1; ve++)
            if (ie[ve] !== he[ve]) {
              ge("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return lx(re, ie, he, 0);
      }, fx = function(re, ie, he, ve) {
        if (he >= ie.length)
          return ve;
        var Ce = ie[he], ke = Di(re) ? re.slice() : Xr({}, re);
        return ke[Ce] = fx(re[Ce], ie, he + 1, ve), ke;
      }, cx = function(re, ie, he) {
        return fx(re, ie, 0, he);
      }, FS = function(re, ie) {
        for (var he = re.memoizedState; he !== null && ie > 0; )
          he = he.next, ie--;
        return he;
      };
      KC = function(re, ie, he, ve) {
        var Ce = FS(re, ie);
        if (Ce !== null) {
          var ke = cx(Ce.memoizedState, he, ve);
          Ce.memoizedState = ke, Ce.baseState = ke, re.memoizedProps = Xr({}, re.memoizedProps);
          var at = Eo(re, Vr);
          at !== null && Ji(at, re, Vr, Pn);
        }
      }, JC = function(re, ie, he) {
        var ve = FS(re, ie);
        if (ve !== null) {
          var Ce = sx(ve.memoizedState, he);
          ve.memoizedState = Ce, ve.baseState = Ce, re.memoizedProps = Xr({}, re.memoizedProps);
          var ke = Eo(re, Vr);
          ke !== null && Ji(ke, re, Vr, Pn);
        }
      }, ZC = function(re, ie, he, ve) {
        var Ce = FS(re, ie);
        if (Ce !== null) {
          var ke = ux(Ce.memoizedState, he, ve);
          Ce.memoizedState = ke, Ce.baseState = ke, re.memoizedProps = Xr({}, re.memoizedProps);
          var at = Eo(re, Vr);
          at !== null && Ji(at, re, Vr, Pn);
        }
      }, ex = function(re, ie, he) {
        re.pendingProps = cx(re.memoizedProps, ie, he), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var ve = Eo(re, Vr);
        ve !== null && Ji(ve, re, Vr, Pn);
      }, tx = function(re, ie) {
        re.pendingProps = sx(re.memoizedProps, ie), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var he = Eo(re, Vr);
        he !== null && Ji(he, re, Vr, Pn);
      }, rx = function(re, ie, he) {
        re.pendingProps = ux(re.memoizedProps, ie, he), re.alternate && (re.alternate.pendingProps = re.pendingProps);
        var ve = Eo(re, Vr);
        ve !== null && Ji(ve, re, Vr, Pn);
      }, nx = function(re) {
        var ie = Eo(re, Vr);
        ie !== null && Ji(ie, re, Vr, Pn);
      }, ix = function(re) {
        QC = re;
      }, ax = function(re) {
        XC = re;
      };
    }
    function OP(re) {
      var ie = co(re);
      return ie === null ? null : ie.stateNode;
    }
    function LP(re) {
      return null;
    }
    function $P() {
      return ni;
    }
    function IP(re) {
      var ie = re.findFiberByHostInstance, he = oe.ReactCurrentDispatcher;
      return Gh({
        bundleType: re.bundleType,
        version: re.version,
        rendererPackageName: re.rendererPackageName,
        rendererConfig: re.rendererConfig,
        overrideHookState: KC,
        overrideHookStateDeletePath: JC,
        overrideHookStateRenamePath: ZC,
        overrideProps: ex,
        overridePropsDeletePath: tx,
        overridePropsRenamePath: rx,
        setErrorHandler: ix,
        setSuspenseHandler: ax,
        scheduleUpdate: nx,
        currentDispatcherRef: he,
        findHostInstanceByFiber: OP,
        findFiberByHostInstance: ie || LP,
        // React Refresh
        findHostInstancesForRefresh: hP,
        scheduleRefresh: cP,
        scheduleRoot: dP,
        setRefreshHandler: fP,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: $P,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: PS
      });
    }
    var dx = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(re) {
      console.error(re);
    };
    function DS(re) {
      this._internalRoot = re;
    }
    og.prototype.render = DS.prototype.render = function(re) {
      var ie = this._internalRoot;
      if (ie === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? be("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : sg(arguments[1]) ? be("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && be("You passed a second argument to root.render(...) but it only accepts one argument.");
        var he = ie.containerInfo;
        if (he.nodeType !== mi) {
          var ve = YC(ie.current);
          ve && ve.parentNode !== he && be("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      gm(re, ie, null, null);
    }, og.prototype.unmount = DS.prototype.unmount = function() {
      typeof arguments[0] == "function" && be("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var re = this._internalRoot;
      if (re !== null) {
        this._internalRoot = null;
        var ie = re.containerInfo;
        TC() && be("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), nu(function() {
          gm(null, re, null, null);
        }), fE(ie);
      }
    };
    function NP(re, ie) {
      if (!sg(re))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      hx(re);
      var he = !1, ve = !1, Ce = "", ke = dx;
      ie != null && (ie.hydrate ? ge("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof ie == "object" && ie !== null && ie.$$typeof === Ms && be(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), ie.unstable_strictMode === !0 && (he = !0), ie.identifierPrefix !== void 0 && (Ce = ie.identifierPrefix), ie.onRecoverableError !== void 0 && (ke = ie.onRecoverableError), ie.transitionCallbacks !== void 0 && ie.transitionCallbacks);
      var at = GC(re, ty, null, he, ve, Ce, ke);
      Yv(at.current, re);
      var mt = re.nodeType === mi ? re.parentNode : re;
      return _p(mt), new DS(at);
    }
    function og(re) {
      this._internalRoot = re;
    }
    function zP(re) {
      re && Cv(re);
    }
    og.prototype.unstable_scheduleHydration = zP;
    function VP(re, ie, he) {
      if (!sg(re))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      hx(re), ie === void 0 && be("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var ve = he ?? null, Ce = he != null && he.hydratedSources || null, ke = !1, at = !1, mt = "", gt = dx;
      he != null && (he.unstable_strictMode === !0 && (ke = !0), he.identifierPrefix !== void 0 && (mt = he.identifierPrefix), he.onRecoverableError !== void 0 && (gt = he.onRecoverableError));
      var Tt = WC(ie, null, re, ty, ve, ke, at, mt, gt);
      if (Yv(Tt.current, re), _p(re), Ce)
        for (var Pt = 0; Pt < Ce.length; Pt++) {
          var Nt = Ce[Pt];
          Yw(Tt, Nt);
        }
      return new og(Tt);
    }
    function sg(re) {
      return !!(re && (re.nodeType === wa || re.nodeType === _o || re.nodeType === El || !nr));
    }
    function Sm(re) {
      return !!(re && (re.nodeType === wa || re.nodeType === _o || re.nodeType === El || re.nodeType === mi && re.nodeValue === " react-mount-point-unstable "));
    }
    function hx(re) {
      re.nodeType === wa && re.tagName && re.tagName.toUpperCase() === "BODY" && be("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Ip(re) && (re._reactRootContainer ? be("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : be("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var BP = oe.ReactCurrentOwner, px;
    px = function(re) {
      if (re._reactRootContainer && re.nodeType !== mi) {
        var ie = YC(re._reactRootContainer.current);
        ie && ie.parentNode !== re && be("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var he = !!re._reactRootContainer, ve = OS(re), Ce = !!(ve && Yu(ve));
      Ce && !he && be("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), re.nodeType === wa && re.tagName && re.tagName.toUpperCase() === "BODY" && be("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function OS(re) {
      return re ? re.nodeType === _o ? re.documentElement : re.firstChild : null;
    }
    function mx() {
    }
    function HP(re, ie, he, ve, Ce) {
      if (Ce) {
        if (typeof ve == "function") {
          var ke = ve;
          ve = function() {
            var $t = ag(at);
            ke.call($t);
          };
        }
        var at = WC(
          ie,
          ve,
          re,
          Xu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          mx
        );
        re._reactRootContainer = at, Yv(at.current, re);
        var mt = re.nodeType === mi ? re.parentNode : re;
        return _p(mt), nu(), at;
      } else {
        for (var gt; gt = re.lastChild; )
          re.removeChild(gt);
        if (typeof ve == "function") {
          var Tt = ve;
          ve = function() {
            var $t = ag(Pt);
            Tt.call($t);
          };
        }
        var Pt = GC(
          re,
          Xu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          mx
        );
        re._reactRootContainer = Pt, Yv(Pt.current, re);
        var Nt = re.nodeType === mi ? re.parentNode : re;
        return _p(Nt), nu(function() {
          gm(ie, Pt, he, ve);
        }), Pt;
      }
    }
    function UP(re, ie) {
      re !== null && typeof re != "function" && be("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", ie, re);
    }
    function lg(re, ie, he, ve, Ce) {
      px(he), UP(Ce === void 0 ? null : Ce, "render");
      var ke = he._reactRootContainer, at;
      if (!ke)
        at = HP(he, ie, re, Ce, ve);
      else {
        if (at = ke, typeof Ce == "function") {
          var mt = Ce;
          Ce = function() {
            var gt = ag(at);
            mt.call(gt);
          };
        }
        gm(ie, at, re, Ce);
      }
      return ag(at);
    }
    function jP(re) {
      {
        var ie = BP.current;
        if (ie !== null && ie.stateNode !== null) {
          var he = ie.stateNode._warnedAboutRefsInRender;
          he || be("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", nn(ie.type) || "A component"), ie.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return re == null ? null : re.nodeType === wa ? re : PP(re, "findDOMNode");
    }
    function GP(re, ie, he) {
      if (be("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Sm(ie))
        throw new Error("Target container is not a DOM element.");
      {
        var ve = Ip(ie) && ie._reactRootContainer === void 0;
        ve && be("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return lg(null, re, ie, !0, he);
    }
    function WP(re, ie, he) {
      if (be("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Sm(ie))
        throw new Error("Target container is not a DOM element.");
      {
        var ve = Ip(ie) && ie._reactRootContainer === void 0;
        ve && be("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return lg(null, re, ie, !1, he);
    }
    function qP(re, ie, he, ve) {
      if (be("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Sm(he))
        throw new Error("Target container is not a DOM element.");
      if (re == null || !Mf(re))
        throw new Error("parentComponent must be a valid React Component");
      return lg(re, ie, he, !1, ve);
    }
    function YP(re) {
      if (!Sm(re))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var ie = Ip(re) && re._reactRootContainer === void 0;
        ie && be("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (re._reactRootContainer) {
        {
          var he = OS(re), ve = he && !Yu(he);
          ve && be("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return nu(function() {
          lg(null, null, re, !1, function() {
            re._reactRootContainer = null, fE(re);
          });
        }), !0;
      } else {
        {
          var Ce = OS(re), ke = !!(Ce && Yu(Ce)), at = re.nodeType === wa && Sm(re.parentNode) && !!re.parentNode._reactRootContainer;
          ke && be("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", at ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Tr(RP), vv(kP), Wf(MP), lp(mo), gv(Uf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && be("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Xm(Kx), Ic(cS, VA, nu);
    function QP(re, ie) {
      var he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!sg(ie))
        throw new Error("Target container is not a DOM element.");
      return AP(re, ie, null, he);
    }
    function XP(re, ie, he, ve) {
      return qP(re, ie, he, ve);
    }
    var LS = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Yu, zd, Qv, $c, Pf, cS]
    };
    function KP(re, ie) {
      return LS.usingClientEntryPoint || be('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), NP(re, ie);
    }
    function JP(re, ie, he) {
      return LS.usingClientEntryPoint || be('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), VP(re, ie, he);
    }
    function ZP(re) {
      return TC() && be("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), nu(re);
    }
    var eR = IP({
      findFiberByHostInstance: rc,
      bundleType: 1,
      version: PS,
      rendererPackageName: "react-dom"
    });
    if (!eR && Rr && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var vx = window.location.protocol;
      /^(https?|file):$/.test(vx) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (vx === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LS, reactDom_development.createPortal = QP, reactDom_development.createRoot = KP, reactDom_development.findDOMNode = jP, reactDom_development.flushSync = ZP, reactDom_development.hydrate = GP, reactDom_development.hydrateRoot = JP, reactDom_development.render = WP, reactDom_development.unmountComponentAtNode = YP, reactDom_development.unstable_batchedUpdates = cS, reactDom_development.unstable_renderSubtreeIntoContainer = XP, reactDom_development.version = PS, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), reactDom_development;
}
var reactDom_production_min = {};
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min)
    return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var L = React__default, ne = requireScheduler();
  function oe(fe) {
    for (var ce = "https://reactjs.org/docs/error-decoder.html?invariant=" + fe, Ee = 1; Ee < arguments.length; Ee++)
      ce += "&args[]=" + encodeURIComponent(arguments[Ee]);
    return "Minified React error #" + fe + "; visit " + ce + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var pe = /* @__PURE__ */ new Set(), me = {};
  function ge(fe, ce) {
    be(fe, ce), be(fe + "Capture", ce);
  }
  function be(fe, ce) {
    for (me[fe] = ce, fe = 0; fe < ce.length; fe++)
      pe.add(ce[fe]);
  }
  var Ie = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Ae = Object.prototype.hasOwnProperty, rt = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, st = {}, dt = {};
  function lt(fe) {
    return Ae.call(dt, fe) ? !0 : Ae.call(st, fe) ? !1 : rt.test(fe) ? dt[fe] = !0 : (st[fe] = !0, !1);
  }
  function pt(fe, ce, Ee, Te) {
    if (Ee !== null && Ee.type === 0)
      return !1;
    switch (typeof ce) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return Te ? !1 : Ee !== null ? !Ee.acceptsBooleans : (fe = fe.toLowerCase().slice(0, 5), fe !== "data-" && fe !== "aria-");
      default:
        return !1;
    }
  }
  function it(fe, ce, Ee, Te) {
    if (ce === null || typeof ce > "u" || pt(fe, ce, Ee, Te))
      return !0;
    if (Te)
      return !1;
    if (Ee !== null)
      switch (Ee.type) {
        case 3:
          return !ce;
        case 4:
          return ce === !1;
        case 5:
          return isNaN(ce);
        case 6:
          return isNaN(ce) || 1 > ce;
      }
    return !1;
  }
  function ut(fe, ce, Ee, Te, nt, ct, bt) {
    this.acceptsBooleans = ce === 2 || ce === 3 || ce === 4, this.attributeName = Te, this.attributeNamespace = nt, this.mustUseProperty = Ee, this.propertyName = fe, this.type = ce, this.sanitizeURL = ct, this.removeEmptyString = bt;
  }
  var St = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(fe) {
    St[fe] = new ut(fe, 0, !1, fe, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(fe) {
    var ce = fe[0];
    St[ce] = new ut(ce, 1, !1, fe[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(fe) {
    St[fe] = new ut(fe, 2, !1, fe.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(fe) {
    St[fe] = new ut(fe, 2, !1, fe, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(fe) {
    St[fe] = new ut(fe, 3, !1, fe.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(fe) {
    St[fe] = new ut(fe, 3, !0, fe, null, !1, !1);
  }), ["capture", "download"].forEach(function(fe) {
    St[fe] = new ut(fe, 4, !1, fe, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(fe) {
    St[fe] = new ut(fe, 6, !1, fe, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(fe) {
    St[fe] = new ut(fe, 5, !1, fe.toLowerCase(), null, !1, !1);
  });
  var ot = /[\-:]([a-z])/g;
  function ht(fe) {
    return fe[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(fe) {
    var ce = fe.replace(
      ot,
      ht
    );
    St[ce] = new ut(ce, 1, !1, fe, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(fe) {
    var ce = fe.replace(ot, ht);
    St[ce] = new ut(ce, 1, !1, fe, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(fe) {
    var ce = fe.replace(ot, ht);
    St[ce] = new ut(ce, 1, !1, fe, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(fe) {
    St[fe] = new ut(fe, 1, !1, fe.toLowerCase(), null, !1, !1);
  }), St.xlinkHref = new ut("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(fe) {
    St[fe] = new ut(fe, 1, !1, fe.toLowerCase(), null, !0, !0);
  });
  function ft(fe, ce, Ee, Te) {
    var nt = St.hasOwnProperty(ce) ? St[ce] : null;
    (nt !== null ? nt.type !== 0 : Te || !(2 < ce.length) || ce[0] !== "o" && ce[0] !== "O" || ce[1] !== "n" && ce[1] !== "N") && (it(ce, Ee, nt, Te) && (Ee = null), Te || nt === null ? lt(ce) && (Ee === null ? fe.removeAttribute(ce) : fe.setAttribute(ce, "" + Ee)) : nt.mustUseProperty ? fe[nt.propertyName] = Ee === null ? nt.type === 3 ? !1 : "" : Ee : (ce = nt.attributeName, Te = nt.attributeNamespace, Ee === null ? fe.removeAttribute(ce) : (nt = nt.type, Ee = nt === 3 || nt === 4 && Ee === !0 ? "" : "" + Ee, Te ? fe.setAttributeNS(Te, ce, Ee) : fe.setAttribute(ce, Ee))));
  }
  var vt = L.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ct = Symbol.for("react.element"), xt = Symbol.for("react.portal"), At = Symbol.for("react.fragment"), kt = Symbol.for("react.strict_mode"), Vt = Symbol.for("react.profiler"), ir = Symbol.for("react.provider"), er = Symbol.for("react.context"), Yt = Symbol.for("react.forward_ref"), Jt = Symbol.for("react.suspense"), rr = Symbol.for("react.suspense_list"), Qt = Symbol.for("react.memo"), wt = Symbol.for("react.lazy"), Ft = Symbol.for("react.offscreen"), yt = Symbol.iterator;
  function Et(fe) {
    return fe === null || typeof fe != "object" ? null : (fe = yt && fe[yt] || fe["@@iterator"], typeof fe == "function" ? fe : null);
  }
  var Dt = Object.assign, Ot;
  function nr(fe) {
    if (Ot === void 0)
      try {
        throw Error();
      } catch (Ee) {
        var ce = Ee.stack.trim().match(/\n( *(at )?)/);
        Ot = ce && ce[1] || "";
      }
    return `
` + Ot + fe;
  }
  var vr = !1;
  function pr(fe, ce) {
    if (!fe || vr)
      return "";
    vr = !0;
    var Ee = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (ce)
        if (ce = function() {
          throw Error();
        }, Object.defineProperty(ce.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(ce, []);
          } catch (qt) {
            var Te = qt;
          }
          Reflect.construct(fe, [], ce);
        } else {
          try {
            ce.call();
          } catch (qt) {
            Te = qt;
          }
          fe.call(ce.prototype);
        }
      else {
        try {
          throw Error();
        } catch (qt) {
          Te = qt;
        }
        fe();
      }
    } catch (qt) {
      if (qt && Te && typeof qt.stack == "string") {
        for (var nt = qt.stack.split(`
`), ct = Te.stack.split(`
`), bt = nt.length - 1, Mt = ct.length - 1; 1 <= bt && 0 <= Mt && nt[bt] !== ct[Mt]; )
          Mt--;
        for (; 1 <= bt && 0 <= Mt; bt--, Mt--)
          if (nt[bt] !== ct[Mt]) {
            if (bt !== 1 || Mt !== 1)
              do
                if (bt--, Mt--, 0 > Mt || nt[bt] !== ct[Mt]) {
                  var Lt = `
` + nt[bt].replace(" at new ", " at ");
                  return fe.displayName && Lt.includes("<anonymous>") && (Lt = Lt.replace("<anonymous>", fe.displayName)), Lt;
                }
              while (1 <= bt && 0 <= Mt);
            break;
          }
      }
    } finally {
      vr = !1, Error.prepareStackTrace = Ee;
    }
    return (fe = fe ? fe.displayName || fe.name : "") ? nr(fe) : "";
  }
  function xr(fe) {
    switch (fe.tag) {
      case 5:
        return nr(fe.type);
      case 16:
        return nr("Lazy");
      case 13:
        return nr("Suspense");
      case 19:
        return nr("SuspenseList");
      case 0:
      case 2:
      case 15:
        return fe = pr(fe.type, !1), fe;
      case 11:
        return fe = pr(fe.type.render, !1), fe;
      case 1:
        return fe = pr(fe.type, !0), fe;
      default:
        return "";
    }
  }
  function Ir(fe) {
    if (fe == null)
      return null;
    if (typeof fe == "function")
      return fe.displayName || fe.name || null;
    if (typeof fe == "string")
      return fe;
    switch (fe) {
      case At:
        return "Fragment";
      case xt:
        return "Portal";
      case Vt:
        return "Profiler";
      case kt:
        return "StrictMode";
      case Jt:
        return "Suspense";
      case rr:
        return "SuspenseList";
    }
    if (typeof fe == "object")
      switch (fe.$$typeof) {
        case er:
          return (fe.displayName || "Context") + ".Consumer";
        case ir:
          return (fe._context.displayName || "Context") + ".Provider";
        case Yt:
          var ce = fe.render;
          return fe = fe.displayName, fe || (fe = ce.displayName || ce.name || "", fe = fe !== "" ? "ForwardRef(" + fe + ")" : "ForwardRef"), fe;
        case Qt:
          return ce = fe.displayName || null, ce !== null ? ce : Ir(fe.type) || "Memo";
        case wt:
          ce = fe._payload, fe = fe._init;
          try {
            return Ir(fe(ce));
          } catch {
          }
      }
    return null;
  }
  function fn(fe) {
    var ce = fe.type;
    switch (fe.tag) {
      case 24:
        return "Cache";
      case 9:
        return (ce.displayName || "Context") + ".Consumer";
      case 10:
        return (ce._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return fe = ce.render, fe = fe.displayName || fe.name || "", ce.displayName || (fe !== "" ? "ForwardRef(" + fe + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return ce;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ir(ce);
      case 8:
        return ce === kt ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof ce == "function")
          return ce.displayName || ce.name || null;
        if (typeof ce == "string")
          return ce;
    }
    return null;
  }
  function Zr(fe) {
    switch (typeof fe) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return fe;
      case "object":
        return fe;
      default:
        return "";
    }
  }
  function xn(fe) {
    var ce = fe.type;
    return (fe = fe.nodeName) && fe.toLowerCase() === "input" && (ce === "checkbox" || ce === "radio");
  }
  function kn(fe) {
    var ce = xn(fe) ? "checked" : "value", Ee = Object.getOwnPropertyDescriptor(fe.constructor.prototype, ce), Te = "" + fe[ce];
    if (!fe.hasOwnProperty(ce) && typeof Ee < "u" && typeof Ee.get == "function" && typeof Ee.set == "function") {
      var nt = Ee.get, ct = Ee.set;
      return Object.defineProperty(fe, ce, { configurable: !0, get: function() {
        return nt.call(this);
      }, set: function(bt) {
        Te = "" + bt, ct.call(this, bt);
      } }), Object.defineProperty(fe, ce, { enumerable: Ee.enumerable }), { getValue: function() {
        return Te;
      }, setValue: function(bt) {
        Te = "" + bt;
      }, stopTracking: function() {
        fe._valueTracker = null, delete fe[ce];
      } };
    }
  }
  function Lr(fe) {
    fe._valueTracker || (fe._valueTracker = kn(fe));
  }
  function en(fe) {
    if (!fe)
      return !1;
    var ce = fe._valueTracker;
    if (!ce)
      return !0;
    var Ee = ce.getValue(), Te = "";
    return fe && (Te = xn(fe) ? fe.checked ? "true" : "false" : fe.value), fe = Te, fe !== Ee ? (ce.setValue(fe), !0) : !1;
  }
  function Rr(fe) {
    if (fe = fe || (typeof document < "u" ? document : void 0), typeof fe > "u")
      return null;
    try {
      return fe.activeElement || fe.body;
    } catch {
      return fe.body;
    }
  }
  function cr(fe, ce) {
    var Ee = ce.checked;
    return Dt({}, ce, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: Ee ?? fe._wrapperState.initialChecked });
  }
  function Nn(fe, ce) {
    var Ee = ce.defaultValue == null ? "" : ce.defaultValue, Te = ce.checked != null ? ce.checked : ce.defaultChecked;
    Ee = Zr(ce.value != null ? ce.value : Ee), fe._wrapperState = { initialChecked: Te, initialValue: Ee, controlled: ce.type === "checkbox" || ce.type === "radio" ? ce.checked != null : ce.value != null };
  }
  function Xn(fe, ce) {
    ce = ce.checked, ce != null && ft(fe, "checked", ce, !1);
  }
  function Mn(fe, ce) {
    Xn(fe, ce);
    var Ee = Zr(ce.value), Te = ce.type;
    if (Ee != null)
      Te === "number" ? (Ee === 0 && fe.value === "" || fe.value != Ee) && (fe.value = "" + Ee) : fe.value !== "" + Ee && (fe.value = "" + Ee);
    else if (Te === "submit" || Te === "reset") {
      fe.removeAttribute("value");
      return;
    }
    ce.hasOwnProperty("value") ? Ri(fe, ce.type, Ee) : ce.hasOwnProperty("defaultValue") && Ri(fe, ce.type, Zr(ce.defaultValue)), ce.checked == null && ce.defaultChecked != null && (fe.defaultChecked = !!ce.defaultChecked);
  }
  function Kn(fe, ce, Ee) {
    if (ce.hasOwnProperty("value") || ce.hasOwnProperty("defaultValue")) {
      var Te = ce.type;
      if (!(Te !== "submit" && Te !== "reset" || ce.value !== void 0 && ce.value !== null))
        return;
      ce = "" + fe._wrapperState.initialValue, Ee || ce === fe.value || (fe.value = ce), fe.defaultValue = ce;
    }
    Ee = fe.name, Ee !== "" && (fe.name = ""), fe.defaultChecked = !!fe._wrapperState.initialChecked, Ee !== "" && (fe.name = Ee);
  }
  function Ri(fe, ce, Ee) {
    (ce !== "number" || Rr(fe.ownerDocument) !== fe) && (Ee == null ? fe.defaultValue = "" + fe._wrapperState.initialValue : fe.defaultValue !== "" + Ee && (fe.defaultValue = "" + Ee));
  }
  var Si = Array.isArray;
  function Fn(fe, ce, Ee, Te) {
    if (fe = fe.options, ce) {
      ce = {};
      for (var nt = 0; nt < Ee.length; nt++)
        ce["$" + Ee[nt]] = !0;
      for (Ee = 0; Ee < fe.length; Ee++)
        nt = ce.hasOwnProperty("$" + fe[Ee].value), fe[Ee].selected !== nt && (fe[Ee].selected = nt), nt && Te && (fe[Ee].defaultSelected = !0);
    } else {
      for (Ee = "" + Zr(Ee), ce = null, nt = 0; nt < fe.length; nt++) {
        if (fe[nt].value === Ee) {
          fe[nt].selected = !0, Te && (fe[nt].defaultSelected = !0);
          return;
        }
        ce !== null || fe[nt].disabled || (ce = fe[nt]);
      }
      ce !== null && (ce.selected = !0);
    }
  }
  function ki(fe, ce) {
    if (ce.dangerouslySetInnerHTML != null)
      throw Error(oe(91));
    return Dt({}, ce, { value: void 0, defaultValue: void 0, children: "" + fe._wrapperState.initialValue });
  }
  function Jn(fe, ce) {
    var Ee = ce.value;
    if (Ee == null) {
      if (Ee = ce.children, ce = ce.defaultValue, Ee != null) {
        if (ce != null)
          throw Error(oe(92));
        if (Si(Ee)) {
          if (1 < Ee.length)
            throw Error(oe(93));
          Ee = Ee[0];
        }
        ce = Ee;
      }
      ce == null && (ce = ""), Ee = ce;
    }
    fe._wrapperState = { initialValue: Zr(Ee) };
  }
  function Zn(fe, ce) {
    var Ee = Zr(ce.value), Te = Zr(ce.defaultValue);
    Ee != null && (Ee = "" + Ee, Ee !== fe.value && (fe.value = Ee), ce.defaultValue == null && fe.defaultValue !== Ee && (fe.defaultValue = Ee)), Te != null && (fe.defaultValue = "" + Te);
  }
  function ui(fe) {
    var ce = fe.textContent;
    ce === fe._wrapperState.initialValue && ce !== "" && ce !== null && (fe.value = ce);
  }
  function ei(fe) {
    switch (fe) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Tn(fe, ce) {
    return fe == null || fe === "http://www.w3.org/1999/xhtml" ? ei(ce) : fe === "http://www.w3.org/2000/svg" && ce === "foreignObject" ? "http://www.w3.org/1999/xhtml" : fe;
  }
  var hi, za = function(fe) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(ce, Ee, Te, nt) {
      MSApp.execUnsafeLocalFunction(function() {
        return fe(ce, Ee, Te, nt);
      });
    } : fe;
  }(function(fe, ce) {
    if (fe.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in fe)
      fe.innerHTML = ce;
    else {
      for (hi = hi || document.createElement("div"), hi.innerHTML = "<svg>" + ce.valueOf().toString() + "</svg>", ce = hi.firstChild; fe.firstChild; )
        fe.removeChild(fe.firstChild);
      for (; ce.firstChild; )
        fe.appendChild(ce.firstChild);
    }
  });
  function zn(fe, ce) {
    if (ce) {
      var Ee = fe.firstChild;
      if (Ee && Ee === fe.lastChild && Ee.nodeType === 3) {
        Ee.nodeValue = ce;
        return;
      }
    }
    fe.textContent = ce;
  }
  var mr = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Fr = ["Webkit", "ms", "Moz", "O"];
  Object.keys(mr).forEach(function(fe) {
    Fr.forEach(function(ce) {
      ce = ce + fe.charAt(0).toUpperCase() + fe.substring(1), mr[ce] = mr[fe];
    });
  });
  function Kr(fe, ce, Ee) {
    return ce == null || typeof ce == "boolean" || ce === "" ? "" : Ee || typeof ce != "number" || ce === 0 || mr.hasOwnProperty(fe) && mr[fe] ? ("" + ce).trim() : ce + "px";
  }
  function pn(fe, ce) {
    fe = fe.style;
    for (var Ee in ce)
      if (ce.hasOwnProperty(Ee)) {
        var Te = Ee.indexOf("--") === 0, nt = Kr(Ee, ce[Ee], Te);
        Ee === "float" && (Ee = "cssFloat"), Te ? fe.setProperty(Ee, nt) : fe[Ee] = nt;
      }
  }
  var Rn = Dt({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Ei(fe, ce) {
    if (ce) {
      if (Rn[fe] && (ce.children != null || ce.dangerouslySetInnerHTML != null))
        throw Error(oe(137, fe));
      if (ce.dangerouslySetInnerHTML != null) {
        if (ce.children != null)
          throw Error(oe(60));
        if (typeof ce.dangerouslySetInnerHTML != "object" || !("__html" in ce.dangerouslySetInnerHTML))
          throw Error(oe(61));
      }
      if (ce.style != null && typeof ce.style != "object")
        throw Error(oe(62));
    }
  }
  function ti(fe, ce) {
    if (fe.indexOf("-") === -1)
      return typeof ce.is == "string";
    switch (fe) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Ea = null;
  function mn(fe) {
    return fe = fe.target || fe.srcElement || window, fe.correspondingUseElement && (fe = fe.correspondingUseElement), fe.nodeType === 3 ? fe.parentNode : fe;
  }
  var Va = null, ri = null, Vn = null;
  function ou(fe) {
    if (fe = Mf(fe)) {
      if (typeof Va != "function")
        throw Error(oe(280));
      var ce = fe.stateNode;
      ce && (ce = Or(ce), Va(fe.stateNode, fe.type, ce));
    }
  }
  function Oo(fe) {
    ri ? Vn ? Vn.push(fe) : Vn = [fe] : ri = fe;
  }
  function ks() {
    if (ri) {
      var fe = ri, ce = Vn;
      if (Vn = ri = null, ou(fe), ce)
        for (fe = 0; fe < ce.length; fe++)
          ou(ce[fe]);
    }
  }
  function su(fe, ce) {
    return fe(ce);
  }
  function lu() {
  }
  var Lo = !1;
  function cf(fe, ce, Ee) {
    if (Lo)
      return fe(ce, Ee);
    Lo = !0;
    try {
      return su(fe, ce, Ee);
    } finally {
      Lo = !1, (ri !== null || Vn !== null) && (lu(), ks());
    }
  }
  function dl(fe, ce) {
    var Ee = fe.stateNode;
    if (Ee === null)
      return null;
    var Te = Or(Ee);
    if (Te === null)
      return null;
    Ee = Te[ce];
    e:
      switch (ce) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (Te = !Te.disabled) || (fe = fe.type, Te = !(fe === "button" || fe === "input" || fe === "select" || fe === "textarea")), fe = !Te;
          break e;
        default:
          fe = !1;
      }
    if (fe)
      return null;
    if (Ee && typeof Ee != "function")
      throw Error(oe(231, ce, typeof Ee));
    return Ee;
  }
  var uu = !1;
  if (Ie)
    try {
      var es = {};
      Object.defineProperty(es, "passive", { get: function() {
        uu = !0;
      } }), window.addEventListener("test", es, es), window.removeEventListener("test", es, es);
    } catch {
      uu = !1;
    }
  function Ms(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    var qt = Array.prototype.slice.call(arguments, 3);
    try {
      ce.apply(Ee, qt);
    } catch (sr) {
      this.onError(sr);
    }
  }
  var ba = !1, Ba = null, Ca = !1, hl = null, df = { onError: function(fe) {
    ba = !0, Ba = fe;
  } };
  function hf(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    ba = !1, Ba = null, Ms.apply(df, arguments);
  }
  function Fs(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    if (hf.apply(this, arguments), ba) {
      if (ba) {
        var qt = Ba;
        ba = !1, Ba = null;
      } else
        throw Error(oe(198));
      Ca || (Ca = !0, hl = qt);
    }
  }
  function to(fe) {
    var ce = fe, Ee = fe;
    if (fe.alternate)
      for (; ce.return; )
        ce = ce.return;
    else {
      fe = ce;
      do
        ce = fe, ce.flags & 4098 && (Ee = ce.return), fe = ce.return;
      while (fe);
    }
    return ce.tag === 3 ? Ee : null;
  }
  function oa(fe) {
    if (fe.tag === 13) {
      var ce = fe.memoizedState;
      if (ce === null && (fe = fe.alternate, fe !== null && (ce = fe.memoizedState)), ce !== null)
        return ce.dehydrated;
    }
    return null;
  }
  function Ds(fe) {
    if (to(fe) !== fe)
      throw Error(oe(188));
  }
  function Bi(fe) {
    var ce = fe.alternate;
    if (!ce) {
      if (ce = to(fe), ce === null)
        throw Error(oe(188));
      return ce !== fe ? null : fe;
    }
    for (var Ee = fe, Te = ce; ; ) {
      var nt = Ee.return;
      if (nt === null)
        break;
      var ct = nt.alternate;
      if (ct === null) {
        if (Te = nt.return, Te !== null) {
          Ee = Te;
          continue;
        }
        break;
      }
      if (nt.child === ct.child) {
        for (ct = nt.child; ct; ) {
          if (ct === Ee)
            return Ds(nt), fe;
          if (ct === Te)
            return Ds(nt), ce;
          ct = ct.sibling;
        }
        throw Error(oe(188));
      }
      if (Ee.return !== Te.return)
        Ee = nt, Te = ct;
      else {
        for (var bt = !1, Mt = nt.child; Mt; ) {
          if (Mt === Ee) {
            bt = !0, Ee = nt, Te = ct;
            break;
          }
          if (Mt === Te) {
            bt = !0, Te = nt, Ee = ct;
            break;
          }
          Mt = Mt.sibling;
        }
        if (!bt) {
          for (Mt = ct.child; Mt; ) {
            if (Mt === Ee) {
              bt = !0, Ee = ct, Te = nt;
              break;
            }
            if (Mt === Te) {
              bt = !0, Te = ct, Ee = nt;
              break;
            }
            Mt = Mt.sibling;
          }
          if (!bt)
            throw Error(oe(189));
        }
      }
      if (Ee.alternate !== Te)
        throw Error(oe(190));
    }
    if (Ee.tag !== 3)
      throw Error(oe(188));
    return Ee.stateNode.current === Ee ? fe : ce;
  }
  function gc(fe) {
    return fe = Bi(fe), fe !== null ? Sc(fe) : null;
  }
  function Sc(fe) {
    if (fe.tag === 5 || fe.tag === 6)
      return fe;
    for (fe = fe.child; fe !== null; ) {
      var ce = Sc(fe);
      if (ce !== null)
        return ce;
      fe = fe.sibling;
    }
    return null;
  }
  var pf = ne.unstable_scheduleCallback, $o = ne.unstable_cancelCallback, fh = ne.unstable_shouldYield, ch = ne.unstable_requestPaint, Bn = ne.unstable_now, dh = ne.unstable_getCurrentPriorityLevel, To = ne.unstable_ImmediatePriority, Xr = ne.unstable_UserBlockingPriority, Io = ne.unstable_NormalPriority, Ec = ne.unstable_LowPriority, ro = ne.unstable_IdlePriority, pl = null, Ha = null;
  function bc(fe) {
    if (Ha && typeof Ha.onCommitFiberRoot == "function")
      try {
        Ha.onCommitFiberRoot(pl, fe, void 0, (fe.current.flags & 128) === 128);
      } catch {
      }
  }
  var xa = Math.clz32 ? Math.clz32 : fu, Cc = Math.log, xc = Math.LN2;
  function fu(fe) {
    return fe >>>= 0, fe === 0 ? 32 : 31 - (Cc(fe) / xc | 0) | 0;
  }
  var cu = 64, no = 4194304;
  function No(fe) {
    switch (fe & -fe) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return fe & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return fe & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return fe;
    }
  }
  function Ta(fe, ce) {
    var Ee = fe.pendingLanes;
    if (Ee === 0)
      return 0;
    var Te = 0, nt = fe.suspendedLanes, ct = fe.pingedLanes, bt = Ee & 268435455;
    if (bt !== 0) {
      var Mt = bt & ~nt;
      Mt !== 0 ? Te = No(Mt) : (ct &= bt, ct !== 0 && (Te = No(ct)));
    } else
      bt = Ee & ~nt, bt !== 0 ? Te = No(bt) : ct !== 0 && (Te = No(ct));
    if (Te === 0)
      return 0;
    if (ce !== 0 && ce !== Te && !(ce & nt) && (nt = Te & -Te, ct = ce & -ce, nt >= ct || nt === 16 && (ct & 4194240) !== 0))
      return ce;
    if (Te & 4 && (Te |= Ee & 16), ce = fe.entangledLanes, ce !== 0)
      for (fe = fe.entanglements, ce &= Te; 0 < ce; )
        Ee = 31 - xa(ce), nt = 1 << Ee, Te |= fe[Ee], ce &= ~nt;
    return Te;
  }
  function mf(fe, ce) {
    switch (fe) {
      case 1:
      case 2:
      case 4:
        return ce + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return ce + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function du(fe, ce) {
    for (var Ee = fe.suspendedLanes, Te = fe.pingedLanes, nt = fe.expirationTimes, ct = fe.pendingLanes; 0 < ct; ) {
      var bt = 31 - xa(ct), Mt = 1 << bt, Lt = nt[bt];
      Lt === -1 ? (!(Mt & Ee) || Mt & Te) && (nt[bt] = mf(Mt, ce)) : Lt <= ce && (fe.expiredLanes |= Mt), ct &= ~Mt;
    }
  }
  function vf(fe) {
    return fe = fe.pendingLanes & -1073741825, fe !== 0 ? fe : fe & 1073741824 ? 1073741824 : 0;
  }
  function hu() {
    var fe = cu;
    return cu <<= 1, !(cu & 4194240) && (cu = 64), fe;
  }
  function pu(fe) {
    for (var ce = [], Ee = 0; 31 > Ee; Ee++)
      ce.push(fe);
    return ce;
  }
  function ts(fe, ce, Ee) {
    fe.pendingLanes |= ce, ce !== 536870912 && (fe.suspendedLanes = 0, fe.pingedLanes = 0), fe = fe.eventTimes, ce = 31 - xa(ce), fe[ce] = Ee;
  }
  function hh(fe, ce) {
    var Ee = fe.pendingLanes & ~ce;
    fe.pendingLanes = ce, fe.suspendedLanes = 0, fe.pingedLanes = 0, fe.expiredLanes &= ce, fe.mutableReadLanes &= ce, fe.entangledLanes &= ce, ce = fe.entanglements;
    var Te = fe.eventTimes;
    for (fe = fe.expirationTimes; 0 < Ee; ) {
      var nt = 31 - xa(Ee), ct = 1 << nt;
      ce[nt] = 0, Te[nt] = -1, fe[nt] = -1, Ee &= ~ct;
    }
  }
  function Os(fe, ce) {
    var Ee = fe.entangledLanes |= ce;
    for (fe = fe.entanglements; Ee; ) {
      var Te = 31 - xa(Ee), nt = 1 << Te;
      nt & ce | fe[Te] & ce && (fe[Te] |= ce), Ee &= ~nt;
    }
  }
  var ln = 0;
  function zo(fe) {
    return fe &= -fe, 1 < fe ? 4 < fe ? fe & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Tc, mu, nn, wc, yf, Gr = !1, ml = [], ni = null, pi = null, sa = null, vl = /* @__PURE__ */ new Map(), Hn = /* @__PURE__ */ new Map(), vn = [], gf = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ua(fe, ce) {
    switch (fe) {
      case "focusin":
      case "focusout":
        ni = null;
        break;
      case "dragenter":
      case "dragleave":
        pi = null;
        break;
      case "mouseover":
      case "mouseout":
        sa = null;
        break;
      case "pointerover":
      case "pointerout":
        vl.delete(ce.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Hn.delete(ce.pointerId);
    }
  }
  function bi(fe, ce, Ee, Te, nt, ct) {
    return fe === null || fe.nativeEvent !== ct ? (fe = { blockedOn: ce, domEventName: Ee, eventSystemFlags: Te, nativeEvent: ct, targetContainers: [nt] }, ce !== null && (ce = Mf(ce), ce !== null && mu(ce)), fe) : (fe.eventSystemFlags |= Te, ce = fe.targetContainers, nt !== null && ce.indexOf(nt) === -1 && ce.push(nt), fe);
  }
  function wo(fe, ce, Ee, Te, nt) {
    switch (ce) {
      case "focusin":
        return ni = bi(ni, fe, ce, Ee, Te, nt), !0;
      case "dragenter":
        return pi = bi(pi, fe, ce, Ee, Te, nt), !0;
      case "mouseover":
        return sa = bi(sa, fe, ce, Ee, Te, nt), !0;
      case "pointerover":
        var ct = nt.pointerId;
        return vl.set(ct, bi(vl.get(ct) || null, fe, ce, Ee, Te, nt)), !0;
      case "gotpointercapture":
        return ct = nt.pointerId, Hn.set(ct, bi(Hn.get(ct) || null, fe, ce, Ee, Te, nt)), !0;
    }
    return !1;
  }
  function Sf(fe) {
    var ce = so(fe.target);
    if (ce !== null) {
      var Ee = to(ce);
      if (Ee !== null) {
        if (ce = Ee.tag, ce === 13) {
          if (ce = oa(Ee), ce !== null) {
            fe.blockedOn = ce, yf(fe.priority, function() {
              nn(Ee);
            });
            return;
          }
        } else if (ce === 3 && Ee.stateNode.current.memoizedState.isDehydrated) {
          fe.blockedOn = Ee.tag === 3 ? Ee.stateNode.containerInfo : null;
          return;
        }
      }
    }
    fe.blockedOn = null;
  }
  function io(fe) {
    if (fe.blockedOn !== null)
      return !1;
    for (var ce = fe.targetContainers; 0 < ce.length; ) {
      var Ee = wn(fe.domEventName, fe.eventSystemFlags, ce[0], fe.nativeEvent);
      if (Ee === null) {
        Ee = fe.nativeEvent;
        var Te = new Ee.constructor(Ee.type, Ee);
        Ea = Te, Ee.target.dispatchEvent(Te), Ea = null;
      } else
        return ce = Mf(Ee), ce !== null && mu(ce), fe.blockedOn = Ee, !1;
      ce.shift();
    }
    return !0;
  }
  function vu(fe, ce, Ee) {
    io(fe) && Ee.delete(ce);
  }
  function _c() {
    Gr = !1, ni !== null && io(ni) && (ni = null), pi !== null && io(pi) && (pi = null), sa !== null && io(sa) && (sa = null), vl.forEach(vu), Hn.forEach(vu);
  }
  function yl(fe, ce) {
    fe.blockedOn === ce && (fe.blockedOn = null, Gr || (Gr = !0, ne.unstable_scheduleCallback(ne.unstable_NormalPriority, _c)));
  }
  function gl(fe) {
    function ce(nt) {
      return yl(nt, fe);
    }
    if (0 < ml.length) {
      yl(ml[0], fe);
      for (var Ee = 1; Ee < ml.length; Ee++) {
        var Te = ml[Ee];
        Te.blockedOn === fe && (Te.blockedOn = null);
      }
    }
    for (ni !== null && yl(ni, fe), pi !== null && yl(pi, fe), sa !== null && yl(sa, fe), vl.forEach(ce), Hn.forEach(ce), Ee = 0; Ee < vn.length; Ee++)
      Te = vn[Ee], Te.blockedOn === fe && (Te.blockedOn = null);
    for (; 0 < vn.length && (Ee = vn[0], Ee.blockedOn === null); )
      Sf(Ee), Ee.blockedOn === null && vn.shift();
  }
  var Rt = vt.ReactCurrentBatchConfig, zt = !0;
  function ar(fe, ce, Ee, Te) {
    var nt = ln, ct = Rt.transition;
    Rt.transition = null;
    try {
      ln = 1, yn(fe, ce, Ee, Te);
    } finally {
      ln = nt, Rt.transition = ct;
    }
  }
  function gr(fe, ce, Ee, Te) {
    var nt = ln, ct = Rt.transition;
    Rt.transition = null;
    try {
      ln = 4, yn(fe, ce, Ee, Te);
    } finally {
      ln = nt, Rt.transition = ct;
    }
  }
  function yn(fe, ce, Ee, Te) {
    if (zt) {
      var nt = wn(fe, ce, Ee, Te);
      if (nt === null)
        $c(fe, ce, Te, jr, Ee), Ua(fe, Te);
      else if (wo(nt, fe, ce, Ee, Te))
        Te.stopPropagation();
      else if (Ua(fe, Te), ce & 4 && -1 < gf.indexOf(fe)) {
        for (; nt !== null; ) {
          var ct = Mf(nt);
          if (ct !== null && Tc(ct), ct = wn(fe, ce, Ee, Te), ct === null && $c(fe, ce, Te, jr, Ee), ct === nt)
            break;
          nt = ct;
        }
        nt !== null && Te.stopPropagation();
      } else
        $c(fe, ce, Te, null, Ee);
    }
  }
  var jr = null;
  function wn(fe, ce, Ee, Te) {
    if (jr = null, fe = mn(Te), fe = so(fe), fe !== null)
      if (ce = to(fe), ce === null)
        fe = null;
      else if (Ee = ce.tag, Ee === 13) {
        if (fe = oa(ce), fe !== null)
          return fe;
        fe = null;
      } else if (Ee === 3) {
        if (ce.stateNode.current.memoizedState.isDehydrated)
          return ce.tag === 3 ? ce.stateNode.containerInfo : null;
        fe = null;
      } else
        ce !== fe && (fe = null);
    return jr = fe, null;
  }
  function ii(fe) {
    switch (fe) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (dh()) {
          case To:
            return 1;
          case Xr:
            return 4;
          case Io:
          case Ec:
            return 16;
          case ro:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var _n = null, En = null, Ci = null;
  function la() {
    if (Ci)
      return Ci;
    var fe, ce = En, Ee = ce.length, Te, nt = "value" in _n ? _n.value : _n.textContent, ct = nt.length;
    for (fe = 0; fe < Ee && ce[fe] === nt[fe]; fe++)
      ;
    var bt = Ee - fe;
    for (Te = 1; Te <= bt && ce[Ee - Te] === nt[ct - Te]; Te++)
      ;
    return Ci = nt.slice(fe, 1 < Te ? 1 - Te : void 0);
  }
  function Gn(fe) {
    var ce = fe.keyCode;
    return "charCode" in fe ? (fe = fe.charCode, fe === 0 && ce === 13 && (fe = 13)) : fe = ce, fe === 10 && (fe = 13), 32 <= fe || fe === 13 ? fe : 0;
  }
  function Mi() {
    return !0;
  }
  function ua() {
    return !1;
  }
  function ai(fe) {
    function ce(Ee, Te, nt, ct, bt) {
      this._reactName = Ee, this._targetInst = nt, this.type = Te, this.nativeEvent = ct, this.target = bt, this.currentTarget = null;
      for (var Mt in fe)
        fe.hasOwnProperty(Mt) && (Ee = fe[Mt], this[Mt] = Ee ? Ee(ct) : ct[Mt]);
      return this.isDefaultPrevented = (ct.defaultPrevented != null ? ct.defaultPrevented : ct.returnValue === !1) ? Mi : ua, this.isPropagationStopped = ua, this;
    }
    return Dt(ce.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var Ee = this.nativeEvent;
      Ee && (Ee.preventDefault ? Ee.preventDefault() : typeof Ee.returnValue != "unknown" && (Ee.returnValue = !1), this.isDefaultPrevented = Mi);
    }, stopPropagation: function() {
      var Ee = this.nativeEvent;
      Ee && (Ee.stopPropagation ? Ee.stopPropagation() : typeof Ee.cancelBubble != "unknown" && (Ee.cancelBubble = !0), this.isPropagationStopped = Mi);
    }, persist: function() {
    }, isPersistent: Mi }), ce;
  }
  var Fi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(fe) {
    return fe.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, ao = ai(Fi), rs = Dt({}, Fi, { view: 0, detail: 0 }), Sl = ai(rs), ns, ph, Ef, Di = Dt({}, rs, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: gh, button: 0, buttons: 0, relatedTarget: function(fe) {
    return fe.relatedTarget === void 0 ? fe.fromElement === fe.srcElement ? fe.toElement : fe.fromElement : fe.relatedTarget;
  }, movementX: function(fe) {
    return "movementX" in fe ? fe.movementX : (fe !== Ef && (Ef && fe.type === "mousemove" ? (ns = fe.screenX - Ef.screenX, ph = fe.screenY - Ef.screenY) : ph = ns = 0, Ef = fe), ns);
  }, movementY: function(fe) {
    return "movementY" in fe ? fe.movementY : ph;
  } }), Ac = ai(Di), bm = Dt({}, Di, { dataTransfer: 0 }), Cm = ai(bm), ug = Dt({}, rs, { relatedTarget: 0 }), Ls = ai(ug), mh = Dt({}, Fi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), xm = ai(mh), fg = Dt({}, Fi, { clipboardData: function(fe) {
    return "clipboardData" in fe ? fe.clipboardData : window.clipboardData;
  } }), cg = ai(fg), dg = Dt({}, Fi, { data: 0 }), vh = ai(dg), yh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Tm = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, wm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function _m(fe) {
    var ce = this.nativeEvent;
    return ce.getModifierState ? ce.getModifierState(fe) : (fe = wm[fe]) ? !!ce[fe] : !1;
  }
  function gh() {
    return _m;
  }
  var is = Dt({}, rs, { key: function(fe) {
    if (fe.key) {
      var ce = yh[fe.key] || fe.key;
      if (ce !== "Unidentified")
        return ce;
    }
    return fe.type === "keypress" ? (fe = Gn(fe), fe === 13 ? "Enter" : String.fromCharCode(fe)) : fe.type === "keydown" || fe.type === "keyup" ? Tm[fe.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: gh, charCode: function(fe) {
    return fe.type === "keypress" ? Gn(fe) : 0;
  }, keyCode: function(fe) {
    return fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0;
  }, which: function(fe) {
    return fe.type === "keypress" ? Gn(fe) : fe.type === "keydown" || fe.type === "keyup" ? fe.keyCode : 0;
  } }), hg = ai(is), Sh = Dt({}, Di, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Pc = ai(Sh), Eh = Dt({}, rs, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: gh }), pg = ai(Eh), Rc = Dt({}, Fi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Am = ai(Rc), wa = Dt({}, Di, {
    deltaX: function(fe) {
      return "deltaX" in fe ? fe.deltaX : "wheelDeltaX" in fe ? -fe.wheelDeltaX : 0;
    },
    deltaY: function(fe) {
      return "deltaY" in fe ? fe.deltaY : "wheelDeltaY" in fe ? -fe.wheelDeltaY : "wheelDelta" in fe ? -fe.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), as = ai(wa), mi = [9, 13, 27, 32], _o = Ie && "CompositionEvent" in window, El = null;
  Ie && "documentMode" in document && (El = document.documentMode);
  var kc = Ie && "TextEvent" in window && !El, Pm = Ie && (!_o || El && 8 < El && 11 >= El), yu = " ", Rm = !1;
  function km(fe, ce) {
    switch (fe) {
      case "keyup":
        return mi.indexOf(ce.keyCode) !== -1;
      case "keydown":
        return ce.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Mc(fe) {
    return fe = fe.detail, typeof fe == "object" && "data" in fe ? fe.data : null;
  }
  var gu = !1;
  function mg(fe, ce) {
    switch (fe) {
      case "compositionend":
        return Mc(ce);
      case "keypress":
        return ce.which !== 32 ? null : (Rm = !0, yu);
      case "textInput":
        return fe = ce.data, fe === yu && Rm ? null : fe;
      default:
        return null;
    }
  }
  function vg(fe, ce) {
    if (gu)
      return fe === "compositionend" || !_o && km(fe, ce) ? (fe = la(), Ci = En = _n = null, gu = !1, fe) : null;
    switch (fe) {
      case "paste":
        return null;
      case "keypress":
        if (!(ce.ctrlKey || ce.altKey || ce.metaKey) || ce.ctrlKey && ce.altKey) {
          if (ce.char && 1 < ce.char.length)
            return ce.char;
          if (ce.which)
            return String.fromCharCode(ce.which);
        }
        return null;
      case "compositionend":
        return Pm && ce.locale !== "ko" ? null : ce.data;
      default:
        return null;
    }
  }
  var Mm = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Fm(fe) {
    var ce = fe && fe.nodeName && fe.nodeName.toLowerCase();
    return ce === "input" ? !!Mm[fe.type] : ce === "textarea";
  }
  function Dm(fe, ce, Ee, Te) {
    Oo(Te), ce = Pf(ce, "onChange"), 0 < ce.length && (Ee = new ao("onChange", "change", null, Ee, Te), fe.push({ event: Ee, listeners: ce }));
  }
  var bf = null, Su = null;
  function Eu(fe) {
    Lc(fe, 0);
  }
  function bu(fe) {
    var ce = xu(fe);
    if (en(ce))
      return fe;
  }
  function Om(fe, ce) {
    if (fe === "change")
      return ce;
  }
  var bh = !1;
  if (Ie) {
    var Ch;
    if (Ie) {
      var xh = "oninput" in document;
      if (!xh) {
        var Lm = document.createElement("div");
        Lm.setAttribute("oninput", "return;"), xh = typeof Lm.oninput == "function";
      }
      Ch = xh;
    } else
      Ch = !1;
    bh = Ch && (!document.documentMode || 9 < document.documentMode);
  }
  function $m() {
    bf && (bf.detachEvent("onpropertychange", Im), Su = bf = null);
  }
  function Im(fe) {
    if (fe.propertyName === "value" && bu(Su)) {
      var ce = [];
      Dm(ce, Su, fe, mn(fe)), cf(Eu, ce);
    }
  }
  function yg(fe, ce, Ee) {
    fe === "focusin" ? ($m(), bf = ce, Su = Ee, bf.attachEvent("onpropertychange", Im)) : fe === "focusout" && $m();
  }
  function gg(fe) {
    if (fe === "selectionchange" || fe === "keyup" || fe === "keydown")
      return bu(Su);
  }
  function Sg(fe, ce) {
    if (fe === "click")
      return bu(ce);
  }
  function Nm(fe, ce) {
    if (fe === "input" || fe === "change")
      return bu(ce);
  }
  function Eg(fe, ce) {
    return fe === ce && (fe !== 0 || 1 / fe === 1 / ce) || fe !== fe && ce !== ce;
  }
  var oo = typeof Object.is == "function" ? Object.is : Eg;
  function Cf(fe, ce) {
    if (oo(fe, ce))
      return !0;
    if (typeof fe != "object" || fe === null || typeof ce != "object" || ce === null)
      return !1;
    var Ee = Object.keys(fe), Te = Object.keys(ce);
    if (Ee.length !== Te.length)
      return !1;
    for (Te = 0; Te < Ee.length; Te++) {
      var nt = Ee[Te];
      if (!Ae.call(ce, nt) || !oo(fe[nt], ce[nt]))
        return !1;
    }
    return !0;
  }
  function zm(fe) {
    for (; fe && fe.firstChild; )
      fe = fe.firstChild;
    return fe;
  }
  function Vm(fe, ce) {
    var Ee = zm(fe);
    fe = 0;
    for (var Te; Ee; ) {
      if (Ee.nodeType === 3) {
        if (Te = fe + Ee.textContent.length, fe <= ce && Te >= ce)
          return { node: Ee, offset: ce - fe };
        fe = Te;
      }
      e: {
        for (; Ee; ) {
          if (Ee.nextSibling) {
            Ee = Ee.nextSibling;
            break e;
          }
          Ee = Ee.parentNode;
        }
        Ee = void 0;
      }
      Ee = zm(Ee);
    }
  }
  function Bm(fe, ce) {
    return fe && ce ? fe === ce ? !0 : fe && fe.nodeType === 3 ? !1 : ce && ce.nodeType === 3 ? Bm(fe, ce.parentNode) : "contains" in fe ? fe.contains(ce) : fe.compareDocumentPosition ? !!(fe.compareDocumentPosition(ce) & 16) : !1 : !1;
  }
  function Fc() {
    for (var fe = window, ce = Rr(); ce instanceof fe.HTMLIFrameElement; ) {
      try {
        var Ee = typeof ce.contentWindow.location.href == "string";
      } catch {
        Ee = !1;
      }
      if (Ee)
        fe = ce.contentWindow;
      else
        break;
      ce = Rr(fe.document);
    }
    return ce;
  }
  function os(fe) {
    var ce = fe && fe.nodeName && fe.nodeName.toLowerCase();
    return ce && (ce === "input" && (fe.type === "text" || fe.type === "search" || fe.type === "tel" || fe.type === "url" || fe.type === "password") || ce === "textarea" || fe.contentEditable === "true");
  }
  function Dc(fe) {
    var ce = Fc(), Ee = fe.focusedElem, Te = fe.selectionRange;
    if (ce !== Ee && Ee && Ee.ownerDocument && Bm(Ee.ownerDocument.documentElement, Ee)) {
      if (Te !== null && os(Ee)) {
        if (ce = Te.start, fe = Te.end, fe === void 0 && (fe = ce), "selectionStart" in Ee)
          Ee.selectionStart = ce, Ee.selectionEnd = Math.min(fe, Ee.value.length);
        else if (fe = (ce = Ee.ownerDocument || document) && ce.defaultView || window, fe.getSelection) {
          fe = fe.getSelection();
          var nt = Ee.textContent.length, ct = Math.min(Te.start, nt);
          Te = Te.end === void 0 ? ct : Math.min(Te.end, nt), !fe.extend && ct > Te && (nt = Te, Te = ct, ct = nt), nt = Vm(Ee, ct);
          var bt = Vm(
            Ee,
            Te
          );
          nt && bt && (fe.rangeCount !== 1 || fe.anchorNode !== nt.node || fe.anchorOffset !== nt.offset || fe.focusNode !== bt.node || fe.focusOffset !== bt.offset) && (ce = ce.createRange(), ce.setStart(nt.node, nt.offset), fe.removeAllRanges(), ct > Te ? (fe.addRange(ce), fe.extend(bt.node, bt.offset)) : (ce.setEnd(bt.node, bt.offset), fe.addRange(ce)));
        }
      }
      for (ce = [], fe = Ee; fe = fe.parentNode; )
        fe.nodeType === 1 && ce.push({ element: fe, left: fe.scrollLeft, top: fe.scrollTop });
      for (typeof Ee.focus == "function" && Ee.focus(), Ee = 0; Ee < ce.length; Ee++)
        fe = ce[Ee], fe.element.scrollLeft = fe.left, fe.element.scrollTop = fe.top;
    }
  }
  var Hm = Ie && "documentMode" in document && 11 >= document.documentMode, Ao = null, Th = null, xf = null, wh = !1;
  function Um(fe, ce, Ee) {
    var Te = Ee.window === Ee ? Ee.document : Ee.nodeType === 9 ? Ee : Ee.ownerDocument;
    wh || Ao == null || Ao !== Rr(Te) || (Te = Ao, "selectionStart" in Te && os(Te) ? Te = { start: Te.selectionStart, end: Te.selectionEnd } : (Te = (Te.ownerDocument && Te.ownerDocument.defaultView || window).getSelection(), Te = { anchorNode: Te.anchorNode, anchorOffset: Te.anchorOffset, focusNode: Te.focusNode, focusOffset: Te.focusOffset }), xf && Cf(xf, Te) || (xf = Te, Te = Pf(Th, "onSelect"), 0 < Te.length && (ce = new ao("onSelect", "select", null, ce, Ee), fe.push({ event: ce, listeners: Te }), ce.target = Ao)));
  }
  function Oc(fe, ce) {
    var Ee = {};
    return Ee[fe.toLowerCase()] = ce.toLowerCase(), Ee["Webkit" + fe] = "webkit" + ce, Ee["Moz" + fe] = "moz" + ce, Ee;
  }
  var bl = { animationend: Oc("Animation", "AnimationEnd"), animationiteration: Oc("Animation", "AnimationIteration"), animationstart: Oc("Animation", "AnimationStart"), transitionend: Oc("Transition", "TransitionEnd") }, _h = {}, Ah = {};
  Ie && (Ah = document.createElement("div").style, "AnimationEvent" in window || (delete bl.animationend.animation, delete bl.animationiteration.animation, delete bl.animationstart.animation), "TransitionEvent" in window || delete bl.transitionend.transition);
  function Oi(fe) {
    if (_h[fe])
      return _h[fe];
    if (!bl[fe])
      return fe;
    var ce = bl[fe], Ee;
    for (Ee in ce)
      if (ce.hasOwnProperty(Ee) && Ee in Ah)
        return _h[fe] = ce[Ee];
    return fe;
  }
  var Ph = Oi("animationend"), jm = Oi("animationiteration"), Gm = Oi("animationstart"), Wm = Oi("transitionend"), qm = /* @__PURE__ */ new Map(), Ym = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ss(fe, ce) {
    qm.set(fe, ce), ge(ce, [fe]);
  }
  for (var Tf = 0; Tf < Ym.length; Tf++) {
    var Cl = Ym[Tf], bg = Cl.toLowerCase(), wf = Cl[0].toUpperCase() + Cl.slice(1);
    ss(bg, "on" + wf);
  }
  ss(Ph, "onAnimationEnd"), ss(jm, "onAnimationIteration"), ss(Gm, "onAnimationStart"), ss("dblclick", "onDoubleClick"), ss("focusin", "onFocus"), ss("focusout", "onBlur"), ss(Wm, "onTransitionEnd"), be("onMouseEnter", ["mouseout", "mouseover"]), be("onMouseLeave", ["mouseout", "mouseover"]), be("onPointerEnter", ["pointerout", "pointerover"]), be("onPointerLeave", ["pointerout", "pointerover"]), ge("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ge("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ge("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ge("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ge("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ge("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var _f = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Cg = new Set("cancel close invalid load scroll toggle".split(" ").concat(_f));
  function Qm(fe, ce, Ee) {
    var Te = fe.type || "unknown-event";
    fe.currentTarget = Ee, Fs(Te, ce, void 0, fe), fe.currentTarget = null;
  }
  function Lc(fe, ce) {
    ce = (ce & 4) !== 0;
    for (var Ee = 0; Ee < fe.length; Ee++) {
      var Te = fe[Ee], nt = Te.event;
      Te = Te.listeners;
      e: {
        var ct = void 0;
        if (ce)
          for (var bt = Te.length - 1; 0 <= bt; bt--) {
            var Mt = Te[bt], Lt = Mt.instance, qt = Mt.currentTarget;
            if (Mt = Mt.listener, Lt !== ct && nt.isPropagationStopped())
              break e;
            Qm(nt, Mt, qt), ct = Lt;
          }
        else
          for (bt = 0; bt < Te.length; bt++) {
            if (Mt = Te[bt], Lt = Mt.instance, qt = Mt.currentTarget, Mt = Mt.listener, Lt !== ct && nt.isPropagationStopped())
              break e;
            Qm(nt, Mt, qt), ct = Lt;
          }
      }
    }
    if (Ca)
      throw fe = hl, Ca = !1, hl = null, fe;
  }
  function An(fe, ce) {
    var Ee = ce[Lh];
    Ee === void 0 && (Ee = ce[Lh] = /* @__PURE__ */ new Set());
    var Te = fe + "__bubble";
    Ee.has(Te) || (Xm(ce, fe, 2, !1), Ee.add(Te));
  }
  function $s(fe, ce, Ee) {
    var Te = 0;
    ce && (Te |= 4), Xm(Ee, fe, Te, ce);
  }
  var ls = "_reactListening" + Math.random().toString(36).slice(2);
  function Cu(fe) {
    if (!fe[ls]) {
      fe[ls] = !0, pe.forEach(function(Ee) {
        Ee !== "selectionchange" && (Cg.has(Ee) || $s(Ee, !1, fe), $s(Ee, !0, fe));
      });
      var ce = fe.nodeType === 9 ? fe : fe.ownerDocument;
      ce === null || ce[ls] || (ce[ls] = !0, $s("selectionchange", !1, ce));
    }
  }
  function Xm(fe, ce, Ee, Te) {
    switch (ii(ce)) {
      case 1:
        var nt = ar;
        break;
      case 4:
        nt = gr;
        break;
      default:
        nt = yn;
    }
    Ee = nt.bind(null, ce, Ee, fe), nt = void 0, !uu || ce !== "touchstart" && ce !== "touchmove" && ce !== "wheel" || (nt = !0), Te ? nt !== void 0 ? fe.addEventListener(ce, Ee, { capture: !0, passive: nt }) : fe.addEventListener(ce, Ee, !0) : nt !== void 0 ? fe.addEventListener(ce, Ee, { passive: nt }) : fe.addEventListener(ce, Ee, !1);
  }
  function $c(fe, ce, Ee, Te, nt) {
    var ct = Te;
    if (!(ce & 1) && !(ce & 2) && Te !== null)
      e:
        for (; ; ) {
          if (Te === null)
            return;
          var bt = Te.tag;
          if (bt === 3 || bt === 4) {
            var Mt = Te.stateNode.containerInfo;
            if (Mt === nt || Mt.nodeType === 8 && Mt.parentNode === nt)
              break;
            if (bt === 4)
              for (bt = Te.return; bt !== null; ) {
                var Lt = bt.tag;
                if ((Lt === 3 || Lt === 4) && (Lt = bt.stateNode.containerInfo, Lt === nt || Lt.nodeType === 8 && Lt.parentNode === nt))
                  return;
                bt = bt.return;
              }
            for (; Mt !== null; ) {
              if (bt = so(Mt), bt === null)
                return;
              if (Lt = bt.tag, Lt === 5 || Lt === 6) {
                Te = ct = bt;
                continue e;
              }
              Mt = Mt.parentNode;
            }
          }
          Te = Te.return;
        }
    cf(function() {
      var qt = ct, sr = mn(Ee), lr = [];
      e: {
        var or = qm.get(fe);
        if (or !== void 0) {
          var Sr = ao, wr = fe;
          switch (fe) {
            case "keypress":
              if (Gn(Ee) === 0)
                break e;
            case "keydown":
            case "keyup":
              Sr = hg;
              break;
            case "focusin":
              wr = "focus", Sr = Ls;
              break;
            case "focusout":
              wr = "blur", Sr = Ls;
              break;
            case "beforeblur":
            case "afterblur":
              Sr = Ls;
              break;
            case "click":
              if (Ee.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Sr = Ac;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Sr = Cm;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Sr = pg;
              break;
            case Ph:
            case jm:
            case Gm:
              Sr = xm;
              break;
            case Wm:
              Sr = Am;
              break;
            case "scroll":
              Sr = Sl;
              break;
            case "wheel":
              Sr = as;
              break;
            case "copy":
            case "cut":
            case "paste":
              Sr = cg;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Sr = Pc;
          }
          var Pr = (ce & 4) !== 0, ci = !Pr && fe === "scroll", Bt = Pr ? or !== null ? or + "Capture" : null : or;
          Pr = [];
          for (var It = qt, jt; It !== null; ) {
            jt = It;
            var fr = jt.stateNode;
            if (jt.tag === 5 && fr !== null && (jt = fr, Bt !== null && (fr = dl(It, Bt), fr != null && Pr.push(Af(It, fr, jt)))), ci)
              break;
            It = It.return;
          }
          0 < Pr.length && (or = new Sr(or, wr, null, Ee, sr), lr.push({ event: or, listeners: Pr }));
        }
      }
      if (!(ce & 7)) {
        e: {
          if (or = fe === "mouseover" || fe === "pointerover", Sr = fe === "mouseout" || fe === "pointerout", or && Ee !== Ea && (wr = Ee.relatedTarget || Ee.fromElement) && (so(wr) || wr[us]))
            break e;
          if ((Sr || or) && (or = sr.window === sr ? sr : (or = sr.ownerDocument) ? or.defaultView || or.parentWindow : window, Sr ? (wr = Ee.relatedTarget || Ee.toElement, Sr = qt, wr = wr ? so(wr) : null, wr !== null && (ci = to(wr), wr !== ci || wr.tag !== 5 && wr.tag !== 6) && (wr = null)) : (Sr = null, wr = qt), Sr !== wr)) {
            if (Pr = Ac, fr = "onMouseLeave", Bt = "onMouseEnter", It = "mouse", (fe === "pointerout" || fe === "pointerover") && (Pr = Pc, fr = "onPointerLeave", Bt = "onPointerEnter", It = "pointer"), ci = Sr == null ? or : xu(Sr), jt = wr == null ? or : xu(wr), or = new Pr(fr, It + "leave", Sr, Ee, sr), or.target = ci, or.relatedTarget = jt, fr = null, so(sr) === qt && (Pr = new Pr(Bt, It + "enter", wr, Ee, sr), Pr.target = jt, Pr.relatedTarget = ci, fr = Pr), ci = fr, Sr && wr)
              t: {
                for (Pr = Sr, Bt = wr, It = 0, jt = Pr; jt; jt = xl(jt))
                  It++;
                for (jt = 0, fr = Bt; fr; fr = xl(fr))
                  jt++;
                for (; 0 < It - jt; )
                  Pr = xl(Pr), It--;
                for (; 0 < jt - It; )
                  Bt = xl(Bt), jt--;
                for (; It--; ) {
                  if (Pr === Bt || Bt !== null && Pr === Bt.alternate)
                    break t;
                  Pr = xl(Pr), Bt = xl(Bt);
                }
                Pr = null;
              }
            else
              Pr = null;
            Sr !== null && Rh(lr, or, Sr, Pr, !1), wr !== null && ci !== null && Rh(lr, ci, wr, Pr, !0);
          }
        }
        e: {
          if (or = qt ? xu(qt) : window, Sr = or.nodeName && or.nodeName.toLowerCase(), Sr === "select" || Sr === "input" && or.type === "file")
            var kr = Om;
          else if (Fm(or))
            if (bh)
              kr = Nm;
            else {
              kr = gg;
              var _r = yg;
            }
          else
            (Sr = or.nodeName) && Sr.toLowerCase() === "input" && (or.type === "checkbox" || or.type === "radio") && (kr = Sg);
          if (kr && (kr = kr(fe, qt))) {
            Dm(lr, kr, Ee, sr);
            break e;
          }
          _r && _r(fe, or, qt), fe === "focusout" && (_r = or._wrapperState) && _r.controlled && or.type === "number" && Ri(or, "number", or.value);
        }
        switch (_r = qt ? xu(qt) : window, fe) {
          case "focusin":
            (Fm(_r) || _r.contentEditable === "true") && (Ao = _r, Th = qt, xf = null);
            break;
          case "focusout":
            xf = Th = Ao = null;
            break;
          case "mousedown":
            wh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            wh = !1, Um(lr, Ee, sr);
            break;
          case "selectionchange":
            if (Hm)
              break;
          case "keydown":
          case "keyup":
            Um(lr, Ee, sr);
        }
        var Dr;
        if (_o)
          e: {
            switch (fe) {
              case "compositionstart":
                var Ur = "onCompositionStart";
                break e;
              case "compositionend":
                Ur = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ur = "onCompositionUpdate";
                break e;
            }
            Ur = void 0;
          }
        else
          gu ? km(fe, Ee) && (Ur = "onCompositionEnd") : fe === "keydown" && Ee.keyCode === 229 && (Ur = "onCompositionStart");
        Ur && (Pm && Ee.locale !== "ko" && (gu || Ur !== "onCompositionStart" ? Ur === "onCompositionEnd" && gu && (Dr = la()) : (_n = sr, En = "value" in _n ? _n.value : _n.textContent, gu = !0)), _r = Pf(qt, Ur), 0 < _r.length && (Ur = new vh(Ur, fe, null, Ee, sr), lr.push({ event: Ur, listeners: _r }), Dr ? Ur.data = Dr : (Dr = Mc(Ee), Dr !== null && (Ur.data = Dr)))), (Dr = kc ? mg(fe, Ee) : vg(fe, Ee)) && (qt = Pf(qt, "onBeforeInput"), 0 < qt.length && (sr = new vh("onBeforeInput", "beforeinput", null, Ee, sr), lr.push({ event: sr, listeners: qt }), sr.data = Dr));
      }
      Lc(lr, ce);
    });
  }
  function Af(fe, ce, Ee) {
    return { instance: fe, listener: ce, currentTarget: Ee };
  }
  function Pf(fe, ce) {
    for (var Ee = ce + "Capture", Te = []; fe !== null; ) {
      var nt = fe, ct = nt.stateNode;
      nt.tag === 5 && ct !== null && (nt = ct, ct = dl(fe, Ee), ct != null && Te.unshift(Af(fe, ct, nt)), ct = dl(fe, ce), ct != null && Te.push(Af(fe, ct, nt))), fe = fe.return;
    }
    return Te;
  }
  function xl(fe) {
    if (fe === null)
      return null;
    do
      fe = fe.return;
    while (fe && fe.tag !== 5);
    return fe || null;
  }
  function Rh(fe, ce, Ee, Te, nt) {
    for (var ct = ce._reactName, bt = []; Ee !== null && Ee !== Te; ) {
      var Mt = Ee, Lt = Mt.alternate, qt = Mt.stateNode;
      if (Lt !== null && Lt === Te)
        break;
      Mt.tag === 5 && qt !== null && (Mt = qt, nt ? (Lt = dl(Ee, ct), Lt != null && bt.unshift(Af(Ee, Lt, Mt))) : nt || (Lt = dl(Ee, ct), Lt != null && bt.push(Af(Ee, Lt, Mt)))), Ee = Ee.return;
    }
    bt.length !== 0 && fe.push({ event: ce, listeners: bt });
  }
  var kh = /\r\n?/g, xg = /\u0000|\uFFFD/g;
  function Mh(fe) {
    return (typeof fe == "string" ? fe : "" + fe).replace(kh, `
`).replace(xg, "");
  }
  function Ic(fe, ce, Ee) {
    if (ce = Mh(ce), Mh(fe) !== ce && Ee)
      throw Error(oe(425));
  }
  function Nc() {
  }
  var Fh = null, Tl = null;
  function Rf(fe, ce) {
    return fe === "textarea" || fe === "noscript" || typeof ce.children == "string" || typeof ce.children == "number" || typeof ce.dangerouslySetInnerHTML == "object" && ce.dangerouslySetInnerHTML !== null && ce.dangerouslySetInnerHTML.__html != null;
  }
  var wl = typeof setTimeout == "function" ? setTimeout : void 0, Km = typeof clearTimeout == "function" ? clearTimeout : void 0, Dh = typeof Promise == "function" ? Promise : void 0, Oh = typeof queueMicrotask == "function" ? queueMicrotask : typeof Dh < "u" ? function(fe) {
    return Dh.resolve(null).then(fe).catch(Tg);
  } : wl;
  function Tg(fe) {
    setTimeout(function() {
      throw fe;
    });
  }
  function Is(fe, ce) {
    var Ee = ce, Te = 0;
    do {
      var nt = Ee.nextSibling;
      if (fe.removeChild(Ee), nt && nt.nodeType === 8)
        if (Ee = nt.data, Ee === "/$") {
          if (Te === 0) {
            fe.removeChild(nt), gl(ce);
            return;
          }
          Te--;
        } else
          Ee !== "$" && Ee !== "$?" && Ee !== "$!" || Te++;
      Ee = nt;
    } while (Ee);
    gl(ce);
  }
  function Po(fe) {
    for (; fe != null; fe = fe.nextSibling) {
      var ce = fe.nodeType;
      if (ce === 1 || ce === 3)
        break;
      if (ce === 8) {
        if (ce = fe.data, ce === "$" || ce === "$!" || ce === "$?")
          break;
        if (ce === "/$")
          return null;
      }
    }
    return fe;
  }
  function kf(fe) {
    fe = fe.previousSibling;
    for (var ce = 0; fe; ) {
      if (fe.nodeType === 8) {
        var Ee = fe.data;
        if (Ee === "$" || Ee === "$!" || Ee === "$?") {
          if (ce === 0)
            return fe;
          ce--;
        } else
          Ee === "/$" && ce++;
      }
      fe = fe.previousSibling;
    }
    return null;
  }
  var Ns = Math.random().toString(36).slice(2), Vo = "__reactFiber$" + Ns, _l = "__reactProps$" + Ns, us = "__reactContainer$" + Ns, Lh = "__reactEvents$" + Ns, wg = "__reactListeners$" + Ns, $h = "__reactHandles$" + Ns;
  function so(fe) {
    var ce = fe[Vo];
    if (ce)
      return ce;
    for (var Ee = fe.parentNode; Ee; ) {
      if (ce = Ee[us] || Ee[Vo]) {
        if (Ee = ce.alternate, ce.child !== null || Ee !== null && Ee.child !== null)
          for (fe = kf(fe); fe !== null; ) {
            if (Ee = fe[Vo])
              return Ee;
            fe = kf(fe);
          }
        return ce;
      }
      fe = Ee, Ee = fe.parentNode;
    }
    return null;
  }
  function Mf(fe) {
    return fe = fe[Vo] || fe[us], !fe || fe.tag !== 5 && fe.tag !== 6 && fe.tag !== 13 && fe.tag !== 3 ? null : fe;
  }
  function xu(fe) {
    if (fe.tag === 5 || fe.tag === 6)
      return fe.stateNode;
    throw Error(oe(33));
  }
  function Or(fe) {
    return fe[_l] || null;
  }
  var zs = [], Dn = -1;
  function Yr(fe) {
    return { current: fe };
  }
  function hn(fe) {
    0 > Dn || (fe.current = zs[Dn], zs[Dn] = null, Dn--);
  }
  function gn(fe, ce) {
    Dn++, zs[Dn] = fe.current, fe.current = ce;
  }
  var Bo = {}, Hr = Yr(Bo), oi = Yr(!1), _a = Bo;
  function lo(fe, ce) {
    var Ee = fe.type.contextTypes;
    if (!Ee)
      return Bo;
    var Te = fe.stateNode;
    if (Te && Te.__reactInternalMemoizedUnmaskedChildContext === ce)
      return Te.__reactInternalMemoizedMaskedChildContext;
    var nt = {}, ct;
    for (ct in Ee)
      nt[ct] = ce[ct];
    return Te && (fe = fe.stateNode, fe.__reactInternalMemoizedUnmaskedChildContext = ce, fe.__reactInternalMemoizedMaskedChildContext = nt), nt;
  }
  function Un(fe) {
    return fe = fe.childContextTypes, fe != null;
  }
  function uo() {
    hn(oi), hn(Hr);
  }
  function Vs(fe, ce, Ee) {
    if (Hr.current !== Bo)
      throw Error(oe(168));
    gn(Hr, ce), gn(oi, Ee);
  }
  function Ff(fe, ce, Ee) {
    var Te = fe.stateNode;
    if (ce = ce.childContextTypes, typeof Te.getChildContext != "function")
      return Ee;
    Te = Te.getChildContext();
    for (var nt in Te)
      if (!(nt in ce))
        throw Error(oe(108, fn(fe) || "Unknown", nt));
    return Dt({}, Ee, Te);
  }
  function zc(fe) {
    return fe = (fe = fe.stateNode) && fe.__reactInternalMemoizedMergedChildContext || Bo, _a = Hr.current, gn(Hr, fe), gn(oi, oi.current), !0;
  }
  function Jm(fe, ce, Ee) {
    var Te = fe.stateNode;
    if (!Te)
      throw Error(oe(169));
    Ee ? (fe = Ff(fe, ce, _a), Te.__reactInternalMemoizedMergedChildContext = fe, hn(oi), hn(Hr), gn(Hr, fe)) : hn(oi), gn(oi, Ee);
  }
  var ja = null, Li = !1, Df = !1;
  function Ih(fe) {
    ja === null ? ja = [fe] : ja.push(fe);
  }
  function Nh(fe) {
    Li = !0, Ih(fe);
  }
  function Aa() {
    if (!Df && ja !== null) {
      Df = !0;
      var fe = 0, ce = ln;
      try {
        var Ee = ja;
        for (ln = 1; fe < Ee.length; fe++) {
          var Te = Ee[fe];
          do
            Te = Te(!0);
          while (Te !== null);
        }
        ja = null, Li = !1;
      } catch (nt) {
        throw ja !== null && (ja = ja.slice(fe + 1)), pf(To, Aa), nt;
      } finally {
        ln = ce, Df = !1;
      }
    }
    return null;
  }
  var Bs = [], Pa = 0, Al = null, Tu = 0, Ra = [], Zi = 0, fo = null, Hi = 1, fs = "";
  function Ga(fe, ce) {
    Bs[Pa++] = Tu, Bs[Pa++] = Al, Al = fe, Tu = ce;
  }
  function zh(fe, ce, Ee) {
    Ra[Zi++] = Hi, Ra[Zi++] = fs, Ra[Zi++] = fo, fo = fe;
    var Te = Hi;
    fe = fs;
    var nt = 32 - xa(Te) - 1;
    Te &= ~(1 << nt), Ee += 1;
    var ct = 32 - xa(ce) + nt;
    if (30 < ct) {
      var bt = nt - nt % 5;
      ct = (Te & (1 << bt) - 1).toString(32), Te >>= bt, nt -= bt, Hi = 1 << 32 - xa(ce) + nt | Ee << nt | Te, fs = ct + fe;
    } else
      Hi = 1 << ct | Ee << nt | Te, fs = fe;
  }
  function Vc(fe) {
    fe.return !== null && (Ga(fe, 1), zh(fe, 1, 0));
  }
  function Vh(fe) {
    for (; fe === Al; )
      Al = Bs[--Pa], Bs[Pa] = null, Tu = Bs[--Pa], Bs[Pa] = null;
    for (; fe === fo; )
      fo = Ra[--Zi], Ra[Zi] = null, fs = Ra[--Zi], Ra[Zi] = null, Hi = Ra[--Zi], Ra[Zi] = null;
  }
  var Wa = null, ka = null, On = !1, co = null;
  function Bh(fe, ce) {
    var Ee = go(5, null, null, 0);
    Ee.elementType = "DELETED", Ee.stateNode = ce, Ee.return = fe, ce = fe.deletions, ce === null ? (fe.deletions = [Ee], fe.flags |= 16) : ce.push(Ee);
  }
  function Zm(fe, ce) {
    switch (fe.tag) {
      case 5:
        var Ee = fe.type;
        return ce = ce.nodeType !== 1 || Ee.toLowerCase() !== ce.nodeName.toLowerCase() ? null : ce, ce !== null ? (fe.stateNode = ce, Wa = fe, ka = Po(ce.firstChild), !0) : !1;
      case 6:
        return ce = fe.pendingProps === "" || ce.nodeType !== 3 ? null : ce, ce !== null ? (fe.stateNode = ce, Wa = fe, ka = null, !0) : !1;
      case 13:
        return ce = ce.nodeType !== 8 ? null : ce, ce !== null ? (Ee = fo !== null ? { id: Hi, overflow: fs } : null, fe.memoizedState = { dehydrated: ce, treeContext: Ee, retryLane: 1073741824 }, Ee = go(18, null, null, 0), Ee.stateNode = ce, Ee.return = fe, fe.child = Ee, Wa = fe, ka = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Bc(fe) {
    return (fe.mode & 1) !== 0 && (fe.flags & 128) === 0;
  }
  function Hc(fe) {
    if (On) {
      var ce = ka;
      if (ce) {
        var Ee = ce;
        if (!Zm(fe, ce)) {
          if (Bc(fe))
            throw Error(oe(418));
          ce = Po(Ee.nextSibling);
          var Te = Wa;
          ce && Zm(fe, ce) ? Bh(Te, Ee) : (fe.flags = fe.flags & -4097 | 2, On = !1, Wa = fe);
        }
      } else {
        if (Bc(fe))
          throw Error(oe(418));
        fe.flags = fe.flags & -4097 | 2, On = !1, Wa = fe;
      }
    }
  }
  function ev(fe) {
    for (fe = fe.return; fe !== null && fe.tag !== 5 && fe.tag !== 3 && fe.tag !== 13; )
      fe = fe.return;
    Wa = fe;
  }
  function Uc(fe) {
    if (fe !== Wa)
      return !1;
    if (!On)
      return ev(fe), On = !0, !1;
    var ce;
    if ((ce = fe.tag !== 3) && !(ce = fe.tag !== 5) && (ce = fe.type, ce = ce !== "head" && ce !== "body" && !Rf(fe.type, fe.memoizedProps)), ce && (ce = ka)) {
      if (Bc(fe))
        throw tv(), Error(oe(418));
      for (; ce; )
        Bh(fe, ce), ce = Po(ce.nextSibling);
    }
    if (ev(fe), fe.tag === 13) {
      if (fe = fe.memoizedState, fe = fe !== null ? fe.dehydrated : null, !fe)
        throw Error(oe(317));
      e: {
        for (fe = fe.nextSibling, ce = 0; fe; ) {
          if (fe.nodeType === 8) {
            var Ee = fe.data;
            if (Ee === "/$") {
              if (ce === 0) {
                ka = Po(fe.nextSibling);
                break e;
              }
              ce--;
            } else
              Ee !== "$" && Ee !== "$!" && Ee !== "$?" || ce++;
          }
          fe = fe.nextSibling;
        }
        ka = null;
      }
    } else
      ka = Wa ? Po(fe.stateNode.nextSibling) : null;
    return !0;
  }
  function tv() {
    for (var fe = ka; fe; )
      fe = Po(fe.nextSibling);
  }
  function Wn() {
    ka = Wa = null, On = !1;
  }
  function Hh(fe) {
    co === null ? co = [fe] : co.push(fe);
  }
  var jc = vt.ReactCurrentBatchConfig;
  function qa(fe, ce) {
    if (fe && fe.defaultProps) {
      ce = Dt({}, ce), fe = fe.defaultProps;
      for (var Ee in fe)
        ce[Ee] === void 0 && (ce[Ee] = fe[Ee]);
      return ce;
    }
    return ce;
  }
  var Ho = Yr(null), Gc = null, Hs = null, Uh = null;
  function jh() {
    Uh = Hs = Gc = null;
  }
  function Us(fe) {
    var ce = Ho.current;
    hn(Ho), fe._currentValue = ce;
  }
  function $i(fe, ce, Ee) {
    for (; fe !== null; ) {
      var Te = fe.alternate;
      if ((fe.childLanes & ce) !== ce ? (fe.childLanes |= ce, Te !== null && (Te.childLanes |= ce)) : Te !== null && (Te.childLanes & ce) !== ce && (Te.childLanes |= ce), fe === Ee)
        break;
      fe = fe.return;
    }
  }
  function dr(fe, ce) {
    Gc = fe, Uh = Hs = null, fe = fe.dependencies, fe !== null && fe.firstContext !== null && (fe.lanes & ce && (vi = !0), fe.firstContext = null);
  }
  function fi(fe) {
    var ce = fe._currentValue;
    if (Uh !== fe)
      if (fe = { context: fe, memoizedValue: ce, next: null }, Hs === null) {
        if (Gc === null)
          throw Error(oe(308));
        Hs = fe, Gc.dependencies = { lanes: 0, firstContext: fe };
      } else
        Hs = Hs.next = fe;
    return ce;
  }
  var Ui = null;
  function Gh(fe) {
    Ui === null ? Ui = [fe] : Ui.push(fe);
  }
  function rv(fe, ce, Ee, Te) {
    var nt = ce.interleaved;
    return nt === null ? (Ee.next = Ee, Gh(ce)) : (Ee.next = nt.next, nt.next = Ee), ce.interleaved = Ee, cs(fe, Te);
  }
  function cs(fe, ce) {
    fe.lanes |= ce;
    var Ee = fe.alternate;
    for (Ee !== null && (Ee.lanes |= ce), Ee = fe, fe = fe.return; fe !== null; )
      fe.childLanes |= ce, Ee = fe.alternate, Ee !== null && (Ee.childLanes |= ce), Ee = fe, fe = fe.return;
    return Ee.tag === 3 ? Ee.stateNode : null;
  }
  var js = !1;
  function Wh(fe) {
    fe.updateQueue = { baseState: fe.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function xi(fe, ce) {
    fe = fe.updateQueue, ce.updateQueue === fe && (ce.updateQueue = { baseState: fe.baseState, firstBaseUpdate: fe.firstBaseUpdate, lastBaseUpdate: fe.lastBaseUpdate, shared: fe.shared, effects: fe.effects });
  }
  function ds(fe, ce) {
    return { eventTime: fe, lane: ce, tag: 0, payload: null, callback: null, next: null };
  }
  function Gs(fe, ce, Ee) {
    var Te = fe.updateQueue;
    if (Te === null)
      return null;
    if (Te = Te.shared, tn & 2) {
      var nt = Te.pending;
      return nt === null ? ce.next = ce : (ce.next = nt.next, nt.next = ce), Te.pending = ce, cs(fe, Ee);
    }
    return nt = Te.interleaved, nt === null ? (ce.next = ce, Gh(Te)) : (ce.next = nt.next, nt.next = ce), Te.interleaved = ce, cs(fe, Ee);
  }
  function Wc(fe, ce, Ee) {
    if (ce = ce.updateQueue, ce !== null && (ce = ce.shared, (Ee & 4194240) !== 0)) {
      var Te = ce.lanes;
      Te &= fe.pendingLanes, Ee |= Te, ce.lanes = Ee, Os(fe, Ee);
    }
  }
  function qh(fe, ce) {
    var Ee = fe.updateQueue, Te = fe.alternate;
    if (Te !== null && (Te = Te.updateQueue, Ee === Te)) {
      var nt = null, ct = null;
      if (Ee = Ee.firstBaseUpdate, Ee !== null) {
        do {
          var bt = { eventTime: Ee.eventTime, lane: Ee.lane, tag: Ee.tag, payload: Ee.payload, callback: Ee.callback, next: null };
          ct === null ? nt = ct = bt : ct = ct.next = bt, Ee = Ee.next;
        } while (Ee !== null);
        ct === null ? nt = ct = ce : ct = ct.next = ce;
      } else
        nt = ct = ce;
      Ee = { baseState: Te.baseState, firstBaseUpdate: nt, lastBaseUpdate: ct, shared: Te.shared, effects: Te.effects }, fe.updateQueue = Ee;
      return;
    }
    fe = Ee.lastBaseUpdate, fe === null ? Ee.firstBaseUpdate = ce : fe.next = ce, Ee.lastBaseUpdate = ce;
  }
  function Ws(fe, ce, Ee, Te) {
    var nt = fe.updateQueue;
    js = !1;
    var ct = nt.firstBaseUpdate, bt = nt.lastBaseUpdate, Mt = nt.shared.pending;
    if (Mt !== null) {
      nt.shared.pending = null;
      var Lt = Mt, qt = Lt.next;
      Lt.next = null, bt === null ? ct = qt : bt.next = qt, bt = Lt;
      var sr = fe.alternate;
      sr !== null && (sr = sr.updateQueue, Mt = sr.lastBaseUpdate, Mt !== bt && (Mt === null ? sr.firstBaseUpdate = qt : Mt.next = qt, sr.lastBaseUpdate = Lt));
    }
    if (ct !== null) {
      var lr = nt.baseState;
      bt = 0, sr = qt = Lt = null, Mt = ct;
      do {
        var or = Mt.lane, Sr = Mt.eventTime;
        if ((Te & or) === or) {
          sr !== null && (sr = sr.next = {
            eventTime: Sr,
            lane: 0,
            tag: Mt.tag,
            payload: Mt.payload,
            callback: Mt.callback,
            next: null
          });
          e: {
            var wr = fe, Pr = Mt;
            switch (or = ce, Sr = Ee, Pr.tag) {
              case 1:
                if (wr = Pr.payload, typeof wr == "function") {
                  lr = wr.call(Sr, lr, or);
                  break e;
                }
                lr = wr;
                break e;
              case 3:
                wr.flags = wr.flags & -65537 | 128;
              case 0:
                if (wr = Pr.payload, or = typeof wr == "function" ? wr.call(Sr, lr, or) : wr, or == null)
                  break e;
                lr = Dt({}, lr, or);
                break e;
              case 2:
                js = !0;
            }
          }
          Mt.callback !== null && Mt.lane !== 0 && (fe.flags |= 64, or = nt.effects, or === null ? nt.effects = [Mt] : or.push(Mt));
        } else
          Sr = { eventTime: Sr, lane: or, tag: Mt.tag, payload: Mt.payload, callback: Mt.callback, next: null }, sr === null ? (qt = sr = Sr, Lt = lr) : sr = sr.next = Sr, bt |= or;
        if (Mt = Mt.next, Mt === null) {
          if (Mt = nt.shared.pending, Mt === null)
            break;
          or = Mt, Mt = or.next, or.next = null, nt.lastBaseUpdate = or, nt.shared.pending = null;
        }
      } while (!0);
      if (sr === null && (Lt = lr), nt.baseState = Lt, nt.firstBaseUpdate = qt, nt.lastBaseUpdate = sr, ce = nt.shared.interleaved, ce !== null) {
        nt = ce;
        do
          bt |= nt.lane, nt = nt.next;
        while (nt !== ce);
      } else
        ct === null && (nt.shared.lanes = 0);
      vs |= bt, fe.lanes = bt, fe.memoizedState = lr;
    }
  }
  function Pl(fe, ce, Ee) {
    if (fe = ce.effects, ce.effects = null, fe !== null)
      for (ce = 0; ce < fe.length; ce++) {
        var Te = fe[ce], nt = Te.callback;
        if (nt !== null) {
          if (Te.callback = null, Te = Ee, typeof nt != "function")
            throw Error(oe(191, nt));
          nt.call(Te);
        }
      }
  }
  var nv = new L.Component().refs;
  function Yh(fe, ce, Ee, Te) {
    ce = fe.memoizedState, Ee = Ee(Te, ce), Ee = Ee == null ? ce : Dt({}, ce, Ee), fe.memoizedState = Ee, fe.lanes === 0 && (fe.updateQueue.baseState = Ee);
  }
  var qc = { isMounted: function(fe) {
    return (fe = fe._reactInternals) ? to(fe) === fe : !1;
  }, enqueueSetState: function(fe, ce, Ee) {
    fe = fe._reactInternals;
    var Te = na(), nt = yi(fe), ct = ds(Te, nt);
    ct.payload = ce, Ee != null && (ct.callback = Ee), ce = Gs(fe, ct, nt), ce !== null && (ia(ce, fe, nt, Te), Wc(ce, fe, nt));
  }, enqueueReplaceState: function(fe, ce, Ee) {
    fe = fe._reactInternals;
    var Te = na(), nt = yi(fe), ct = ds(Te, nt);
    ct.tag = 1, ct.payload = ce, Ee != null && (ct.callback = Ee), ce = Gs(fe, ct, nt), ce !== null && (ia(ce, fe, nt, Te), Wc(ce, fe, nt));
  }, enqueueForceUpdate: function(fe, ce) {
    fe = fe._reactInternals;
    var Ee = na(), Te = yi(fe), nt = ds(Ee, Te);
    nt.tag = 2, ce != null && (nt.callback = ce), ce = Gs(fe, nt, Te), ce !== null && (ia(ce, fe, Te, Ee), Wc(ce, fe, Te));
  } };
  function iv(fe, ce, Ee, Te, nt, ct, bt) {
    return fe = fe.stateNode, typeof fe.shouldComponentUpdate == "function" ? fe.shouldComponentUpdate(Te, ct, bt) : ce.prototype && ce.prototype.isPureReactComponent ? !Cf(Ee, Te) || !Cf(nt, ct) : !0;
  }
  function av(fe, ce, Ee) {
    var Te = !1, nt = Bo, ct = ce.contextType;
    return typeof ct == "object" && ct !== null ? ct = fi(ct) : (nt = Un(ce) ? _a : Hr.current, Te = ce.contextTypes, ct = (Te = Te != null) ? lo(fe, nt) : Bo), ce = new ce(Ee, ct), fe.memoizedState = ce.state !== null && ce.state !== void 0 ? ce.state : null, ce.updater = qc, fe.stateNode = ce, ce._reactInternals = fe, Te && (fe = fe.stateNode, fe.__reactInternalMemoizedUnmaskedChildContext = nt, fe.__reactInternalMemoizedMaskedChildContext = ct), ce;
  }
  function ov(fe, ce, Ee, Te) {
    fe = ce.state, typeof ce.componentWillReceiveProps == "function" && ce.componentWillReceiveProps(Ee, Te), typeof ce.UNSAFE_componentWillReceiveProps == "function" && ce.UNSAFE_componentWillReceiveProps(Ee, Te), ce.state !== fe && qc.enqueueReplaceState(ce, ce.state, null);
  }
  function Yc(fe, ce, Ee, Te) {
    var nt = fe.stateNode;
    nt.props = Ee, nt.state = fe.memoizedState, nt.refs = nv, Wh(fe);
    var ct = ce.contextType;
    typeof ct == "object" && ct !== null ? nt.context = fi(ct) : (ct = Un(ce) ? _a : Hr.current, nt.context = lo(fe, ct)), nt.state = fe.memoizedState, ct = ce.getDerivedStateFromProps, typeof ct == "function" && (Yh(fe, ce, ct, Ee), nt.state = fe.memoizedState), typeof ce.getDerivedStateFromProps == "function" || typeof nt.getSnapshotBeforeUpdate == "function" || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || (ce = nt.state, typeof nt.componentWillMount == "function" && nt.componentWillMount(), typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount(), ce !== nt.state && qc.enqueueReplaceState(nt, nt.state, null), Ws(fe, Ee, nt, Te), nt.state = fe.memoizedState), typeof nt.componentDidMount == "function" && (fe.flags |= 4194308);
  }
  function wu(fe, ce, Ee) {
    if (fe = Ee.ref, fe !== null && typeof fe != "function" && typeof fe != "object") {
      if (Ee._owner) {
        if (Ee = Ee._owner, Ee) {
          if (Ee.tag !== 1)
            throw Error(oe(309));
          var Te = Ee.stateNode;
        }
        if (!Te)
          throw Error(oe(147, fe));
        var nt = Te, ct = "" + fe;
        return ce !== null && ce.ref !== null && typeof ce.ref == "function" && ce.ref._stringRef === ct ? ce.ref : (ce = function(bt) {
          var Mt = nt.refs;
          Mt === nv && (Mt = nt.refs = {}), bt === null ? delete Mt[ct] : Mt[ct] = bt;
        }, ce._stringRef = ct, ce);
      }
      if (typeof fe != "string")
        throw Error(oe(284));
      if (!Ee._owner)
        throw Error(oe(290, fe));
    }
    return fe;
  }
  function Qc(fe, ce) {
    throw fe = Object.prototype.toString.call(ce), Error(oe(31, fe === "[object Object]" ? "object with keys {" + Object.keys(ce).join(", ") + "}" : fe));
  }
  function sv(fe) {
    var ce = fe._init;
    return ce(fe._payload);
  }
  function lv(fe) {
    function ce(Bt, It) {
      if (fe) {
        var jt = Bt.deletions;
        jt === null ? (Bt.deletions = [It], Bt.flags |= 16) : jt.push(It);
      }
    }
    function Ee(Bt, It) {
      if (!fe)
        return null;
      for (; It !== null; )
        ce(Bt, It), It = It.sibling;
      return null;
    }
    function Te(Bt, It) {
      for (Bt = /* @__PURE__ */ new Map(); It !== null; )
        It.key !== null ? Bt.set(It.key, It) : Bt.set(It.index, It), It = It.sibling;
      return Bt;
    }
    function nt(Bt, It) {
      return Bt = el(Bt, It), Bt.index = 0, Bt.sibling = null, Bt;
    }
    function ct(Bt, It, jt) {
      return Bt.index = jt, fe ? (jt = Bt.alternate, jt !== null ? (jt = jt.index, jt < It ? (Bt.flags |= 2, It) : jt) : (Bt.flags |= 2, It)) : (Bt.flags |= 1048576, It);
    }
    function bt(Bt) {
      return fe && Bt.alternate === null && (Bt.flags |= 2), Bt;
    }
    function Mt(Bt, It, jt, fr) {
      return It === null || It.tag !== 6 ? (It = Jf(jt, Bt.mode, fr), It.return = Bt, It) : (It = nt(It, jt), It.return = Bt, It);
    }
    function Lt(Bt, It, jt, fr) {
      var kr = jt.type;
      return kr === At ? sr(Bt, It, jt.props.children, fr, jt.key) : It !== null && (It.elementType === kr || typeof kr == "object" && kr !== null && kr.$$typeof === wt && sv(kr) === It.type) ? (fr = nt(It, jt.props), fr.ref = wu(Bt, It, jt), fr.return = Bt, fr) : (fr = Ad(jt.type, jt.key, jt.props, null, Bt.mode, fr), fr.ref = wu(Bt, It, jt), fr.return = Bt, fr);
    }
    function qt(Bt, It, jt, fr) {
      return It === null || It.tag !== 4 || It.stateNode.containerInfo !== jt.containerInfo || It.stateNode.implementation !== jt.implementation ? (It = ql(jt, Bt.mode, fr), It.return = Bt, It) : (It = nt(It, jt.children || []), It.return = Bt, It);
    }
    function sr(Bt, It, jt, fr, kr) {
      return It === null || It.tag !== 7 ? (It = Wl(jt, Bt.mode, fr, kr), It.return = Bt, It) : (It = nt(It, jt), It.return = Bt, It);
    }
    function lr(Bt, It, jt) {
      if (typeof It == "string" && It !== "" || typeof It == "number")
        return It = Jf("" + It, Bt.mode, jt), It.return = Bt, It;
      if (typeof It == "object" && It !== null) {
        switch (It.$$typeof) {
          case Ct:
            return jt = Ad(It.type, It.key, It.props, null, Bt.mode, jt), jt.ref = wu(Bt, null, It), jt.return = Bt, jt;
          case xt:
            return It = ql(It, Bt.mode, jt), It.return = Bt, It;
          case wt:
            var fr = It._init;
            return lr(Bt, fr(It._payload), jt);
        }
        if (Si(It) || Et(It))
          return It = Wl(It, Bt.mode, jt, null), It.return = Bt, It;
        Qc(Bt, It);
      }
      return null;
    }
    function or(Bt, It, jt, fr) {
      var kr = It !== null ? It.key : null;
      if (typeof jt == "string" && jt !== "" || typeof jt == "number")
        return kr !== null ? null : Mt(Bt, It, "" + jt, fr);
      if (typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case Ct:
            return jt.key === kr ? Lt(Bt, It, jt, fr) : null;
          case xt:
            return jt.key === kr ? qt(Bt, It, jt, fr) : null;
          case wt:
            return kr = jt._init, or(
              Bt,
              It,
              kr(jt._payload),
              fr
            );
        }
        if (Si(jt) || Et(jt))
          return kr !== null ? null : sr(Bt, It, jt, fr, null);
        Qc(Bt, jt);
      }
      return null;
    }
    function Sr(Bt, It, jt, fr, kr) {
      if (typeof fr == "string" && fr !== "" || typeof fr == "number")
        return Bt = Bt.get(jt) || null, Mt(It, Bt, "" + fr, kr);
      if (typeof fr == "object" && fr !== null) {
        switch (fr.$$typeof) {
          case Ct:
            return Bt = Bt.get(fr.key === null ? jt : fr.key) || null, Lt(It, Bt, fr, kr);
          case xt:
            return Bt = Bt.get(fr.key === null ? jt : fr.key) || null, qt(It, Bt, fr, kr);
          case wt:
            var _r = fr._init;
            return Sr(Bt, It, jt, _r(fr._payload), kr);
        }
        if (Si(fr) || Et(fr))
          return Bt = Bt.get(jt) || null, sr(It, Bt, fr, kr, null);
        Qc(It, fr);
      }
      return null;
    }
    function wr(Bt, It, jt, fr) {
      for (var kr = null, _r = null, Dr = It, Ur = It = 0, zi = null; Dr !== null && Ur < jt.length; Ur++) {
        Dr.index > Ur ? (zi = Dr, Dr = null) : zi = Dr.sibling;
        var un = or(Bt, Dr, jt[Ur], fr);
        if (un === null) {
          Dr === null && (Dr = zi);
          break;
        }
        fe && Dr && un.alternate === null && ce(Bt, Dr), It = ct(un, It, Ur), _r === null ? kr = un : _r.sibling = un, _r = un, Dr = zi;
      }
      if (Ur === jt.length)
        return Ee(Bt, Dr), On && Ga(Bt, Ur), kr;
      if (Dr === null) {
        for (; Ur < jt.length; Ur++)
          Dr = lr(Bt, jt[Ur], fr), Dr !== null && (It = ct(Dr, It, Ur), _r === null ? kr = Dr : _r.sibling = Dr, _r = Dr);
        return On && Ga(Bt, Ur), kr;
      }
      for (Dr = Te(Bt, Dr); Ur < jt.length; Ur++)
        zi = Sr(Dr, Bt, Ur, jt[Ur], fr), zi !== null && (fe && zi.alternate !== null && Dr.delete(zi.key === null ? Ur : zi.key), It = ct(zi, It, Ur), _r === null ? kr = zi : _r.sibling = zi, _r = zi);
      return fe && Dr.forEach(function(tl) {
        return ce(Bt, tl);
      }), On && Ga(Bt, Ur), kr;
    }
    function Pr(Bt, It, jt, fr) {
      var kr = Et(jt);
      if (typeof kr != "function")
        throw Error(oe(150));
      if (jt = kr.call(jt), jt == null)
        throw Error(oe(151));
      for (var _r = kr = null, Dr = It, Ur = It = 0, zi = null, un = jt.next(); Dr !== null && !un.done; Ur++, un = jt.next()) {
        Dr.index > Ur ? (zi = Dr, Dr = null) : zi = Dr.sibling;
        var tl = or(Bt, Dr, un.value, fr);
        if (tl === null) {
          Dr === null && (Dr = zi);
          break;
        }
        fe && Dr && tl.alternate === null && ce(Bt, Dr), It = ct(tl, It, Ur), _r === null ? kr = tl : _r.sibling = tl, _r = tl, Dr = zi;
      }
      if (un.done)
        return Ee(
          Bt,
          Dr
        ), On && Ga(Bt, Ur), kr;
      if (Dr === null) {
        for (; !un.done; Ur++, un = jt.next())
          un = lr(Bt, un.value, fr), un !== null && (It = ct(un, It, Ur), _r === null ? kr = un : _r.sibling = un, _r = un);
        return On && Ga(Bt, Ur), kr;
      }
      for (Dr = Te(Bt, Dr); !un.done; Ur++, un = jt.next())
        un = Sr(Dr, Bt, Ur, un.value, fr), un !== null && (fe && un.alternate !== null && Dr.delete(un.key === null ? Ur : un.key), It = ct(un, It, Ur), _r === null ? kr = un : _r.sibling = un, _r = un);
      return fe && Dr.forEach(function(Gg) {
        return ce(Bt, Gg);
      }), On && Ga(Bt, Ur), kr;
    }
    function ci(Bt, It, jt, fr) {
      if (typeof jt == "object" && jt !== null && jt.type === At && jt.key === null && (jt = jt.props.children), typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case Ct:
            e: {
              for (var kr = jt.key, _r = It; _r !== null; ) {
                if (_r.key === kr) {
                  if (kr = jt.type, kr === At) {
                    if (_r.tag === 7) {
                      Ee(Bt, _r.sibling), It = nt(_r, jt.props.children), It.return = Bt, Bt = It;
                      break e;
                    }
                  } else if (_r.elementType === kr || typeof kr == "object" && kr !== null && kr.$$typeof === wt && sv(kr) === _r.type) {
                    Ee(Bt, _r.sibling), It = nt(_r, jt.props), It.ref = wu(Bt, _r, jt), It.return = Bt, Bt = It;
                    break e;
                  }
                  Ee(Bt, _r);
                  break;
                } else
                  ce(Bt, _r);
                _r = _r.sibling;
              }
              jt.type === At ? (It = Wl(jt.props.children, Bt.mode, fr, jt.key), It.return = Bt, Bt = It) : (fr = Ad(jt.type, jt.key, jt.props, null, Bt.mode, fr), fr.ref = wu(Bt, It, jt), fr.return = Bt, Bt = fr);
            }
            return bt(Bt);
          case xt:
            e: {
              for (_r = jt.key; It !== null; ) {
                if (It.key === _r)
                  if (It.tag === 4 && It.stateNode.containerInfo === jt.containerInfo && It.stateNode.implementation === jt.implementation) {
                    Ee(Bt, It.sibling), It = nt(It, jt.children || []), It.return = Bt, Bt = It;
                    break e;
                  } else {
                    Ee(Bt, It);
                    break;
                  }
                else
                  ce(Bt, It);
                It = It.sibling;
              }
              It = ql(jt, Bt.mode, fr), It.return = Bt, Bt = It;
            }
            return bt(Bt);
          case wt:
            return _r = jt._init, ci(Bt, It, _r(jt._payload), fr);
        }
        if (Si(jt))
          return wr(Bt, It, jt, fr);
        if (Et(jt))
          return Pr(Bt, It, jt, fr);
        Qc(Bt, jt);
      }
      return typeof jt == "string" && jt !== "" || typeof jt == "number" ? (jt = "" + jt, It !== null && It.tag === 6 ? (Ee(Bt, It.sibling), It = nt(It, jt), It.return = Bt, Bt = It) : (Ee(Bt, It), It = Jf(jt, Bt.mode, fr), It.return = Bt, Bt = It), bt(Bt)) : Ee(Bt, It);
    }
    return ci;
  }
  var _u = lv(!0), uv = lv(!1), Of = {}, Ro = Yr(Of), Lf = Yr(Of), Au = Yr(Of);
  function Rl(fe) {
    if (fe === Of)
      throw Error(oe(174));
    return fe;
  }
  function Qh(fe, ce) {
    switch (gn(Au, ce), gn(Lf, fe), gn(Ro, Of), fe = ce.nodeType, fe) {
      case 9:
      case 11:
        ce = (ce = ce.documentElement) ? ce.namespaceURI : Tn(null, "");
        break;
      default:
        fe = fe === 8 ? ce.parentNode : ce, ce = fe.namespaceURI || null, fe = fe.tagName, ce = Tn(ce, fe);
    }
    hn(Ro), gn(Ro, ce);
  }
  function qs() {
    hn(Ro), hn(Lf), hn(Au);
  }
  function Nr(fe) {
    Rl(Au.current);
    var ce = Rl(Ro.current), Ee = Tn(ce, fe.type);
    ce !== Ee && (gn(Lf, fe), gn(Ro, Ee));
  }
  function Jr(fe) {
    Lf.current === fe && (hn(Ro), hn(Lf));
  }
  var zr = Yr(0);
  function qn(fe) {
    for (var ce = fe; ce !== null; ) {
      if (ce.tag === 13) {
        var Ee = ce.memoizedState;
        if (Ee !== null && (Ee = Ee.dehydrated, Ee === null || Ee.data === "$?" || Ee.data === "$!"))
          return ce;
      } else if (ce.tag === 19 && ce.memoizedProps.revealOrder !== void 0) {
        if (ce.flags & 128)
          return ce;
      } else if (ce.child !== null) {
        ce.child.return = ce, ce = ce.child;
        continue;
      }
      if (ce === fe)
        break;
      for (; ce.sibling === null; ) {
        if (ce.return === null || ce.return === fe)
          return null;
        ce = ce.return;
      }
      ce.sibling.return = ce.return, ce = ce.sibling;
    }
    return null;
  }
  var ho = [];
  function Xc() {
    for (var fe = 0; fe < ho.length; fe++)
      ho[fe]._workInProgressVersionPrimary = null;
    ho.length = 0;
  }
  var Kc = vt.ReactCurrentDispatcher, Xh = vt.ReactCurrentBatchConfig, kl = 0, Ln = null, Zt = null, an = null, Vr = !1, Uo = !1, Ya = 0, Ml = 0;
  function $n() {
    throw Error(oe(321));
  }
  function Fl(fe, ce) {
    if (ce === null)
      return !1;
    for (var Ee = 0; Ee < ce.length && Ee < fe.length; Ee++)
      if (!oo(fe[Ee], ce[Ee]))
        return !1;
    return !0;
  }
  function Ys(fe, ce, Ee, Te, nt, ct) {
    if (kl = ct, Ln = ce, ce.memoizedState = null, ce.updateQueue = null, ce.lanes = 0, Kc.current = fe === null || fe.memoizedState === null ? Ag : Pg, fe = Ee(Te, nt), Uo) {
      ct = 0;
      do {
        if (Uo = !1, Ya = 0, 25 <= ct)
          throw Error(oe(301));
        ct += 1, an = Zt = null, ce.updateQueue = null, Kc.current = Jh, fe = Ee(Te, nt);
      } while (Uo);
    }
    if (Kc.current = hd, ce = Zt !== null && Zt.next !== null, kl = 0, an = Zt = Ln = null, Vr = !1, ce)
      throw Error(oe(300));
    return fe;
  }
  function Dl() {
    var fe = Ya !== 0;
    return Ya = 0, fe;
  }
  function po() {
    var fe = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return an === null ? Ln.memoizedState = an = fe : an = an.next = fe, an;
  }
  function Ma() {
    if (Zt === null) {
      var fe = Ln.alternate;
      fe = fe !== null ? fe.memoizedState : null;
    } else
      fe = Zt.next;
    var ce = an === null ? Ln.memoizedState : an.next;
    if (ce !== null)
      an = ce, Zt = fe;
    else {
      if (fe === null)
        throw Error(oe(310));
      Zt = fe, fe = { memoizedState: Zt.memoizedState, baseState: Zt.baseState, baseQueue: Zt.baseQueue, queue: Zt.queue, next: null }, an === null ? Ln.memoizedState = an = fe : an = an.next = fe;
    }
    return an;
  }
  function Ol(fe, ce) {
    return typeof ce == "function" ? ce(fe) : ce;
  }
  function $f(fe) {
    var ce = Ma(), Ee = ce.queue;
    if (Ee === null)
      throw Error(oe(311));
    Ee.lastRenderedReducer = fe;
    var Te = Zt, nt = Te.baseQueue, ct = Ee.pending;
    if (ct !== null) {
      if (nt !== null) {
        var bt = nt.next;
        nt.next = ct.next, ct.next = bt;
      }
      Te.baseQueue = nt = ct, Ee.pending = null;
    }
    if (nt !== null) {
      ct = nt.next, Te = Te.baseState;
      var Mt = bt = null, Lt = null, qt = ct;
      do {
        var sr = qt.lane;
        if ((kl & sr) === sr)
          Lt !== null && (Lt = Lt.next = { lane: 0, action: qt.action, hasEagerState: qt.hasEagerState, eagerState: qt.eagerState, next: null }), Te = qt.hasEagerState ? qt.eagerState : fe(Te, qt.action);
        else {
          var lr = {
            lane: sr,
            action: qt.action,
            hasEagerState: qt.hasEagerState,
            eagerState: qt.eagerState,
            next: null
          };
          Lt === null ? (Mt = Lt = lr, bt = Te) : Lt = Lt.next = lr, Ln.lanes |= sr, vs |= sr;
        }
        qt = qt.next;
      } while (qt !== null && qt !== ct);
      Lt === null ? bt = Te : Lt.next = Mt, oo(Te, ce.memoizedState) || (vi = !0), ce.memoizedState = Te, ce.baseState = bt, ce.baseQueue = Lt, Ee.lastRenderedState = Te;
    }
    if (fe = Ee.interleaved, fe !== null) {
      nt = fe;
      do
        ct = nt.lane, Ln.lanes |= ct, vs |= ct, nt = nt.next;
      while (nt !== fe);
    } else
      nt === null && (Ee.lanes = 0);
    return [ce.memoizedState, Ee.dispatch];
  }
  function If(fe) {
    var ce = Ma(), Ee = ce.queue;
    if (Ee === null)
      throw Error(oe(311));
    Ee.lastRenderedReducer = fe;
    var Te = Ee.dispatch, nt = Ee.pending, ct = ce.memoizedState;
    if (nt !== null) {
      Ee.pending = null;
      var bt = nt = nt.next;
      do
        ct = fe(ct, bt.action), bt = bt.next;
      while (bt !== nt);
      oo(ct, ce.memoizedState) || (vi = !0), ce.memoizedState = ct, ce.baseQueue === null && (ce.baseState = ct), Ee.lastRenderedState = ct;
    }
    return [ct, Te];
  }
  function Jc() {
  }
  function Zc(fe, ce) {
    var Ee = Ln, Te = Ma(), nt = ce(), ct = !oo(Te.memoizedState, nt);
    if (ct && (Te.memoizedState = nt, vi = !0), Te = Te.queue, Nf(rd.bind(null, Ee, Te, fe), [fe]), Te.getSnapshot !== ce || ct || an !== null && an.memoizedState.tag & 1) {
      if (Ee.flags |= 2048, Ll(9, td.bind(null, Ee, Te, nt, ce), void 0, null), Yn === null)
        throw Error(oe(349));
      kl & 30 || ed(Ee, ce, nt);
    }
    return nt;
  }
  function ed(fe, ce, Ee) {
    fe.flags |= 16384, fe = { getSnapshot: ce, value: Ee }, ce = Ln.updateQueue, ce === null ? (ce = { lastEffect: null, stores: null }, Ln.updateQueue = ce, ce.stores = [fe]) : (Ee = ce.stores, Ee === null ? ce.stores = [fe] : Ee.push(fe));
  }
  function td(fe, ce, Ee, Te) {
    ce.value = Ee, ce.getSnapshot = Te, nd(ce) && id(fe);
  }
  function rd(fe, ce, Ee) {
    return Ee(function() {
      nd(ce) && id(fe);
    });
  }
  function nd(fe) {
    var ce = fe.getSnapshot;
    fe = fe.value;
    try {
      var Ee = ce();
      return !oo(fe, Ee);
    } catch {
      return !0;
    }
  }
  function id(fe) {
    var ce = cs(fe, 1);
    ce !== null && ia(ce, fe, 1, -1);
  }
  function ad(fe) {
    var ce = po();
    return typeof fe == "function" && (fe = fe()), ce.memoizedState = ce.baseState = fe, fe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ol, lastRenderedState: fe }, ce.queue = fe, fe = fe.dispatch = dd.bind(null, Ln, fe), [ce.memoizedState, fe];
  }
  function Ll(fe, ce, Ee, Te) {
    return fe = { tag: fe, create: ce, destroy: Ee, deps: Te, next: null }, ce = Ln.updateQueue, ce === null ? (ce = { lastEffect: null, stores: null }, Ln.updateQueue = ce, ce.lastEffect = fe.next = fe) : (Ee = ce.lastEffect, Ee === null ? ce.lastEffect = fe.next = fe : (Te = Ee.next, Ee.next = fe, fe.next = Te, ce.lastEffect = fe)), fe;
  }
  function od() {
    return Ma().memoizedState;
  }
  function $l(fe, ce, Ee, Te) {
    var nt = po();
    Ln.flags |= fe, nt.memoizedState = Ll(1 | ce, Ee, void 0, Te === void 0 ? null : Te);
  }
  function hs(fe, ce, Ee, Te) {
    var nt = Ma();
    Te = Te === void 0 ? null : Te;
    var ct = void 0;
    if (Zt !== null) {
      var bt = Zt.memoizedState;
      if (ct = bt.destroy, Te !== null && Fl(Te, bt.deps)) {
        nt.memoizedState = Ll(ce, Ee, ct, Te);
        return;
      }
    }
    Ln.flags |= fe, nt.memoizedState = Ll(1 | ce, Ee, ct, Te);
  }
  function sd(fe, ce) {
    return $l(8390656, 8, fe, ce);
  }
  function Nf(fe, ce) {
    return hs(2048, 8, fe, ce);
  }
  function ld(fe, ce) {
    return hs(4, 2, fe, ce);
  }
  function ud(fe, ce) {
    return hs(4, 4, fe, ce);
  }
  function Kh(fe, ce) {
    if (typeof ce == "function")
      return fe = fe(), ce(fe), function() {
        ce(null);
      };
    if (ce != null)
      return fe = fe(), ce.current = fe, function() {
        ce.current = null;
      };
  }
  function Pu(fe, ce, Ee) {
    return Ee = Ee != null ? Ee.concat([fe]) : null, hs(4, 4, Kh.bind(null, ce, fe), Ee);
  }
  function fd() {
  }
  function Ru(fe, ce) {
    var Ee = Ma();
    ce = ce === void 0 ? null : ce;
    var Te = Ee.memoizedState;
    return Te !== null && ce !== null && Fl(ce, Te[1]) ? Te[0] : (Ee.memoizedState = [fe, ce], fe);
  }
  function Qs(fe, ce) {
    var Ee = Ma();
    ce = ce === void 0 ? null : ce;
    var Te = Ee.memoizedState;
    return Te !== null && ce !== null && Fl(ce, Te[1]) ? Te[0] : (fe = fe(), Ee.memoizedState = [fe, ce], fe);
  }
  function Fa(fe, ce, Ee) {
    return kl & 21 ? (oo(Ee, ce) || (Ee = hu(), Ln.lanes |= Ee, vs |= Ee, fe.baseState = !0), ce) : (fe.baseState && (fe.baseState = !1, vi = !0), fe.memoizedState = Ee);
  }
  function _g(fe, ce) {
    var Ee = ln;
    ln = Ee !== 0 && 4 > Ee ? Ee : 4, fe(!0);
    var Te = Xh.transition;
    Xh.transition = {};
    try {
      fe(!1), ce();
    } finally {
      ln = Ee, Xh.transition = Te;
    }
  }
  function Pn() {
    return Ma().memoizedState;
  }
  function cd(fe, ce, Ee) {
    var Te = yi(fe);
    if (Ee = { lane: Te, action: Ee, hasEagerState: !1, eagerState: null, next: null }, ku(fe))
      zf(ce, Ee);
    else if (Ee = rv(fe, ce, Ee, Te), Ee !== null) {
      var nt = na();
      ia(Ee, fe, Te, nt), fv(Ee, ce, Te);
    }
  }
  function dd(fe, ce, Ee) {
    var Te = yi(fe), nt = { lane: Te, action: Ee, hasEagerState: !1, eagerState: null, next: null };
    if (ku(fe))
      zf(ce, nt);
    else {
      var ct = fe.alternate;
      if (fe.lanes === 0 && (ct === null || ct.lanes === 0) && (ct = ce.lastRenderedReducer, ct !== null))
        try {
          var bt = ce.lastRenderedState, Mt = ct(bt, Ee);
          if (nt.hasEagerState = !0, nt.eagerState = Mt, oo(Mt, bt)) {
            var Lt = ce.interleaved;
            Lt === null ? (nt.next = nt, Gh(ce)) : (nt.next = Lt.next, Lt.next = nt), ce.interleaved = nt;
            return;
          }
        } catch {
        } finally {
        }
      Ee = rv(fe, ce, nt, Te), Ee !== null && (nt = na(), ia(Ee, fe, Te, nt), fv(Ee, ce, Te));
    }
  }
  function ku(fe) {
    var ce = fe.alternate;
    return fe === Ln || ce !== null && ce === Ln;
  }
  function zf(fe, ce) {
    Uo = Vr = !0;
    var Ee = fe.pending;
    Ee === null ? ce.next = ce : (ce.next = Ee.next, Ee.next = ce), fe.pending = ce;
  }
  function fv(fe, ce, Ee) {
    if (Ee & 4194240) {
      var Te = ce.lanes;
      Te &= fe.pendingLanes, Ee |= Te, ce.lanes = Ee, Os(fe, Ee);
    }
  }
  var hd = { readContext: fi, useCallback: $n, useContext: $n, useEffect: $n, useImperativeHandle: $n, useInsertionEffect: $n, useLayoutEffect: $n, useMemo: $n, useReducer: $n, useRef: $n, useState: $n, useDebugValue: $n, useDeferredValue: $n, useTransition: $n, useMutableSource: $n, useSyncExternalStore: $n, useId: $n, unstable_isNewReconciler: !1 }, Ag = { readContext: fi, useCallback: function(fe, ce) {
    return po().memoizedState = [fe, ce === void 0 ? null : ce], fe;
  }, useContext: fi, useEffect: sd, useImperativeHandle: function(fe, ce, Ee) {
    return Ee = Ee != null ? Ee.concat([fe]) : null, $l(
      4194308,
      4,
      Kh.bind(null, ce, fe),
      Ee
    );
  }, useLayoutEffect: function(fe, ce) {
    return $l(4194308, 4, fe, ce);
  }, useInsertionEffect: function(fe, ce) {
    return $l(4, 2, fe, ce);
  }, useMemo: function(fe, ce) {
    var Ee = po();
    return ce = ce === void 0 ? null : ce, fe = fe(), Ee.memoizedState = [fe, ce], fe;
  }, useReducer: function(fe, ce, Ee) {
    var Te = po();
    return ce = Ee !== void 0 ? Ee(ce) : ce, Te.memoizedState = Te.baseState = ce, fe = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: fe, lastRenderedState: ce }, Te.queue = fe, fe = fe.dispatch = cd.bind(null, Ln, fe), [Te.memoizedState, fe];
  }, useRef: function(fe) {
    var ce = po();
    return fe = { current: fe }, ce.memoizedState = fe;
  }, useState: ad, useDebugValue: fd, useDeferredValue: function(fe) {
    return po().memoizedState = fe;
  }, useTransition: function() {
    var fe = ad(!1), ce = fe[0];
    return fe = _g.bind(null, fe[1]), po().memoizedState = fe, [ce, fe];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(fe, ce, Ee) {
    var Te = Ln, nt = po();
    if (On) {
      if (Ee === void 0)
        throw Error(oe(407));
      Ee = Ee();
    } else {
      if (Ee = ce(), Yn === null)
        throw Error(oe(349));
      kl & 30 || ed(Te, ce, Ee);
    }
    nt.memoizedState = Ee;
    var ct = { value: Ee, getSnapshot: ce };
    return nt.queue = ct, sd(rd.bind(
      null,
      Te,
      ct,
      fe
    ), [fe]), Te.flags |= 2048, Ll(9, td.bind(null, Te, ct, Ee, ce), void 0, null), Ee;
  }, useId: function() {
    var fe = po(), ce = Yn.identifierPrefix;
    if (On) {
      var Ee = fs, Te = Hi;
      Ee = (Te & ~(1 << 32 - xa(Te) - 1)).toString(32) + Ee, ce = ":" + ce + "R" + Ee, Ee = Ya++, 0 < Ee && (ce += "H" + Ee.toString(32)), ce += ":";
    } else
      Ee = Ml++, ce = ":" + ce + "r" + Ee.toString(32) + ":";
    return fe.memoizedState = ce;
  }, unstable_isNewReconciler: !1 }, Pg = {
    readContext: fi,
    useCallback: Ru,
    useContext: fi,
    useEffect: Nf,
    useImperativeHandle: Pu,
    useInsertionEffect: ld,
    useLayoutEffect: ud,
    useMemo: Qs,
    useReducer: $f,
    useRef: od,
    useState: function() {
      return $f(Ol);
    },
    useDebugValue: fd,
    useDeferredValue: function(fe) {
      var ce = Ma();
      return Fa(ce, Zt.memoizedState, fe);
    },
    useTransition: function() {
      var fe = $f(Ol)[0], ce = Ma().memoizedState;
      return [fe, ce];
    },
    useMutableSource: Jc,
    useSyncExternalStore: Zc,
    useId: Pn,
    unstable_isNewReconciler: !1
  }, Jh = { readContext: fi, useCallback: Ru, useContext: fi, useEffect: Nf, useImperativeHandle: Pu, useInsertionEffect: ld, useLayoutEffect: ud, useMemo: Qs, useReducer: If, useRef: od, useState: function() {
    return If(Ol);
  }, useDebugValue: fd, useDeferredValue: function(fe) {
    var ce = Ma();
    return Zt === null ? ce.memoizedState = fe : Fa(ce, Zt.memoizedState, fe);
  }, useTransition: function() {
    var fe = If(Ol)[0], ce = Ma().memoizedState;
    return [fe, ce];
  }, useMutableSource: Jc, useSyncExternalStore: Zc, useId: Pn, unstable_isNewReconciler: !1 };
  function Mu(fe, ce) {
    try {
      var Ee = "", Te = ce;
      do
        Ee += xr(Te), Te = Te.return;
      while (Te);
      var nt = Ee;
    } catch (ct) {
      nt = `
Error generating stack: ` + ct.message + `
` + ct.stack;
    }
    return { value: fe, source: ce, stack: nt, digest: null };
  }
  function Vf(fe, ce, Ee) {
    return { value: fe, source: null, stack: Ee ?? null, digest: ce ?? null };
  }
  function pd(fe, ce) {
    try {
      console.error(ce.value);
    } catch (Ee) {
      setTimeout(function() {
        throw Ee;
      });
    }
  }
  var Rg = typeof WeakMap == "function" ? WeakMap : Map;
  function cv(fe, ce, Ee) {
    Ee = ds(-1, Ee), Ee.tag = 3, Ee.payload = { element: null };
    var Te = ce.value;
    return Ee.callback = function() {
      bd || (bd = !0, Bl = Te), pd(fe, ce);
    }, Ee;
  }
  function Bf(fe, ce, Ee) {
    Ee = ds(-1, Ee), Ee.tag = 3;
    var Te = fe.type.getDerivedStateFromError;
    if (typeof Te == "function") {
      var nt = ce.value;
      Ee.payload = function() {
        return Te(nt);
      }, Ee.callback = function() {
        pd(fe, ce);
      };
    }
    var ct = fe.stateNode;
    return ct !== null && typeof ct.componentDidCatch == "function" && (Ee.callback = function() {
      pd(fe, ce), typeof Te != "function" && (Wo === null ? Wo = /* @__PURE__ */ new Set([this]) : Wo.add(this));
      var bt = ce.stack;
      this.componentDidCatch(ce.value, { componentStack: bt !== null ? bt : "" });
    }), Ee;
  }
  function dv(fe, ce, Ee) {
    var Te = fe.pingCache;
    if (Te === null) {
      Te = fe.pingCache = new Rg();
      var nt = /* @__PURE__ */ new Set();
      Te.set(ce, nt);
    } else
      nt = Te.get(ce), nt === void 0 && (nt = /* @__PURE__ */ new Set(), Te.set(ce, nt));
    nt.has(Ee) || (nt.add(Ee), fe = $g.bind(null, fe, ce, Ee), ce.then(fe, fe));
  }
  function Zh(fe) {
    do {
      var ce;
      if ((ce = fe.tag === 13) && (ce = fe.memoizedState, ce = ce !== null ? ce.dehydrated !== null : !0), ce)
        return fe;
      fe = fe.return;
    } while (fe !== null);
    return null;
  }
  function ep(fe, ce, Ee, Te, nt) {
    return fe.mode & 1 ? (fe.flags |= 65536, fe.lanes = nt, fe) : (fe === ce ? fe.flags |= 65536 : (fe.flags |= 128, Ee.flags |= 131072, Ee.flags &= -52805, Ee.tag === 1 && (Ee.alternate === null ? Ee.tag = 17 : (ce = ds(-1, 1), ce.tag = 2, Gs(Ee, ce, 1))), Ee.lanes |= 1), fe);
  }
  var kg = vt.ReactCurrentOwner, vi = !1;
  function Ti(fe, ce, Ee, Te) {
    ce.child = fe === null ? uv(ce, null, Ee, Te) : _u(ce, fe.child, Ee, Te);
  }
  function Xs(fe, ce, Ee, Te, nt) {
    Ee = Ee.render;
    var ct = ce.ref;
    return dr(ce, nt), Te = Ys(fe, ce, Ee, Te, ct, nt), Ee = Dl(), fe !== null && !vi ? (ce.updateQueue = fe.updateQueue, ce.flags &= -2053, fe.lanes &= ~nt, ji(fe, ce, nt)) : (On && Ee && Vc(ce), ce.flags |= 1, Ti(fe, ce, Te, nt), ce.child);
  }
  function md(fe, ce, Ee, Te, nt) {
    if (fe === null) {
      var ct = Ee.type;
      return typeof ct == "function" && !Sp(ct) && ct.defaultProps === void 0 && Ee.compare === null && Ee.defaultProps === void 0 ? (ce.tag = 15, ce.type = ct, Da(fe, ce, ct, Te, nt)) : (fe = Ad(Ee.type, null, Te, ce, ce.mode, nt), fe.ref = ce.ref, fe.return = ce, ce.child = fe);
    }
    if (ct = fe.child, !(fe.lanes & nt)) {
      var bt = ct.memoizedProps;
      if (Ee = Ee.compare, Ee = Ee !== null ? Ee : Cf, Ee(bt, Te) && fe.ref === ce.ref)
        return ji(fe, ce, nt);
    }
    return ce.flags |= 1, fe = el(ct, Te), fe.ref = ce.ref, fe.return = ce, ce.child = fe;
  }
  function Da(fe, ce, Ee, Te, nt) {
    if (fe !== null) {
      var ct = fe.memoizedProps;
      if (Cf(ct, Te) && fe.ref === ce.ref)
        if (vi = !1, ce.pendingProps = Te = ct, (fe.lanes & nt) !== 0)
          fe.flags & 131072 && (vi = !0);
        else
          return ce.lanes = fe.lanes, ji(fe, ce, nt);
    }
    return Fu(fe, ce, Ee, Te, nt);
  }
  function Il(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = Te.children, ct = fe !== null ? fe.memoizedState : null;
    if (Te.mode === "hidden")
      if (!(ce.mode & 1))
        ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, gn(Nu, Qa), Qa |= Ee;
      else {
        if (!(Ee & 1073741824))
          return fe = ct !== null ? ct.baseLanes | Ee : Ee, ce.lanes = ce.childLanes = 1073741824, ce.memoizedState = { baseLanes: fe, cachePool: null, transitions: null }, ce.updateQueue = null, gn(Nu, Qa), Qa |= fe, null;
        ce.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Te = ct !== null ? ct.baseLanes : Ee, gn(Nu, Qa), Qa |= Te;
      }
    else
      ct !== null ? (Te = ct.baseLanes | Ee, ce.memoizedState = null) : Te = Ee, gn(Nu, Qa), Qa |= Te;
    return Ti(fe, ce, nt, Ee), ce.child;
  }
  function Qr(fe, ce) {
    var Ee = ce.ref;
    (fe === null && Ee !== null || fe !== null && fe.ref !== Ee) && (ce.flags |= 512, ce.flags |= 2097152);
  }
  function Fu(fe, ce, Ee, Te, nt) {
    var ct = Un(Ee) ? _a : Hr.current;
    return ct = lo(ce, ct), dr(ce, nt), Ee = Ys(fe, ce, Ee, Te, ct, nt), Te = Dl(), fe !== null && !vi ? (ce.updateQueue = fe.updateQueue, ce.flags &= -2053, fe.lanes &= ~nt, ji(fe, ce, nt)) : (On && Te && Vc(ce), ce.flags |= 1, Ti(fe, ce, Ee, nt), ce.child);
  }
  function tp(fe, ce, Ee, Te, nt) {
    if (Un(Ee)) {
      var ct = !0;
      zc(ce);
    } else
      ct = !1;
    if (dr(ce, nt), ce.stateNode === null)
      ea(fe, ce), av(ce, Ee, Te), Yc(ce, Ee, Te, nt), Te = !0;
    else if (fe === null) {
      var bt = ce.stateNode, Mt = ce.memoizedProps;
      bt.props = Mt;
      var Lt = bt.context, qt = Ee.contextType;
      typeof qt == "object" && qt !== null ? qt = fi(qt) : (qt = Un(Ee) ? _a : Hr.current, qt = lo(ce, qt));
      var sr = Ee.getDerivedStateFromProps, lr = typeof sr == "function" || typeof bt.getSnapshotBeforeUpdate == "function";
      lr || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (Mt !== Te || Lt !== qt) && ov(ce, bt, Te, qt), js = !1;
      var or = ce.memoizedState;
      bt.state = or, Ws(ce, Te, bt, nt), Lt = ce.memoizedState, Mt !== Te || or !== Lt || oi.current || js ? (typeof sr == "function" && (Yh(ce, Ee, sr, Te), Lt = ce.memoizedState), (Mt = js || iv(ce, Ee, Mt, Te, or, Lt, qt)) ? (lr || typeof bt.UNSAFE_componentWillMount != "function" && typeof bt.componentWillMount != "function" || (typeof bt.componentWillMount == "function" && bt.componentWillMount(), typeof bt.UNSAFE_componentWillMount == "function" && bt.UNSAFE_componentWillMount()), typeof bt.componentDidMount == "function" && (ce.flags |= 4194308)) : (typeof bt.componentDidMount == "function" && (ce.flags |= 4194308), ce.memoizedProps = Te, ce.memoizedState = Lt), bt.props = Te, bt.state = Lt, bt.context = qt, Te = Mt) : (typeof bt.componentDidMount == "function" && (ce.flags |= 4194308), Te = !1);
    } else {
      bt = ce.stateNode, xi(fe, ce), Mt = ce.memoizedProps, qt = ce.type === ce.elementType ? Mt : qa(ce.type, Mt), bt.props = qt, lr = ce.pendingProps, or = bt.context, Lt = Ee.contextType, typeof Lt == "object" && Lt !== null ? Lt = fi(Lt) : (Lt = Un(Ee) ? _a : Hr.current, Lt = lo(ce, Lt));
      var Sr = Ee.getDerivedStateFromProps;
      (sr = typeof Sr == "function" || typeof bt.getSnapshotBeforeUpdate == "function") || typeof bt.UNSAFE_componentWillReceiveProps != "function" && typeof bt.componentWillReceiveProps != "function" || (Mt !== lr || or !== Lt) && ov(ce, bt, Te, Lt), js = !1, or = ce.memoizedState, bt.state = or, Ws(ce, Te, bt, nt);
      var wr = ce.memoizedState;
      Mt !== lr || or !== wr || oi.current || js ? (typeof Sr == "function" && (Yh(ce, Ee, Sr, Te), wr = ce.memoizedState), (qt = js || iv(ce, Ee, qt, Te, or, wr, Lt) || !1) ? (sr || typeof bt.UNSAFE_componentWillUpdate != "function" && typeof bt.componentWillUpdate != "function" || (typeof bt.componentWillUpdate == "function" && bt.componentWillUpdate(Te, wr, Lt), typeof bt.UNSAFE_componentWillUpdate == "function" && bt.UNSAFE_componentWillUpdate(Te, wr, Lt)), typeof bt.componentDidUpdate == "function" && (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate == "function" && (ce.flags |= 1024)) : (typeof bt.componentDidUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 1024), ce.memoizedProps = Te, ce.memoizedState = wr), bt.props = Te, bt.state = wr, bt.context = Lt, Te = qt) : (typeof bt.componentDidUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 4), typeof bt.getSnapshotBeforeUpdate != "function" || Mt === fe.memoizedProps && or === fe.memoizedState || (ce.flags |= 1024), Te = !1);
    }
    return hv(fe, ce, Ee, Te, ct, nt);
  }
  function hv(fe, ce, Ee, Te, nt, ct) {
    Qr(fe, ce);
    var bt = (ce.flags & 128) !== 0;
    if (!Te && !bt)
      return nt && Jm(ce, Ee, !1), ji(fe, ce, ct);
    Te = ce.stateNode, kg.current = ce;
    var Mt = bt && typeof Ee.getDerivedStateFromError != "function" ? null : Te.render();
    return ce.flags |= 1, fe !== null && bt ? (ce.child = _u(ce, fe.child, null, ct), ce.child = _u(ce, null, Mt, ct)) : Ti(fe, ce, Mt, ct), ce.memoizedState = Te.state, nt && Jm(ce, Ee, !0), ce.child;
  }
  function pv(fe) {
    var ce = fe.stateNode;
    ce.pendingContext ? Vs(fe, ce.pendingContext, ce.pendingContext !== ce.context) : ce.context && Vs(fe, ce.context, !1), Qh(fe, ce.containerInfo);
  }
  function vd(fe, ce, Ee, Te, nt) {
    return Wn(), Hh(nt), ce.flags |= 256, Ti(fe, ce, Ee, Te), ce.child;
  }
  var Nl = { dehydrated: null, treeContext: null, retryLane: 0 };
  function rp(fe) {
    return { baseLanes: fe, cachePool: null, transitions: null };
  }
  function np(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = zr.current, ct = !1, bt = (ce.flags & 128) !== 0, Mt;
    if ((Mt = bt) || (Mt = fe !== null && fe.memoizedState === null ? !1 : (nt & 2) !== 0), Mt ? (ct = !0, ce.flags &= -129) : (fe === null || fe.memoizedState !== null) && (nt |= 1), gn(zr, nt & 1), fe === null)
      return Hc(ce), fe = ce.memoizedState, fe !== null && (fe = fe.dehydrated, fe !== null) ? (ce.mode & 1 ? fe.data === "$!" ? ce.lanes = 8 : ce.lanes = 1073741824 : ce.lanes = 1, null) : (bt = Te.children, fe = Te.fallback, ct ? (Te = ce.mode, ct = ce.child, bt = { mode: "hidden", children: bt }, !(Te & 1) && ct !== null ? (ct.childLanes = 0, ct.pendingProps = bt) : ct = Kf(bt, Te, 0, null), fe = Wl(fe, Te, Ee, null), ct.return = ce, fe.return = ce, ct.sibling = fe, ce.child = ct, ce.child.memoizedState = rp(Ee), ce.memoizedState = Nl, fe) : ip(ce, bt));
    if (nt = fe.memoizedState, nt !== null && (Mt = nt.dehydrated, Mt !== null))
      return Mg(fe, ce, bt, Te, Mt, nt, Ee);
    if (ct) {
      ct = Te.fallback, bt = ce.mode, nt = fe.child, Mt = nt.sibling;
      var Lt = { mode: "hidden", children: Te.children };
      return !(bt & 1) && ce.child !== nt ? (Te = ce.child, Te.childLanes = 0, Te.pendingProps = Lt, ce.deletions = null) : (Te = el(nt, Lt), Te.subtreeFlags = nt.subtreeFlags & 14680064), Mt !== null ? ct = el(Mt, ct) : (ct = Wl(ct, bt, Ee, null), ct.flags |= 2), ct.return = ce, Te.return = ce, Te.sibling = ct, ce.child = Te, Te = ct, ct = ce.child, bt = fe.child.memoizedState, bt = bt === null ? rp(Ee) : { baseLanes: bt.baseLanes | Ee, cachePool: null, transitions: bt.transitions }, ct.memoizedState = bt, ct.childLanes = fe.childLanes & ~Ee, ce.memoizedState = Nl, Te;
    }
    return ct = fe.child, fe = ct.sibling, Te = el(ct, { mode: "visible", children: Te.children }), !(ce.mode & 1) && (Te.lanes = Ee), Te.return = ce, Te.sibling = null, fe !== null && (Ee = ce.deletions, Ee === null ? (ce.deletions = [fe], ce.flags |= 16) : Ee.push(fe)), ce.child = Te, ce.memoizedState = null, Te;
  }
  function ip(fe, ce) {
    return ce = Kf({ mode: "visible", children: ce }, fe.mode, 0, null), ce.return = fe, fe.child = ce;
  }
  function Du(fe, ce, Ee, Te) {
    return Te !== null && Hh(Te), _u(ce, fe.child, null, Ee), fe = ip(ce, ce.pendingProps.children), fe.flags |= 2, ce.memoizedState = null, fe;
  }
  function Mg(fe, ce, Ee, Te, nt, ct, bt) {
    if (Ee)
      return ce.flags & 256 ? (ce.flags &= -257, Te = Vf(Error(oe(422))), Du(fe, ce, bt, Te)) : ce.memoizedState !== null ? (ce.child = fe.child, ce.flags |= 128, null) : (ct = Te.fallback, nt = ce.mode, Te = Kf({ mode: "visible", children: Te.children }, nt, 0, null), ct = Wl(ct, nt, bt, null), ct.flags |= 2, Te.return = ce, ct.return = ce, Te.sibling = ct, ce.child = Te, ce.mode & 1 && _u(ce, fe.child, null, bt), ce.child.memoizedState = rp(bt), ce.memoizedState = Nl, ct);
    if (!(ce.mode & 1))
      return Du(fe, ce, bt, null);
    if (nt.data === "$!") {
      if (Te = nt.nextSibling && nt.nextSibling.dataset, Te)
        var Mt = Te.dgst;
      return Te = Mt, ct = Error(oe(419)), Te = Vf(ct, Te, void 0), Du(fe, ce, bt, Te);
    }
    if (Mt = (bt & fe.childLanes) !== 0, vi || Mt) {
      if (Te = Yn, Te !== null) {
        switch (bt & -bt) {
          case 4:
            nt = 2;
            break;
          case 16:
            nt = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            nt = 32;
            break;
          case 536870912:
            nt = 268435456;
            break;
          default:
            nt = 0;
        }
        nt = nt & (Te.suspendedLanes | bt) ? 0 : nt, nt !== 0 && nt !== ct.retryLane && (ct.retryLane = nt, cs(fe, nt), ia(Te, fe, nt, -1));
      }
      return vp(), Te = Vf(Error(oe(421))), Du(fe, ce, bt, Te);
    }
    return nt.data === "$?" ? (ce.flags |= 128, ce.child = fe.child, ce = Ig.bind(null, fe), nt._reactRetry = ce, null) : (fe = ct.treeContext, ka = Po(nt.nextSibling), Wa = ce, On = !0, co = null, fe !== null && (Ra[Zi++] = Hi, Ra[Zi++] = fs, Ra[Zi++] = fo, Hi = fe.id, fs = fe.overflow, fo = ce), ce = ip(ce, Te.children), ce.flags |= 4096, ce);
  }
  function ap(fe, ce, Ee) {
    fe.lanes |= ce;
    var Te = fe.alternate;
    Te !== null && (Te.lanes |= ce), $i(fe.return, ce, Ee);
  }
  function yd(fe, ce, Ee, Te, nt) {
    var ct = fe.memoizedState;
    ct === null ? fe.memoizedState = { isBackwards: ce, rendering: null, renderingStartTime: 0, last: Te, tail: Ee, tailMode: nt } : (ct.isBackwards = ce, ct.rendering = null, ct.renderingStartTime = 0, ct.last = Te, ct.tail = Ee, ct.tailMode = nt);
  }
  function op(fe, ce, Ee) {
    var Te = ce.pendingProps, nt = Te.revealOrder, ct = Te.tail;
    if (Ti(fe, ce, Te.children, Ee), Te = zr.current, Te & 2)
      Te = Te & 1 | 2, ce.flags |= 128;
    else {
      if (fe !== null && fe.flags & 128)
        e:
          for (fe = ce.child; fe !== null; ) {
            if (fe.tag === 13)
              fe.memoizedState !== null && ap(fe, Ee, ce);
            else if (fe.tag === 19)
              ap(fe, Ee, ce);
            else if (fe.child !== null) {
              fe.child.return = fe, fe = fe.child;
              continue;
            }
            if (fe === ce)
              break e;
            for (; fe.sibling === null; ) {
              if (fe.return === null || fe.return === ce)
                break e;
              fe = fe.return;
            }
            fe.sibling.return = fe.return, fe = fe.sibling;
          }
      Te &= 1;
    }
    if (gn(zr, Te), !(ce.mode & 1))
      ce.memoizedState = null;
    else
      switch (nt) {
        case "forwards":
          for (Ee = ce.child, nt = null; Ee !== null; )
            fe = Ee.alternate, fe !== null && qn(fe) === null && (nt = Ee), Ee = Ee.sibling;
          Ee = nt, Ee === null ? (nt = ce.child, ce.child = null) : (nt = Ee.sibling, Ee.sibling = null), yd(ce, !1, nt, Ee, ct);
          break;
        case "backwards":
          for (Ee = null, nt = ce.child, ce.child = null; nt !== null; ) {
            if (fe = nt.alternate, fe !== null && qn(fe) === null) {
              ce.child = nt;
              break;
            }
            fe = nt.sibling, nt.sibling = Ee, Ee = nt, nt = fe;
          }
          yd(ce, !0, Ee, null, ct);
          break;
        case "together":
          yd(ce, !1, null, null, void 0);
          break;
        default:
          ce.memoizedState = null;
      }
    return ce.child;
  }
  function ea(fe, ce) {
    !(ce.mode & 1) && fe !== null && (fe.alternate = null, ce.alternate = null, ce.flags |= 2);
  }
  function ji(fe, ce, Ee) {
    if (fe !== null && (ce.dependencies = fe.dependencies), vs |= ce.lanes, !(Ee & ce.childLanes))
      return null;
    if (fe !== null && ce.child !== fe.child)
      throw Error(oe(153));
    if (ce.child !== null) {
      for (fe = ce.child, Ee = el(fe, fe.pendingProps), ce.child = Ee, Ee.return = ce; fe.sibling !== null; )
        fe = fe.sibling, Ee = Ee.sibling = el(fe, fe.pendingProps), Ee.return = ce;
      Ee.sibling = null;
    }
    return ce.child;
  }
  function ps(fe, ce, Ee) {
    switch (ce.tag) {
      case 3:
        pv(ce), Wn();
        break;
      case 5:
        Nr(ce);
        break;
      case 1:
        Un(ce.type) && zc(ce);
        break;
      case 4:
        Qh(ce, ce.stateNode.containerInfo);
        break;
      case 10:
        var Te = ce.type._context, nt = ce.memoizedProps.value;
        gn(Ho, Te._currentValue), Te._currentValue = nt;
        break;
      case 13:
        if (Te = ce.memoizedState, Te !== null)
          return Te.dehydrated !== null ? (gn(zr, zr.current & 1), ce.flags |= 128, null) : Ee & ce.child.childLanes ? np(fe, ce, Ee) : (gn(zr, zr.current & 1), fe = ji(fe, ce, Ee), fe !== null ? fe.sibling : null);
        gn(zr, zr.current & 1);
        break;
      case 19:
        if (Te = (Ee & ce.childLanes) !== 0, fe.flags & 128) {
          if (Te)
            return op(fe, ce, Ee);
          ce.flags |= 128;
        }
        if (nt = ce.memoizedState, nt !== null && (nt.rendering = null, nt.tail = null, nt.lastEffect = null), gn(zr, zr.current), Te)
          break;
        return null;
      case 22:
      case 23:
        return ce.lanes = 0, Il(fe, ce, Ee);
    }
    return ji(fe, ce, Ee);
  }
  var Hf, zl, mo, wi;
  Hf = function(fe, ce) {
    for (var Ee = ce.child; Ee !== null; ) {
      if (Ee.tag === 5 || Ee.tag === 6)
        fe.appendChild(Ee.stateNode);
      else if (Ee.tag !== 4 && Ee.child !== null) {
        Ee.child.return = Ee, Ee = Ee.child;
        continue;
      }
      if (Ee === ce)
        break;
      for (; Ee.sibling === null; ) {
        if (Ee.return === null || Ee.return === ce)
          return;
        Ee = Ee.return;
      }
      Ee.sibling.return = Ee.return, Ee = Ee.sibling;
    }
  }, zl = function() {
  }, mo = function(fe, ce, Ee, Te) {
    var nt = fe.memoizedProps;
    if (nt !== Te) {
      fe = ce.stateNode, Rl(Ro.current);
      var ct = null;
      switch (Ee) {
        case "input":
          nt = cr(fe, nt), Te = cr(fe, Te), ct = [];
          break;
        case "select":
          nt = Dt({}, nt, { value: void 0 }), Te = Dt({}, Te, { value: void 0 }), ct = [];
          break;
        case "textarea":
          nt = ki(fe, nt), Te = ki(fe, Te), ct = [];
          break;
        default:
          typeof nt.onClick != "function" && typeof Te.onClick == "function" && (fe.onclick = Nc);
      }
      Ei(Ee, Te);
      var bt;
      Ee = null;
      for (qt in nt)
        if (!Te.hasOwnProperty(qt) && nt.hasOwnProperty(qt) && nt[qt] != null)
          if (qt === "style") {
            var Mt = nt[qt];
            for (bt in Mt)
              Mt.hasOwnProperty(bt) && (Ee || (Ee = {}), Ee[bt] = "");
          } else
            qt !== "dangerouslySetInnerHTML" && qt !== "children" && qt !== "suppressContentEditableWarning" && qt !== "suppressHydrationWarning" && qt !== "autoFocus" && (me.hasOwnProperty(qt) ? ct || (ct = []) : (ct = ct || []).push(qt, null));
      for (qt in Te) {
        var Lt = Te[qt];
        if (Mt = nt != null ? nt[qt] : void 0, Te.hasOwnProperty(qt) && Lt !== Mt && (Lt != null || Mt != null))
          if (qt === "style")
            if (Mt) {
              for (bt in Mt)
                !Mt.hasOwnProperty(bt) || Lt && Lt.hasOwnProperty(bt) || (Ee || (Ee = {}), Ee[bt] = "");
              for (bt in Lt)
                Lt.hasOwnProperty(bt) && Mt[bt] !== Lt[bt] && (Ee || (Ee = {}), Ee[bt] = Lt[bt]);
            } else
              Ee || (ct || (ct = []), ct.push(
                qt,
                Ee
              )), Ee = Lt;
          else
            qt === "dangerouslySetInnerHTML" ? (Lt = Lt ? Lt.__html : void 0, Mt = Mt ? Mt.__html : void 0, Lt != null && Mt !== Lt && (ct = ct || []).push(qt, Lt)) : qt === "children" ? typeof Lt != "string" && typeof Lt != "number" || (ct = ct || []).push(qt, "" + Lt) : qt !== "suppressContentEditableWarning" && qt !== "suppressHydrationWarning" && (me.hasOwnProperty(qt) ? (Lt != null && qt === "onScroll" && An("scroll", fe), ct || Mt === Lt || (ct = [])) : (ct = ct || []).push(qt, Lt));
      }
      Ee && (ct = ct || []).push("style", Ee);
      var qt = ct;
      (ce.updateQueue = qt) && (ce.flags |= 4);
    }
  }, wi = function(fe, ce, Ee, Te) {
    Ee !== Te && (ce.flags |= 4);
  };
  function Uf(fe, ce) {
    if (!On)
      switch (fe.tailMode) {
        case "hidden":
          ce = fe.tail;
          for (var Ee = null; ce !== null; )
            ce.alternate !== null && (Ee = ce), ce = ce.sibling;
          Ee === null ? fe.tail = null : Ee.sibling = null;
          break;
        case "collapsed":
          Ee = fe.tail;
          for (var Te = null; Ee !== null; )
            Ee.alternate !== null && (Te = Ee), Ee = Ee.sibling;
          Te === null ? ce || fe.tail === null ? fe.tail = null : fe.tail.sibling = null : Te.sibling = null;
      }
  }
  function ta(fe) {
    var ce = fe.alternate !== null && fe.alternate.child === fe.child, Ee = 0, Te = 0;
    if (ce)
      for (var nt = fe.child; nt !== null; )
        Ee |= nt.lanes | nt.childLanes, Te |= nt.subtreeFlags & 14680064, Te |= nt.flags & 14680064, nt.return = fe, nt = nt.sibling;
    else
      for (nt = fe.child; nt !== null; )
        Ee |= nt.lanes | nt.childLanes, Te |= nt.subtreeFlags, Te |= nt.flags, nt.return = fe, nt = nt.sibling;
    return fe.subtreeFlags |= Te, fe.childLanes = Ee, ce;
  }
  function Fg(fe, ce, Ee) {
    var Te = ce.pendingProps;
    switch (Vh(ce), ce.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ta(ce), null;
      case 1:
        return Un(ce.type) && uo(), ta(ce), null;
      case 3:
        return Te = ce.stateNode, qs(), hn(oi), hn(Hr), Xc(), Te.pendingContext && (Te.context = Te.pendingContext, Te.pendingContext = null), (fe === null || fe.child === null) && (Uc(ce) ? ce.flags |= 4 : fe === null || fe.memoizedState.isDehydrated && !(ce.flags & 256) || (ce.flags |= 1024, co !== null && (Xf(co), co = null))), zl(fe, ce), ta(ce), null;
      case 5:
        Jr(ce);
        var nt = Rl(Au.current);
        if (Ee = ce.type, fe !== null && ce.stateNode != null)
          mo(fe, ce, Ee, Te, nt), fe.ref !== ce.ref && (ce.flags |= 512, ce.flags |= 2097152);
        else {
          if (!Te) {
            if (ce.stateNode === null)
              throw Error(oe(166));
            return ta(ce), null;
          }
          if (fe = Rl(Ro.current), Uc(ce)) {
            Te = ce.stateNode, Ee = ce.type;
            var ct = ce.memoizedProps;
            switch (Te[Vo] = ce, Te[_l] = ct, fe = (ce.mode & 1) !== 0, Ee) {
              case "dialog":
                An("cancel", Te), An("close", Te);
                break;
              case "iframe":
              case "object":
              case "embed":
                An("load", Te);
                break;
              case "video":
              case "audio":
                for (nt = 0; nt < _f.length; nt++)
                  An(_f[nt], Te);
                break;
              case "source":
                An("error", Te);
                break;
              case "img":
              case "image":
              case "link":
                An(
                  "error",
                  Te
                ), An("load", Te);
                break;
              case "details":
                An("toggle", Te);
                break;
              case "input":
                Nn(Te, ct), An("invalid", Te);
                break;
              case "select":
                Te._wrapperState = { wasMultiple: !!ct.multiple }, An("invalid", Te);
                break;
              case "textarea":
                Jn(Te, ct), An("invalid", Te);
            }
            Ei(Ee, ct), nt = null;
            for (var bt in ct)
              if (ct.hasOwnProperty(bt)) {
                var Mt = ct[bt];
                bt === "children" ? typeof Mt == "string" ? Te.textContent !== Mt && (ct.suppressHydrationWarning !== !0 && Ic(Te.textContent, Mt, fe), nt = ["children", Mt]) : typeof Mt == "number" && Te.textContent !== "" + Mt && (ct.suppressHydrationWarning !== !0 && Ic(
                  Te.textContent,
                  Mt,
                  fe
                ), nt = ["children", "" + Mt]) : me.hasOwnProperty(bt) && Mt != null && bt === "onScroll" && An("scroll", Te);
              }
            switch (Ee) {
              case "input":
                Lr(Te), Kn(Te, ct, !0);
                break;
              case "textarea":
                Lr(Te), ui(Te);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof ct.onClick == "function" && (Te.onclick = Nc);
            }
            Te = nt, ce.updateQueue = Te, Te !== null && (ce.flags |= 4);
          } else {
            bt = nt.nodeType === 9 ? nt : nt.ownerDocument, fe === "http://www.w3.org/1999/xhtml" && (fe = ei(Ee)), fe === "http://www.w3.org/1999/xhtml" ? Ee === "script" ? (fe = bt.createElement("div"), fe.innerHTML = "<script><\/script>", fe = fe.removeChild(fe.firstChild)) : typeof Te.is == "string" ? fe = bt.createElement(Ee, { is: Te.is }) : (fe = bt.createElement(Ee), Ee === "select" && (bt = fe, Te.multiple ? bt.multiple = !0 : Te.size && (bt.size = Te.size))) : fe = bt.createElementNS(fe, Ee), fe[Vo] = ce, fe[_l] = Te, Hf(fe, ce, !1, !1), ce.stateNode = fe;
            e: {
              switch (bt = ti(Ee, Te), Ee) {
                case "dialog":
                  An("cancel", fe), An("close", fe), nt = Te;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  An("load", fe), nt = Te;
                  break;
                case "video":
                case "audio":
                  for (nt = 0; nt < _f.length; nt++)
                    An(_f[nt], fe);
                  nt = Te;
                  break;
                case "source":
                  An("error", fe), nt = Te;
                  break;
                case "img":
                case "image":
                case "link":
                  An(
                    "error",
                    fe
                  ), An("load", fe), nt = Te;
                  break;
                case "details":
                  An("toggle", fe), nt = Te;
                  break;
                case "input":
                  Nn(fe, Te), nt = cr(fe, Te), An("invalid", fe);
                  break;
                case "option":
                  nt = Te;
                  break;
                case "select":
                  fe._wrapperState = { wasMultiple: !!Te.multiple }, nt = Dt({}, Te, { value: void 0 }), An("invalid", fe);
                  break;
                case "textarea":
                  Jn(fe, Te), nt = ki(fe, Te), An("invalid", fe);
                  break;
                default:
                  nt = Te;
              }
              Ei(Ee, nt), Mt = nt;
              for (ct in Mt)
                if (Mt.hasOwnProperty(ct)) {
                  var Lt = Mt[ct];
                  ct === "style" ? pn(fe, Lt) : ct === "dangerouslySetInnerHTML" ? (Lt = Lt ? Lt.__html : void 0, Lt != null && za(fe, Lt)) : ct === "children" ? typeof Lt == "string" ? (Ee !== "textarea" || Lt !== "") && zn(fe, Lt) : typeof Lt == "number" && zn(fe, "" + Lt) : ct !== "suppressContentEditableWarning" && ct !== "suppressHydrationWarning" && ct !== "autoFocus" && (me.hasOwnProperty(ct) ? Lt != null && ct === "onScroll" && An("scroll", fe) : Lt != null && ft(fe, ct, Lt, bt));
                }
              switch (Ee) {
                case "input":
                  Lr(fe), Kn(fe, Te, !1);
                  break;
                case "textarea":
                  Lr(fe), ui(fe);
                  break;
                case "option":
                  Te.value != null && fe.setAttribute("value", "" + Zr(Te.value));
                  break;
                case "select":
                  fe.multiple = !!Te.multiple, ct = Te.value, ct != null ? Fn(fe, !!Te.multiple, ct, !1) : Te.defaultValue != null && Fn(
                    fe,
                    !!Te.multiple,
                    Te.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof nt.onClick == "function" && (fe.onclick = Nc);
              }
              switch (Ee) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  Te = !!Te.autoFocus;
                  break e;
                case "img":
                  Te = !0;
                  break e;
                default:
                  Te = !1;
              }
            }
            Te && (ce.flags |= 4);
          }
          ce.ref !== null && (ce.flags |= 512, ce.flags |= 2097152);
        }
        return ta(ce), null;
      case 6:
        if (fe && ce.stateNode != null)
          wi(fe, ce, fe.memoizedProps, Te);
        else {
          if (typeof Te != "string" && ce.stateNode === null)
            throw Error(oe(166));
          if (Ee = Rl(Au.current), Rl(Ro.current), Uc(ce)) {
            if (Te = ce.stateNode, Ee = ce.memoizedProps, Te[Vo] = ce, (ct = Te.nodeValue !== Ee) && (fe = Wa, fe !== null))
              switch (fe.tag) {
                case 3:
                  Ic(Te.nodeValue, Ee, (fe.mode & 1) !== 0);
                  break;
                case 5:
                  fe.memoizedProps.suppressHydrationWarning !== !0 && Ic(Te.nodeValue, Ee, (fe.mode & 1) !== 0);
              }
            ct && (ce.flags |= 4);
          } else
            Te = (Ee.nodeType === 9 ? Ee : Ee.ownerDocument).createTextNode(Te), Te[Vo] = ce, ce.stateNode = Te;
        }
        return ta(ce), null;
      case 13:
        if (hn(zr), Te = ce.memoizedState, fe === null || fe.memoizedState !== null && fe.memoizedState.dehydrated !== null) {
          if (On && ka !== null && ce.mode & 1 && !(ce.flags & 128))
            tv(), Wn(), ce.flags |= 98560, ct = !1;
          else if (ct = Uc(ce), Te !== null && Te.dehydrated !== null) {
            if (fe === null) {
              if (!ct)
                throw Error(oe(318));
              if (ct = ce.memoizedState, ct = ct !== null ? ct.dehydrated : null, !ct)
                throw Error(oe(317));
              ct[Vo] = ce;
            } else
              Wn(), !(ce.flags & 128) && (ce.memoizedState = null), ce.flags |= 4;
            ta(ce), ct = !1;
          } else
            co !== null && (Xf(co), co = null), ct = !0;
          if (!ct)
            return ce.flags & 65536 ? ce : null;
        }
        return ce.flags & 128 ? (ce.lanes = Ee, ce) : (Te = Te !== null, Te !== (fe !== null && fe.memoizedState !== null) && Te && (ce.child.flags |= 8192, ce.mode & 1 && (fe === null || zr.current & 1 ? Ai === 0 && (Ai = 3) : vp())), ce.updateQueue !== null && (ce.flags |= 4), ta(ce), null);
      case 4:
        return qs(), zl(fe, ce), fe === null && Cu(ce.stateNode.containerInfo), ta(ce), null;
      case 10:
        return Us(ce.type._context), ta(ce), null;
      case 17:
        return Un(ce.type) && uo(), ta(ce), null;
      case 19:
        if (hn(zr), ct = ce.memoizedState, ct === null)
          return ta(ce), null;
        if (Te = (ce.flags & 128) !== 0, bt = ct.rendering, bt === null)
          if (Te)
            Uf(ct, !1);
          else {
            if (Ai !== 0 || fe !== null && fe.flags & 128)
              for (fe = ce.child; fe !== null; ) {
                if (bt = qn(fe), bt !== null) {
                  for (ce.flags |= 128, Uf(ct, !1), Te = bt.updateQueue, Te !== null && (ce.updateQueue = Te, ce.flags |= 4), ce.subtreeFlags = 0, Te = Ee, Ee = ce.child; Ee !== null; )
                    ct = Ee, fe = Te, ct.flags &= 14680066, bt = ct.alternate, bt === null ? (ct.childLanes = 0, ct.lanes = fe, ct.child = null, ct.subtreeFlags = 0, ct.memoizedProps = null, ct.memoizedState = null, ct.updateQueue = null, ct.dependencies = null, ct.stateNode = null) : (ct.childLanes = bt.childLanes, ct.lanes = bt.lanes, ct.child = bt.child, ct.subtreeFlags = 0, ct.deletions = null, ct.memoizedProps = bt.memoizedProps, ct.memoizedState = bt.memoizedState, ct.updateQueue = bt.updateQueue, ct.type = bt.type, fe = bt.dependencies, ct.dependencies = fe === null ? null : { lanes: fe.lanes, firstContext: fe.firstContext }), Ee = Ee.sibling;
                  return gn(zr, zr.current & 1 | 2), ce.child;
                }
                fe = fe.sibling;
              }
            ct.tail !== null && Bn() > Vu && (ce.flags |= 128, Te = !0, Uf(ct, !1), ce.lanes = 4194304);
          }
        else {
          if (!Te)
            if (fe = qn(bt), fe !== null) {
              if (ce.flags |= 128, Te = !0, Ee = fe.updateQueue, Ee !== null && (ce.updateQueue = Ee, ce.flags |= 4), Uf(ct, !0), ct.tail === null && ct.tailMode === "hidden" && !bt.alternate && !On)
                return ta(ce), null;
            } else
              2 * Bn() - ct.renderingStartTime > Vu && Ee !== 1073741824 && (ce.flags |= 128, Te = !0, Uf(ct, !1), ce.lanes = 4194304);
          ct.isBackwards ? (bt.sibling = ce.child, ce.child = bt) : (Ee = ct.last, Ee !== null ? Ee.sibling = bt : ce.child = bt, ct.last = bt);
        }
        return ct.tail !== null ? (ce = ct.tail, ct.rendering = ce, ct.tail = ce.sibling, ct.renderingStartTime = Bn(), ce.sibling = null, Ee = zr.current, gn(zr, Te ? Ee & 1 | 2 : Ee & 1), ce) : (ta(ce), null);
      case 22:
      case 23:
        return mp(), Te = ce.memoizedState !== null, fe !== null && fe.memoizedState !== null !== Te && (ce.flags |= 8192), Te && ce.mode & 1 ? Qa & 1073741824 && (ta(ce), ce.subtreeFlags & 6 && (ce.flags |= 8192)) : ta(ce), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(oe(156, ce.tag));
  }
  function sp(fe, ce) {
    switch (Vh(ce), ce.tag) {
      case 1:
        return Un(ce.type) && uo(), fe = ce.flags, fe & 65536 ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 3:
        return qs(), hn(oi), hn(Hr), Xc(), fe = ce.flags, fe & 65536 && !(fe & 128) ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 5:
        return Jr(ce), null;
      case 13:
        if (hn(zr), fe = ce.memoizedState, fe !== null && fe.dehydrated !== null) {
          if (ce.alternate === null)
            throw Error(oe(340));
          Wn();
        }
        return fe = ce.flags, fe & 65536 ? (ce.flags = fe & -65537 | 128, ce) : null;
      case 19:
        return hn(zr), null;
      case 4:
        return qs(), null;
      case 10:
        return Us(ce.type._context), null;
      case 22:
      case 23:
        return mp(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var jf = !1, _i = !1, mv = typeof WeakSet == "function" ? WeakSet : Set, Tr = null;
  function Ou(fe, ce) {
    var Ee = fe.ref;
    if (Ee !== null)
      if (typeof Ee == "function")
        try {
          Ee(null);
        } catch (Te) {
          li(fe, ce, Te);
        }
      else
        Ee.current = null;
  }
  function Gf(fe, ce, Ee) {
    try {
      Ee();
    } catch (Te) {
      li(fe, ce, Te);
    }
  }
  var vv = !1;
  function yv(fe, ce) {
    if (Fh = zt, fe = Fc(), os(fe)) {
      if ("selectionStart" in fe)
        var Ee = { start: fe.selectionStart, end: fe.selectionEnd };
      else
        e: {
          Ee = (Ee = fe.ownerDocument) && Ee.defaultView || window;
          var Te = Ee.getSelection && Ee.getSelection();
          if (Te && Te.rangeCount !== 0) {
            Ee = Te.anchorNode;
            var nt = Te.anchorOffset, ct = Te.focusNode;
            Te = Te.focusOffset;
            try {
              Ee.nodeType, ct.nodeType;
            } catch {
              Ee = null;
              break e;
            }
            var bt = 0, Mt = -1, Lt = -1, qt = 0, sr = 0, lr = fe, or = null;
            t:
              for (; ; ) {
                for (var Sr; lr !== Ee || nt !== 0 && lr.nodeType !== 3 || (Mt = bt + nt), lr !== ct || Te !== 0 && lr.nodeType !== 3 || (Lt = bt + Te), lr.nodeType === 3 && (bt += lr.nodeValue.length), (Sr = lr.firstChild) !== null; )
                  or = lr, lr = Sr;
                for (; ; ) {
                  if (lr === fe)
                    break t;
                  if (or === Ee && ++qt === nt && (Mt = bt), or === ct && ++sr === Te && (Lt = bt), (Sr = lr.nextSibling) !== null)
                    break;
                  lr = or, or = lr.parentNode;
                }
                lr = Sr;
              }
            Ee = Mt === -1 || Lt === -1 ? null : { start: Mt, end: Lt };
          } else
            Ee = null;
        }
      Ee = Ee || { start: 0, end: 0 };
    } else
      Ee = null;
    for (Tl = { focusedElem: fe, selectionRange: Ee }, zt = !1, Tr = ce; Tr !== null; )
      if (ce = Tr, fe = ce.child, (ce.subtreeFlags & 1028) !== 0 && fe !== null)
        fe.return = ce, Tr = fe;
      else
        for (; Tr !== null; ) {
          ce = Tr;
          try {
            var wr = ce.alternate;
            if (ce.flags & 1024)
              switch (ce.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (wr !== null) {
                    var Pr = wr.memoizedProps, ci = wr.memoizedState, Bt = ce.stateNode, It = Bt.getSnapshotBeforeUpdate(ce.elementType === ce.type ? Pr : qa(ce.type, Pr), ci);
                    Bt.__reactInternalSnapshotBeforeUpdate = It;
                  }
                  break;
                case 3:
                  var jt = ce.stateNode.containerInfo;
                  jt.nodeType === 1 ? jt.textContent = "" : jt.nodeType === 9 && jt.documentElement && jt.removeChild(jt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(oe(163));
              }
          } catch (fr) {
            li(ce, ce.return, fr);
          }
          if (fe = ce.sibling, fe !== null) {
            fe.return = ce.return, Tr = fe;
            break;
          }
          Tr = ce.return;
        }
    return wr = vv, vv = !1, wr;
  }
  function Wf(fe, ce, Ee) {
    var Te = ce.updateQueue;
    if (Te = Te !== null ? Te.lastEffect : null, Te !== null) {
      var nt = Te = Te.next;
      do {
        if ((nt.tag & fe) === fe) {
          var ct = nt.destroy;
          nt.destroy = void 0, ct !== void 0 && Gf(ce, Ee, ct);
        }
        nt = nt.next;
      } while (nt !== Te);
    }
  }
  function qf(fe, ce) {
    if (ce = ce.updateQueue, ce = ce !== null ? ce.lastEffect : null, ce !== null) {
      var Ee = ce = ce.next;
      do {
        if ((Ee.tag & fe) === fe) {
          var Te = Ee.create;
          Ee.destroy = Te();
        }
        Ee = Ee.next;
      } while (Ee !== ce);
    }
  }
  function lp(fe) {
    var ce = fe.ref;
    if (ce !== null) {
      var Ee = fe.stateNode;
      switch (fe.tag) {
        case 5:
          fe = Ee;
          break;
        default:
          fe = Ee;
      }
      typeof ce == "function" ? ce(fe) : ce.current = fe;
    }
  }
  function up(fe) {
    var ce = fe.alternate;
    ce !== null && (fe.alternate = null, up(ce)), fe.child = null, fe.deletions = null, fe.sibling = null, fe.tag === 5 && (ce = fe.stateNode, ce !== null && (delete ce[Vo], delete ce[_l], delete ce[Lh], delete ce[wg], delete ce[$h])), fe.stateNode = null, fe.return = null, fe.dependencies = null, fe.memoizedProps = null, fe.memoizedState = null, fe.pendingProps = null, fe.stateNode = null, fe.updateQueue = null;
  }
  function gv(fe) {
    return fe.tag === 5 || fe.tag === 3 || fe.tag === 4;
  }
  function gd(fe) {
    e:
      for (; ; ) {
        for (; fe.sibling === null; ) {
          if (fe.return === null || gv(fe.return))
            return null;
          fe = fe.return;
        }
        for (fe.sibling.return = fe.return, fe = fe.sibling; fe.tag !== 5 && fe.tag !== 6 && fe.tag !== 18; ) {
          if (fe.flags & 2 || fe.child === null || fe.tag === 4)
            continue e;
          fe.child.return = fe, fe = fe.child;
        }
        if (!(fe.flags & 2))
          return fe.stateNode;
      }
  }
  function Lu(fe, ce, Ee) {
    var Te = fe.tag;
    if (Te === 5 || Te === 6)
      fe = fe.stateNode, ce ? Ee.nodeType === 8 ? Ee.parentNode.insertBefore(fe, ce) : Ee.insertBefore(fe, ce) : (Ee.nodeType === 8 ? (ce = Ee.parentNode, ce.insertBefore(fe, Ee)) : (ce = Ee, ce.appendChild(fe)), Ee = Ee._reactRootContainer, Ee != null || ce.onclick !== null || (ce.onclick = Nc));
    else if (Te !== 4 && (fe = fe.child, fe !== null))
      for (Lu(fe, ce, Ee), fe = fe.sibling; fe !== null; )
        Lu(fe, ce, Ee), fe = fe.sibling;
  }
  function jo(fe, ce, Ee) {
    var Te = fe.tag;
    if (Te === 5 || Te === 6)
      fe = fe.stateNode, ce ? Ee.insertBefore(fe, ce) : Ee.appendChild(fe);
    else if (Te !== 4 && (fe = fe.child, fe !== null))
      for (jo(fe, ce, Ee), fe = fe.sibling; fe !== null; )
        jo(fe, ce, Ee), fe = fe.sibling;
  }
  var jn = null, Ii = !1;
  function vo(fe, ce, Ee) {
    for (Ee = Ee.child; Ee !== null; )
      $u(fe, ce, Ee), Ee = Ee.sibling;
  }
  function $u(fe, ce, Ee) {
    if (Ha && typeof Ha.onCommitFiberUnmount == "function")
      try {
        Ha.onCommitFiberUnmount(pl, Ee);
      } catch {
      }
    switch (Ee.tag) {
      case 5:
        _i || Ou(Ee, ce);
      case 6:
        var Te = jn, nt = Ii;
        jn = null, vo(fe, ce, Ee), jn = Te, Ii = nt, jn !== null && (Ii ? (fe = jn, Ee = Ee.stateNode, fe.nodeType === 8 ? fe.parentNode.removeChild(Ee) : fe.removeChild(Ee)) : jn.removeChild(Ee.stateNode));
        break;
      case 18:
        jn !== null && (Ii ? (fe = jn, Ee = Ee.stateNode, fe.nodeType === 8 ? Is(fe.parentNode, Ee) : fe.nodeType === 1 && Is(fe, Ee), gl(fe)) : Is(jn, Ee.stateNode));
        break;
      case 4:
        Te = jn, nt = Ii, jn = Ee.stateNode.containerInfo, Ii = !0, vo(fe, ce, Ee), jn = Te, Ii = nt;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!_i && (Te = Ee.updateQueue, Te !== null && (Te = Te.lastEffect, Te !== null))) {
          nt = Te = Te.next;
          do {
            var ct = nt, bt = ct.destroy;
            ct = ct.tag, bt !== void 0 && (ct & 2 || ct & 4) && Gf(Ee, ce, bt), nt = nt.next;
          } while (nt !== Te);
        }
        vo(fe, ce, Ee);
        break;
      case 1:
        if (!_i && (Ou(Ee, ce), Te = Ee.stateNode, typeof Te.componentWillUnmount == "function"))
          try {
            Te.props = Ee.memoizedProps, Te.state = Ee.memoizedState, Te.componentWillUnmount();
          } catch (Mt) {
            li(Ee, ce, Mt);
          }
        vo(fe, ce, Ee);
        break;
      case 21:
        vo(fe, ce, Ee);
        break;
      case 22:
        Ee.mode & 1 ? (_i = (Te = _i) || Ee.memoizedState !== null, vo(fe, ce, Ee), _i = Te) : vo(fe, ce, Ee);
        break;
      default:
        vo(fe, ce, Ee);
    }
  }
  function ms(fe) {
    var ce = fe.updateQueue;
    if (ce !== null) {
      fe.updateQueue = null;
      var Ee = fe.stateNode;
      Ee === null && (Ee = fe.stateNode = new mv()), ce.forEach(function(Te) {
        var nt = Ng.bind(null, fe, Te);
        Ee.has(Te) || (Ee.add(Te), Te.then(nt, nt));
      });
    }
  }
  function ko(fe, ce) {
    var Ee = ce.deletions;
    if (Ee !== null)
      for (var Te = 0; Te < Ee.length; Te++) {
        var nt = Ee[Te];
        try {
          var ct = fe, bt = ce, Mt = bt;
          e:
            for (; Mt !== null; ) {
              switch (Mt.tag) {
                case 5:
                  jn = Mt.stateNode, Ii = !1;
                  break e;
                case 3:
                  jn = Mt.stateNode.containerInfo, Ii = !0;
                  break e;
                case 4:
                  jn = Mt.stateNode.containerInfo, Ii = !0;
                  break e;
              }
              Mt = Mt.return;
            }
          if (jn === null)
            throw Error(oe(160));
          $u(ct, bt, nt), jn = null, Ii = !1;
          var Lt = nt.alternate;
          Lt !== null && (Lt.return = null), nt.return = null;
        } catch (qt) {
          li(nt, ce, qt);
        }
      }
    if (ce.subtreeFlags & 12854)
      for (ce = ce.child; ce !== null; )
        Sv(ce, fe), ce = ce.sibling;
  }
  function Sv(fe, ce) {
    var Ee = fe.alternate, Te = fe.flags;
    switch (fe.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ko(ce, fe), Go(fe), Te & 4) {
          try {
            Wf(3, fe, fe.return), qf(3, fe);
          } catch (Pr) {
            li(fe, fe.return, Pr);
          }
          try {
            Wf(5, fe, fe.return);
          } catch (Pr) {
            li(fe, fe.return, Pr);
          }
        }
        break;
      case 1:
        ko(ce, fe), Go(fe), Te & 512 && Ee !== null && Ou(Ee, Ee.return);
        break;
      case 5:
        if (ko(ce, fe), Go(fe), Te & 512 && Ee !== null && Ou(Ee, Ee.return), fe.flags & 32) {
          var nt = fe.stateNode;
          try {
            zn(nt, "");
          } catch (Pr) {
            li(fe, fe.return, Pr);
          }
        }
        if (Te & 4 && (nt = fe.stateNode, nt != null)) {
          var ct = fe.memoizedProps, bt = Ee !== null ? Ee.memoizedProps : ct, Mt = fe.type, Lt = fe.updateQueue;
          if (fe.updateQueue = null, Lt !== null)
            try {
              Mt === "input" && ct.type === "radio" && ct.name != null && Xn(nt, ct), ti(Mt, bt);
              var qt = ti(Mt, ct);
              for (bt = 0; bt < Lt.length; bt += 2) {
                var sr = Lt[bt], lr = Lt[bt + 1];
                sr === "style" ? pn(nt, lr) : sr === "dangerouslySetInnerHTML" ? za(nt, lr) : sr === "children" ? zn(nt, lr) : ft(nt, sr, lr, qt);
              }
              switch (Mt) {
                case "input":
                  Mn(nt, ct);
                  break;
                case "textarea":
                  Zn(nt, ct);
                  break;
                case "select":
                  var or = nt._wrapperState.wasMultiple;
                  nt._wrapperState.wasMultiple = !!ct.multiple;
                  var Sr = ct.value;
                  Sr != null ? Fn(nt, !!ct.multiple, Sr, !1) : or !== !!ct.multiple && (ct.defaultValue != null ? Fn(
                    nt,
                    !!ct.multiple,
                    ct.defaultValue,
                    !0
                  ) : Fn(nt, !!ct.multiple, ct.multiple ? [] : "", !1));
              }
              nt[_l] = ct;
            } catch (Pr) {
              li(fe, fe.return, Pr);
            }
        }
        break;
      case 6:
        if (ko(ce, fe), Go(fe), Te & 4) {
          if (fe.stateNode === null)
            throw Error(oe(162));
          nt = fe.stateNode, ct = fe.memoizedProps;
          try {
            nt.nodeValue = ct;
          } catch (Pr) {
            li(fe, fe.return, Pr);
          }
        }
        break;
      case 3:
        if (ko(ce, fe), Go(fe), Te & 4 && Ee !== null && Ee.memoizedState.isDehydrated)
          try {
            gl(ce.containerInfo);
          } catch (Pr) {
            li(fe, fe.return, Pr);
          }
        break;
      case 4:
        ko(ce, fe), Go(fe);
        break;
      case 13:
        ko(ce, fe), Go(fe), nt = fe.child, nt.flags & 8192 && (ct = nt.memoizedState !== null, nt.stateNode.isHidden = ct, !ct || nt.alternate !== null && nt.alternate.memoizedState !== null || (dp = Bn())), Te & 4 && ms(fe);
        break;
      case 22:
        if (sr = Ee !== null && Ee.memoizedState !== null, fe.mode & 1 ? (_i = (qt = _i) || sr, ko(ce, fe), _i = qt) : ko(ce, fe), Go(fe), Te & 8192) {
          if (qt = fe.memoizedState !== null, (fe.stateNode.isHidden = qt) && !sr && fe.mode & 1)
            for (Tr = fe, sr = fe.child; sr !== null; ) {
              for (lr = Tr = sr; Tr !== null; ) {
                switch (or = Tr, Sr = or.child, or.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Wf(4, or, or.return);
                    break;
                  case 1:
                    Ou(or, or.return);
                    var wr = or.stateNode;
                    if (typeof wr.componentWillUnmount == "function") {
                      Te = or, Ee = or.return;
                      try {
                        ce = Te, wr.props = ce.memoizedProps, wr.state = ce.memoizedState, wr.componentWillUnmount();
                      } catch (Pr) {
                        li(Te, Ee, Pr);
                      }
                    }
                    break;
                  case 5:
                    Ou(or, or.return);
                    break;
                  case 22:
                    if (or.memoizedState !== null) {
                      fp(lr);
                      continue;
                    }
                }
                Sr !== null ? (Sr.return = or, Tr = Sr) : fp(lr);
              }
              sr = sr.sibling;
            }
          e:
            for (sr = null, lr = fe; ; ) {
              if (lr.tag === 5) {
                if (sr === null) {
                  sr = lr;
                  try {
                    nt = lr.stateNode, qt ? (ct = nt.style, typeof ct.setProperty == "function" ? ct.setProperty("display", "none", "important") : ct.display = "none") : (Mt = lr.stateNode, Lt = lr.memoizedProps.style, bt = Lt != null && Lt.hasOwnProperty("display") ? Lt.display : null, Mt.style.display = Kr("display", bt));
                  } catch (Pr) {
                    li(fe, fe.return, Pr);
                  }
                }
              } else if (lr.tag === 6) {
                if (sr === null)
                  try {
                    lr.stateNode.nodeValue = qt ? "" : lr.memoizedProps;
                  } catch (Pr) {
                    li(fe, fe.return, Pr);
                  }
              } else if ((lr.tag !== 22 && lr.tag !== 23 || lr.memoizedState === null || lr === fe) && lr.child !== null) {
                lr.child.return = lr, lr = lr.child;
                continue;
              }
              if (lr === fe)
                break e;
              for (; lr.sibling === null; ) {
                if (lr.return === null || lr.return === fe)
                  break e;
                sr === lr && (sr = null), lr = lr.return;
              }
              sr === lr && (sr = null), lr.sibling.return = lr.return, lr = lr.sibling;
            }
        }
        break;
      case 19:
        ko(ce, fe), Go(fe), Te & 4 && ms(fe);
        break;
      case 21:
        break;
      default:
        ko(
          ce,
          fe
        ), Go(fe);
    }
  }
  function Go(fe) {
    var ce = fe.flags;
    if (ce & 2) {
      try {
        e: {
          for (var Ee = fe.return; Ee !== null; ) {
            if (gv(Ee)) {
              var Te = Ee;
              break e;
            }
            Ee = Ee.return;
          }
          throw Error(oe(160));
        }
        switch (Te.tag) {
          case 5:
            var nt = Te.stateNode;
            Te.flags & 32 && (zn(nt, ""), Te.flags &= -33);
            var ct = gd(fe);
            jo(fe, ct, nt);
            break;
          case 3:
          case 4:
            var bt = Te.stateNode.containerInfo, Mt = gd(fe);
            Lu(fe, Mt, bt);
            break;
          default:
            throw Error(oe(161));
        }
      } catch (Lt) {
        li(fe, fe.return, Lt);
      }
      fe.flags &= -3;
    }
    ce & 4096 && (fe.flags &= -4097);
  }
  function Ev(fe, ce, Ee) {
    Tr = fe, Iu(fe);
  }
  function Iu(fe, ce, Ee) {
    for (var Te = (fe.mode & 1) !== 0; Tr !== null; ) {
      var nt = Tr, ct = nt.child;
      if (nt.tag === 22 && Te) {
        var bt = nt.memoizedState !== null || jf;
        if (!bt) {
          var Mt = nt.alternate, Lt = Mt !== null && Mt.memoizedState !== null || _i;
          Mt = jf;
          var qt = _i;
          if (jf = bt, (_i = Lt) && !qt)
            for (Tr = nt; Tr !== null; )
              bt = Tr, Lt = bt.child, bt.tag === 22 && bt.memoizedState !== null ? Cv(nt) : Lt !== null ? (Lt.return = bt, Tr = Lt) : Cv(nt);
          for (; ct !== null; )
            Tr = ct, Iu(ct), ct = ct.sibling;
          Tr = nt, jf = Mt, _i = qt;
        }
        bv(fe);
      } else
        nt.subtreeFlags & 8772 && ct !== null ? (ct.return = nt, Tr = ct) : bv(fe);
    }
  }
  function bv(fe) {
    for (; Tr !== null; ) {
      var ce = Tr;
      if (ce.flags & 8772) {
        var Ee = ce.alternate;
        try {
          if (ce.flags & 8772)
            switch (ce.tag) {
              case 0:
              case 11:
              case 15:
                _i || qf(5, ce);
                break;
              case 1:
                var Te = ce.stateNode;
                if (ce.flags & 4 && !_i)
                  if (Ee === null)
                    Te.componentDidMount();
                  else {
                    var nt = ce.elementType === ce.type ? Ee.memoizedProps : qa(ce.type, Ee.memoizedProps);
                    Te.componentDidUpdate(nt, Ee.memoizedState, Te.__reactInternalSnapshotBeforeUpdate);
                  }
                var ct = ce.updateQueue;
                ct !== null && Pl(ce, ct, Te);
                break;
              case 3:
                var bt = ce.updateQueue;
                if (bt !== null) {
                  if (Ee = null, ce.child !== null)
                    switch (ce.child.tag) {
                      case 5:
                        Ee = ce.child.stateNode;
                        break;
                      case 1:
                        Ee = ce.child.stateNode;
                    }
                  Pl(ce, bt, Ee);
                }
                break;
              case 5:
                var Mt = ce.stateNode;
                if (Ee === null && ce.flags & 4) {
                  Ee = Mt;
                  var Lt = ce.memoizedProps;
                  switch (ce.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Lt.autoFocus && Ee.focus();
                      break;
                    case "img":
                      Lt.src && (Ee.src = Lt.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ce.memoizedState === null) {
                  var qt = ce.alternate;
                  if (qt !== null) {
                    var sr = qt.memoizedState;
                    if (sr !== null) {
                      var lr = sr.dehydrated;
                      lr !== null && gl(lr);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(oe(163));
            }
          _i || ce.flags & 512 && lp(ce);
        } catch (or) {
          li(ce, ce.return, or);
        }
      }
      if (ce === fe) {
        Tr = null;
        break;
      }
      if (Ee = ce.sibling, Ee !== null) {
        Ee.return = ce.return, Tr = Ee;
        break;
      }
      Tr = ce.return;
    }
  }
  function fp(fe) {
    for (; Tr !== null; ) {
      var ce = Tr;
      if (ce === fe) {
        Tr = null;
        break;
      }
      var Ee = ce.sibling;
      if (Ee !== null) {
        Ee.return = ce.return, Tr = Ee;
        break;
      }
      Tr = ce.return;
    }
  }
  function Cv(fe) {
    for (; Tr !== null; ) {
      var ce = Tr;
      try {
        switch (ce.tag) {
          case 0:
          case 11:
          case 15:
            var Ee = ce.return;
            try {
              qf(4, ce);
            } catch (Lt) {
              li(ce, Ee, Lt);
            }
            break;
          case 1:
            var Te = ce.stateNode;
            if (typeof Te.componentDidMount == "function") {
              var nt = ce.return;
              try {
                Te.componentDidMount();
              } catch (Lt) {
                li(ce, nt, Lt);
              }
            }
            var ct = ce.return;
            try {
              lp(ce);
            } catch (Lt) {
              li(ce, ct, Lt);
            }
            break;
          case 5:
            var bt = ce.return;
            try {
              lp(ce);
            } catch (Lt) {
              li(ce, bt, Lt);
            }
        }
      } catch (Lt) {
        li(ce, ce.return, Lt);
      }
      if (ce === fe) {
        Tr = null;
        break;
      }
      var Mt = ce.sibling;
      if (Mt !== null) {
        Mt.return = ce.return, Tr = Mt;
        break;
      }
      Tr = ce.return;
    }
  }
  var Sd = Math.ceil, Yf = vt.ReactCurrentDispatcher, cp = vt.ReactCurrentOwner, ra = vt.ReactCurrentBatchConfig, tn = 0, Yn = null, si = null, Ni = 0, Qa = 0, Nu = Yr(0), Ai = 0, Qf = null, vs = 0, Ed = 0, zu = 0, Vl = null, fa = null, dp = 0, Vu = 1 / 0, ys = null, bd = !1, Bl = null, Wo = null, Ks = !1, Js = null, Cd = 0, Bu = 0, xd = null, Hl = -1, Ul = 0;
  function na() {
    return tn & 6 ? Bn() : Hl !== -1 ? Hl : Hl = Bn();
  }
  function yi(fe) {
    return fe.mode & 1 ? tn & 2 && Ni !== 0 ? Ni & -Ni : jc.transition !== null ? (Ul === 0 && (Ul = hu()), Ul) : (fe = ln, fe !== 0 || (fe = window.event, fe = fe === void 0 ? 16 : ii(fe.type)), fe) : 1;
  }
  function ia(fe, ce, Ee, Te) {
    if (50 < Bu)
      throw Bu = 0, xd = null, Error(oe(185));
    ts(fe, Ee, Te), (!(tn & 2) || fe !== Yn) && (fe === Yn && (!(tn & 2) && (Ed |= Ee), Ai === 4 && yo(fe, Ni)), aa(fe, Te), Ee === 1 && tn === 0 && !(ce.mode & 1) && (Vu = Bn() + 500, Li && Aa()));
  }
  function aa(fe, ce) {
    var Ee = fe.callbackNode;
    du(fe, ce);
    var Te = Ta(fe, fe === Yn ? Ni : 0);
    if (Te === 0)
      Ee !== null && $o(Ee), fe.callbackNode = null, fe.callbackPriority = 0;
    else if (ce = Te & -Te, fe.callbackPriority !== ce) {
      if (Ee != null && $o(Ee), ce === 1)
        fe.tag === 0 ? Nh(xv.bind(null, fe)) : Ih(xv.bind(null, fe)), Oh(function() {
          !(tn & 6) && Aa();
        }), Ee = null;
      else {
        switch (zo(Te)) {
          case 1:
            Ee = To;
            break;
          case 4:
            Ee = Xr;
            break;
          case 16:
            Ee = Io;
            break;
          case 536870912:
            Ee = ro;
            break;
          default:
            Ee = Io;
        }
        Ee = gp(Ee, Hu.bind(null, fe));
      }
      fe.callbackPriority = ce, fe.callbackNode = Ee;
    }
  }
  function Hu(fe, ce) {
    if (Hl = -1, Ul = 0, tn & 6)
      throw Error(oe(327));
    var Ee = fe.callbackNode;
    if (ju() && fe.callbackNode !== Ee)
      return null;
    var Te = Ta(fe, fe === Yn ? Ni : 0);
    if (Te === 0)
      return null;
    if (Te & 30 || Te & fe.expiredLanes || ce)
      ce = wd(fe, Te);
    else {
      ce = Te;
      var nt = tn;
      tn |= 2;
      var ct = Td();
      (Yn !== fe || Ni !== ce) && (ys = null, Vu = Bn() + 500, jl(fe, ce));
      do
        try {
          Og();
          break;
        } catch (Mt) {
          Tv(fe, Mt);
        }
      while (!0);
      jh(), Yf.current = ct, tn = nt, si !== null ? ce = 0 : (Yn = null, Ni = 0, ce = Ai);
    }
    if (ce !== 0) {
      if (ce === 2 && (nt = vf(fe), nt !== 0 && (Te = nt, ce = hp(fe, nt))), ce === 1)
        throw Ee = Qf, jl(fe, 0), yo(fe, Te), aa(fe, Bn()), Ee;
      if (ce === 6)
        yo(fe, Te);
      else {
        if (nt = fe.current.alternate, !(Te & 30) && !pp(nt) && (ce = wd(fe, Te), ce === 2 && (ct = vf(fe), ct !== 0 && (Te = ct, ce = hp(fe, ct))), ce === 1))
          throw Ee = Qf, jl(fe, 0), yo(fe, Te), aa(fe, Bn()), Ee;
        switch (fe.finishedWork = nt, fe.finishedLanes = Te, ce) {
          case 0:
          case 1:
            throw Error(oe(345));
          case 2:
            Gl(fe, fa, ys);
            break;
          case 3:
            if (yo(fe, Te), (Te & 130023424) === Te && (ce = dp + 500 - Bn(), 10 < ce)) {
              if (Ta(fe, 0) !== 0)
                break;
              if (nt = fe.suspendedLanes, (nt & Te) !== Te) {
                na(), fe.pingedLanes |= fe.suspendedLanes & nt;
                break;
              }
              fe.timeoutHandle = wl(Gl.bind(null, fe, fa, ys), ce);
              break;
            }
            Gl(fe, fa, ys);
            break;
          case 4:
            if (yo(fe, Te), (Te & 4194240) === Te)
              break;
            for (ce = fe.eventTimes, nt = -1; 0 < Te; ) {
              var bt = 31 - xa(Te);
              ct = 1 << bt, bt = ce[bt], bt > nt && (nt = bt), Te &= ~ct;
            }
            if (Te = nt, Te = Bn() - Te, Te = (120 > Te ? 120 : 480 > Te ? 480 : 1080 > Te ? 1080 : 1920 > Te ? 1920 : 3e3 > Te ? 3e3 : 4320 > Te ? 4320 : 1960 * Sd(Te / 1960)) - Te, 10 < Te) {
              fe.timeoutHandle = wl(Gl.bind(null, fe, fa, ys), Te);
              break;
            }
            Gl(fe, fa, ys);
            break;
          case 5:
            Gl(fe, fa, ys);
            break;
          default:
            throw Error(oe(329));
        }
      }
    }
    return aa(fe, Bn()), fe.callbackNode === Ee ? Hu.bind(null, fe) : null;
  }
  function hp(fe, ce) {
    var Ee = Vl;
    return fe.current.memoizedState.isDehydrated && (jl(fe, ce).flags |= 256), fe = wd(fe, ce), fe !== 2 && (ce = fa, fa = Ee, ce !== null && Xf(ce)), fe;
  }
  function Xf(fe) {
    fa === null ? fa = fe : fa.push.apply(fa, fe);
  }
  function pp(fe) {
    for (var ce = fe; ; ) {
      if (ce.flags & 16384) {
        var Ee = ce.updateQueue;
        if (Ee !== null && (Ee = Ee.stores, Ee !== null))
          for (var Te = 0; Te < Ee.length; Te++) {
            var nt = Ee[Te], ct = nt.getSnapshot;
            nt = nt.value;
            try {
              if (!oo(ct(), nt))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (Ee = ce.child, ce.subtreeFlags & 16384 && Ee !== null)
        Ee.return = ce, ce = Ee;
      else {
        if (ce === fe)
          break;
        for (; ce.sibling === null; ) {
          if (ce.return === null || ce.return === fe)
            return !0;
          ce = ce.return;
        }
        ce.sibling.return = ce.return, ce = ce.sibling;
      }
    }
    return !0;
  }
  function yo(fe, ce) {
    for (ce &= ~zu, ce &= ~Ed, fe.suspendedLanes |= ce, fe.pingedLanes &= ~ce, fe = fe.expirationTimes; 0 < ce; ) {
      var Ee = 31 - xa(ce), Te = 1 << Ee;
      fe[Ee] = -1, ce &= ~Te;
    }
  }
  function xv(fe) {
    if (tn & 6)
      throw Error(oe(327));
    ju();
    var ce = Ta(fe, 0);
    if (!(ce & 1))
      return aa(fe, Bn()), null;
    var Ee = wd(fe, ce);
    if (fe.tag !== 0 && Ee === 2) {
      var Te = vf(fe);
      Te !== 0 && (ce = Te, Ee = hp(fe, Te));
    }
    if (Ee === 1)
      throw Ee = Qf, jl(fe, 0), yo(fe, ce), aa(fe, Bn()), Ee;
    if (Ee === 6)
      throw Error(oe(345));
    return fe.finishedWork = fe.current.alternate, fe.finishedLanes = ce, Gl(fe, fa, ys), aa(fe, Bn()), null;
  }
  function Uu(fe, ce) {
    var Ee = tn;
    tn |= 1;
    try {
      return fe(ce);
    } finally {
      tn = Ee, tn === 0 && (Vu = Bn() + 500, Li && Aa());
    }
  }
  function Zs(fe) {
    Js !== null && Js.tag === 0 && !(tn & 6) && ju();
    var ce = tn;
    tn |= 1;
    var Ee = ra.transition, Te = ln;
    try {
      if (ra.transition = null, ln = 1, fe)
        return fe();
    } finally {
      ln = Te, ra.transition = Ee, tn = ce, !(tn & 6) && Aa();
    }
  }
  function mp() {
    Qa = Nu.current, hn(Nu);
  }
  function jl(fe, ce) {
    fe.finishedWork = null, fe.finishedLanes = 0;
    var Ee = fe.timeoutHandle;
    if (Ee !== -1 && (fe.timeoutHandle = -1, Km(Ee)), si !== null)
      for (Ee = si.return; Ee !== null; ) {
        var Te = Ee;
        switch (Vh(Te), Te.tag) {
          case 1:
            Te = Te.type.childContextTypes, Te != null && uo();
            break;
          case 3:
            qs(), hn(oi), hn(Hr), Xc();
            break;
          case 5:
            Jr(Te);
            break;
          case 4:
            qs();
            break;
          case 13:
            hn(zr);
            break;
          case 19:
            hn(zr);
            break;
          case 10:
            Us(Te.type._context);
            break;
          case 22:
          case 23:
            mp();
        }
        Ee = Ee.return;
      }
    if (Yn = fe, si = fe = el(fe.current, null), Ni = Qa = ce, Ai = 0, Qf = null, zu = Ed = vs = 0, fa = Vl = null, Ui !== null) {
      for (ce = 0; ce < Ui.length; ce++)
        if (Ee = Ui[ce], Te = Ee.interleaved, Te !== null) {
          Ee.interleaved = null;
          var nt = Te.next, ct = Ee.pending;
          if (ct !== null) {
            var bt = ct.next;
            ct.next = nt, Te.next = bt;
          }
          Ee.pending = Te;
        }
      Ui = null;
    }
    return fe;
  }
  function Tv(fe, ce) {
    do {
      var Ee = si;
      try {
        if (jh(), Kc.current = hd, Vr) {
          for (var Te = Ln.memoizedState; Te !== null; ) {
            var nt = Te.queue;
            nt !== null && (nt.pending = null), Te = Te.next;
          }
          Vr = !1;
        }
        if (kl = 0, an = Zt = Ln = null, Uo = !1, Ya = 0, cp.current = null, Ee === null || Ee.return === null) {
          Ai = 1, Qf = ce, si = null;
          break;
        }
        e: {
          var ct = fe, bt = Ee.return, Mt = Ee, Lt = ce;
          if (ce = Ni, Mt.flags |= 32768, Lt !== null && typeof Lt == "object" && typeof Lt.then == "function") {
            var qt = Lt, sr = Mt, lr = sr.tag;
            if (!(sr.mode & 1) && (lr === 0 || lr === 11 || lr === 15)) {
              var or = sr.alternate;
              or ? (sr.updateQueue = or.updateQueue, sr.memoizedState = or.memoizedState, sr.lanes = or.lanes) : (sr.updateQueue = null, sr.memoizedState = null);
            }
            var Sr = Zh(bt);
            if (Sr !== null) {
              Sr.flags &= -257, ep(Sr, bt, Mt, ct, ce), Sr.mode & 1 && dv(ct, qt, ce), ce = Sr, Lt = qt;
              var wr = ce.updateQueue;
              if (wr === null) {
                var Pr = /* @__PURE__ */ new Set();
                Pr.add(Lt), ce.updateQueue = Pr;
              } else
                wr.add(Lt);
              break e;
            } else {
              if (!(ce & 1)) {
                dv(ct, qt, ce), vp();
                break e;
              }
              Lt = Error(oe(426));
            }
          } else if (On && Mt.mode & 1) {
            var ci = Zh(bt);
            if (ci !== null) {
              !(ci.flags & 65536) && (ci.flags |= 256), ep(ci, bt, Mt, ct, ce), Hh(Mu(Lt, Mt));
              break e;
            }
          }
          ct = Lt = Mu(Lt, Mt), Ai !== 4 && (Ai = 2), Vl === null ? Vl = [ct] : Vl.push(ct), ct = bt;
          do {
            switch (ct.tag) {
              case 3:
                ct.flags |= 65536, ce &= -ce, ct.lanes |= ce;
                var Bt = cv(ct, Lt, ce);
                qh(ct, Bt);
                break e;
              case 1:
                Mt = Lt;
                var It = ct.type, jt = ct.stateNode;
                if (!(ct.flags & 128) && (typeof It.getDerivedStateFromError == "function" || jt !== null && typeof jt.componentDidCatch == "function" && (Wo === null || !Wo.has(jt)))) {
                  ct.flags |= 65536, ce &= -ce, ct.lanes |= ce;
                  var fr = Bf(ct, Mt, ce);
                  qh(ct, fr);
                  break e;
                }
            }
            ct = ct.return;
          } while (ct !== null);
        }
        yp(Ee);
      } catch (kr) {
        ce = kr, si === Ee && Ee !== null && (si = Ee = Ee.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Td() {
    var fe = Yf.current;
    return Yf.current = hd, fe === null ? hd : fe;
  }
  function vp() {
    (Ai === 0 || Ai === 3 || Ai === 2) && (Ai = 4), Yn === null || !(vs & 268435455) && !(Ed & 268435455) || yo(Yn, Ni);
  }
  function wd(fe, ce) {
    var Ee = tn;
    tn |= 2;
    var Te = Td();
    (Yn !== fe || Ni !== ce) && (ys = null, jl(fe, ce));
    do
      try {
        Dg();
        break;
      } catch (nt) {
        Tv(fe, nt);
      }
    while (!0);
    if (jh(), tn = Ee, Yf.current = Te, si !== null)
      throw Error(oe(261));
    return Yn = null, Ni = 0, Ai;
  }
  function Dg() {
    for (; si !== null; )
      wv(si);
  }
  function Og() {
    for (; si !== null && !fh(); )
      wv(si);
  }
  function wv(fe) {
    var ce = Av(fe.alternate, fe, Qa);
    fe.memoizedProps = fe.pendingProps, ce === null ? yp(fe) : si = ce, cp.current = null;
  }
  function yp(fe) {
    var ce = fe;
    do {
      var Ee = ce.alternate;
      if (fe = ce.return, ce.flags & 32768) {
        if (Ee = sp(Ee, ce), Ee !== null) {
          Ee.flags &= 32767, si = Ee;
          return;
        }
        if (fe !== null)
          fe.flags |= 32768, fe.subtreeFlags = 0, fe.deletions = null;
        else {
          Ai = 6, si = null;
          return;
        }
      } else if (Ee = Fg(Ee, ce, Qa), Ee !== null) {
        si = Ee;
        return;
      }
      if (ce = ce.sibling, ce !== null) {
        si = ce;
        return;
      }
      si = ce = fe;
    } while (ce !== null);
    Ai === 0 && (Ai = 5);
  }
  function Gl(fe, ce, Ee) {
    var Te = ln, nt = ra.transition;
    try {
      ra.transition = null, ln = 1, Lg(fe, ce, Ee, Te);
    } finally {
      ra.transition = nt, ln = Te;
    }
    return null;
  }
  function Lg(fe, ce, Ee, Te) {
    do
      ju();
    while (Js !== null);
    if (tn & 6)
      throw Error(oe(327));
    Ee = fe.finishedWork;
    var nt = fe.finishedLanes;
    if (Ee === null)
      return null;
    if (fe.finishedWork = null, fe.finishedLanes = 0, Ee === fe.current)
      throw Error(oe(177));
    fe.callbackNode = null, fe.callbackPriority = 0;
    var ct = Ee.lanes | Ee.childLanes;
    if (hh(fe, ct), fe === Yn && (si = Yn = null, Ni = 0), !(Ee.subtreeFlags & 2064) && !(Ee.flags & 2064) || Ks || (Ks = !0, gp(Io, function() {
      return ju(), null;
    })), ct = (Ee.flags & 15990) !== 0, Ee.subtreeFlags & 15990 || ct) {
      ct = ra.transition, ra.transition = null;
      var bt = ln;
      ln = 1;
      var Mt = tn;
      tn |= 4, cp.current = null, yv(fe, Ee), Sv(Ee, fe), Dc(Tl), zt = !!Fh, Tl = Fh = null, fe.current = Ee, Ev(Ee), ch(), tn = Mt, ln = bt, ra.transition = ct;
    } else
      fe.current = Ee;
    if (Ks && (Ks = !1, Js = fe, Cd = nt), ct = fe.pendingLanes, ct === 0 && (Wo = null), bc(Ee.stateNode), aa(fe, Bn()), ce !== null)
      for (Te = fe.onRecoverableError, Ee = 0; Ee < ce.length; Ee++)
        nt = ce[Ee], Te(nt.value, { componentStack: nt.stack, digest: nt.digest });
    if (bd)
      throw bd = !1, fe = Bl, Bl = null, fe;
    return Cd & 1 && fe.tag !== 0 && ju(), ct = fe.pendingLanes, ct & 1 ? fe === xd ? Bu++ : (Bu = 0, xd = fe) : Bu = 0, Aa(), null;
  }
  function ju() {
    if (Js !== null) {
      var fe = zo(Cd), ce = ra.transition, Ee = ln;
      try {
        if (ra.transition = null, ln = 16 > fe ? 16 : fe, Js === null)
          var Te = !1;
        else {
          if (fe = Js, Js = null, Cd = 0, tn & 6)
            throw Error(oe(331));
          var nt = tn;
          for (tn |= 4, Tr = fe.current; Tr !== null; ) {
            var ct = Tr, bt = ct.child;
            if (Tr.flags & 16) {
              var Mt = ct.deletions;
              if (Mt !== null) {
                for (var Lt = 0; Lt < Mt.length; Lt++) {
                  var qt = Mt[Lt];
                  for (Tr = qt; Tr !== null; ) {
                    var sr = Tr;
                    switch (sr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Wf(8, sr, ct);
                    }
                    var lr = sr.child;
                    if (lr !== null)
                      lr.return = sr, Tr = lr;
                    else
                      for (; Tr !== null; ) {
                        sr = Tr;
                        var or = sr.sibling, Sr = sr.return;
                        if (up(sr), sr === qt) {
                          Tr = null;
                          break;
                        }
                        if (or !== null) {
                          or.return = Sr, Tr = or;
                          break;
                        }
                        Tr = Sr;
                      }
                  }
                }
                var wr = ct.alternate;
                if (wr !== null) {
                  var Pr = wr.child;
                  if (Pr !== null) {
                    wr.child = null;
                    do {
                      var ci = Pr.sibling;
                      Pr.sibling = null, Pr = ci;
                    } while (Pr !== null);
                  }
                }
                Tr = ct;
              }
            }
            if (ct.subtreeFlags & 2064 && bt !== null)
              bt.return = ct, Tr = bt;
            else
              e:
                for (; Tr !== null; ) {
                  if (ct = Tr, ct.flags & 2048)
                    switch (ct.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Wf(9, ct, ct.return);
                    }
                  var Bt = ct.sibling;
                  if (Bt !== null) {
                    Bt.return = ct.return, Tr = Bt;
                    break e;
                  }
                  Tr = ct.return;
                }
          }
          var It = fe.current;
          for (Tr = It; Tr !== null; ) {
            bt = Tr;
            var jt = bt.child;
            if (bt.subtreeFlags & 2064 && jt !== null)
              jt.return = bt, Tr = jt;
            else
              e:
                for (bt = It; Tr !== null; ) {
                  if (Mt = Tr, Mt.flags & 2048)
                    try {
                      switch (Mt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          qf(9, Mt);
                      }
                    } catch (kr) {
                      li(Mt, Mt.return, kr);
                    }
                  if (Mt === bt) {
                    Tr = null;
                    break e;
                  }
                  var fr = Mt.sibling;
                  if (fr !== null) {
                    fr.return = Mt.return, Tr = fr;
                    break e;
                  }
                  Tr = Mt.return;
                }
          }
          if (tn = nt, Aa(), Ha && typeof Ha.onPostCommitFiberRoot == "function")
            try {
              Ha.onPostCommitFiberRoot(pl, fe);
            } catch {
            }
          Te = !0;
        }
        return Te;
      } finally {
        ln = Ee, ra.transition = ce;
      }
    }
    return !1;
  }
  function _v(fe, ce, Ee) {
    ce = Mu(Ee, ce), ce = cv(fe, ce, 1), fe = Gs(fe, ce, 1), ce = na(), fe !== null && (ts(fe, 1, ce), aa(fe, ce));
  }
  function li(fe, ce, Ee) {
    if (fe.tag === 3)
      _v(fe, fe, Ee);
    else
      for (; ce !== null; ) {
        if (ce.tag === 3) {
          _v(ce, fe, Ee);
          break;
        } else if (ce.tag === 1) {
          var Te = ce.stateNode;
          if (typeof ce.type.getDerivedStateFromError == "function" || typeof Te.componentDidCatch == "function" && (Wo === null || !Wo.has(Te))) {
            fe = Mu(Ee, fe), fe = Bf(ce, fe, 1), ce = Gs(ce, fe, 1), fe = na(), ce !== null && (ts(ce, 1, fe), aa(ce, fe));
            break;
          }
        }
        ce = ce.return;
      }
  }
  function $g(fe, ce, Ee) {
    var Te = fe.pingCache;
    Te !== null && Te.delete(ce), ce = na(), fe.pingedLanes |= fe.suspendedLanes & Ee, Yn === fe && (Ni & Ee) === Ee && (Ai === 4 || Ai === 3 && (Ni & 130023424) === Ni && 500 > Bn() - dp ? jl(fe, 0) : zu |= Ee), aa(fe, ce);
  }
  function _d(fe, ce) {
    ce === 0 && (fe.mode & 1 ? (ce = no, no <<= 1, !(no & 130023424) && (no = 4194304)) : ce = 1);
    var Ee = na();
    fe = cs(fe, ce), fe !== null && (ts(fe, ce, Ee), aa(fe, Ee));
  }
  function Ig(fe) {
    var ce = fe.memoizedState, Ee = 0;
    ce !== null && (Ee = ce.retryLane), _d(fe, Ee);
  }
  function Ng(fe, ce) {
    var Ee = 0;
    switch (fe.tag) {
      case 13:
        var Te = fe.stateNode, nt = fe.memoizedState;
        nt !== null && (Ee = nt.retryLane);
        break;
      case 19:
        Te = fe.stateNode;
        break;
      default:
        throw Error(oe(314));
    }
    Te !== null && Te.delete(ce), _d(fe, Ee);
  }
  var Av;
  Av = function(fe, ce, Ee) {
    if (fe !== null)
      if (fe.memoizedProps !== ce.pendingProps || oi.current)
        vi = !0;
      else {
        if (!(fe.lanes & Ee) && !(ce.flags & 128))
          return vi = !1, ps(fe, ce, Ee);
        vi = !!(fe.flags & 131072);
      }
    else
      vi = !1, On && ce.flags & 1048576 && zh(ce, Tu, ce.index);
    switch (ce.lanes = 0, ce.tag) {
      case 2:
        var Te = ce.type;
        ea(fe, ce), fe = ce.pendingProps;
        var nt = lo(ce, Hr.current);
        dr(ce, Ee), nt = Ys(null, ce, Te, fe, nt, Ee);
        var ct = Dl();
        return ce.flags |= 1, typeof nt == "object" && nt !== null && typeof nt.render == "function" && nt.$$typeof === void 0 ? (ce.tag = 1, ce.memoizedState = null, ce.updateQueue = null, Un(Te) ? (ct = !0, zc(ce)) : ct = !1, ce.memoizedState = nt.state !== null && nt.state !== void 0 ? nt.state : null, Wh(ce), nt.updater = qc, ce.stateNode = nt, nt._reactInternals = ce, Yc(ce, Te, fe, Ee), ce = hv(null, ce, Te, !0, ct, Ee)) : (ce.tag = 0, On && ct && Vc(ce), Ti(null, ce, nt, Ee), ce = ce.child), ce;
      case 16:
        Te = ce.elementType;
        e: {
          switch (ea(fe, ce), fe = ce.pendingProps, nt = Te._init, Te = nt(Te._payload), ce.type = Te, nt = ce.tag = Vg(Te), fe = qa(Te, fe), nt) {
            case 0:
              ce = Fu(null, ce, Te, fe, Ee);
              break e;
            case 1:
              ce = tp(null, ce, Te, fe, Ee);
              break e;
            case 11:
              ce = Xs(null, ce, Te, fe, Ee);
              break e;
            case 14:
              ce = md(null, ce, Te, qa(Te.type, fe), Ee);
              break e;
          }
          throw Error(oe(
            306,
            Te,
            ""
          ));
        }
        return ce;
      case 0:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : qa(Te, nt), Fu(fe, ce, Te, nt, Ee);
      case 1:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : qa(Te, nt), tp(fe, ce, Te, nt, Ee);
      case 3:
        e: {
          if (pv(ce), fe === null)
            throw Error(oe(387));
          Te = ce.pendingProps, ct = ce.memoizedState, nt = ct.element, xi(fe, ce), Ws(ce, Te, null, Ee);
          var bt = ce.memoizedState;
          if (Te = bt.element, ct.isDehydrated)
            if (ct = { element: Te, isDehydrated: !1, cache: bt.cache, pendingSuspenseBoundaries: bt.pendingSuspenseBoundaries, transitions: bt.transitions }, ce.updateQueue.baseState = ct, ce.memoizedState = ct, ce.flags & 256) {
              nt = Mu(Error(oe(423)), ce), ce = vd(fe, ce, Te, Ee, nt);
              break e;
            } else if (Te !== nt) {
              nt = Mu(Error(oe(424)), ce), ce = vd(fe, ce, Te, Ee, nt);
              break e;
            } else
              for (ka = Po(ce.stateNode.containerInfo.firstChild), Wa = ce, On = !0, co = null, Ee = uv(ce, null, Te, Ee), ce.child = Ee; Ee; )
                Ee.flags = Ee.flags & -3 | 4096, Ee = Ee.sibling;
          else {
            if (Wn(), Te === nt) {
              ce = ji(fe, ce, Ee);
              break e;
            }
            Ti(fe, ce, Te, Ee);
          }
          ce = ce.child;
        }
        return ce;
      case 5:
        return Nr(ce), fe === null && Hc(ce), Te = ce.type, nt = ce.pendingProps, ct = fe !== null ? fe.memoizedProps : null, bt = nt.children, Rf(Te, nt) ? bt = null : ct !== null && Rf(Te, ct) && (ce.flags |= 32), Qr(fe, ce), Ti(fe, ce, bt, Ee), ce.child;
      case 6:
        return fe === null && Hc(ce), null;
      case 13:
        return np(fe, ce, Ee);
      case 4:
        return Qh(ce, ce.stateNode.containerInfo), Te = ce.pendingProps, fe === null ? ce.child = _u(ce, null, Te, Ee) : Ti(fe, ce, Te, Ee), ce.child;
      case 11:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : qa(Te, nt), Xs(fe, ce, Te, nt, Ee);
      case 7:
        return Ti(fe, ce, ce.pendingProps, Ee), ce.child;
      case 8:
        return Ti(fe, ce, ce.pendingProps.children, Ee), ce.child;
      case 12:
        return Ti(fe, ce, ce.pendingProps.children, Ee), ce.child;
      case 10:
        e: {
          if (Te = ce.type._context, nt = ce.pendingProps, ct = ce.memoizedProps, bt = nt.value, gn(Ho, Te._currentValue), Te._currentValue = bt, ct !== null)
            if (oo(ct.value, bt)) {
              if (ct.children === nt.children && !oi.current) {
                ce = ji(fe, ce, Ee);
                break e;
              }
            } else
              for (ct = ce.child, ct !== null && (ct.return = ce); ct !== null; ) {
                var Mt = ct.dependencies;
                if (Mt !== null) {
                  bt = ct.child;
                  for (var Lt = Mt.firstContext; Lt !== null; ) {
                    if (Lt.context === Te) {
                      if (ct.tag === 1) {
                        Lt = ds(-1, Ee & -Ee), Lt.tag = 2;
                        var qt = ct.updateQueue;
                        if (qt !== null) {
                          qt = qt.shared;
                          var sr = qt.pending;
                          sr === null ? Lt.next = Lt : (Lt.next = sr.next, sr.next = Lt), qt.pending = Lt;
                        }
                      }
                      ct.lanes |= Ee, Lt = ct.alternate, Lt !== null && (Lt.lanes |= Ee), $i(
                        ct.return,
                        Ee,
                        ce
                      ), Mt.lanes |= Ee;
                      break;
                    }
                    Lt = Lt.next;
                  }
                } else if (ct.tag === 10)
                  bt = ct.type === ce.type ? null : ct.child;
                else if (ct.tag === 18) {
                  if (bt = ct.return, bt === null)
                    throw Error(oe(341));
                  bt.lanes |= Ee, Mt = bt.alternate, Mt !== null && (Mt.lanes |= Ee), $i(bt, Ee, ce), bt = ct.sibling;
                } else
                  bt = ct.child;
                if (bt !== null)
                  bt.return = ct;
                else
                  for (bt = ct; bt !== null; ) {
                    if (bt === ce) {
                      bt = null;
                      break;
                    }
                    if (ct = bt.sibling, ct !== null) {
                      ct.return = bt.return, bt = ct;
                      break;
                    }
                    bt = bt.return;
                  }
                ct = bt;
              }
          Ti(fe, ce, nt.children, Ee), ce = ce.child;
        }
        return ce;
      case 9:
        return nt = ce.type, Te = ce.pendingProps.children, dr(ce, Ee), nt = fi(nt), Te = Te(nt), ce.flags |= 1, Ti(fe, ce, Te, Ee), ce.child;
      case 14:
        return Te = ce.type, nt = qa(Te, ce.pendingProps), nt = qa(Te.type, nt), md(fe, ce, Te, nt, Ee);
      case 15:
        return Da(fe, ce, ce.type, ce.pendingProps, Ee);
      case 17:
        return Te = ce.type, nt = ce.pendingProps, nt = ce.elementType === Te ? nt : qa(Te, nt), ea(fe, ce), ce.tag = 1, Un(Te) ? (fe = !0, zc(ce)) : fe = !1, dr(ce, Ee), av(ce, Te, nt), Yc(ce, Te, nt, Ee), hv(null, ce, Te, !0, fe, Ee);
      case 19:
        return op(fe, ce, Ee);
      case 22:
        return Il(fe, ce, Ee);
    }
    throw Error(oe(156, ce.tag));
  };
  function gp(fe, ce) {
    return pf(fe, ce);
  }
  function zg(fe, ce, Ee, Te) {
    this.tag = fe, this.key = Ee, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = ce, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = Te, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function go(fe, ce, Ee, Te) {
    return new zg(fe, ce, Ee, Te);
  }
  function Sp(fe) {
    return fe = fe.prototype, !(!fe || !fe.isReactComponent);
  }
  function Vg(fe) {
    if (typeof fe == "function")
      return Sp(fe) ? 1 : 0;
    if (fe != null) {
      if (fe = fe.$$typeof, fe === Yt)
        return 11;
      if (fe === Qt)
        return 14;
    }
    return 2;
  }
  function el(fe, ce) {
    var Ee = fe.alternate;
    return Ee === null ? (Ee = go(fe.tag, ce, fe.key, fe.mode), Ee.elementType = fe.elementType, Ee.type = fe.type, Ee.stateNode = fe.stateNode, Ee.alternate = fe, fe.alternate = Ee) : (Ee.pendingProps = ce, Ee.type = fe.type, Ee.flags = 0, Ee.subtreeFlags = 0, Ee.deletions = null), Ee.flags = fe.flags & 14680064, Ee.childLanes = fe.childLanes, Ee.lanes = fe.lanes, Ee.child = fe.child, Ee.memoizedProps = fe.memoizedProps, Ee.memoizedState = fe.memoizedState, Ee.updateQueue = fe.updateQueue, ce = fe.dependencies, Ee.dependencies = ce === null ? null : { lanes: ce.lanes, firstContext: ce.firstContext }, Ee.sibling = fe.sibling, Ee.index = fe.index, Ee.ref = fe.ref, Ee;
  }
  function Ad(fe, ce, Ee, Te, nt, ct) {
    var bt = 2;
    if (Te = fe, typeof fe == "function")
      Sp(fe) && (bt = 1);
    else if (typeof fe == "string")
      bt = 5;
    else
      e:
        switch (fe) {
          case At:
            return Wl(Ee.children, nt, ct, ce);
          case kt:
            bt = 8, nt |= 8;
            break;
          case Vt:
            return fe = go(12, Ee, ce, nt | 2), fe.elementType = Vt, fe.lanes = ct, fe;
          case Jt:
            return fe = go(13, Ee, ce, nt), fe.elementType = Jt, fe.lanes = ct, fe;
          case rr:
            return fe = go(19, Ee, ce, nt), fe.elementType = rr, fe.lanes = ct, fe;
          case Ft:
            return Kf(Ee, nt, ct, ce);
          default:
            if (typeof fe == "object" && fe !== null)
              switch (fe.$$typeof) {
                case ir:
                  bt = 10;
                  break e;
                case er:
                  bt = 9;
                  break e;
                case Yt:
                  bt = 11;
                  break e;
                case Qt:
                  bt = 14;
                  break e;
                case wt:
                  bt = 16, Te = null;
                  break e;
              }
            throw Error(oe(130, fe == null ? fe : typeof fe, ""));
        }
    return ce = go(bt, Ee, ce, nt), ce.elementType = fe, ce.type = Te, ce.lanes = ct, ce;
  }
  function Wl(fe, ce, Ee, Te) {
    return fe = go(7, fe, Te, ce), fe.lanes = Ee, fe;
  }
  function Kf(fe, ce, Ee, Te) {
    return fe = go(22, fe, Te, ce), fe.elementType = Ft, fe.lanes = Ee, fe.stateNode = { isHidden: !1 }, fe;
  }
  function Jf(fe, ce, Ee) {
    return fe = go(6, fe, null, ce), fe.lanes = Ee, fe;
  }
  function ql(fe, ce, Ee) {
    return ce = go(4, fe.children !== null ? fe.children : [], fe.key, ce), ce.lanes = Ee, ce.stateNode = { containerInfo: fe.containerInfo, pendingChildren: null, implementation: fe.implementation }, ce;
  }
  function Bg(fe, ce, Ee, Te, nt) {
    this.tag = ce, this.containerInfo = fe, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = pu(0), this.expirationTimes = pu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = pu(0), this.identifierPrefix = Te, this.onRecoverableError = nt, this.mutableSourceEagerHydrationData = null;
  }
  function Pd(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    return fe = new Bg(fe, ce, Ee, Mt, Lt), ce === 1 ? (ce = 1, ct === !0 && (ce |= 8)) : ce = 0, ct = go(3, null, null, ce), fe.current = ct, ct.stateNode = fe, ct.memoizedState = { element: Te, isDehydrated: Ee, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Wh(ct), fe;
  }
  function Pv(fe, ce, Ee) {
    var Te = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: xt, key: Te == null ? null : "" + Te, children: fe, containerInfo: ce, implementation: Ee };
  }
  function Ep(fe) {
    if (!fe)
      return Bo;
    fe = fe._reactInternals;
    e: {
      if (to(fe) !== fe || fe.tag !== 1)
        throw Error(oe(170));
      var ce = fe;
      do {
        switch (ce.tag) {
          case 3:
            ce = ce.stateNode.context;
            break e;
          case 1:
            if (Un(ce.type)) {
              ce = ce.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        ce = ce.return;
      } while (ce !== null);
      throw Error(oe(171));
    }
    if (fe.tag === 1) {
      var Ee = fe.type;
      if (Un(Ee))
        return Ff(fe, Ee, ce);
    }
    return ce;
  }
  function Rv(fe, ce, Ee, Te, nt, ct, bt, Mt, Lt) {
    return fe = Pd(Ee, Te, !0, fe, nt, ct, bt, Mt, Lt), fe.context = Ep(null), Ee = fe.current, Te = na(), nt = yi(Ee), ct = ds(Te, nt), ct.callback = ce ?? null, Gs(Ee, ct, nt), fe.current.lanes = nt, ts(fe, nt, Te), aa(fe, Te), fe;
  }
  function Zf(fe, ce, Ee, Te) {
    var nt = ce.current, ct = na(), bt = yi(nt);
    return Ee = Ep(Ee), ce.context === null ? ce.context = Ee : ce.pendingContext = Ee, ce = ds(ct, bt), ce.payload = { element: fe }, Te = Te === void 0 ? null : Te, Te !== null && (ce.callback = Te), fe = Gs(nt, ce, bt), fe !== null && (ia(fe, nt, bt, ct), Wc(fe, nt, bt)), bt;
  }
  function Rd(fe) {
    if (fe = fe.current, !fe.child)
      return null;
    switch (fe.child.tag) {
      case 5:
        return fe.child.stateNode;
      default:
        return fe.child.stateNode;
    }
  }
  function kv(fe, ce) {
    if (fe = fe.memoizedState, fe !== null && fe.dehydrated !== null) {
      var Ee = fe.retryLane;
      fe.retryLane = Ee !== 0 && Ee < ce ? Ee : ce;
    }
  }
  function bp(fe, ce) {
    kv(fe, ce), (fe = fe.alternate) && kv(fe, ce);
  }
  function Mv() {
    return null;
  }
  var Cp = typeof reportError == "function" ? reportError : function(fe) {
    console.error(fe);
  };
  function kd(fe) {
    this._internalRoot = fe;
  }
  gs.prototype.render = kd.prototype.render = function(fe) {
    var ce = this._internalRoot;
    if (ce === null)
      throw Error(oe(409));
    Zf(fe, ce, null, null);
  }, gs.prototype.unmount = kd.prototype.unmount = function() {
    var fe = this._internalRoot;
    if (fe !== null) {
      this._internalRoot = null;
      var ce = fe.containerInfo;
      Zs(function() {
        Zf(null, fe, null, null);
      }), ce[us] = null;
    }
  };
  function gs(fe) {
    this._internalRoot = fe;
  }
  gs.prototype.unstable_scheduleHydration = function(fe) {
    if (fe) {
      var ce = wc();
      fe = { blockedOn: null, target: fe, priority: ce };
      for (var Ee = 0; Ee < vn.length && ce !== 0 && ce < vn[Ee].priority; Ee++)
        ;
      vn.splice(Ee, 0, fe), Ee === 0 && Sf(fe);
    }
  };
  function xp(fe) {
    return !(!fe || fe.nodeType !== 1 && fe.nodeType !== 9 && fe.nodeType !== 11);
  }
  function Md(fe) {
    return !(!fe || fe.nodeType !== 1 && fe.nodeType !== 9 && fe.nodeType !== 11 && (fe.nodeType !== 8 || fe.nodeValue !== " react-mount-point-unstable "));
  }
  function Fv() {
  }
  function Hg(fe, ce, Ee, Te, nt) {
    if (nt) {
      if (typeof Te == "function") {
        var ct = Te;
        Te = function() {
          var qt = Rd(bt);
          ct.call(qt);
        };
      }
      var bt = Rv(ce, Te, fe, 0, null, !1, !1, "", Fv);
      return fe._reactRootContainer = bt, fe[us] = bt.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), Zs(), bt;
    }
    for (; nt = fe.lastChild; )
      fe.removeChild(nt);
    if (typeof Te == "function") {
      var Mt = Te;
      Te = function() {
        var qt = Rd(Lt);
        Mt.call(qt);
      };
    }
    var Lt = Pd(fe, 0, !1, null, null, !1, !1, "", Fv);
    return fe._reactRootContainer = Lt, fe[us] = Lt.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), Zs(function() {
      Zf(ce, Lt, Ee, Te);
    }), Lt;
  }
  function Fd(fe, ce, Ee, Te, nt) {
    var ct = Ee._reactRootContainer;
    if (ct) {
      var bt = ct;
      if (typeof nt == "function") {
        var Mt = nt;
        nt = function() {
          var Lt = Rd(bt);
          Mt.call(Lt);
        };
      }
      Zf(ce, bt, fe, nt);
    } else
      bt = Hg(Ee, ce, fe, nt, Te);
    return Rd(bt);
  }
  Tc = function(fe) {
    switch (fe.tag) {
      case 3:
        var ce = fe.stateNode;
        if (ce.current.memoizedState.isDehydrated) {
          var Ee = No(ce.pendingLanes);
          Ee !== 0 && (Os(ce, Ee | 1), aa(ce, Bn()), !(tn & 6) && (Vu = Bn() + 500, Aa()));
        }
        break;
      case 13:
        Zs(function() {
          var Te = cs(fe, 1);
          if (Te !== null) {
            var nt = na();
            ia(Te, fe, 1, nt);
          }
        }), bp(fe, 1);
    }
  }, mu = function(fe) {
    if (fe.tag === 13) {
      var ce = cs(fe, 134217728);
      if (ce !== null) {
        var Ee = na();
        ia(ce, fe, 134217728, Ee);
      }
      bp(fe, 134217728);
    }
  }, nn = function(fe) {
    if (fe.tag === 13) {
      var ce = yi(fe), Ee = cs(fe, ce);
      if (Ee !== null) {
        var Te = na();
        ia(Ee, fe, ce, Te);
      }
      bp(fe, ce);
    }
  }, wc = function() {
    return ln;
  }, yf = function(fe, ce) {
    var Ee = ln;
    try {
      return ln = fe, ce();
    } finally {
      ln = Ee;
    }
  }, Va = function(fe, ce, Ee) {
    switch (ce) {
      case "input":
        if (Mn(fe, Ee), ce = Ee.name, Ee.type === "radio" && ce != null) {
          for (Ee = fe; Ee.parentNode; )
            Ee = Ee.parentNode;
          for (Ee = Ee.querySelectorAll("input[name=" + JSON.stringify("" + ce) + '][type="radio"]'), ce = 0; ce < Ee.length; ce++) {
            var Te = Ee[ce];
            if (Te !== fe && Te.form === fe.form) {
              var nt = Or(Te);
              if (!nt)
                throw Error(oe(90));
              en(Te), Mn(Te, nt);
            }
          }
        }
        break;
      case "textarea":
        Zn(fe, Ee);
        break;
      case "select":
        ce = Ee.value, ce != null && Fn(fe, !!Ee.multiple, ce, !1);
    }
  }, su = Uu, lu = Zs;
  var Ug = { usingClientEntryPoint: !1, Events: [Mf, xu, Or, Oo, ks, Uu] }, Gu = { findFiberByHostInstance: so, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, jg = { bundleType: Gu.bundleType, version: Gu.version, rendererPackageName: Gu.rendererPackageName, rendererConfig: Gu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: vt.ReactCurrentDispatcher, findHostInstanceByFiber: function(fe) {
    return fe = gc(fe), fe === null ? null : fe.stateNode;
  }, findFiberByHostInstance: Gu.findFiberByHostInstance || Mv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Dd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Dd.isDisabled && Dd.supportsFiber)
      try {
        pl = Dd.inject(jg), Ha = Dd;
      } catch {
      }
  }
  return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ug, reactDom_production_min.createPortal = function(fe, ce) {
    var Ee = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!xp(ce))
      throw Error(oe(200));
    return Pv(fe, ce, null, Ee);
  }, reactDom_production_min.createRoot = function(fe, ce) {
    if (!xp(fe))
      throw Error(oe(299));
    var Ee = !1, Te = "", nt = Cp;
    return ce != null && (ce.unstable_strictMode === !0 && (Ee = !0), ce.identifierPrefix !== void 0 && (Te = ce.identifierPrefix), ce.onRecoverableError !== void 0 && (nt = ce.onRecoverableError)), ce = Pd(fe, 1, !1, null, null, Ee, !1, Te, nt), fe[us] = ce.current, Cu(fe.nodeType === 8 ? fe.parentNode : fe), new kd(ce);
  }, reactDom_production_min.findDOMNode = function(fe) {
    if (fe == null)
      return null;
    if (fe.nodeType === 1)
      return fe;
    var ce = fe._reactInternals;
    if (ce === void 0)
      throw typeof fe.render == "function" ? Error(oe(188)) : (fe = Object.keys(fe).join(","), Error(oe(268, fe)));
    return fe = gc(ce), fe = fe === null ? null : fe.stateNode, fe;
  }, reactDom_production_min.flushSync = function(fe) {
    return Zs(fe);
  }, reactDom_production_min.hydrate = function(fe, ce, Ee) {
    if (!Md(ce))
      throw Error(oe(200));
    return Fd(null, fe, ce, !0, Ee);
  }, reactDom_production_min.hydrateRoot = function(fe, ce, Ee) {
    if (!xp(fe))
      throw Error(oe(405));
    var Te = Ee != null && Ee.hydratedSources || null, nt = !1, ct = "", bt = Cp;
    if (Ee != null && (Ee.unstable_strictMode === !0 && (nt = !0), Ee.identifierPrefix !== void 0 && (ct = Ee.identifierPrefix), Ee.onRecoverableError !== void 0 && (bt = Ee.onRecoverableError)), ce = Rv(ce, null, fe, 1, Ee ?? null, nt, !1, ct, bt), fe[us] = ce.current, Cu(fe), Te)
      for (fe = 0; fe < Te.length; fe++)
        Ee = Te[fe], nt = Ee._getVersion, nt = nt(Ee._source), ce.mutableSourceEagerHydrationData == null ? ce.mutableSourceEagerHydrationData = [Ee, nt] : ce.mutableSourceEagerHydrationData.push(
          Ee,
          nt
        );
    return new gs(ce);
  }, reactDom_production_min.render = function(fe, ce, Ee) {
    if (!Md(ce))
      throw Error(oe(200));
    return Fd(null, fe, ce, !1, Ee);
  }, reactDom_production_min.unmountComponentAtNode = function(fe) {
    if (!Md(fe))
      throw Error(oe(40));
    return fe._reactRootContainer ? (Zs(function() {
      Fd(null, null, fe, !1, function() {
        fe._reactRootContainer = null, fe[us] = null;
      });
    }), !0) : !1;
  }, reactDom_production_min.unstable_batchedUpdates = Uu, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(fe, ce, Ee, Te) {
    if (!Md(Ee))
      throw Error(oe(200));
    if (fe == null || fe._reactInternals === void 0)
      throw Error(oe(38));
    return Fd(fe, ce, Ee, !1, Te);
  }, reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608", reactDom_production_min;
}
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (L) {
      console.error(L);
    }
  }
}
process.env.NODE_ENV === "production" ? (checkDCE(), reactDom.exports = requireReactDom_production_min()) : reactDom.exports = requireReactDom_development();
var reactDomExports = reactDom.exports, i$3 = Object.defineProperty, d$5 = (L, ne, oe) => ne in L ? i$3(L, ne, { enumerable: !0, configurable: !0, writable: !0, value: oe }) : L[ne] = oe, r$3 = (L, ne, oe) => (d$5(L, typeof ne != "symbol" ? ne + "" : ne, oe), oe);
let o$5 = class {
  constructor() {
    r$3(this, "current", this.detect()), r$3(this, "handoffState", "pending"), r$3(this, "currentId", 0);
  }
  set(ne) {
    this.current !== ne && (this.handoffState = "pending", this.currentId = 0, this.current = ne);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$8 = new o$5(), l$5 = (L, ne) => {
  s$8.isServer ? useEffect(L, ne) : useLayoutEffect(L, ne);
};
function s$7(L) {
  let ne = useRef(L);
  return l$5(() => {
    ne.current = L;
  }, [L]), ne;
}
let o$4 = function(L) {
  let ne = s$7(L);
  return React__default.useCallback((...oe) => ne.current(...oe), [ne]);
};
function t$6(L) {
  typeof queueMicrotask == "function" ? queueMicrotask(L) : Promise.resolve().then(L).catch((ne) => setTimeout(() => {
    throw ne;
  }));
}
function o$3() {
  let L = [], ne = { addEventListener(oe, pe, me, ge) {
    return oe.addEventListener(pe, me, ge), ne.add(() => oe.removeEventListener(pe, me, ge));
  }, requestAnimationFrame(...oe) {
    let pe = requestAnimationFrame(...oe);
    return ne.add(() => cancelAnimationFrame(pe));
  }, nextFrame(...oe) {
    return ne.requestAnimationFrame(() => ne.requestAnimationFrame(...oe));
  }, setTimeout(...oe) {
    let pe = setTimeout(...oe);
    return ne.add(() => clearTimeout(pe));
  }, microTask(...oe) {
    let pe = { current: !0 };
    return t$6(() => {
      pe.current && oe[0]();
    }), ne.add(() => {
      pe.current = !1;
    });
  }, style(oe, pe, me) {
    let ge = oe.style.getPropertyValue(pe);
    return Object.assign(oe.style, { [pe]: me }), this.add(() => {
      Object.assign(oe.style, { [pe]: ge });
    });
  }, group(oe) {
    let pe = o$3();
    return oe(pe), this.add(() => pe.dispose());
  }, add(oe) {
    return L.push(oe), () => {
      let pe = L.indexOf(oe);
      if (pe >= 0)
        for (let me of L.splice(pe, 1))
          me();
    };
  }, dispose() {
    for (let oe of L.splice(0))
      oe();
  } };
  return ne;
}
function p$3() {
  let [L] = useState(o$3);
  return useEffect(() => () => L.dispose(), [L]), L;
}
function s$6() {
  let L = typeof document > "u";
  return "useSyncExternalStore" in React ? ((ne) => ne.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !L) : !1;
}
function l$4() {
  let L = s$6(), [ne, oe] = React.useState(s$8.isHandoffComplete);
  return ne && s$8.isHandoffComplete === !1 && oe(!1), React.useEffect(() => {
    ne !== !0 && oe(!0);
  }, [ne]), React.useEffect(() => s$8.handoff(), []), L ? !1 : ne;
}
var o$2;
let I$6 = (o$2 = React__default.useId) != null ? o$2 : function() {
  let L = l$4(), [ne, oe] = React__default.useState(L ? () => s$8.nextId() : null);
  return l$5(() => {
    ne === null && oe(s$8.nextId());
  }, [ne]), ne != null ? "" + ne : void 0;
};
function u$4(L, ne, ...oe) {
  if (L in ne) {
    let me = ne[L];
    return typeof me == "function" ? me(...oe) : me;
  }
  let pe = new Error(`Tried to handle "${L}" but there is no handler defined. Only defined handlers are: ${Object.keys(ne).map((me) => `"${me}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(pe, u$4), pe;
}
function o$1(L) {
  return s$8.isServer ? null : L instanceof Node ? L.ownerDocument : L != null && L.hasOwnProperty("current") && L.current instanceof Node ? L.current.ownerDocument : document;
}
let c$4 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((L) => `${L}:not([tabindex='-1'])`).join(",");
var M$3 = ((L) => (L[L.First = 1] = "First", L[L.Previous = 2] = "Previous", L[L.Next = 4] = "Next", L[L.Last = 8] = "Last", L[L.WrapAround = 16] = "WrapAround", L[L.NoScroll = 32] = "NoScroll", L))(M$3 || {}), N$4 = ((L) => (L[L.Error = 0] = "Error", L[L.Overflow = 1] = "Overflow", L[L.Success = 2] = "Success", L[L.Underflow = 3] = "Underflow", L))(N$4 || {}), F$3 = ((L) => (L[L.Previous = -1] = "Previous", L[L.Next = 1] = "Next", L))(F$3 || {});
function f$6(L = document.body) {
  return L == null ? [] : Array.from(L.querySelectorAll(c$4)).sort((ne, oe) => Math.sign((ne.tabIndex || Number.MAX_SAFE_INTEGER) - (oe.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$1 = ((L) => (L[L.Strict = 0] = "Strict", L[L.Loose = 1] = "Loose", L))(T$1 || {});
function h$2(L, ne = 0) {
  var oe;
  return L === ((oe = o$1(L)) == null ? void 0 : oe.body) ? !1 : u$4(ne, { 0() {
    return L.matches(c$4);
  }, 1() {
    let pe = L;
    for (; pe !== null; ) {
      if (pe.matches(c$4))
        return !0;
      pe = pe.parentElement;
    }
    return !1;
  } });
}
var w$2 = ((L) => (L[L.Keyboard = 0] = "Keyboard", L[L.Mouse = 1] = "Mouse", L))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (L) => {
  L.metaKey || L.altKey || L.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (L) => {
  L.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : L.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(L) {
  L == null || L.focus({ preventScroll: !0 });
}
let S$6 = ["textarea", "input"].join(",");
function H$1(L) {
  var ne, oe;
  return (oe = (ne = L == null ? void 0 : L.matches) == null ? void 0 : ne.call(L, S$6)) != null ? oe : !1;
}
function I$5(L, ne = (oe) => oe) {
  return L.slice().sort((oe, pe) => {
    let me = ne(oe), ge = ne(pe);
    if (me === null || ge === null)
      return 0;
    let be = me.compareDocumentPosition(ge);
    return be & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : be & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function O$1(L, ne, { sorted: oe = !0, relativeTo: pe = null, skipElements: me = [] } = {}) {
  let ge = Array.isArray(L) ? L.length > 0 ? L[0].ownerDocument : document : L.ownerDocument, be = Array.isArray(L) ? oe ? I$5(L) : L : f$6(L);
  me.length > 0 && be.length > 1 && (be = be.filter((pt) => !me.includes(pt))), pe = pe ?? ge.activeElement;
  let Ie = (() => {
    if (ne & 5)
      return 1;
    if (ne & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ae = (() => {
    if (ne & 1)
      return 0;
    if (ne & 2)
      return Math.max(0, be.indexOf(pe)) - 1;
    if (ne & 4)
      return Math.max(0, be.indexOf(pe)) + 1;
    if (ne & 8)
      return be.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), rt = ne & 32 ? { preventScroll: !0 } : {}, st = 0, dt = be.length, lt;
  do {
    if (st >= dt || st + dt <= 0)
      return 0;
    let pt = Ae + st;
    if (ne & 16)
      pt = (pt + dt) % dt;
    else {
      if (pt < 0)
        return 3;
      if (pt >= dt)
        return 1;
    }
    lt = be[pt], lt == null || lt.focus(rt), st += Ie;
  } while (lt !== ge.activeElement);
  return ne & 6 && H$1(lt) && lt.select(), 2;
}
function t$5() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$2() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$5() || i$2();
}
function d$4(L, ne, oe) {
  let pe = s$7(ne);
  useEffect(() => {
    function me(ge) {
      pe.current(ge);
    }
    return document.addEventListener(L, me, oe), () => document.removeEventListener(L, me, oe);
  }, [L, oe]);
}
function s$5(L, ne, oe) {
  let pe = s$7(ne);
  useEffect(() => {
    function me(ge) {
      pe.current(ge);
    }
    return window.addEventListener(L, me, oe), () => window.removeEventListener(L, me, oe);
  }, [L, oe]);
}
function y$2(L, ne, oe = !0) {
  let pe = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      pe.current = oe;
    });
  }, [oe]);
  function me(be, Ie) {
    if (!pe.current || be.defaultPrevented)
      return;
    let Ae = Ie(be);
    if (Ae === null || !Ae.getRootNode().contains(Ae) || !Ae.isConnected)
      return;
    let rt = function st(dt) {
      return typeof dt == "function" ? st(dt()) : Array.isArray(dt) || dt instanceof Set ? dt : [dt];
    }(L);
    for (let st of rt) {
      if (st === null)
        continue;
      let dt = st instanceof HTMLElement ? st : st.current;
      if (dt != null && dt.contains(Ae) || be.composed && be.composedPath().includes(dt))
        return;
    }
    return !h$2(Ae, T$1.Loose) && Ae.tabIndex !== -1 && be.preventDefault(), ne(be, Ae);
  }
  let ge = useRef(null);
  d$4("pointerdown", (be) => {
    var Ie, Ae;
    pe.current && (ge.current = ((Ae = (Ie = be.composedPath) == null ? void 0 : Ie.call(be)) == null ? void 0 : Ae[0]) || be.target);
  }, !0), d$4("mousedown", (be) => {
    var Ie, Ae;
    pe.current && (ge.current = ((Ae = (Ie = be.composedPath) == null ? void 0 : Ie.call(be)) == null ? void 0 : Ae[0]) || be.target);
  }, !0), d$4("click", (be) => {
    n$3() || ge.current && (me(be, () => ge.current), ge.current = null);
  }, !0), d$4("touchend", (be) => me(be, () => be.target instanceof HTMLElement ? be.target : null), !0), s$5("blur", (be) => me(be, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...L) {
  return useMemo(() => o$1(...L), [...L]);
}
let u$3 = Symbol();
function T(L, ne = !0) {
  return Object.assign(L, { [u$3]: ne });
}
function y$1(...L) {
  let ne = useRef(L);
  useEffect(() => {
    ne.current = L;
  }, [L]);
  let oe = o$4((pe) => {
    for (let me of ne.current)
      me != null && (typeof me == "function" ? me(pe) : me.current = pe);
  });
  return L.every((pe) => pe == null || (pe == null ? void 0 : pe[u$3])) ? void 0 : oe;
}
function m$2(L, ne) {
  let oe = useRef([]), pe = o$4(L);
  useEffect(() => {
    let me = [...oe.current];
    for (let [ge, be] of ne.entries())
      if (oe.current[ge] !== be) {
        let Ie = pe(ne, me);
        return oe.current = ne, Ie;
      }
  }, [pe, ...ne]);
}
function t$4(...L) {
  return Array.from(new Set(L.flatMap((ne) => typeof ne == "string" ? ne.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((L) => (L[L.None = 0] = "None", L[L.RenderStrategy = 1] = "RenderStrategy", L[L.Static = 2] = "Static", L))(O || {}), v$2 = ((L) => (L[L.Unmount = 0] = "Unmount", L[L.Hidden = 1] = "Hidden", L))(v$2 || {});
function C$1({ ourProps: L, theirProps: ne, slot: oe, defaultTag: pe, features: me, visible: ge = !0, name: be, mergeRefs: Ie }) {
  Ie = Ie ?? k$1;
  let Ae = R$1(ne, L);
  if (ge)
    return m$1(Ae, oe, pe, be, Ie);
  let rt = me ?? 0;
  if (rt & 2) {
    let { static: st = !1, ...dt } = Ae;
    if (st)
      return m$1(dt, oe, pe, be, Ie);
  }
  if (rt & 1) {
    let { unmount: st = !0, ...dt } = Ae;
    return u$4(st ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...dt, hidden: !0, style: { display: "none" } }, oe, pe, be, Ie);
    } });
  }
  return m$1(Ae, oe, pe, be, Ie);
}
function m$1(L, ne = {}, oe, pe, me) {
  let { as: ge = oe, children: be, refName: Ie = "ref", ...Ae } = F$2(L, ["unmount", "static"]), rt = L.ref !== void 0 ? { [Ie]: L.ref } : {}, st = typeof be == "function" ? be(ne) : be;
  "className" in Ae && Ae.className && typeof Ae.className == "function" && (Ae.className = Ae.className(ne));
  let dt = {};
  if (ne) {
    let lt = !1, pt = [];
    for (let [it, ut] of Object.entries(ne))
      typeof ut == "boolean" && (lt = !0), ut === !0 && pt.push(it);
    lt && (dt["data-headlessui-state"] = pt.join(" "));
  }
  if (ge === Fragment && Object.keys(x$1(Ae)).length > 0) {
    if (!isValidElement(st) || Array.isArray(st) && st.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${pe} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(Ae).map((ut) => `  - ${ut}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((ut) => `  - ${ut}`).join(`
`)].join(`
`));
    let lt = st.props, pt = typeof (lt == null ? void 0 : lt.className) == "function" ? (...ut) => t$4(lt == null ? void 0 : lt.className(...ut), Ae.className) : t$4(lt == null ? void 0 : lt.className, Ae.className), it = pt ? { className: pt } : {};
    return cloneElement(st, Object.assign({}, R$1(st.props, x$1(F$2(Ae, ["ref"]))), dt, rt, { ref: me(st.ref, rt.ref) }, it));
  }
  return createElement(ge, Object.assign({}, F$2(Ae, ["ref"]), ge !== Fragment && rt, ge !== Fragment && dt), st);
}
function k$1(...L) {
  return L.every((ne) => ne == null) ? void 0 : (ne) => {
    for (let oe of L)
      oe != null && (typeof oe == "function" ? oe(ne) : oe.current = ne);
  };
}
function R$1(...L) {
  if (L.length === 0)
    return {};
  if (L.length === 1)
    return L[0];
  let ne = {}, oe = {};
  for (let pe of L)
    for (let me in pe)
      me.startsWith("on") && typeof pe[me] == "function" ? (oe[me] != null || (oe[me] = []), oe[me].push(pe[me])) : ne[me] = pe[me];
  if (ne.disabled || ne["aria-disabled"])
    return Object.assign(ne, Object.fromEntries(Object.keys(oe).map((pe) => [pe, void 0])));
  for (let pe in oe)
    Object.assign(ne, { [pe](me, ...ge) {
      let be = oe[pe];
      for (let Ie of be) {
        if ((me instanceof Event || (me == null ? void 0 : me.nativeEvent) instanceof Event) && me.defaultPrevented)
          return;
        Ie(me, ...ge);
      }
    } });
  return ne;
}
function U$2(L) {
  var ne;
  return Object.assign(forwardRef(L), { displayName: (ne = L.displayName) != null ? ne : L.name });
}
function x$1(L) {
  let ne = Object.assign({}, L);
  for (let oe in ne)
    ne[oe] === void 0 && delete ne[oe];
  return ne;
}
function F$2(L, ne = []) {
  let oe = Object.assign({}, L);
  for (let pe of ne)
    pe in oe && delete oe[pe];
  return oe;
}
let p$2 = "div";
var s$4 = ((L) => (L[L.None = 1] = "None", L[L.Focusable = 2] = "Focusable", L[L.Hidden = 4] = "Hidden", L))(s$4 || {});
function l$3(L, ne) {
  var oe;
  let { features: pe = 1, ...me } = L, ge = { ref: ne, "aria-hidden": (pe & 2) === 2 ? !0 : (oe = me["aria-hidden"]) != null ? oe : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(pe & 4) === 4 && (pe & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: ge, theirProps: me, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let f$5 = U$2(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((L) => (L[L.Open = 1] = "Open", L[L.Closed = 2] = "Closed", L[L.Closing = 4] = "Closing", L[L.Opening = 8] = "Opening", L))(d$3 || {});
function u$2() {
  return useContext(n$1);
}
function s$3({ value: L, children: ne }) {
  return React__default.createElement(n$1.Provider, { value: L }, ne);
}
function t$3(L) {
  function ne() {
    document.readyState !== "loading" && (L(), document.removeEventListener("DOMContentLoaded", ne));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", ne), ne());
}
let t$2 = [];
t$3(() => {
  function L(ne) {
    ne.target instanceof HTMLElement && ne.target !== document.body && t$2[0] !== ne.target && (t$2.unshift(ne.target), t$2 = t$2.filter((oe) => oe != null && oe.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", L, { capture: !0 }), window.addEventListener("mousedown", L, { capture: !0 }), window.addEventListener("focus", L, { capture: !0 }), document.body.addEventListener("click", L, { capture: !0 }), document.body.addEventListener("mousedown", L, { capture: !0 }), document.body.addEventListener("focus", L, { capture: !0 });
});
function r$2(L) {
  let ne = L.parentElement, oe = null;
  for (; ne && !(ne instanceof HTMLFieldSetElement); )
    ne instanceof HTMLLegendElement && (oe = ne), ne = ne.parentElement;
  let pe = (ne == null ? void 0 : ne.getAttribute("disabled")) === "";
  return pe && i$1(oe) ? !1 : pe;
}
function i$1(L) {
  if (!L)
    return !1;
  let ne = L.previousElementSibling;
  for (; ne !== null; ) {
    if (ne instanceof HTMLLegendElement)
      return !1;
    ne = ne.previousElementSibling;
  }
  return !0;
}
var o = ((L) => (L.Space = " ", L.Enter = "Enter", L.Escape = "Escape", L.Backspace = "Backspace", L.Delete = "Delete", L.ArrowLeft = "ArrowLeft", L.ArrowUp = "ArrowUp", L.ArrowRight = "ArrowRight", L.ArrowDown = "ArrowDown", L.Home = "Home", L.End = "End", L.PageUp = "PageUp", L.PageDown = "PageDown", L.Tab = "Tab", L))(o || {});
function E(L, ne, oe, pe) {
  let me = s$7(oe);
  useEffect(() => {
    L = L ?? window;
    function ge(be) {
      me.current(be);
    }
    return L.addEventListener(ne, ge, pe), () => L.removeEventListener(ne, ge, pe);
  }, [L, ne, pe]);
}
function f$4() {
  let L = useRef(!1);
  return l$5(() => (L.current = !0, () => {
    L.current = !1;
  }), []), L;
}
function c$3(L) {
  let ne = o$4(L), oe = useRef(!1);
  useEffect(() => (oe.current = !1, () => {
    oe.current = !0, t$6(() => {
      oe.current && ne();
    });
  }), [ne]);
}
var s$2 = ((L) => (L[L.Forwards = 0] = "Forwards", L[L.Backwards = 1] = "Backwards", L))(s$2 || {});
function n() {
  let L = useRef(0);
  return s$5("keydown", (ne) => {
    ne.key === "Tab" && (L.current = ne.shiftKey ? 1 : 0);
  }, !0), L;
}
function P(L) {
  if (!L)
    return /* @__PURE__ */ new Set();
  if (typeof L == "function")
    return new Set(L());
  let ne = /* @__PURE__ */ new Set();
  for (let oe of L.current)
    oe.current instanceof HTMLElement && ne.add(oe.current);
  return ne;
}
let X$1 = "div";
var _$2 = ((L) => (L[L.None = 1] = "None", L[L.InitialFocus = 2] = "InitialFocus", L[L.TabLock = 4] = "TabLock", L[L.FocusLock = 8] = "FocusLock", L[L.RestoreFocus = 16] = "RestoreFocus", L[L.All = 30] = "All", L))(_$2 || {});
function z$1(L, ne) {
  let oe = useRef(null), pe = y$1(oe, ne), { initialFocus: me, containers: ge, features: be = 30, ...Ie } = L;
  l$4() || (be = 1);
  let Ae = n$2(oe);
  Y({ ownerDocument: Ae }, !!(be & 16));
  let rt = Z({ ownerDocument: Ae, container: oe, initialFocus: me }, !!(be & 2));
  $$1({ ownerDocument: Ae, container: oe, containers: ge, previousActiveElement: rt }, !!(be & 8));
  let st = n(), dt = o$4((ut) => {
    let St = oe.current;
    St && ((ot) => ot())(() => {
      u$4(st.current, { [s$2.Forwards]: () => {
        O$1(St, M$3.First, { skipElements: [ut.relatedTarget] });
      }, [s$2.Backwards]: () => {
        O$1(St, M$3.Last, { skipElements: [ut.relatedTarget] });
      } });
    });
  }), lt = p$3(), pt = useRef(!1), it = { ref: pe, onKeyDown(ut) {
    ut.key == "Tab" && (pt.current = !0, lt.requestAnimationFrame(() => {
      pt.current = !1;
    }));
  }, onBlur(ut) {
    let St = P(ge);
    oe.current instanceof HTMLElement && St.add(oe.current);
    let ot = ut.relatedTarget;
    ot instanceof HTMLElement && ot.dataset.headlessuiFocusGuard !== "true" && (S$5(St, ot) || (pt.current ? O$1(oe.current, u$4(st.current, { [s$2.Forwards]: () => M$3.Next, [s$2.Backwards]: () => M$3.Previous }) | M$3.WrapAround, { relativeTo: ut.target }) : ut.target instanceof HTMLElement && y$3(ut.target)));
  } };
  return React__default.createElement(React__default.Fragment, null, !!(be & 4) && React__default.createElement(f$5, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: dt, features: s$4.Focusable }), C$1({ ourProps: it, theirProps: Ie, defaultTag: X$1, name: "FocusTrap" }), !!(be & 4) && React__default.createElement(f$5, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: dt, features: s$4.Focusable }));
}
let D$2 = U$2(z$1), de = Object.assign(D$2, { features: _$2 });
function Q(L = !0) {
  let ne = useRef(t$2.slice());
  return m$2(([oe], [pe]) => {
    pe === !0 && oe === !1 && t$6(() => {
      ne.current.splice(0);
    }), pe === !1 && oe === !0 && (ne.current = t$2.slice());
  }, [L, t$2, ne]), o$4(() => {
    var oe;
    return (oe = ne.current.find((pe) => pe != null && pe.isConnected)) != null ? oe : null;
  });
}
function Y({ ownerDocument: L }, ne) {
  let oe = Q(ne);
  m$2(() => {
    ne || (L == null ? void 0 : L.activeElement) === (L == null ? void 0 : L.body) && y$3(oe());
  }, [ne]), c$3(() => {
    ne && y$3(oe());
  });
}
function Z({ ownerDocument: L, container: ne, initialFocus: oe }, pe) {
  let me = useRef(null), ge = f$4();
  return m$2(() => {
    if (!pe)
      return;
    let be = ne.current;
    be && t$6(() => {
      if (!ge.current)
        return;
      let Ie = L == null ? void 0 : L.activeElement;
      if (oe != null && oe.current) {
        if ((oe == null ? void 0 : oe.current) === Ie) {
          me.current = Ie;
          return;
        }
      } else if (be.contains(Ie)) {
        me.current = Ie;
        return;
      }
      oe != null && oe.current ? y$3(oe.current) : O$1(be, M$3.First) === N$4.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), me.current = L == null ? void 0 : L.activeElement;
    });
  }, [pe]), me;
}
function $$1({ ownerDocument: L, container: ne, containers: oe, previousActiveElement: pe }, me) {
  let ge = f$4();
  E(L == null ? void 0 : L.defaultView, "focus", (be) => {
    if (!me || !ge.current)
      return;
    let Ie = P(oe);
    ne.current instanceof HTMLElement && Ie.add(ne.current);
    let Ae = pe.current;
    if (!Ae)
      return;
    let rt = be.target;
    rt && rt instanceof HTMLElement ? S$5(Ie, rt) ? (pe.current = rt, y$3(rt)) : (be.preventDefault(), be.stopPropagation(), y$3(Ae)) : y$3(pe.current);
  }, !0);
}
function S$5(L, ne) {
  for (let oe of L)
    if (oe.contains(ne))
      return !0;
  return !1;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l$2(L) {
  return React__default.createElement(e.Provider, { value: L.force }, L.children);
}
function F$1(L) {
  let ne = a$4(), oe = useContext(_$1), pe = n$2(L), [me, ge] = useState(() => {
    if (!ne && oe !== null || s$8.isServer)
      return null;
    let be = pe == null ? void 0 : pe.getElementById("headlessui-portal-root");
    if (be)
      return be;
    if (pe === null)
      return null;
    let Ie = pe.createElement("div");
    return Ie.setAttribute("id", "headlessui-portal-root"), pe.body.appendChild(Ie);
  });
  return useEffect(() => {
    me !== null && (pe != null && pe.body.contains(me) || pe == null || pe.body.appendChild(me));
  }, [me, pe]), useEffect(() => {
    ne || oe !== null && ge(oe.current);
  }, [oe, ge, ne]), me;
}
let U$1 = Fragment;
function N$3(L, ne) {
  let oe = L, pe = useRef(null), me = y$1(T((st) => {
    pe.current = st;
  }), ne), ge = n$2(pe), be = F$1(pe), [Ie] = useState(() => {
    var st;
    return s$8.isServer ? null : (st = ge == null ? void 0 : ge.createElement("div")) != null ? st : null;
  }), Ae = useContext(f$3), rt = l$4();
  return l$5(() => {
    !be || !Ie || be.contains(Ie) || (Ie.setAttribute("data-headlessui-portal", ""), be.appendChild(Ie));
  }, [be, Ie]), l$5(() => {
    if (Ie && Ae)
      return Ae.register(Ie);
  }, [Ae, Ie]), c$3(() => {
    var st;
    !be || !Ie || (Ie instanceof Node && be.contains(Ie) && be.removeChild(Ie), be.childNodes.length <= 0 && ((st = be.parentElement) == null || st.removeChild(be)));
  }), rt ? !be || !Ie ? null : reactDomExports.createPortal(C$1({ ourProps: { ref: me }, theirProps: oe, defaultTag: U$1, name: "Portal" }), Ie) : null;
}
let S$4 = Fragment, _$1 = createContext(null);
function j$1(L, ne) {
  let { target: oe, ...pe } = L, me = { ref: y$1(ne) };
  return React__default.createElement(_$1.Provider, { value: oe }, C$1({ ourProps: me, theirProps: pe, defaultTag: S$4, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee$1() {
  let L = useContext(f$3), ne = useRef([]), oe = o$4((ge) => (ne.current.push(ge), L && L.register(ge), () => pe(ge))), pe = o$4((ge) => {
    let be = ne.current.indexOf(ge);
    be !== -1 && ne.current.splice(be, 1), L && L.unregister(ge);
  }), me = useMemo(() => ({ register: oe, unregister: pe, portals: ne }), [oe, pe, ne]);
  return [ne, useMemo(() => function({ children: ge }) {
    return React__default.createElement(f$3.Provider, { value: me }, ge);
  }, [me])];
}
let D$1 = U$2(N$3), I$4 = U$2(j$1), te$1 = Object.assign(D$1, { Group: I$4 });
function i(L, ne) {
  return L === ne && (L !== 0 || 1 / L === 1 / ne) || L !== L && ne !== ne;
}
const d$2 = typeof Object.is == "function" ? Object.is : i, { useState: u$1, useEffect: h$1, useLayoutEffect: f$2, useDebugValue: p$1 } = React;
function y(L, ne, oe) {
  const pe = ne(), [{ inst: me }, ge] = u$1({ inst: { value: pe, getSnapshot: ne } });
  return f$2(() => {
    me.value = pe, me.getSnapshot = ne, r$1(me) && ge({ inst: me });
  }, [L, pe, ne]), h$1(() => (r$1(me) && ge({ inst: me }), L(() => {
    r$1(me) && ge({ inst: me });
  })), [L]), p$1(pe), pe;
}
function r$1(L) {
  const ne = L.getSnapshot, oe = L.value;
  try {
    const pe = ne();
    return !d$2(oe, pe);
  } catch {
    return !0;
  }
}
function t$1(L, ne, oe) {
  return ne();
}
const r = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$1 = !r, c$2 = s$1 ? t$1 : y, a$3 = "useSyncExternalStore" in React ? ((L) => L.useSyncExternalStore)(React) : c$2;
function S$3(L) {
  return a$3(L.subscribe, L.getSnapshot, L.getSnapshot);
}
function a$2(L, ne) {
  let oe = L(), pe = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return oe;
  }, subscribe(me) {
    return pe.add(me), () => pe.delete(me);
  }, dispatch(me, ...ge) {
    let be = ne[me].call(oe, ...ge);
    be && (oe = be, pe.forEach((Ie) => Ie()));
  } };
}
function c$1() {
  let L;
  return { before({ doc: ne }) {
    var oe;
    let pe = ne.documentElement;
    L = ((oe = ne.defaultView) != null ? oe : window).innerWidth - pe.clientWidth;
  }, after({ doc: ne, d: oe }) {
    let pe = ne.documentElement, me = pe.clientWidth - pe.offsetWidth, ge = L - me;
    oe.style(pe, "paddingRight", `${ge}px`);
  } };
}
function d$1() {
  return t$5() ? { before({ doc: L, d: ne, meta: oe }) {
    function pe(me) {
      return oe.containers.flatMap((ge) => ge()).some((ge) => ge.contains(me));
    }
    ne.microTask(() => {
      var me;
      if (window.getComputedStyle(L.documentElement).scrollBehavior !== "auto") {
        let Ie = o$3();
        Ie.style(L.documentElement, "scrollBehavior", "auto"), ne.add(() => ne.microTask(() => Ie.dispose()));
      }
      let ge = (me = window.scrollY) != null ? me : window.pageYOffset, be = null;
      ne.addEventListener(L, "click", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          try {
            let Ae = Ie.target.closest("a");
            if (!Ae)
              return;
            let { hash: rt } = new URL(Ae.href), st = L.querySelector(rt);
            st && !pe(st) && (be = st);
          } catch {
          }
      }, !0), ne.addEventListener(L, "touchstart", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          if (pe(Ie.target)) {
            let Ae = Ie.target;
            for (; Ae.parentElement && pe(Ae.parentElement); )
              Ae = Ae.parentElement;
            ne.style(Ae, "overscrollBehavior", "contain");
          } else
            ne.style(Ie.target, "touchAction", "none");
      }), ne.addEventListener(L, "touchmove", (Ie) => {
        if (Ie.target instanceof HTMLElement)
          if (pe(Ie.target)) {
            let Ae = Ie.target;
            for (; Ae.parentElement && Ae.dataset.headlessuiPortal !== "" && !(Ae.scrollHeight > Ae.clientHeight || Ae.scrollWidth > Ae.clientWidth); )
              Ae = Ae.parentElement;
            Ae.dataset.headlessuiPortal === "" && Ie.preventDefault();
          } else
            Ie.preventDefault();
      }, { passive: !1 }), ne.add(() => {
        var Ie;
        let Ae = (Ie = window.scrollY) != null ? Ie : window.pageYOffset;
        ge !== Ae && window.scrollTo(0, ge), be && be.isConnected && (be.scrollIntoView({ block: "nearest" }), be = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: L, d: ne }) {
    ne.style(L.documentElement, "overflow", "hidden");
  } };
}
function m(L) {
  let ne = {};
  for (let oe of L)
    Object.assign(ne, oe(ne));
  return ne;
}
let a$1 = a$2(() => /* @__PURE__ */ new Map(), { PUSH(L, ne) {
  var oe;
  let pe = (oe = this.get(L)) != null ? oe : { doc: L, count: 0, d: o$3(), meta: /* @__PURE__ */ new Set() };
  return pe.count++, pe.meta.add(ne), this.set(L, pe), this;
}, POP(L, ne) {
  let oe = this.get(L);
  return oe && (oe.count--, oe.meta.delete(ne)), this;
}, SCROLL_PREVENT({ doc: L, d: ne, meta: oe }) {
  let pe = { doc: L, d: ne, meta: m(oe) }, me = [d$1(), c$1(), l$1()];
  me.forEach(({ before: ge }) => ge == null ? void 0 : ge(pe)), me.forEach(({ after: ge }) => ge == null ? void 0 : ge(pe));
}, SCROLL_ALLOW({ d: L }) {
  L.dispose();
}, TEARDOWN({ doc: L }) {
  this.delete(L);
} });
a$1.subscribe(() => {
  let L = a$1.getSnapshot(), ne = /* @__PURE__ */ new Map();
  for (let [oe] of L)
    ne.set(oe, oe.documentElement.style.overflow);
  for (let oe of L.values()) {
    let pe = ne.get(oe.doc) === "hidden", me = oe.count !== 0;
    (me && !pe || !me && pe) && a$1.dispatch(oe.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", oe), oe.count === 0 && a$1.dispatch("TEARDOWN", oe);
  }
});
function p(L, ne, oe) {
  let pe = S$3(a$1), me = L ? pe.get(L) : void 0, ge = me ? me.count > 0 : !1;
  return l$5(() => {
    if (!(!L || !ne))
      return a$1.dispatch("PUSH", L, oe), () => a$1.dispatch("POP", L, oe);
  }, [ne, L]), ge;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(L, ne = !0) {
  l$5(() => {
    var oe;
    if (!ne)
      return;
    let pe = typeof L == "function" ? L() : L.current;
    if (!pe)
      return;
    function me() {
      var be;
      if (!pe)
        return;
      let Ie = (be = t.get(pe)) != null ? be : 1;
      if (Ie === 1 ? t.delete(pe) : t.set(pe, Ie - 1), Ie !== 1)
        return;
      let Ae = u.get(pe);
      Ae && (Ae["aria-hidden"] === null ? pe.removeAttribute("aria-hidden") : pe.setAttribute("aria-hidden", Ae["aria-hidden"]), pe.inert = Ae.inert, u.delete(pe));
    }
    let ge = (oe = t.get(pe)) != null ? oe : 0;
    return t.set(pe, ge + 1), ge !== 0 || (u.set(pe, { "aria-hidden": pe.getAttribute("aria-hidden"), inert: pe.inert }), pe.setAttribute("aria-hidden", "true"), pe.inert = !0), me;
  }, [L, ne]);
}
function N$2({ defaultContainers: L = [], portals: ne, mainTreeNodeRef: oe } = {}) {
  var pe;
  let me = useRef((pe = oe == null ? void 0 : oe.current) != null ? pe : null), ge = n$2(me), be = o$4(() => {
    var Ie, Ae, rt;
    let st = [];
    for (let dt of L)
      dt !== null && (dt instanceof HTMLElement ? st.push(dt) : "current" in dt && dt.current instanceof HTMLElement && st.push(dt.current));
    if (ne != null && ne.current)
      for (let dt of ne.current)
        st.push(dt);
    for (let dt of (Ie = ge == null ? void 0 : ge.querySelectorAll("html > *, body > *")) != null ? Ie : [])
      dt !== document.body && dt !== document.head && dt instanceof HTMLElement && dt.id !== "headlessui-portal-root" && (dt.contains(me.current) || dt.contains((rt = (Ae = me.current) == null ? void 0 : Ae.getRootNode()) == null ? void 0 : rt.host) || st.some((lt) => dt.contains(lt)) || st.push(dt));
    return st;
  });
  return { resolveContainers: be, contains: o$4((Ie) => be().some((Ae) => Ae.contains(Ie))), mainTreeNodeRef: me, MainTreeNode: useMemo(() => function() {
    return oe != null ? null : React__default.createElement(f$5, { features: s$4.Hidden, ref: me });
  }, [me, oe]) };
}
let a = createContext(() => {
});
a.displayName = "StackContext";
var s = ((L) => (L[L.Add = 0] = "Add", L[L.Remove = 1] = "Remove", L))(s || {});
function x() {
  return useContext(a);
}
function b$2({ children: L, onUpdate: ne, type: oe, element: pe, enabled: me }) {
  let ge = x(), be = o$4((...Ie) => {
    ne == null || ne(...Ie), ge(...Ie);
  });
  return l$5(() => {
    let Ie = me === void 0 || me === !0;
    return Ie && be(0, oe, pe), () => {
      Ie && be(1, oe, pe);
    };
  }, [be, oe, pe, me]), React__default.createElement(a.Provider, { value: be }, L);
}
let d = createContext(null);
function f$1() {
  let L = useContext(d);
  if (L === null) {
    let ne = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(ne, f$1), ne;
  }
  return L;
}
function w$1() {
  let [L, ne] = useState([]);
  return [L.length > 0 ? L.join(" ") : void 0, useMemo(() => function(oe) {
    let pe = o$4((ge) => (ne((be) => [...be, ge]), () => ne((be) => {
      let Ie = be.slice(), Ae = Ie.indexOf(ge);
      return Ae !== -1 && Ie.splice(Ae, 1), Ie;
    }))), me = useMemo(() => ({ register: pe, slot: oe.slot, name: oe.name, props: oe.props }), [pe, oe.slot, oe.name, oe.props]);
    return React__default.createElement(d.Provider, { value: me }, oe.children);
  }, [ne])];
}
let I$3 = "p";
function S$2(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-description-${oe}`, ...me } = L, ge = f$1(), be = y$1(ne);
  l$5(() => ge.register(pe), [pe, ge.register]);
  let Ie = { ref: be, ...ge.props, id: pe };
  return C$1({ ourProps: Ie, theirProps: me, slot: ge.slot || {}, defaultTag: I$3, name: ge.name || "Description" });
}
let h = U$2(S$2), G = Object.assign(h, {});
var Me = ((L) => (L[L.Open = 0] = "Open", L[L.Closed = 1] = "Closed", L))(Me || {}), we = ((L) => (L[L.SetTitleId = 0] = "SetTitleId", L))(we || {});
let He$1 = { 0(L, ne) {
  return L.titleId === ne.id ? L : { ...L, titleId: ne.id };
} }, I$2 = createContext(null);
I$2.displayName = "DialogContext";
function b$1(L) {
  let ne = useContext(I$2);
  if (ne === null) {
    let oe = new Error(`<${L} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(oe, b$1), oe;
  }
  return ne;
}
function Be(L, ne, oe = () => [document.body]) {
  p(L, ne, (pe) => {
    var me;
    return { containers: [...(me = pe.containers) != null ? me : [], oe] };
  });
}
function Ge(L, ne) {
  return u$4(ne.type, He$1, L, ne);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-${oe}`, open: me, onClose: ge, initialFocus: be, role: Ie = "dialog", __demoMode: Ae = !1, ...rt } = L, [st, dt] = useState(0), lt = useRef(!1);
  Ie = function() {
    return Ie === "dialog" || Ie === "alertdialog" ? Ie : (lt.current || (lt.current = !0, console.warn(`Invalid role [${Ie}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let pt = u$2();
  me === void 0 && pt !== null && (me = (pt & d$3.Open) === d$3.Open);
  let it = useRef(null), ut = y$1(it, ne), St = n$2(it), ot = L.hasOwnProperty("open") || pt !== null, ht = L.hasOwnProperty("onClose");
  if (!ot && !ht)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ot)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ht)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof me != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${me}`);
  if (typeof ge != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${ge}`);
  let ft = me ? 0 : 1, [vt, Ct] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), xt = o$4(() => ge(!1)), At = o$4((Lr) => Ct({ type: 0, id: Lr })), kt = l$4() ? Ae ? !1 : ft === 0 : !1, Vt = st > 1, ir = useContext(I$2) !== null, [er, Yt] = ee$1(), Jt = { get current() {
    var Lr;
    return (Lr = vt.panelRef.current) != null ? Lr : it.current;
  } }, { resolveContainers: rr, mainTreeNodeRef: Qt, MainTreeNode: wt } = N$2({ portals: er, defaultContainers: [Jt] }), Ft = Vt ? "parent" : "leaf", yt = pt !== null ? (pt & d$3.Closing) === d$3.Closing : !1, Et = ir || yt ? !1 : kt, Dt = useCallback(() => {
    var Lr, en;
    return (en = Array.from((Lr = St == null ? void 0 : St.querySelectorAll("body > *")) != null ? Lr : []).find((Rr) => Rr.id === "headlessui-portal-root" ? !1 : Rr.contains(Qt.current) && Rr instanceof HTMLElement)) != null ? en : null;
  }, [Qt]);
  b$3(Dt, Et);
  let Ot = Vt ? !0 : kt, nr = useCallback(() => {
    var Lr, en;
    return (en = Array.from((Lr = St == null ? void 0 : St.querySelectorAll("[data-headlessui-portal]")) != null ? Lr : []).find((Rr) => Rr.contains(Qt.current) && Rr instanceof HTMLElement)) != null ? en : null;
  }, [Qt]);
  b$3(nr, Ot), y$2(rr, xt, !(!kt || Vt));
  let pr = !(Vt || ft !== 0);
  E(St == null ? void 0 : St.defaultView, "keydown", (Lr) => {
    pr && (Lr.defaultPrevented || Lr.key === o.Escape && (Lr.preventDefault(), Lr.stopPropagation(), xt()));
  }), Be(St, !(yt || ft !== 0 || ir), rr), useEffect(() => {
    if (ft !== 0 || !it.current)
      return;
    let Lr = new ResizeObserver((en) => {
      for (let Rr of en) {
        let cr = Rr.target.getBoundingClientRect();
        cr.x === 0 && cr.y === 0 && cr.width === 0 && cr.height === 0 && xt();
      }
    });
    return Lr.observe(it.current), () => Lr.disconnect();
  }, [ft, it, xt]);
  let [Ir, fn] = w$1(), Zr = useMemo(() => [{ dialogState: ft, close: xt, setTitleId: At }, vt], [ft, vt, xt, At]), xn = useMemo(() => ({ open: ft === 0 }), [ft]), kn = { ref: ut, id: pe, role: Ie, "aria-modal": ft === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": Ir };
  return React__default.createElement(b$2, { type: "Dialog", enabled: ft === 0, element: it, onUpdate: o$4((Lr, en) => {
    en === "Dialog" && u$4(Lr, { [s.Add]: () => dt((Rr) => Rr + 1), [s.Remove]: () => dt((Rr) => Rr - 1) });
  }) }, React__default.createElement(l$2, { force: !0 }, React__default.createElement(te$1, null, React__default.createElement(I$2.Provider, { value: Zr }, React__default.createElement(te$1.Group, { target: it }, React__default.createElement(l$2, { force: !1 }, React__default.createElement(fn, { slot: xn, name: "Dialog.Description" }, React__default.createElement(de, { initialFocus: be, containers: rr, features: kt ? u$4(Ft, { parent: de.features.RestoreFocus, leaf: de.features.All & ~de.features.FocusLock }) : de.features.None }, React__default.createElement(Yt, null, C$1({ ourProps: kn, theirProps: rt, slot: xn, defaultTag: Ne$1, features: Ue, visible: ft === 0, name: "Dialog" }))))))))), React__default.createElement(wt, null));
}
let $e = "div";
function Ye(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-overlay-${oe}`, ...me } = L, [{ dialogState: ge, close: be }] = b$1("Dialog.Overlay"), Ie = y$1(ne), Ae = o$4((st) => {
    if (st.target === st.currentTarget) {
      if (r$2(st.currentTarget))
        return st.preventDefault();
      st.preventDefault(), st.stopPropagation(), be();
    }
  }), rt = useMemo(() => ({ open: ge === 0 }), [ge]);
  return C$1({ ourProps: { ref: Ie, id: pe, "aria-hidden": !0, onClick: Ae }, theirProps: me, slot: rt, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-backdrop-${oe}`, ...me } = L, [{ dialogState: ge }, be] = b$1("Dialog.Backdrop"), Ie = y$1(ne);
  useEffect(() => {
    if (be.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [be.panelRef]);
  let Ae = useMemo(() => ({ open: ge === 0 }), [ge]);
  return React__default.createElement(l$2, { force: !0 }, React__default.createElement(te$1, null, C$1({ ourProps: { ref: Ie, id: pe, "aria-hidden": !0 }, theirProps: me, slot: Ae, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-panel-${oe}`, ...me } = L, [{ dialogState: ge }, be] = b$1("Dialog.Panel"), Ie = y$1(ne, be.panelRef), Ae = useMemo(() => ({ open: ge === 0 }), [ge]), rt = o$4((st) => {
    st.stopPropagation();
  });
  return C$1({ ourProps: { ref: Ie, id: pe, onClick: rt }, theirProps: me, slot: Ae, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$1(L, ne) {
  let oe = I$6(), { id: pe = `headlessui-dialog-title-${oe}`, ...me } = L, [{ dialogState: ge, setTitleId: be }] = b$1("Dialog.Title"), Ie = y$1(ne);
  useEffect(() => (be(pe), () => be(null)), [pe, be]);
  let Ae = useMemo(() => ({ open: ge === 0 }), [ge]);
  return C$1({ ourProps: { ref: Ie, id: pe }, theirProps: me, slot: Ae, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$2(We), Qe = U$2(Je), Ze = U$2(Ke), et = U$2(Ye), tt = U$2(qe$1), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G });
function c(L = 0) {
  let [ne, oe] = useState(L), pe = f$4(), me = useCallback((Ae) => {
    pe.current && oe((rt) => rt | Ae);
  }, [ne, pe]), ge = useCallback((Ae) => !!(ne & Ae), [ne]), be = useCallback((Ae) => {
    pe.current && oe((rt) => rt & ~Ae);
  }, [oe, pe]), Ie = useCallback((Ae) => {
    pe.current && oe((rt) => rt ^ Ae);
  }, [oe]);
  return { flags: ne, addFlag: me, hasFlag: ge, removeFlag: be, toggleFlag: Ie };
}
function l(L) {
  let ne = { called: !1 };
  return (...oe) => {
    if (!ne.called)
      return ne.called = !0, L(...oe);
  };
}
function g(L, ...ne) {
  L && ne.length > 0 && L.classList.add(...ne);
}
function v$1(L, ...ne) {
  L && ne.length > 0 && L.classList.remove(...ne);
}
function b(L, ne) {
  let oe = o$3();
  if (!L)
    return oe.dispose;
  let { transitionDuration: pe, transitionDelay: me } = getComputedStyle(L), [ge, be] = [pe, me].map((Ae) => {
    let [rt = 0] = Ae.split(",").filter(Boolean).map((st) => st.includes("ms") ? parseFloat(st) : parseFloat(st) * 1e3).sort((st, dt) => dt - st);
    return rt;
  }), Ie = ge + be;
  if (Ie !== 0) {
    oe.group((rt) => {
      rt.setTimeout(() => {
        ne(), rt.dispose();
      }, Ie), rt.addEventListener(L, "transitionrun", (st) => {
        st.target === st.currentTarget && rt.dispose();
      });
    });
    let Ae = oe.addEventListener(L, "transitionend", (rt) => {
      rt.target === rt.currentTarget && (ne(), Ae());
    });
  } else
    ne();
  return oe.add(() => ne()), oe.dispose;
}
function M$2(L, ne, oe, pe) {
  let me = oe ? "enter" : "leave", ge = o$3(), be = pe !== void 0 ? l(pe) : () => {
  };
  me === "enter" && (L.removeAttribute("hidden"), L.style.display = "");
  let Ie = u$4(me, { enter: () => ne.enter, leave: () => ne.leave }), Ae = u$4(me, { enter: () => ne.enterTo, leave: () => ne.leaveTo }), rt = u$4(me, { enter: () => ne.enterFrom, leave: () => ne.leaveFrom });
  return v$1(L, ...ne.base, ...ne.enter, ...ne.enterTo, ...ne.enterFrom, ...ne.leave, ...ne.leaveFrom, ...ne.leaveTo, ...ne.entered), g(L, ...ne.base, ...Ie, ...rt), ge.nextFrame(() => {
    v$1(L, ...ne.base, ...Ie, ...rt), g(L, ...ne.base, ...Ie, ...Ae), b(L, () => (v$1(L, ...ne.base, ...Ie), g(L, ...ne.base, ...ne.entered), be()));
  }), ge.dispose;
}
function D({ immediate: L, container: ne, direction: oe, classes: pe, onStart: me, onStop: ge }) {
  let be = f$4(), Ie = p$3(), Ae = s$7(oe);
  l$5(() => {
    L && (Ae.current = "enter");
  }, [L]), l$5(() => {
    let rt = o$3();
    Ie.add(rt.dispose);
    let st = ne.current;
    if (st && Ae.current !== "idle" && be.current)
      return rt.dispose(), me.current(Ae.current), rt.add(M$2(st, pe.current, Ae.current === "enter", () => {
        rt.dispose(), ge.current(Ae.current);
      })), rt.dispose;
  }, [oe]);
}
function S$1(L = "") {
  return L.split(/\s+/).filter((ne) => ne.length > 1);
}
let I$1 = createContext(null);
I$1.displayName = "TransitionContext";
var Se = ((L) => (L.Visible = "visible", L.Hidden = "hidden", L))(Se || {});
function ye() {
  let L = useContext(I$1);
  if (L === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return L;
}
function xe() {
  let L = useContext(M$1);
  if (L === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return L;
}
let M$1 = createContext(null);
M$1.displayName = "NestingContext";
function U(L) {
  return "children" in L ? U(L.children) : L.current.filter(({ el: ne }) => ne.current !== null).filter(({ state: ne }) => ne === "visible").length > 0;
}
function se(L, ne) {
  let oe = s$7(L), pe = useRef([]), me = f$4(), ge = p$3(), be = o$4((pt, it = v$2.Hidden) => {
    let ut = pe.current.findIndex(({ el: St }) => St === pt);
    ut !== -1 && (u$4(it, { [v$2.Unmount]() {
      pe.current.splice(ut, 1);
    }, [v$2.Hidden]() {
      pe.current[ut].state = "hidden";
    } }), ge.microTask(() => {
      var St;
      !U(pe) && me.current && ((St = oe.current) == null || St.call(oe));
    }));
  }), Ie = o$4((pt) => {
    let it = pe.current.find(({ el: ut }) => ut === pt);
    return it ? it.state !== "visible" && (it.state = "visible") : pe.current.push({ el: pt, state: "visible" }), () => be(pt, v$2.Unmount);
  }), Ae = useRef([]), rt = useRef(Promise.resolve()), st = useRef({ enter: [], leave: [], idle: [] }), dt = o$4((pt, it, ut) => {
    Ae.current.splice(0), ne && (ne.chains.current[it] = ne.chains.current[it].filter(([St]) => St !== pt)), ne == null || ne.chains.current[it].push([pt, new Promise((St) => {
      Ae.current.push(St);
    })]), ne == null || ne.chains.current[it].push([pt, new Promise((St) => {
      Promise.all(st.current[it].map(([ot, ht]) => ht)).then(() => St());
    })]), it === "enter" ? rt.current = rt.current.then(() => ne == null ? void 0 : ne.wait.current).then(() => ut(it)) : ut(it);
  }), lt = o$4((pt, it, ut) => {
    Promise.all(st.current[it].splice(0).map(([St, ot]) => ot)).then(() => {
      var St;
      (St = Ae.current.shift()) == null || St();
    }).then(() => ut(it));
  });
  return useMemo(() => ({ children: pe, register: Ie, unregister: be, onStart: dt, onStop: lt, wait: rt, chains: st }), [Ie, be, pe, dt, lt, st, rt]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(L) {
  var ne;
  let oe = {};
  for (let pe of Pe)
    oe[pe] = (ne = L[pe]) != null ? ne : Ne;
  return oe;
}
function Re(L) {
  let ne = useRef(ae(L));
  return useEffect(() => {
    ne.current = ae(L);
  }, [L]), ne;
}
let De = "div", le = O.RenderStrategy;
function He(L, ne) {
  var oe, pe;
  let { beforeEnter: me, afterEnter: ge, beforeLeave: be, afterLeave: Ie, enter: Ae, enterFrom: rt, enterTo: st, entered: dt, leave: lt, leaveFrom: pt, leaveTo: it, ...ut } = L, St = useRef(null), ot = y$1(St, ne), ht = (oe = ut.unmount) == null || oe ? v$2.Unmount : v$2.Hidden, { show: ft, appear: vt, initial: Ct } = ye(), [xt, At] = useState(ft ? "visible" : "hidden"), kt = xe(), { register: Vt, unregister: ir } = kt;
  useEffect(() => Vt(St), [Vt, St]), useEffect(() => {
    if (ht === v$2.Hidden && St.current) {
      if (ft && xt !== "visible") {
        At("visible");
        return;
      }
      return u$4(xt, { hidden: () => ir(St), visible: () => Vt(St) });
    }
  }, [xt, St, Vt, ir, ft, ht]);
  let er = s$7({ base: S$1(ut.className), enter: S$1(Ae), enterFrom: S$1(rt), enterTo: S$1(st), entered: S$1(dt), leave: S$1(lt), leaveFrom: S$1(pt), leaveTo: S$1(it) }), Yt = Re({ beforeEnter: me, afterEnter: ge, beforeLeave: be, afterLeave: Ie }), Jt = l$4();
  useEffect(() => {
    if (Jt && xt === "visible" && St.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [St, xt, Jt]);
  let rr = Ct && !vt, Qt = vt && ft && Ct, wt = !Jt || rr ? "idle" : ft ? "enter" : "leave", Ft = c(0), yt = o$4((pr) => u$4(pr, { enter: () => {
    Ft.addFlag(d$3.Opening), Yt.current.beforeEnter();
  }, leave: () => {
    Ft.addFlag(d$3.Closing), Yt.current.beforeLeave();
  }, idle: () => {
  } })), Et = o$4((pr) => u$4(pr, { enter: () => {
    Ft.removeFlag(d$3.Opening), Yt.current.afterEnter();
  }, leave: () => {
    Ft.removeFlag(d$3.Closing), Yt.current.afterLeave();
  }, idle: () => {
  } })), Dt = se(() => {
    At("hidden"), ir(St);
  }, kt), Ot = useRef(!1);
  D({ immediate: Qt, container: St, classes: er, direction: wt, onStart: s$7((pr) => {
    Ot.current = !0, Dt.onStart(St, pr, yt);
  }), onStop: s$7((pr) => {
    Ot.current = !1, Dt.onStop(St, pr, Et), pr === "leave" && !U(Dt) && (At("hidden"), ir(St));
  }) });
  let nr = ut, vr = { ref: ot };
  return Qt ? nr = { ...nr, className: t$4(ut.className, ...er.current.enter, ...er.current.enterFrom) } : Ot.current && (nr.className = t$4(ut.className, (pe = St.current) == null ? void 0 : pe.className), nr.className === "" && delete nr.className), React__default.createElement(M$1.Provider, { value: Dt }, React__default.createElement(s$3, { value: u$4(xt, { visible: d$3.Open, hidden: d$3.Closed }) | Ft.flags }, C$1({ ourProps: vr, theirProps: nr, defaultTag: De, features: le, visible: xt === "visible", name: "Transition.Child" })));
}
function Fe(L, ne) {
  let { show: oe, appear: pe = !1, unmount: me = !0, ...ge } = L, be = useRef(null), Ie = y$1(be, ne);
  l$4();
  let Ae = u$2();
  if (oe === void 0 && Ae !== null && (oe = (Ae & d$3.Open) === d$3.Open), ![!0, !1].includes(oe))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [rt, st] = useState(oe ? "visible" : "hidden"), dt = se(() => {
    st("hidden");
  }), [lt, pt] = useState(!0), it = useRef([oe]);
  l$5(() => {
    lt !== !1 && it.current[it.current.length - 1] !== oe && (it.current.push(oe), pt(!1));
  }, [it, oe]);
  let ut = useMemo(() => ({ show: oe, appear: pe, initial: lt }), [oe, pe, lt]);
  useEffect(() => {
    if (oe)
      st("visible");
    else if (!U(dt))
      st("hidden");
    else {
      let ft = be.current;
      if (!ft)
        return;
      let vt = ft.getBoundingClientRect();
      vt.x === 0 && vt.y === 0 && vt.width === 0 && vt.height === 0 && st("hidden");
    }
  }, [oe, dt]);
  let St = { unmount: me }, ot = o$4(() => {
    var ft;
    lt && pt(!1), (ft = L.beforeEnter) == null || ft.call(L);
  }), ht = o$4(() => {
    var ft;
    lt && pt(!1), (ft = L.beforeLeave) == null || ft.call(L);
  });
  return React__default.createElement(M$1.Provider, { value: dt }, React__default.createElement(I$1.Provider, { value: ut }, C$1({ ourProps: { ...St, as: Fragment, children: React__default.createElement(ue, { ref: Ie, ...St, ...ge, beforeEnter: ot, beforeLeave: ht }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: rt === "visible", name: "Transition" })));
}
function _e(L, ne) {
  let oe = useContext(I$1) !== null, pe = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !oe && pe ? React__default.createElement(q$1, { ref: ne, ...L }) : React__default.createElement(ue, { ref: ne, ...L }));
}
let q$1 = U$2(Fe), ue = U$2(He), Le = U$2(_e), qe = Object.assign(q$1, { Child: Le, Root: q$1 });
const MainSidebar = ({ gtlsLogo: L, mobileMenuOpen: ne, XMarkIcon: oe, ChevronDownIcon: pe, handleClick: me, handleMenuSide: ge, handleClickSide: be, ResponsiveNavLink: Ie, setMobileMenuOpen: Ae, currentAppId: rt, allowedApplications: st, sidebarElements: dt, LogoutIcon: lt, SupportIcon: pt, handleLogout: it, SupportModal: ut }) => {
  function St(...ot) {
    return ot.filter(Boolean).join(" ");
  }
  return /* @__PURE__ */ React__default.createElement("div", null, /* @__PURE__ */ React__default.createElement("div", { className: "hidden md:flex md:flex-shrink-0 h-full fixed top-0 left-0 z-50 w-auto" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex w-20 flex-col" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex min-h-0 flex-1 flex-col overflow-y-auto bg-gray-800 containerscroll" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex-1" }, /* @__PURE__ */ React__default.createElement("div", { className: "flex items-center justify-center bg-gray-800 py-4" }, /* @__PURE__ */ React__default.createElement("a", { href: "/" }, typeof L == "string" ? /* @__PURE__ */ React__default.createElement("img", { src: L, alt: "tiger" }) : /* @__PURE__ */ React__default.createElement("div", null, L))), /* @__PURE__ */ React__default.createElement(
    "nav",
    {
      "aria-label": "Sidebar",
      className: "flex flex-col items-center space-y-3 pt-6"
    },
    st == null ? void 0 : st.map((ot) => /* @__PURE__ */ React__default.createElement(
      "a",
      {
        href: ot == null ? void 0 : ot.AppURL,
        key: ot == null ? void 0 : ot.AppId,
        target: (ot == null ? void 0 : ot.id) === 0 ? void 0 : "_blank"
      },
      " ",
      /* @__PURE__ */ React__default.createElement(
        "button",
        {
          key: ot == null ? void 0 : ot.AppAbv,
          className: St(
            (ot == null ? void 0 : ot.AppId) == rt ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
            "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
          )
        },
        ot.icon ? /* @__PURE__ */ React__default.createElement(
          ot.icon,
          {
            className: St(
              ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
              "h-6 w-6"
            ),
            "aria-hidden": "true"
          }
        ) : /* @__PURE__ */ React__default.createElement(
          "img",
          {
            src: `AppLogo/${ot == null ? void 0 : ot.AppIcon}`,
            className: St(
              (ot == null ? void 0 : ot.AppId) == rt ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
              "h-6 w-8"
            ),
            "aria-hidden": "true"
          }
        ),
        /* @__PURE__ */ React__default.createElement("span", null, ot == null ? void 0 : ot.AppAbv)
      )
    ))
  )), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-col flex-shrink-0 pb-5" }, /* @__PURE__ */ React__default.createElement(
    "a",
    {
      href: "https://support.gtls.com.au/help/2703577665",
      target: "_blank",
      className: "flex justify-center"
    },
    " ",
    /* @__PURE__ */ React__default.createElement(
      "button",
      {
        className: St(
          "text-gray-400 hover:bg-gray-700 hover:text-white",
          "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
        )
      },
      /* @__PURE__ */ React__default.createElement(
        pt,
        {
          className: St(
            "text-gray-400 group-hover:text-white",
            "h-6 w-6"
          ),
          "aria-hidden": "true"
        }
      ),
      /* @__PURE__ */ React__default.createElement("span", { className: "mt-2" }, "Support")
    )
  ), /* @__PURE__ */ React__default.createElement("button", { onClick: it }, /* @__PURE__ */ React__default.createElement(
    Ie,
    {
      className: "flex flex-col hover:bg-gray-900 hover:text-white"
    },
    /* @__PURE__ */ React__default.createElement(lt, { className: "w-7 ml-2 text-gray-400" }),
    /* @__PURE__ */ React__default.createElement("span", { className: "text-xs text-gray-400" }, "LOGOUT")
  )))))), /* @__PURE__ */ React__default.createElement(qe.Root, { show: ne, as: Fragment }, /* @__PURE__ */ React__default.createElement(
    _t,
    {
      as: "div",
      className: "relative z-20 lg:hidden",
      onClose: Ae
    },
    /* @__PURE__ */ React__default.createElement(
      qe.Child,
      {
        as: Fragment,
        enter: "transition-opacity ease-linear duration-300",
        enterFrom: "opacity-0",
        enterTo: "opacity-100",
        leave: "transition-opacity ease-linear duration-300",
        leaveFrom: "opacity-100",
        leaveTo: "opacity-0"
      },
      /* @__PURE__ */ React__default.createElement("div", { className: "fixed inset-0 bg-gray-600 bg-opacity-75" })
    ),
    /* @__PURE__ */ React__default.createElement("div", { className: "fixed inset-0 z-40 flex" }, /* @__PURE__ */ React__default.createElement(
      qe.Child,
      {
        as: Fragment,
        enter: "transition ease-in-out duration-300 transform",
        enterFrom: "-translate-x-full",
        enterTo: "translate-x-0",
        leave: "transition ease-in-out duration-300 transform",
        leaveFrom: "translate-x-0",
        leaveTo: "-translate-x-full"
      },
      /* @__PURE__ */ React__default.createElement(_t.Panel, { className: "relative flex w-full max-w-xs flex-1 flex-col bg-gray-800 pt-5 pb-4" }, /* @__PURE__ */ React__default.createElement(
        qe.Child,
        {
          as: Fragment,
          enter: "ease-in-out duration-300",
          enterFrom: "opacity-0",
          enterTo: "opacity-100",
          leave: "ease-in-out duration-300",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0"
        },
        /* @__PURE__ */ React__default.createElement("div", { className: "absolute top-1 right-0 -mr-14 p-1" }, /* @__PURE__ */ React__default.createElement(
          "button",
          {
            type: "button",
            className: "flex h-12 w-12 items-center justify-center rounded-full focus:outline-none ",
            onClick: Ae
          },
          /* @__PURE__ */ React__default.createElement(
            oe,
            {
              className: "h-6 w-6 text-white",
              "aria-hidden": "true"
            }
          ),
          /* @__PURE__ */ React__default.createElement("span", { className: "sr-only" }, "Close sidebar")
        ))
      ), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-shrink-0 items-center px-4" }, typeof L == "string" ? /* @__PURE__ */ React__default.createElement("img", { className: "h-8 w-auto", src: L, alt: "tiger" }) : /* @__PURE__ */ React__default.createElement("div", { className: "h-8 w-auto" }, L)), /* @__PURE__ */ React__default.createElement("div", { className: "mt-5 h-0 flex-1 overflow-y-auto px-2" }, /* @__PURE__ */ React__default.createElement("nav", { className: "flex h-full flex-col" }, /* @__PURE__ */ React__default.createElement("div", { className: "space-y-1 " }, dt.map((ot) => /* @__PURE__ */ React__default.createElement(
        Accordion,
        {
          key: ot == null ? void 0 : ot.id,
          transition: {
            duration: "300ms",
            timingFunction: "cubic-bezier(0, 0, 0.2, 1)"
          }
        },
        ot != null && ot.options ? /* @__PURE__ */ React__default.createElement(AccordionItem, null, ({}) => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(
          AccordionHeader,
          {
            onClick: ge,
            className: St(
              ot != null && ot.current ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
              "group py-2 px-3 rounded-md gap-x-2 text-sm font-medium w-full flex justify- items-center text-gray-600  p-4"
            )
          },
          ot != null && ot.icon ? /* @__PURE__ */ React__default.createElement(
            ot.icon,
            {
              className: St(
                ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                "h-6 w-6"
              ),
              "aria-hidden": "true"
            }
          ) : /* @__PURE__ */ React__default.createElement(
            "img",
            {
              src: ot == null ? void 0 : ot.img,
              className: St(
                ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                "h-6 w-6"
              ),
              "aria-hidden": "true"
            }
          ),
          /* @__PURE__ */ React__default.createElement(
            "span",
            {
              id: ot == null ? void 0 : ot.name
            },
            ot == null ? void 0 : ot.name
          ),
          (ot == null ? void 0 : ot.options.length) > 0 ? /* @__PURE__ */ React__default.createElement(pe, { className: "h-3" }) : /* @__PURE__ */ React__default.createElement(React__default.Fragment, null)
        ), ot.options ? /* @__PURE__ */ React__default.createElement(AccordionBody, { className: "pl-8 flex flex-col" }, ot.options.map(
          (ht) => /* @__PURE__ */ React__default.createElement(
            "button",
            {
              id: ht.name ? ht == null ? void 0 : ht.name.toString() : "",
              onClick: be,
              className: "p-5 font-light text-left text-white"
            },
            ht == null ? void 0 : ht.name
          )
        )) : "")) : /* @__PURE__ */ React__default.createElement(
          "a",
          {
            href: ot.href,
            onClick: me
          },
          /* @__PURE__ */ React__default.createElement(
            AccordionItem,
            {
              key: ot.name ? ot == null ? void 0 : ot.name.toString() : ""
            },
            ({}) => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(
              AccordionHeader,
              {
                className: St(
                  ot != null && ot.current ? "bg-gray-700 text-white" : "text-gray-400 hover:bg-gray-900 hover:text-white",
                  "group py-2 px-3 rounded-md flex gap-x-2 items-center text-sm font-medium w-full text-gray-600  p-4"
                )
              },
              ot.icon ? /* @__PURE__ */ React__default.createElement(
                ot.icon,
                {
                  className: St(
                    ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                    "h-6 w-6"
                  ),
                  "aria-hidden": "true"
                }
              ) : /* @__PURE__ */ React__default.createElement(
                "img",
                {
                  src: ot == null ? void 0 : ot.img,
                  className: St(
                    ot != null && ot.current ? "text-yellow-400" : "text-gray-400 group-hover:text-white",
                    "h-6 w-6"
                  ),
                  "aria-hidden": "true"
                }
              ),
              /* @__PURE__ */ React__default.createElement("span", null, ot == null ? void 0 : ot.name)
            ), ot.options ? /* @__PURE__ */ React__default.createElement(AccordionBody, { className: "pl-8 flex flex-col" }, ot.options.map(
              (ht) => /* @__PURE__ */ React__default.createElement(
                "button",
                {
                  onClick: be,
                  className: "p-5 font-light text-left text-white"
                },
                ht == null ? void 0 : ht.name
              )
            )) : "")
          )
        )
      ))))), /* @__PURE__ */ React__default.createElement("div", { className: "flex flex-col flex-shrink-0 pb-5" }, /* @__PURE__ */ React__default.createElement(
        "a",
        {
          href: "https://support.gtls.com.au/help/2703577665",
          target: "_blank",
          className: "flex"
        },
        " ",
        /* @__PURE__ */ React__default.createElement(
          "button",
          {
            className: St(
              "text-gray-400 hover:bg-gray-700 hover:text-white",
              "group w-auto p-3 rounded-md flex flex-col items-center text-xs font-medium"
            )
          },
          /* @__PURE__ */ React__default.createElement(
            pt,
            {
              className: St(
                "text-gray-400 group-hover:text-white",
                "h-6 w-6"
              ),
              "aria-hidden": "true"
            }
          ),
          /* @__PURE__ */ React__default.createElement("span", { className: "mt-2" }, "Support")
        )
      ), /* @__PURE__ */ React__default.createElement("button", { onClick: it }, /* @__PURE__ */ React__default.createElement(
        Ie,
        {
          className: "flex flex-col hover:bg-gray-900 hover:text-white w-8 h-14"
        },
        /* @__PURE__ */ React__default.createElement(lt, { className: "w-7 ml-2 text-gray-400" }),
        /* @__PURE__ */ React__default.createElement("span", { className: "text-xs text-gray-400" }, "LOGOUT")
      ))))
    ), /* @__PURE__ */ React__default.createElement("div", { className: "w-14 flex-shrink-0", "aria-hidden": "true" }))
  )), /* @__PURE__ */ React__default.createElement(ut, null));
};
function bind$2(L, ne) {
  return function() {
    return L.apply(ne, arguments);
  };
}
const { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = /* @__PURE__ */ ((L) => (ne) => {
  const oe = toString.call(ne);
  return L[oe] || (L[oe] = oe.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (L) => (L = L.toLowerCase(), (ne) => kindOf(ne) === L), typeOfTest = (L) => (ne) => typeof ne === L, { isArray: isArray$4 } = Array, isUndefined = typeOfTest("undefined");
function isBuffer$1(L) {
  return L !== null && !isUndefined(L) && L.constructor !== null && !isUndefined(L.constructor) && isFunction(L.constructor.isBuffer) && L.constructor.isBuffer(L);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(L) {
  let ne;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ne = ArrayBuffer.isView(L) : ne = L && L.buffer && isArrayBuffer(L.buffer), ne;
}
const isString$1 = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber$1 = typeOfTest("number"), isObject = (L) => L !== null && typeof L == "object", isBoolean$1 = (L) => L === !0 || L === !1, isPlainObject = (L) => {
  if (kindOf(L) !== "object")
    return !1;
  const ne = getPrototypeOf(L);
  return (ne === null || ne === Object.prototype || Object.getPrototypeOf(ne) === null) && !(Symbol.toStringTag in L) && !(Symbol.iterator in L);
}, isDate$1 = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (L) => isObject(L) && isFunction(L.pipe), isFormData = (L) => {
  let ne;
  return L && (typeof FormData == "function" && L instanceof FormData || isFunction(L.append) && ((ne = kindOf(L)) === "formdata" || // detect form-data instance
  ne === "object" && isFunction(L.toString) && L.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (L) => L.trim ? L.trim() : L.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(L, ne, { allOwnKeys: oe = !1 } = {}) {
  if (L === null || typeof L > "u")
    return;
  let pe, me;
  if (typeof L != "object" && (L = [L]), isArray$4(L))
    for (pe = 0, me = L.length; pe < me; pe++)
      ne.call(null, L[pe], pe, L);
  else {
    const ge = oe ? Object.getOwnPropertyNames(L) : Object.keys(L), be = ge.length;
    let Ie;
    for (pe = 0; pe < be; pe++)
      Ie = ge[pe], ne.call(null, L[Ie], Ie, L);
  }
}
function findKey(L, ne) {
  ne = ne.toLowerCase();
  const oe = Object.keys(L);
  let pe = oe.length, me;
  for (; pe-- > 0; )
    if (me = oe[pe], ne === me.toLowerCase())
      return me;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = (L) => !isUndefined(L) && L !== _global;
function merge$1() {
  const { caseless: L } = isContextDefined(this) && this || {}, ne = {}, oe = (pe, me) => {
    const ge = L && findKey(ne, me) || me;
    isPlainObject(ne[ge]) && isPlainObject(pe) ? ne[ge] = merge$1(ne[ge], pe) : isPlainObject(pe) ? ne[ge] = merge$1({}, pe) : isArray$4(pe) ? ne[ge] = pe.slice() : ne[ge] = pe;
  };
  for (let pe = 0, me = arguments.length; pe < me; pe++)
    arguments[pe] && forEach(arguments[pe], oe);
  return ne;
}
const extend = (L, ne, oe, { allOwnKeys: pe } = {}) => (forEach(ne, (me, ge) => {
  oe && isFunction(me) ? L[ge] = bind$2(me, oe) : L[ge] = me;
}, { allOwnKeys: pe }), L), stripBOM = (L) => (L.charCodeAt(0) === 65279 && (L = L.slice(1)), L), inherits = (L, ne, oe, pe) => {
  L.prototype = Object.create(ne.prototype, pe), L.prototype.constructor = L, Object.defineProperty(L, "super", {
    value: ne.prototype
  }), oe && Object.assign(L.prototype, oe);
}, toFlatObject = (L, ne, oe, pe) => {
  let me, ge, be;
  const Ie = {};
  if (ne = ne || {}, L == null)
    return ne;
  do {
    for (me = Object.getOwnPropertyNames(L), ge = me.length; ge-- > 0; )
      be = me[ge], (!pe || pe(be, L, ne)) && !Ie[be] && (ne[be] = L[be], Ie[be] = !0);
    L = oe !== !1 && getPrototypeOf(L);
  } while (L && (!oe || oe(L, ne)) && L !== Object.prototype);
  return ne;
}, endsWith = (L, ne, oe) => {
  L = String(L), (oe === void 0 || oe > L.length) && (oe = L.length), oe -= ne.length;
  const pe = L.indexOf(ne, oe);
  return pe !== -1 && pe === oe;
}, toArray = (L) => {
  if (!L)
    return null;
  if (isArray$4(L))
    return L;
  let ne = L.length;
  if (!isNumber$1(ne))
    return null;
  const oe = new Array(ne);
  for (; ne-- > 0; )
    oe[ne] = L[ne];
  return oe;
}, isTypedArray = /* @__PURE__ */ ((L) => (ne) => L && ne instanceof L)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (L, ne) => {
  const pe = (L && L[Symbol.iterator]).call(L);
  let me;
  for (; (me = pe.next()) && !me.done; ) {
    const ge = me.value;
    ne.call(L, ge[0], ge[1]);
  }
}, matchAll = (L, ne) => {
  let oe;
  const pe = [];
  for (; (oe = L.exec(ne)) !== null; )
    pe.push(oe);
  return pe;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (L) => L.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(oe, pe, me) {
    return pe.toUpperCase() + me;
  }
), hasOwnProperty = (({ hasOwnProperty: L }) => (ne, oe) => L.call(ne, oe))(Object.prototype), isRegExp$2 = kindOfTest("RegExp"), reduceDescriptors = (L, ne) => {
  const oe = Object.getOwnPropertyDescriptors(L), pe = {};
  forEach(oe, (me, ge) => {
    let be;
    (be = ne(me, ge, L)) !== !1 && (pe[ge] = be || me);
  }), Object.defineProperties(L, pe);
}, freezeMethods = (L) => {
  reduceDescriptors(L, (ne, oe) => {
    if (isFunction(L) && ["arguments", "caller", "callee"].indexOf(oe) !== -1)
      return !1;
    const pe = L[oe];
    if (isFunction(pe)) {
      if (ne.enumerable = !1, "writable" in ne) {
        ne.writable = !1;
        return;
      }
      ne.set || (ne.set = () => {
        throw Error("Can not rewrite read-only method '" + oe + "'");
      });
    }
  });
}, toObjectSet = (L, ne) => {
  const oe = {}, pe = (me) => {
    me.forEach((ge) => {
      oe[ge] = !0;
    });
  };
  return isArray$4(L) ? pe(L) : pe(String(L).split(ne)), oe;
}, noop = () => {
}, toFiniteNumber = (L, ne) => (L = +L, Number.isFinite(L) ? L : ne), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (L = 16, ne = ALPHABET.ALPHA_DIGIT) => {
  let oe = "";
  const { length: pe } = ne;
  for (; L--; )
    oe += ne[Math.random() * pe | 0];
  return oe;
};
function isSpecCompliantForm(L) {
  return !!(L && isFunction(L.append) && L[Symbol.toStringTag] === "FormData" && L[Symbol.iterator]);
}
const toJSONObject = (L) => {
  const ne = new Array(10), oe = (pe, me) => {
    if (isObject(pe)) {
      if (ne.indexOf(pe) >= 0)
        return;
      if (!("toJSON" in pe)) {
        ne[me] = pe;
        const ge = isArray$4(pe) ? [] : {};
        return forEach(pe, (be, Ie) => {
          const Ae = oe(be, me + 1);
          !isUndefined(Ae) && (ge[Ie] = Ae);
        }), ne[me] = void 0, ge;
      }
    }
    return pe;
  };
  return oe(L, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (L) => L && (isObject(L) || isFunction(L)) && isFunction(L.then) && isFunction(L.catch), utils$4 = {
  isArray: isArray$4,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isBoolean: isBoolean$1,
  isObject,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp: isRegExp$2,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(L, ne, oe, pe, me) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = L, this.name = "AxiosError", ne && (this.code = ne), oe && (this.config = oe), pe && (this.request = pe), me && (this.response = me);
}
utils$4.inherits(AxiosError, Error, {
  toJSON: function L() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((L) => {
  descriptors[L] = { value: L };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (L, ne, oe, pe, me, ge) => {
  const be = Object.create(prototype$1);
  return utils$4.toFlatObject(L, be, function(Ae) {
    return Ae !== Error.prototype;
  }, (Ie) => Ie !== "isAxiosError"), AxiosError.call(be, L.message, ne, oe, pe, me), be.cause = L, be.name = L.name, ge && Object.assign(be, ge), be;
};
const httpAdapter = null;
function isVisitable(L) {
  return utils$4.isPlainObject(L) || utils$4.isArray(L);
}
function removeBrackets(L) {
  return utils$4.endsWith(L, "[]") ? L.slice(0, -2) : L;
}
function renderKey(L, ne, oe) {
  return L ? L.concat(ne).map(function(me, ge) {
    return me = removeBrackets(me), !oe && ge ? "[" + me + "]" : me;
  }).join(oe ? "." : "") : ne;
}
function isFlatArray(L) {
  return utils$4.isArray(L) && !L.some(isVisitable);
}
const predicates = utils$4.toFlatObject(utils$4, {}, null, function L(ne) {
  return /^is[A-Z]/.test(ne);
});
function toFormData(L, ne, oe) {
  if (!utils$4.isObject(L))
    throw new TypeError("target must be an object");
  ne = ne || new FormData(), oe = utils$4.toFlatObject(oe, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(ut, St) {
    return !utils$4.isUndefined(St[ut]);
  });
  const pe = oe.metaTokens, me = oe.visitor || st, ge = oe.dots, be = oe.indexes, Ae = (oe.Blob || typeof Blob < "u" && Blob) && utils$4.isSpecCompliantForm(ne);
  if (!utils$4.isFunction(me))
    throw new TypeError("visitor must be a function");
  function rt(it) {
    if (it === null)
      return "";
    if (utils$4.isDate(it))
      return it.toISOString();
    if (!Ae && utils$4.isBlob(it))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$4.isArrayBuffer(it) || utils$4.isTypedArray(it) ? Ae && typeof Blob == "function" ? new Blob([it]) : Buffer.from(it) : it;
  }
  function st(it, ut, St) {
    let ot = it;
    if (it && !St && typeof it == "object") {
      if (utils$4.endsWith(ut, "{}"))
        ut = pe ? ut : ut.slice(0, -2), it = JSON.stringify(it);
      else if (utils$4.isArray(it) && isFlatArray(it) || (utils$4.isFileList(it) || utils$4.endsWith(ut, "[]")) && (ot = utils$4.toArray(it)))
        return ut = removeBrackets(ut), ot.forEach(function(ft, vt) {
          !(utils$4.isUndefined(ft) || ft === null) && ne.append(
            // eslint-disable-next-line no-nested-ternary
            be === !0 ? renderKey([ut], vt, ge) : be === null ? ut : ut + "[]",
            rt(ft)
          );
        }), !1;
    }
    return isVisitable(it) ? !0 : (ne.append(renderKey(St, ut, ge), rt(it)), !1);
  }
  const dt = [], lt = Object.assign(predicates, {
    defaultVisitor: st,
    convertValue: rt,
    isVisitable
  });
  function pt(it, ut) {
    if (!utils$4.isUndefined(it)) {
      if (dt.indexOf(it) !== -1)
        throw Error("Circular reference detected in " + ut.join("."));
      dt.push(it), utils$4.forEach(it, function(ot, ht) {
        (!(utils$4.isUndefined(ot) || ot === null) && me.call(
          ne,
          ot,
          utils$4.isString(ht) ? ht.trim() : ht,
          ut,
          lt
        )) === !0 && pt(ot, ut ? ut.concat(ht) : [ht]);
      }), dt.pop();
    }
  }
  if (!utils$4.isObject(L))
    throw new TypeError("data must be an object");
  return pt(L), ne;
}
function encode$2(L) {
  const ne = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(L).replace(/[!'()~]|%20|%00/g, function(pe) {
    return ne[pe];
  });
}
function AxiosURLSearchParams(L, ne) {
  this._pairs = [], L && toFormData(L, this, ne);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function L(ne, oe) {
  this._pairs.push([ne, oe]);
};
prototype.toString = function L(ne) {
  const oe = ne ? function(pe) {
    return ne.call(this, pe, encode$2);
  } : encode$2;
  return this._pairs.map(function(me) {
    return oe(me[0]) + "=" + oe(me[1]);
  }, "").join("&");
};
function encode$1(L) {
  return encodeURIComponent(L).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(L, ne, oe) {
  if (!ne)
    return L;
  const pe = oe && oe.encode || encode$1, me = oe && oe.serialize;
  let ge;
  if (me ? ge = me(ne, oe) : ge = utils$4.isURLSearchParams(ne) ? ne.toString() : new AxiosURLSearchParams(ne, oe).toString(pe), ge) {
    const be = L.indexOf("#");
    be !== -1 && (L = L.slice(0, be)), L += (L.indexOf("?") === -1 ? "?" : "&") + ge;
  }
  return L;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(ne, oe, pe) {
    return this.handlers.push({
      fulfilled: ne,
      rejected: oe,
      synchronous: pe ? pe.synchronous : !1,
      runWhen: pe ? pe.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(ne) {
    this.handlers[ne] && (this.handlers[ne] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(ne) {
    utils$4.forEach(this.handlers, function(pe) {
      pe !== null && ne(pe);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = ((L) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(L) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", utils$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" })), platform = {
  ...utils$3,
  ...platform$1
};
function toURLEncodedForm(L, ne) {
  return toFormData(L, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(oe, pe, me, ge) {
      return platform.isNode && utils$4.isBuffer(oe) ? (this.append(pe, oe.toString("base64")), !1) : ge.defaultVisitor.apply(this, arguments);
    }
  }, ne));
}
function parsePropPath(L) {
  return utils$4.matchAll(/\w+|\[(\w*)]/g, L).map((ne) => ne[0] === "[]" ? "" : ne[1] || ne[0]);
}
function arrayToObject$1(L) {
  const ne = {}, oe = Object.keys(L);
  let pe;
  const me = oe.length;
  let ge;
  for (pe = 0; pe < me; pe++)
    ge = oe[pe], ne[ge] = L[ge];
  return ne;
}
function formDataToJSON(L) {
  function ne(oe, pe, me, ge) {
    let be = oe[ge++];
    if (be === "__proto__")
      return !0;
    const Ie = Number.isFinite(+be), Ae = ge >= oe.length;
    return be = !be && utils$4.isArray(me) ? me.length : be, Ae ? (utils$4.hasOwnProp(me, be) ? me[be] = [me[be], pe] : me[be] = pe, !Ie) : ((!me[be] || !utils$4.isObject(me[be])) && (me[be] = []), ne(oe, pe, me[be], ge) && utils$4.isArray(me[be]) && (me[be] = arrayToObject$1(me[be])), !Ie);
  }
  if (utils$4.isFormData(L) && utils$4.isFunction(L.entries)) {
    const oe = {};
    return utils$4.forEachEntry(L, (pe, me) => {
      ne(parsePropPath(pe), me, oe, 0);
    }), oe;
  }
  return null;
}
function stringifySafely(L, ne, oe) {
  if (utils$4.isString(L))
    try {
      return (ne || JSON.parse)(L), utils$4.trim(L);
    } catch (pe) {
      if (pe.name !== "SyntaxError")
        throw pe;
    }
  return (oe || JSON.stringify)(L);
}
const defaults$2 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function L(ne, oe) {
    const pe = oe.getContentType() || "", me = pe.indexOf("application/json") > -1, ge = utils$4.isObject(ne);
    if (ge && utils$4.isHTMLForm(ne) && (ne = new FormData(ne)), utils$4.isFormData(ne))
      return me && me ? JSON.stringify(formDataToJSON(ne)) : ne;
    if (utils$4.isArrayBuffer(ne) || utils$4.isBuffer(ne) || utils$4.isStream(ne) || utils$4.isFile(ne) || utils$4.isBlob(ne))
      return ne;
    if (utils$4.isArrayBufferView(ne))
      return ne.buffer;
    if (utils$4.isURLSearchParams(ne))
      return oe.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), ne.toString();
    let Ie;
    if (ge) {
      if (pe.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(ne, this.formSerializer).toString();
      if ((Ie = utils$4.isFileList(ne)) || pe.indexOf("multipart/form-data") > -1) {
        const Ae = this.env && this.env.FormData;
        return toFormData(
          Ie ? { "files[]": ne } : ne,
          Ae && new Ae(),
          this.formSerializer
        );
      }
    }
    return ge || me ? (oe.setContentType("application/json", !1), stringifySafely(ne)) : ne;
  }],
  transformResponse: [function L(ne) {
    const oe = this.transitional || defaults$2.transitional, pe = oe && oe.forcedJSONParsing, me = this.responseType === "json";
    if (ne && utils$4.isString(ne) && (pe && !this.responseType || me)) {
      const be = !(oe && oe.silentJSONParsing) && me;
      try {
        return JSON.parse(ne);
      } catch (Ie) {
        if (be)
          throw Ie.name === "SyntaxError" ? AxiosError.from(Ie, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : Ie;
      }
    }
    return ne;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function L(ne) {
    return ne >= 200 && ne < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$4.forEach(["delete", "get", "head", "post", "put", "patch"], (L) => {
  defaults$2.headers[L] = {};
});
const defaults$3 = defaults$2, ignoreDuplicateOf = utils$4.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (L) => {
  const ne = {};
  let oe, pe, me;
  return L && L.split(`
`).forEach(function(be) {
    me = be.indexOf(":"), oe = be.substring(0, me).trim().toLowerCase(), pe = be.substring(me + 1).trim(), !(!oe || ne[oe] && ignoreDuplicateOf[oe]) && (oe === "set-cookie" ? ne[oe] ? ne[oe].push(pe) : ne[oe] = [pe] : ne[oe] = ne[oe] ? ne[oe] + ", " + pe : pe);
  }), ne;
}, $internals = Symbol("internals");
function normalizeHeader(L) {
  return L && String(L).trim().toLowerCase();
}
function normalizeValue(L) {
  return L === !1 || L == null ? L : utils$4.isArray(L) ? L.map(normalizeValue) : String(L);
}
function parseTokens(L) {
  const ne = /* @__PURE__ */ Object.create(null), oe = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let pe;
  for (; pe = oe.exec(L); )
    ne[pe[1]] = pe[2];
  return ne;
}
const isValidHeaderName = (L) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(L.trim());
function matchHeaderValue(L, ne, oe, pe, me) {
  if (utils$4.isFunction(pe))
    return pe.call(this, ne, oe);
  if (me && (ne = oe), !!utils$4.isString(ne)) {
    if (utils$4.isString(pe))
      return ne.indexOf(pe) !== -1;
    if (utils$4.isRegExp(pe))
      return pe.test(ne);
  }
}
function formatHeader(L) {
  return L.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (ne, oe, pe) => oe.toUpperCase() + pe);
}
function buildAccessors(L, ne) {
  const oe = utils$4.toCamelCase(" " + ne);
  ["get", "set", "has"].forEach((pe) => {
    Object.defineProperty(L, pe + oe, {
      value: function(me, ge, be) {
        return this[pe].call(this, ne, me, ge, be);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(ne) {
    ne && this.set(ne);
  }
  set(ne, oe, pe) {
    const me = this;
    function ge(Ie, Ae, rt) {
      const st = normalizeHeader(Ae);
      if (!st)
        throw new Error("header name must be a non-empty string");
      const dt = utils$4.findKey(me, st);
      (!dt || me[dt] === void 0 || rt === !0 || rt === void 0 && me[dt] !== !1) && (me[dt || Ae] = normalizeValue(Ie));
    }
    const be = (Ie, Ae) => utils$4.forEach(Ie, (rt, st) => ge(rt, st, Ae));
    return utils$4.isPlainObject(ne) || ne instanceof this.constructor ? be(ne, oe) : utils$4.isString(ne) && (ne = ne.trim()) && !isValidHeaderName(ne) ? be(parseHeaders(ne), oe) : ne != null && ge(oe, ne, pe), this;
  }
  get(ne, oe) {
    if (ne = normalizeHeader(ne), ne) {
      const pe = utils$4.findKey(this, ne);
      if (pe) {
        const me = this[pe];
        if (!oe)
          return me;
        if (oe === !0)
          return parseTokens(me);
        if (utils$4.isFunction(oe))
          return oe.call(this, me, pe);
        if (utils$4.isRegExp(oe))
          return oe.exec(me);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(ne, oe) {
    if (ne = normalizeHeader(ne), ne) {
      const pe = utils$4.findKey(this, ne);
      return !!(pe && this[pe] !== void 0 && (!oe || matchHeaderValue(this, this[pe], pe, oe)));
    }
    return !1;
  }
  delete(ne, oe) {
    const pe = this;
    let me = !1;
    function ge(be) {
      if (be = normalizeHeader(be), be) {
        const Ie = utils$4.findKey(pe, be);
        Ie && (!oe || matchHeaderValue(pe, pe[Ie], Ie, oe)) && (delete pe[Ie], me = !0);
      }
    }
    return utils$4.isArray(ne) ? ne.forEach(ge) : ge(ne), me;
  }
  clear(ne) {
    const oe = Object.keys(this);
    let pe = oe.length, me = !1;
    for (; pe--; ) {
      const ge = oe[pe];
      (!ne || matchHeaderValue(this, this[ge], ge, ne, !0)) && (delete this[ge], me = !0);
    }
    return me;
  }
  normalize(ne) {
    const oe = this, pe = {};
    return utils$4.forEach(this, (me, ge) => {
      const be = utils$4.findKey(pe, ge);
      if (be) {
        oe[be] = normalizeValue(me), delete oe[ge];
        return;
      }
      const Ie = ne ? formatHeader(ge) : String(ge).trim();
      Ie !== ge && delete oe[ge], oe[Ie] = normalizeValue(me), pe[Ie] = !0;
    }), this;
  }
  concat(...ne) {
    return this.constructor.concat(this, ...ne);
  }
  toJSON(ne) {
    const oe = /* @__PURE__ */ Object.create(null);
    return utils$4.forEach(this, (pe, me) => {
      pe != null && pe !== !1 && (oe[me] = ne && utils$4.isArray(pe) ? pe.join(", ") : pe);
    }), oe;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([ne, oe]) => ne + ": " + oe).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(ne) {
    return ne instanceof this ? ne : new this(ne);
  }
  static concat(ne, ...oe) {
    const pe = new this(ne);
    return oe.forEach((me) => pe.set(me)), pe;
  }
  static accessor(ne) {
    const pe = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, me = this.prototype;
    function ge(be) {
      const Ie = normalizeHeader(be);
      pe[Ie] || (buildAccessors(me, be), pe[Ie] = !0);
    }
    return utils$4.isArray(ne) ? ne.forEach(ge) : ge(ne), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$4.reduceDescriptors(AxiosHeaders.prototype, ({ value: L }, ne) => {
  let oe = ne[0].toUpperCase() + ne.slice(1);
  return {
    get: () => L,
    set(pe) {
      this[oe] = pe;
    }
  };
});
utils$4.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(L, ne) {
  const oe = this || defaults$3, pe = ne || oe, me = AxiosHeaders$1.from(pe.headers);
  let ge = pe.data;
  return utils$4.forEach(L, function(Ie) {
    ge = Ie.call(oe, ge, me.normalize(), ne ? ne.status : void 0);
  }), me.normalize(), ge;
}
function isCancel(L) {
  return !!(L && L.__CANCEL__);
}
function CanceledError(L, ne, oe) {
  AxiosError.call(this, L ?? "canceled", AxiosError.ERR_CANCELED, ne, oe), this.name = "CanceledError";
}
utils$4.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(L, ne, oe) {
  const pe = oe.config.validateStatus;
  !oe.status || !pe || pe(oe.status) ? L(oe) : ne(new AxiosError(
    "Request failed with status code " + oe.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(oe.status / 100) - 4],
    oe.config,
    oe.request,
    oe
  ));
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(L, ne, oe, pe, me, ge) {
      const be = [L + "=" + encodeURIComponent(ne)];
      utils$4.isNumber(oe) && be.push("expires=" + new Date(oe).toGMTString()), utils$4.isString(pe) && be.push("path=" + pe), utils$4.isString(me) && be.push("domain=" + me), ge === !0 && be.push("secure"), document.cookie = be.join("; ");
    },
    read(L) {
      const ne = document.cookie.match(new RegExp("(^|;\\s*)(" + L + ")=([^;]*)"));
      return ne ? decodeURIComponent(ne[3]) : null;
    },
    remove(L) {
      this.write(L, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(L) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(L);
}
function combineURLs(L, ne) {
  return ne ? L.replace(/\/?\/$/, "") + "/" + ne.replace(/^\/+/, "") : L;
}
function buildFullPath(L, ne) {
  return L && !isAbsoluteURL(ne) ? combineURLs(L, ne) : ne;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function L() {
    const ne = /(msie|trident)/i.test(navigator.userAgent), oe = document.createElement("a");
    let pe;
    function me(ge) {
      let be = ge;
      return ne && (oe.setAttribute("href", be), be = oe.href), oe.setAttribute("href", be), {
        href: oe.href,
        protocol: oe.protocol ? oe.protocol.replace(/:$/, "") : "",
        host: oe.host,
        search: oe.search ? oe.search.replace(/^\?/, "") : "",
        hash: oe.hash ? oe.hash.replace(/^#/, "") : "",
        hostname: oe.hostname,
        port: oe.port,
        pathname: oe.pathname.charAt(0) === "/" ? oe.pathname : "/" + oe.pathname
      };
    }
    return pe = me(window.location.href), function(be) {
      const Ie = utils$4.isString(be) ? me(be) : be;
      return Ie.protocol === pe.protocol && Ie.host === pe.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function L() {
    return function() {
      return !0;
    };
  }()
);
function parseProtocol(L) {
  const ne = /^([-+\w]{1,25})(:?\/\/|:)/.exec(L);
  return ne && ne[1] || "";
}
function speedometer(L, ne) {
  L = L || 10;
  const oe = new Array(L), pe = new Array(L);
  let me = 0, ge = 0, be;
  return ne = ne !== void 0 ? ne : 1e3, function(Ae) {
    const rt = Date.now(), st = pe[ge];
    be || (be = rt), oe[me] = Ae, pe[me] = rt;
    let dt = ge, lt = 0;
    for (; dt !== me; )
      lt += oe[dt++], dt = dt % L;
    if (me = (me + 1) % L, me === ge && (ge = (ge + 1) % L), rt - be < ne)
      return;
    const pt = st && rt - st;
    return pt ? Math.round(lt * 1e3 / pt) : void 0;
  };
}
function progressEventReducer(L, ne) {
  let oe = 0;
  const pe = speedometer(50, 250);
  return (me) => {
    const ge = me.loaded, be = me.lengthComputable ? me.total : void 0, Ie = ge - oe, Ae = pe(Ie), rt = ge <= be;
    oe = ge;
    const st = {
      loaded: ge,
      total: be,
      progress: be ? ge / be : void 0,
      bytes: Ie,
      rate: Ae || void 0,
      estimated: Ae && be && rt ? (be - ge) / Ae : void 0,
      event: me
    };
    st[ne ? "download" : "upload"] = !0, L(st);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(L) {
  return new Promise(function(oe, pe) {
    let me = L.data;
    const ge = AxiosHeaders$1.from(L.headers).normalize();
    let { responseType: be, withXSRFToken: Ie } = L, Ae;
    function rt() {
      L.cancelToken && L.cancelToken.unsubscribe(Ae), L.signal && L.signal.removeEventListener("abort", Ae);
    }
    let st;
    if (utils$4.isFormData(me)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
        ge.setContentType(!1);
      else if ((st = ge.getContentType()) !== !1) {
        const [ut, ...St] = st ? st.split(";").map((ot) => ot.trim()).filter(Boolean) : [];
        ge.setContentType([ut || "multipart/form-data", ...St].join("; "));
      }
    }
    let dt = new XMLHttpRequest();
    if (L.auth) {
      const ut = L.auth.username || "", St = L.auth.password ? unescape(encodeURIComponent(L.auth.password)) : "";
      ge.set("Authorization", "Basic " + btoa(ut + ":" + St));
    }
    const lt = buildFullPath(L.baseURL, L.url);
    dt.open(L.method.toUpperCase(), buildURL(lt, L.params, L.paramsSerializer), !0), dt.timeout = L.timeout;
    function pt() {
      if (!dt)
        return;
      const ut = AxiosHeaders$1.from(
        "getAllResponseHeaders" in dt && dt.getAllResponseHeaders()
      ), ot = {
        data: !be || be === "text" || be === "json" ? dt.responseText : dt.response,
        status: dt.status,
        statusText: dt.statusText,
        headers: ut,
        config: L,
        request: dt
      };
      settle(function(ft) {
        oe(ft), rt();
      }, function(ft) {
        pe(ft), rt();
      }, ot), dt = null;
    }
    if ("onloadend" in dt ? dt.onloadend = pt : dt.onreadystatechange = function() {
      !dt || dt.readyState !== 4 || dt.status === 0 && !(dt.responseURL && dt.responseURL.indexOf("file:") === 0) || setTimeout(pt);
    }, dt.onabort = function() {
      dt && (pe(new AxiosError("Request aborted", AxiosError.ECONNABORTED, L, dt)), dt = null);
    }, dt.onerror = function() {
      pe(new AxiosError("Network Error", AxiosError.ERR_NETWORK, L, dt)), dt = null;
    }, dt.ontimeout = function() {
      let St = L.timeout ? "timeout of " + L.timeout + "ms exceeded" : "timeout exceeded";
      const ot = L.transitional || transitionalDefaults;
      L.timeoutErrorMessage && (St = L.timeoutErrorMessage), pe(new AxiosError(
        St,
        ot.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        L,
        dt
      )), dt = null;
    }, platform.hasStandardBrowserEnv && (Ie && utils$4.isFunction(Ie) && (Ie = Ie(L)), Ie || Ie !== !1 && isURLSameOrigin(lt))) {
      const ut = L.xsrfHeaderName && L.xsrfCookieName && cookies.read(L.xsrfCookieName);
      ut && ge.set(L.xsrfHeaderName, ut);
    }
    me === void 0 && ge.setContentType(null), "setRequestHeader" in dt && utils$4.forEach(ge.toJSON(), function(St, ot) {
      dt.setRequestHeader(ot, St);
    }), utils$4.isUndefined(L.withCredentials) || (dt.withCredentials = !!L.withCredentials), be && be !== "json" && (dt.responseType = L.responseType), typeof L.onDownloadProgress == "function" && dt.addEventListener("progress", progressEventReducer(L.onDownloadProgress, !0)), typeof L.onUploadProgress == "function" && dt.upload && dt.upload.addEventListener("progress", progressEventReducer(L.onUploadProgress)), (L.cancelToken || L.signal) && (Ae = (ut) => {
      dt && (pe(!ut || ut.type ? new CanceledError(null, L, dt) : ut), dt.abort(), dt = null);
    }, L.cancelToken && L.cancelToken.subscribe(Ae), L.signal && (L.signal.aborted ? Ae() : L.signal.addEventListener("abort", Ae)));
    const it = parseProtocol(lt);
    if (it && platform.protocols.indexOf(it) === -1) {
      pe(new AxiosError("Unsupported protocol " + it + ":", AxiosError.ERR_BAD_REQUEST, L));
      return;
    }
    dt.send(me || null);
  });
}, knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$4.forEach(knownAdapters, (L, ne) => {
  if (L) {
    try {
      Object.defineProperty(L, "name", { value: ne });
    } catch {
    }
    Object.defineProperty(L, "adapterName", { value: ne });
  }
});
const renderReason = (L) => `- ${L}`, isResolvedHandle = (L) => utils$4.isFunction(L) || L === null || L === !1, adapters = {
  getAdapter: (L) => {
    L = utils$4.isArray(L) ? L : [L];
    const { length: ne } = L;
    let oe, pe;
    const me = {};
    for (let ge = 0; ge < ne; ge++) {
      oe = L[ge];
      let be;
      if (pe = oe, !isResolvedHandle(oe) && (pe = knownAdapters[(be = String(oe)).toLowerCase()], pe === void 0))
        throw new AxiosError(`Unknown adapter '${be}'`);
      if (pe)
        break;
      me[be || "#" + ge] = pe;
    }
    if (!pe) {
      const ge = Object.entries(me).map(
        ([Ie, Ae]) => `adapter ${Ie} ` + (Ae === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let be = ne ? ge.length > 1 ? `since :
` + ge.map(renderReason).join(`
`) : " " + renderReason(ge[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + be,
        "ERR_NOT_SUPPORT"
      );
    }
    return pe;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(L) {
  if (L.cancelToken && L.cancelToken.throwIfRequested(), L.signal && L.signal.aborted)
    throw new CanceledError(null, L);
}
function dispatchRequest(L) {
  return throwIfCancellationRequested(L), L.headers = AxiosHeaders$1.from(L.headers), L.data = transformData.call(
    L,
    L.transformRequest
  ), ["post", "put", "patch"].indexOf(L.method) !== -1 && L.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(L.adapter || defaults$3.adapter)(L).then(function(pe) {
    return throwIfCancellationRequested(L), pe.data = transformData.call(
      L,
      L.transformResponse,
      pe
    ), pe.headers = AxiosHeaders$1.from(pe.headers), pe;
  }, function(pe) {
    return isCancel(pe) || (throwIfCancellationRequested(L), pe && pe.response && (pe.response.data = transformData.call(
      L,
      L.transformResponse,
      pe.response
    ), pe.response.headers = AxiosHeaders$1.from(pe.response.headers))), Promise.reject(pe);
  });
}
const headersToObject = (L) => L instanceof AxiosHeaders$1 ? L.toJSON() : L;
function mergeConfig(L, ne) {
  ne = ne || {};
  const oe = {};
  function pe(rt, st, dt) {
    return utils$4.isPlainObject(rt) && utils$4.isPlainObject(st) ? utils$4.merge.call({ caseless: dt }, rt, st) : utils$4.isPlainObject(st) ? utils$4.merge({}, st) : utils$4.isArray(st) ? st.slice() : st;
  }
  function me(rt, st, dt) {
    if (utils$4.isUndefined(st)) {
      if (!utils$4.isUndefined(rt))
        return pe(void 0, rt, dt);
    } else
      return pe(rt, st, dt);
  }
  function ge(rt, st) {
    if (!utils$4.isUndefined(st))
      return pe(void 0, st);
  }
  function be(rt, st) {
    if (utils$4.isUndefined(st)) {
      if (!utils$4.isUndefined(rt))
        return pe(void 0, rt);
    } else
      return pe(void 0, st);
  }
  function Ie(rt, st, dt) {
    if (dt in ne)
      return pe(rt, st);
    if (dt in L)
      return pe(void 0, rt);
  }
  const Ae = {
    url: ge,
    method: ge,
    data: ge,
    baseURL: be,
    transformRequest: be,
    transformResponse: be,
    paramsSerializer: be,
    timeout: be,
    timeoutMessage: be,
    withCredentials: be,
    withXSRFToken: be,
    adapter: be,
    responseType: be,
    xsrfCookieName: be,
    xsrfHeaderName: be,
    onUploadProgress: be,
    onDownloadProgress: be,
    decompress: be,
    maxContentLength: be,
    maxBodyLength: be,
    beforeRedirect: be,
    transport: be,
    httpAgent: be,
    httpsAgent: be,
    cancelToken: be,
    socketPath: be,
    responseEncoding: be,
    validateStatus: Ie,
    headers: (rt, st) => me(headersToObject(rt), headersToObject(st), !0)
  };
  return utils$4.forEach(Object.keys(Object.assign({}, L, ne)), function(st) {
    const dt = Ae[st] || me, lt = dt(L[st], ne[st], st);
    utils$4.isUndefined(lt) && dt !== Ie || (oe[st] = lt);
  }), oe;
}
const VERSION = "1.6.5", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((L, ne) => {
  validators$1[L] = function(pe) {
    return typeof pe === L || "a" + (ne < 1 ? "n " : " ") + L;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function L(ne, oe, pe) {
  function me(ge, be) {
    return "[Axios v" + VERSION + "] Transitional option '" + ge + "'" + be + (pe ? ". " + pe : "");
  }
  return (ge, be, Ie) => {
    if (ne === !1)
      throw new AxiosError(
        me(be, " has been removed" + (oe ? " in " + oe : "")),
        AxiosError.ERR_DEPRECATED
      );
    return oe && !deprecatedWarnings[be] && (deprecatedWarnings[be] = !0, console.warn(
      me(
        be,
        " has been deprecated since v" + oe + " and will be removed in the near future"
      )
    )), ne ? ne(ge, be, Ie) : !0;
  };
};
function assertOptions(L, ne, oe) {
  if (typeof L != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const pe = Object.keys(L);
  let me = pe.length;
  for (; me-- > 0; ) {
    const ge = pe[me], be = ne[ge];
    if (be) {
      const Ie = L[ge], Ae = Ie === void 0 || be(Ie, ge, L);
      if (Ae !== !0)
        throw new AxiosError("option " + ge + " must be " + Ae, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (oe !== !0)
      throw new AxiosError("Unknown option " + ge, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(ne) {
    this.defaults = ne, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(ne, oe) {
    typeof ne == "string" ? (oe = oe || {}, oe.url = ne) : oe = ne || {}, oe = mergeConfig(this.defaults, oe);
    const { transitional: pe, paramsSerializer: me, headers: ge } = oe;
    pe !== void 0 && validator.assertOptions(pe, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), me != null && (utils$4.isFunction(me) ? oe.paramsSerializer = {
      serialize: me
    } : validator.assertOptions(me, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), oe.method = (oe.method || this.defaults.method || "get").toLowerCase();
    let be = ge && utils$4.merge(
      ge.common,
      ge[oe.method]
    );
    ge && utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (it) => {
        delete ge[it];
      }
    ), oe.headers = AxiosHeaders$1.concat(be, ge);
    const Ie = [];
    let Ae = !0;
    this.interceptors.request.forEach(function(ut) {
      typeof ut.runWhen == "function" && ut.runWhen(oe) === !1 || (Ae = Ae && ut.synchronous, Ie.unshift(ut.fulfilled, ut.rejected));
    });
    const rt = [];
    this.interceptors.response.forEach(function(ut) {
      rt.push(ut.fulfilled, ut.rejected);
    });
    let st, dt = 0, lt;
    if (!Ae) {
      const it = [dispatchRequest.bind(this), void 0];
      for (it.unshift.apply(it, Ie), it.push.apply(it, rt), lt = it.length, st = Promise.resolve(oe); dt < lt; )
        st = st.then(it[dt++], it[dt++]);
      return st;
    }
    lt = Ie.length;
    let pt = oe;
    for (dt = 0; dt < lt; ) {
      const it = Ie[dt++], ut = Ie[dt++];
      try {
        pt = it(pt);
      } catch (St) {
        ut.call(this, St);
        break;
      }
    }
    try {
      st = dispatchRequest.call(this, pt);
    } catch (it) {
      return Promise.reject(it);
    }
    for (dt = 0, lt = rt.length; dt < lt; )
      st = st.then(rt[dt++], rt[dt++]);
    return st;
  }
  getUri(ne) {
    ne = mergeConfig(this.defaults, ne);
    const oe = buildFullPath(ne.baseURL, ne.url);
    return buildURL(oe, ne.params, ne.paramsSerializer);
  }
}
utils$4.forEach(["delete", "get", "head", "options"], function L(ne) {
  Axios.prototype[ne] = function(oe, pe) {
    return this.request(mergeConfig(pe || {}, {
      method: ne,
      url: oe,
      data: (pe || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function L(ne) {
  function oe(pe) {
    return function(ge, be, Ie) {
      return this.request(mergeConfig(Ie || {}, {
        method: ne,
        headers: pe ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: ge,
        data: be
      }));
    };
  }
  Axios.prototype[ne] = oe(), Axios.prototype[ne + "Form"] = oe(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(ne) {
    if (typeof ne != "function")
      throw new TypeError("executor must be a function.");
    let oe;
    this.promise = new Promise(function(ge) {
      oe = ge;
    });
    const pe = this;
    this.promise.then((me) => {
      if (!pe._listeners)
        return;
      let ge = pe._listeners.length;
      for (; ge-- > 0; )
        pe._listeners[ge](me);
      pe._listeners = null;
    }), this.promise.then = (me) => {
      let ge;
      const be = new Promise((Ie) => {
        pe.subscribe(Ie), ge = Ie;
      }).then(me);
      return be.cancel = function() {
        pe.unsubscribe(ge);
      }, be;
    }, ne(function(ge, be, Ie) {
      pe.reason || (pe.reason = new CanceledError(ge, be, Ie), oe(pe.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(ne) {
    if (this.reason) {
      ne(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(ne) : this._listeners = [ne];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(ne) {
    if (!this._listeners)
      return;
    const oe = this._listeners.indexOf(ne);
    oe !== -1 && this._listeners.splice(oe, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let ne;
    return {
      token: new CancelToken(function(me) {
        ne = me;
      }),
      cancel: ne
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(L) {
  return function(oe) {
    return L.apply(null, oe);
  };
}
function isAxiosError(L) {
  return utils$4.isObject(L) && L.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([L, ne]) => {
  HttpStatusCode[ne] = L;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(L) {
  const ne = new Axios$1(L), oe = bind$2(Axios$1.prototype.request, ne);
  return utils$4.extend(oe, Axios$1.prototype, ne, { allOwnKeys: !0 }), utils$4.extend(oe, ne, null, { allOwnKeys: !0 }), oe.create = function(me) {
    return createInstance(mergeConfig(L, me));
  }, oe;
}
const axios = createInstance(defaults$3);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function L(ne) {
  return Promise.all(ne);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (L) => formDataToJSON(utils$4.isHTMLForm(L) ? new FormData(L) : L);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var isMergeableObject = function L(ne) {
  return isNonNullObject(ne) && !isSpecial(ne);
};
function isNonNullObject(L) {
  return !!L && typeof L == "object";
}
function isSpecial(L) {
  var ne = Object.prototype.toString.call(L);
  return ne === "[object RegExp]" || ne === "[object Date]" || isReactElement(L);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(L) {
  return L.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(L) {
  return Array.isArray(L) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(L, ne) {
  return ne.clone !== !1 && ne.isMergeableObject(L) ? deepmerge(emptyTarget(L), L, ne) : L;
}
function defaultArrayMerge(L, ne, oe) {
  return L.concat(ne).map(function(pe) {
    return cloneUnlessOtherwiseSpecified(pe, oe);
  });
}
function getMergeFunction(L, ne) {
  if (!ne.customMerge)
    return deepmerge;
  var oe = ne.customMerge(L);
  return typeof oe == "function" ? oe : deepmerge;
}
function getEnumerableOwnPropertySymbols(L) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(L).filter(function(ne) {
    return Object.propertyIsEnumerable.call(L, ne);
  }) : [];
}
function getKeys(L) {
  return Object.keys(L).concat(getEnumerableOwnPropertySymbols(L));
}
function propertyIsOnObject(L, ne) {
  try {
    return ne in L;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(L, ne) {
  return propertyIsOnObject(L, ne) && !(Object.hasOwnProperty.call(L, ne) && Object.propertyIsEnumerable.call(L, ne));
}
function mergeObject(L, ne, oe) {
  var pe = {};
  return oe.isMergeableObject(L) && getKeys(L).forEach(function(me) {
    pe[me] = cloneUnlessOtherwiseSpecified(L[me], oe);
  }), getKeys(ne).forEach(function(me) {
    propertyIsUnsafe(L, me) || (propertyIsOnObject(L, me) && oe.isMergeableObject(ne[me]) ? pe[me] = getMergeFunction(me, oe)(L[me], ne[me], oe) : pe[me] = cloneUnlessOtherwiseSpecified(ne[me], oe));
  }), pe;
}
function deepmerge(L, ne, oe) {
  oe = oe || {}, oe.arrayMerge = oe.arrayMerge || defaultArrayMerge, oe.isMergeableObject = oe.isMergeableObject || isMergeableObject, oe.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var pe = Array.isArray(ne), me = Array.isArray(L), ge = pe === me;
  return ge ? pe ? oe.arrayMerge(L, ne, oe) : mergeObject(L, ne, oe) : cloneUnlessOtherwiseSpecified(ne, oe);
}
deepmerge.all = function L(ne, oe) {
  if (!Array.isArray(ne))
    throw new Error("first argument should be an array");
  return ne.reduce(function(pe, me) {
    return deepmerge(pe, me, oe);
  }, {});
};
var deepmerge_1 = deepmerge, cjs = deepmerge_1;
const te = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
var shams = function L() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var ne = {}, oe = Symbol("test"), pe = Object(oe);
  if (typeof oe == "string" || Object.prototype.toString.call(oe) !== "[object Symbol]" || Object.prototype.toString.call(pe) !== "[object Symbol]")
    return !1;
  var me = 42;
  ne[oe] = me;
  for (oe in ne)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(ne).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(ne).length !== 0)
    return !1;
  var ge = Object.getOwnPropertySymbols(ne);
  if (ge.length !== 1 || ge[0] !== oe || !Object.prototype.propertyIsEnumerable.call(ne, oe))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var be = Object.getOwnPropertyDescriptor(ne, oe);
    if (be.value !== me || be.enumerable !== !0)
      return !1;
  }
  return !0;
}, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams, hasSymbols$1 = function L() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function L() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$1 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function L(ne, oe) {
  for (var pe = [], me = 0; me < ne.length; me += 1)
    pe[me] = ne[me];
  for (var ge = 0; ge < oe.length; ge += 1)
    pe[ge + ne.length] = oe[ge];
  return pe;
}, slicy = function L(ne, oe) {
  for (var pe = [], me = oe || 0, ge = 0; me < ne.length; me += 1, ge += 1)
    pe[ge] = ne[me];
  return pe;
}, joiny = function(L, ne) {
  for (var oe = "", pe = 0; pe < L.length; pe += 1)
    oe += L[pe], pe + 1 < L.length && (oe += ne);
  return oe;
}, implementation$1 = function L(ne) {
  var oe = this;
  if (typeof oe != "function" || toStr$1.apply(oe) !== funcType)
    throw new TypeError(ERROR_MESSAGE + oe);
  for (var pe = slicy(arguments, 1), me, ge = function() {
    if (this instanceof me) {
      var st = oe.apply(
        this,
        concatty(pe, arguments)
      );
      return Object(st) === st ? st : this;
    }
    return oe.apply(
      ne,
      concatty(pe, arguments)
    );
  }, be = max(0, oe.length - pe.length), Ie = [], Ae = 0; Ae < be; Ae++)
    Ie[Ae] = "$" + Ae;
  if (me = Function("binder", "return function (" + joiny(Ie, ",") + "){ return binder.apply(this,arguments); }")(ge), oe.prototype) {
    var rt = function() {
    };
    rt.prototype = oe.prototype, me.prototype = new rt(), rt.prototype = null;
  }
  return me;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call, $hasOwn), undefined$1, $SyntaxError$1 = SyntaxError, $Function = Function, $TypeError$3 = TypeError, getEvalledConstructor = function(L) {
  try {
    return $Function('"use strict"; return (' + L + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto = Object.getPrototypeOf || (hasProto ? function(L) {
  return L.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto ? undefined$1 : getProto(Uint8Array), INTRINSICS = {
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto)
  try {
    null.error;
  } catch (L) {
    var errorProto = getProto(getProto(L));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function L(ne) {
  var oe;
  if (ne === "%AsyncFunction%")
    oe = getEvalledConstructor("async function () {}");
  else if (ne === "%GeneratorFunction%")
    oe = getEvalledConstructor("function* () {}");
  else if (ne === "%AsyncGeneratorFunction%")
    oe = getEvalledConstructor("async function* () {}");
  else if (ne === "%AsyncGenerator%") {
    var pe = L("%AsyncGeneratorFunction%");
    pe && (oe = pe.prototype);
  } else if (ne === "%AsyncIteratorPrototype%") {
    var me = L("%AsyncGenerator%");
    me && getProto && (oe = getProto(me.prototype));
  }
  return INTRINSICS[ne] = oe, oe;
}, LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn$1 = hasown, $concat$1 = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace$1 = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function L(ne) {
  var oe = $strSlice(ne, 0, 1), pe = $strSlice(ne, -1);
  if (oe === "%" && pe !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (pe === "%" && oe !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var me = [];
  return $replace$1(ne, rePropName, function(ge, be, Ie, Ae) {
    me[me.length] = Ie ? $replace$1(Ae, reEscapeChar, "$1") : be || ge;
  }), me;
}, getBaseIntrinsic = function L(ne, oe) {
  var pe = ne, me;
  if (hasOwn$1(LEGACY_ALIASES, pe) && (me = LEGACY_ALIASES[pe], pe = "%" + me[0] + "%"), hasOwn$1(INTRINSICS, pe)) {
    var ge = INTRINSICS[pe];
    if (ge === needsEval && (ge = doEval(pe)), typeof ge > "u" && !oe)
      throw new $TypeError$3("intrinsic " + ne + " exists, but is not available. Please file an issue!");
    return {
      alias: me,
      name: pe,
      value: ge
    };
  }
  throw new $SyntaxError$1("intrinsic " + ne + " does not exist!");
}, getIntrinsic = function L(ne, oe) {
  if (typeof ne != "string" || ne.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof oe != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, ne) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var pe = stringToPath(ne), me = pe.length > 0 ? pe[0] : "", ge = getBaseIntrinsic("%" + me + "%", oe), be = ge.name, Ie = ge.value, Ae = !1, rt = ge.alias;
  rt && (me = rt[0], $spliceApply(pe, $concat$1([0, 1], rt)));
  for (var st = 1, dt = !0; st < pe.length; st += 1) {
    var lt = pe[st], pt = $strSlice(lt, 0, 1), it = $strSlice(lt, -1);
    if ((pt === '"' || pt === "'" || pt === "`" || it === '"' || it === "'" || it === "`") && pt !== it)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((lt === "constructor" || !dt) && (Ae = !0), me += "." + lt, be = "%" + me + "%", hasOwn$1(INTRINSICS, be))
      Ie = INTRINSICS[be];
    else if (Ie != null) {
      if (!(lt in Ie)) {
        if (!oe)
          throw new $TypeError$3("base intrinsic for " + ne + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && st + 1 >= pe.length) {
        var ut = $gOPD$1(Ie, lt);
        dt = !!ut, dt && "get" in ut && !("originalValue" in ut.get) ? Ie = ut.get : Ie = Ie[lt];
      } else
        dt = hasOwn$1(Ie, lt), Ie = Ie[lt];
      dt && !Ae && (INTRINSICS[be] = Ie);
    }
  }
  return Ie;
}, callBind$1 = { exports: {} }, GetIntrinsic$5 = getIntrinsic, $defineProperty$1 = GetIntrinsic$5("%Object.defineProperty%", !0), hasPropertyDescriptors$1 = function L() {
  if ($defineProperty$1)
    try {
      return $defineProperty$1({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function L() {
  if (!hasPropertyDescriptors$1())
    return null;
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1, GetIntrinsic$4 = getIntrinsic, $gOPD = GetIntrinsic$4("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, hasPropertyDescriptors = hasPropertyDescriptors_1(), GetIntrinsic$3 = getIntrinsic, $defineProperty = hasPropertyDescriptors && GetIntrinsic$3("%Object.defineProperty%", !0);
if ($defineProperty)
  try {
    $defineProperty({}, "a", { value: 1 });
  } catch {
    $defineProperty = !1;
  }
var $SyntaxError = GetIntrinsic$3("%SyntaxError%"), $TypeError$2 = GetIntrinsic$3("%TypeError%"), gopd = gopd$1, defineDataProperty = function L(ne, oe, pe) {
  if (!ne || typeof ne != "object" && typeof ne != "function")
    throw new $TypeError$2("`obj` must be an object or a function`");
  if (typeof oe != "string" && typeof oe != "symbol")
    throw new $TypeError$2("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  var me = arguments.length > 3 ? arguments[3] : null, ge = arguments.length > 4 ? arguments[4] : null, be = arguments.length > 5 ? arguments[5] : null, Ie = arguments.length > 6 ? arguments[6] : !1, Ae = !!gopd && gopd(ne, oe);
  if ($defineProperty)
    $defineProperty(ne, oe, {
      configurable: be === null && Ae ? Ae.configurable : !be,
      enumerable: me === null && Ae ? Ae.enumerable : !me,
      value: pe,
      writable: ge === null && Ae ? Ae.writable : !ge
    });
  else if (Ie || !me && !ge && !be)
    ne[oe] = pe;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, GetIntrinsic$2 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD = gopd$1, $TypeError$1 = GetIntrinsic$2("%TypeError%"), $floor$1 = GetIntrinsic$2("%Math.floor%"), setFunctionLength = function L(ne, oe) {
  if (typeof ne != "function")
    throw new $TypeError$1("`fn` is not a function");
  if (typeof oe != "number" || oe < 0 || oe > 4294967295 || $floor$1(oe) !== oe)
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  var pe = arguments.length > 2 && !!arguments[2], me = !0, ge = !0;
  if ("length" in ne && gOPD) {
    var be = gOPD(ne, "length");
    be && !be.configurable && (me = !1), be && !be.writable && (ge = !1);
  }
  return (me || ge || !pe) && (hasDescriptors ? define(ne, "length", oe, !0, !0) : define(ne, "length", oe)), ne;
};
(function(L) {
  var ne = functionBind, oe = getIntrinsic, pe = setFunctionLength, me = oe("%TypeError%"), ge = oe("%Function.prototype.apply%"), be = oe("%Function.prototype.call%"), Ie = oe("%Reflect.apply%", !0) || ne.call(be, ge), Ae = oe("%Object.defineProperty%", !0), rt = oe("%Math.max%");
  if (Ae)
    try {
      Ae({}, "a", { value: 1 });
    } catch {
      Ae = null;
    }
  L.exports = function(lt) {
    if (typeof lt != "function")
      throw new me("a function is required");
    var pt = Ie(ne, be, arguments);
    return pe(
      pt,
      1 + rt(0, lt.length - (arguments.length - 1)),
      !0
    );
  };
  var st = function() {
    return Ie(ne, ge, arguments);
  };
  Ae ? Ae(L.exports, "apply", { value: st }) : L.exports.apply = st;
})(callBind$1);
var callBindExports = callBind$1.exports, GetIntrinsic$1 = getIntrinsic, callBind = callBindExports, $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf")), callBound$1 = function L(ne, oe) {
  var pe = GetIntrinsic$1(ne, !!oe);
  return typeof pe == "function" && $indexOf(ne, ".prototype.") > -1 ? callBind(pe) : pe;
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map == "function" && Map.prototype, mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get == "function" ? mapSizeDescriptor.get : null, mapForEach = hasMap && Map.prototype.forEach, hasSet = typeof Set == "function" && Set.prototype, setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get == "function" ? setSizeDescriptor.get : null, setForEach = hasSet && Set.prototype.forEach, hasWeakMap = typeof WeakMap == "function" && WeakMap.prototype, weakMapHas = hasWeakMap ? WeakMap.prototype.has : null, hasWeakSet = typeof WeakSet == "function" && WeakSet.prototype, weakSetHas = hasWeakSet ? WeakSet.prototype.has : null, hasWeakRef = typeof WeakRef == "function" && WeakRef.prototype, weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null, booleanValueOf = Boolean.prototype.valueOf, objectToString = Object.prototype.toString, functionToString = Function.prototype.toString, $match = String.prototype.match, $slice = String.prototype.slice, $replace = String.prototype.replace, $toUpperCase = String.prototype.toUpperCase, $toLowerCase = String.prototype.toLowerCase, $test = RegExp.prototype.test, $concat = Array.prototype.concat, $join = Array.prototype.join, $arrSlice = Array.prototype.slice, $floor = Math.floor, bigIntValueOf = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, gOPS = Object.getOwnPropertySymbols, symToString = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, hasShammedSymbols = typeof Symbol == "function" && typeof Symbol.iterator == "object", toStringTag = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols || !0) ? Symbol.toStringTag : null, isEnumerable = Object.prototype.propertyIsEnumerable, gPO = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(L) {
  return L.__proto__;
} : null);
function addNumericSeparator(L, ne) {
  if (L === 1 / 0 || L === -1 / 0 || L !== L || L && L > -1e3 && L < 1e3 || $test.call(/e/, ne))
    return ne;
  var oe = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof L == "number") {
    var pe = L < 0 ? -$floor(-L) : $floor(L);
    if (pe !== L) {
      var me = String(pe), ge = $slice.call(ne, me.length + 1);
      return $replace.call(me, oe, "$&_") + "." + $replace.call($replace.call(ge, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(ne, oe, "$&_");
}
var utilInspect = require$$0, inspectCustom = utilInspect.custom, inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null, objectInspect = function L(ne, oe, pe, me) {
  var ge = oe || {};
  if (has$3(ge, "quoteStyle") && ge.quoteStyle !== "single" && ge.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (has$3(ge, "maxStringLength") && (typeof ge.maxStringLength == "number" ? ge.maxStringLength < 0 && ge.maxStringLength !== 1 / 0 : ge.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var be = has$3(ge, "customInspect") ? ge.customInspect : !0;
  if (typeof be != "boolean" && be !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (has$3(ge, "indent") && ge.indent !== null && ge.indent !== "	" && !(parseInt(ge.indent, 10) === ge.indent && ge.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (has$3(ge, "numericSeparator") && typeof ge.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var Ie = ge.numericSeparator;
  if (typeof ne > "u")
    return "undefined";
  if (ne === null)
    return "null";
  if (typeof ne == "boolean")
    return ne ? "true" : "false";
  if (typeof ne == "string")
    return inspectString(ne, ge);
  if (typeof ne == "number") {
    if (ne === 0)
      return 1 / 0 / ne > 0 ? "0" : "-0";
    var Ae = String(ne);
    return Ie ? addNumericSeparator(ne, Ae) : Ae;
  }
  if (typeof ne == "bigint") {
    var rt = String(ne) + "n";
    return Ie ? addNumericSeparator(ne, rt) : rt;
  }
  var st = typeof ge.depth > "u" ? 5 : ge.depth;
  if (typeof pe > "u" && (pe = 0), pe >= st && st > 0 && typeof ne == "object")
    return isArray$3(ne) ? "[Array]" : "[Object]";
  var dt = getIndent(ge, pe);
  if (typeof me > "u")
    me = [];
  else if (indexOf(me, ne) >= 0)
    return "[Circular]";
  function lt(Jt, rr, Qt) {
    if (rr && (me = $arrSlice.call(me), me.push(rr)), Qt) {
      var wt = {
        depth: ge.depth
      };
      return has$3(ge, "quoteStyle") && (wt.quoteStyle = ge.quoteStyle), L(Jt, wt, pe + 1, me);
    }
    return L(Jt, ge, pe + 1, me);
  }
  if (typeof ne == "function" && !isRegExp$1(ne)) {
    var pt = nameOf(ne), it = arrObjKeys(ne, lt);
    return "[Function" + (pt ? ": " + pt : " (anonymous)") + "]" + (it.length > 0 ? " { " + $join.call(it, ", ") + " }" : "");
  }
  if (isSymbol(ne)) {
    var ut = hasShammedSymbols ? $replace.call(String(ne), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(ne);
    return typeof ne == "object" && !hasShammedSymbols ? markBoxed(ut) : ut;
  }
  if (isElement(ne)) {
    for (var St = "<" + $toLowerCase.call(String(ne.nodeName)), ot = ne.attributes || [], ht = 0; ht < ot.length; ht++)
      St += " " + ot[ht].name + "=" + wrapQuotes(quote(ot[ht].value), "double", ge);
    return St += ">", ne.childNodes && ne.childNodes.length && (St += "..."), St += "</" + $toLowerCase.call(String(ne.nodeName)) + ">", St;
  }
  if (isArray$3(ne)) {
    if (ne.length === 0)
      return "[]";
    var ft = arrObjKeys(ne, lt);
    return dt && !singleLineValues(ft) ? "[" + indentedJoin(ft, dt) + "]" : "[ " + $join.call(ft, ", ") + " ]";
  }
  if (isError(ne)) {
    var vt = arrObjKeys(ne, lt);
    return !("cause" in Error.prototype) && "cause" in ne && !isEnumerable.call(ne, "cause") ? "{ [" + String(ne) + "] " + $join.call($concat.call("[cause]: " + lt(ne.cause), vt), ", ") + " }" : vt.length === 0 ? "[" + String(ne) + "]" : "{ [" + String(ne) + "] " + $join.call(vt, ", ") + " }";
  }
  if (typeof ne == "object" && be) {
    if (inspectSymbol && typeof ne[inspectSymbol] == "function" && utilInspect)
      return utilInspect(ne, { depth: st - pe });
    if (be !== "symbol" && typeof ne.inspect == "function")
      return ne.inspect();
  }
  if (isMap(ne)) {
    var Ct = [];
    return mapForEach && mapForEach.call(ne, function(Jt, rr) {
      Ct.push(lt(rr, ne, !0) + " => " + lt(Jt, ne));
    }), collectionOf("Map", mapSize.call(ne), Ct, dt);
  }
  if (isSet(ne)) {
    var xt = [];
    return setForEach && setForEach.call(ne, function(Jt) {
      xt.push(lt(Jt, ne));
    }), collectionOf("Set", setSize.call(ne), xt, dt);
  }
  if (isWeakMap(ne))
    return weakCollectionOf("WeakMap");
  if (isWeakSet(ne))
    return weakCollectionOf("WeakSet");
  if (isWeakRef(ne))
    return weakCollectionOf("WeakRef");
  if (isNumber(ne))
    return markBoxed(lt(Number(ne)));
  if (isBigInt(ne))
    return markBoxed(lt(bigIntValueOf.call(ne)));
  if (isBoolean(ne))
    return markBoxed(booleanValueOf.call(ne));
  if (isString(ne))
    return markBoxed(lt(String(ne)));
  if (typeof window < "u" && ne === window)
    return "{ [object Window] }";
  if (ne === commonjsGlobal)
    return "{ [object globalThis] }";
  if (!isDate(ne) && !isRegExp$1(ne)) {
    var At = arrObjKeys(ne, lt), kt = gPO ? gPO(ne) === Object.prototype : ne instanceof Object || ne.constructor === Object, Vt = ne instanceof Object ? "" : "null prototype", ir = !kt && toStringTag && Object(ne) === ne && toStringTag in ne ? $slice.call(toStr(ne), 8, -1) : Vt ? "Object" : "", er = kt || typeof ne.constructor != "function" ? "" : ne.constructor.name ? ne.constructor.name + " " : "", Yt = er + (ir || Vt ? "[" + $join.call($concat.call([], ir || [], Vt || []), ": ") + "] " : "");
    return At.length === 0 ? Yt + "{}" : dt ? Yt + "{" + indentedJoin(At, dt) + "}" : Yt + "{ " + $join.call(At, ", ") + " }";
  }
  return String(ne);
};
function wrapQuotes(L, ne, oe) {
  var pe = (oe.quoteStyle || ne) === "double" ? '"' : "'";
  return pe + L + pe;
}
function quote(L) {
  return $replace.call(String(L), /"/g, "&quot;");
}
function isArray$3(L) {
  return toStr(L) === "[object Array]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isDate(L) {
  return toStr(L) === "[object Date]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isRegExp$1(L) {
  return toStr(L) === "[object RegExp]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isError(L) {
  return toStr(L) === "[object Error]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isString(L) {
  return toStr(L) === "[object String]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isNumber(L) {
  return toStr(L) === "[object Number]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isBoolean(L) {
  return toStr(L) === "[object Boolean]" && (!toStringTag || !(typeof L == "object" && toStringTag in L));
}
function isSymbol(L) {
  if (hasShammedSymbols)
    return L && typeof L == "object" && L instanceof Symbol;
  if (typeof L == "symbol")
    return !0;
  if (!L || typeof L != "object" || !symToString)
    return !1;
  try {
    return symToString.call(L), !0;
  } catch {
  }
  return !1;
}
function isBigInt(L) {
  if (!L || typeof L != "object" || !bigIntValueOf)
    return !1;
  try {
    return bigIntValueOf.call(L), !0;
  } catch {
  }
  return !1;
}
var hasOwn = Object.prototype.hasOwnProperty || function(L) {
  return L in this;
};
function has$3(L, ne) {
  return hasOwn.call(L, ne);
}
function toStr(L) {
  return objectToString.call(L);
}
function nameOf(L) {
  if (L.name)
    return L.name;
  var ne = $match.call(functionToString.call(L), /^function\s*([\w$]+)/);
  return ne ? ne[1] : null;
}
function indexOf(L, ne) {
  if (L.indexOf)
    return L.indexOf(ne);
  for (var oe = 0, pe = L.length; oe < pe; oe++)
    if (L[oe] === ne)
      return oe;
  return -1;
}
function isMap(L) {
  if (!mapSize || !L || typeof L != "object")
    return !1;
  try {
    mapSize.call(L);
    try {
      setSize.call(L);
    } catch {
      return !0;
    }
    return L instanceof Map;
  } catch {
  }
  return !1;
}
function isWeakMap(L) {
  if (!weakMapHas || !L || typeof L != "object")
    return !1;
  try {
    weakMapHas.call(L, weakMapHas);
    try {
      weakSetHas.call(L, weakSetHas);
    } catch {
      return !0;
    }
    return L instanceof WeakMap;
  } catch {
  }
  return !1;
}
function isWeakRef(L) {
  if (!weakRefDeref || !L || typeof L != "object")
    return !1;
  try {
    return weakRefDeref.call(L), !0;
  } catch {
  }
  return !1;
}
function isSet(L) {
  if (!setSize || !L || typeof L != "object")
    return !1;
  try {
    setSize.call(L);
    try {
      mapSize.call(L);
    } catch {
      return !0;
    }
    return L instanceof Set;
  } catch {
  }
  return !1;
}
function isWeakSet(L) {
  if (!weakSetHas || !L || typeof L != "object")
    return !1;
  try {
    weakSetHas.call(L, weakSetHas);
    try {
      weakMapHas.call(L, weakMapHas);
    } catch {
      return !0;
    }
    return L instanceof WeakSet;
  } catch {
  }
  return !1;
}
function isElement(L) {
  return !L || typeof L != "object" ? !1 : typeof HTMLElement < "u" && L instanceof HTMLElement ? !0 : typeof L.nodeName == "string" && typeof L.getAttribute == "function";
}
function inspectString(L, ne) {
  if (L.length > ne.maxStringLength) {
    var oe = L.length - ne.maxStringLength, pe = "... " + oe + " more character" + (oe > 1 ? "s" : "");
    return inspectString($slice.call(L, 0, ne.maxStringLength), ne) + pe;
  }
  var me = $replace.call($replace.call(L, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(me, "single", ne);
}
function lowbyte(L) {
  var ne = L.charCodeAt(0), oe = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[ne];
  return oe ? "\\" + oe : "\\x" + (ne < 16 ? "0" : "") + $toUpperCase.call(ne.toString(16));
}
function markBoxed(L) {
  return "Object(" + L + ")";
}
function weakCollectionOf(L) {
  return L + " { ? }";
}
function collectionOf(L, ne, oe, pe) {
  var me = pe ? indentedJoin(oe, pe) : $join.call(oe, ", ");
  return L + " (" + ne + ") {" + me + "}";
}
function singleLineValues(L) {
  for (var ne = 0; ne < L.length; ne++)
    if (indexOf(L[ne], `
`) >= 0)
      return !1;
  return !0;
}
function getIndent(L, ne) {
  var oe;
  if (L.indent === "	")
    oe = "	";
  else if (typeof L.indent == "number" && L.indent > 0)
    oe = $join.call(Array(L.indent + 1), " ");
  else
    return null;
  return {
    base: oe,
    prev: $join.call(Array(ne + 1), oe)
  };
}
function indentedJoin(L, ne) {
  if (L.length === 0)
    return "";
  var oe = `
` + ne.prev + ne.base;
  return oe + $join.call(L, "," + oe) + `
` + ne.prev;
}
function arrObjKeys(L, ne) {
  var oe = isArray$3(L), pe = [];
  if (oe) {
    pe.length = L.length;
    for (var me = 0; me < L.length; me++)
      pe[me] = has$3(L, me) ? ne(L[me], L) : "";
  }
  var ge = typeof gOPS == "function" ? gOPS(L) : [], be;
  if (hasShammedSymbols) {
    be = {};
    for (var Ie = 0; Ie < ge.length; Ie++)
      be["$" + ge[Ie]] = ge[Ie];
  }
  for (var Ae in L)
    has$3(L, Ae) && (oe && String(Number(Ae)) === Ae && Ae < L.length || hasShammedSymbols && be["$" + Ae] instanceof Symbol || ($test.call(/[^\w$]/, Ae) ? pe.push(ne(Ae, L) + ": " + ne(L[Ae], L)) : pe.push(Ae + ": " + ne(L[Ae], L))));
  if (typeof gOPS == "function")
    for (var rt = 0; rt < ge.length; rt++)
      isEnumerable.call(L, ge[rt]) && pe.push("[" + ne(ge[rt]) + "]: " + ne(L[ge[rt]], L));
  return pe;
}
var GetIntrinsic = getIntrinsic, callBound = callBound$1, inspect = objectInspect, $TypeError = GetIntrinsic("%TypeError%"), $WeakMap = GetIntrinsic("%WeakMap%", !0), $Map = GetIntrinsic("%Map%", !0), $weakMapGet = callBound("WeakMap.prototype.get", !0), $weakMapSet = callBound("WeakMap.prototype.set", !0), $weakMapHas = callBound("WeakMap.prototype.has", !0), $mapGet = callBound("Map.prototype.get", !0), $mapSet = callBound("Map.prototype.set", !0), $mapHas = callBound("Map.prototype.has", !0), listGetNode = function(L, ne) {
  for (var oe = L, pe; (pe = oe.next) !== null; oe = pe)
    if (pe.key === ne)
      return oe.next = pe.next, pe.next = L.next, L.next = pe, pe;
}, listGet = function(L, ne) {
  var oe = listGetNode(L, ne);
  return oe && oe.value;
}, listSet = function(L, ne, oe) {
  var pe = listGetNode(L, ne);
  pe ? pe.value = oe : L.next = {
    // eslint-disable-line no-param-reassign
    key: ne,
    next: L.next,
    value: oe
  };
}, listHas = function(L, ne) {
  return !!listGetNode(L, ne);
}, sideChannel = function L() {
  var ne, oe, pe, me = {
    assert: function(ge) {
      if (!me.has(ge))
        throw new $TypeError("Side channel does not contain " + inspect(ge));
    },
    get: function(ge) {
      if ($WeakMap && ge && (typeof ge == "object" || typeof ge == "function")) {
        if (ne)
          return $weakMapGet(ne, ge);
      } else if ($Map) {
        if (oe)
          return $mapGet(oe, ge);
      } else if (pe)
        return listGet(pe, ge);
    },
    has: function(ge) {
      if ($WeakMap && ge && (typeof ge == "object" || typeof ge == "function")) {
        if (ne)
          return $weakMapHas(ne, ge);
      } else if ($Map) {
        if (oe)
          return $mapHas(oe, ge);
      } else if (pe)
        return listHas(pe, ge);
      return !1;
    },
    set: function(ge, be) {
      $WeakMap && ge && (typeof ge == "object" || typeof ge == "function") ? (ne || (ne = new $WeakMap()), $weakMapSet(ne, ge, be)) : $Map ? (oe || (oe = new $Map()), $mapSet(oe, ge, be)) : (pe || (pe = { key: {}, next: null }), listSet(pe, ge, be));
    }
  };
  return me;
}, replace = String.prototype.replace, percentTwenties = /%20/g, Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, formats$3 = {
  default: Format.RFC3986,
  formatters: {
    RFC1738: function(L) {
      return replace.call(L, percentTwenties, "+");
    },
    RFC3986: function(L) {
      return String(L);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
}, formats$2 = formats$3, has$2 = Object.prototype.hasOwnProperty, isArray$2 = Array.isArray, hexTable = function() {
  for (var L = [], ne = 0; ne < 256; ++ne)
    L.push("%" + ((ne < 16 ? "0" : "") + ne.toString(16)).toUpperCase());
  return L;
}(), compactQueue = function L(ne) {
  for (; ne.length > 1; ) {
    var oe = ne.pop(), pe = oe.obj[oe.prop];
    if (isArray$2(pe)) {
      for (var me = [], ge = 0; ge < pe.length; ++ge)
        typeof pe[ge] < "u" && me.push(pe[ge]);
      oe.obj[oe.prop] = me;
    }
  }
}, arrayToObject = function L(ne, oe) {
  for (var pe = oe && oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, me = 0; me < ne.length; ++me)
    typeof ne[me] < "u" && (pe[me] = ne[me]);
  return pe;
}, merge = function L(ne, oe, pe) {
  if (!oe)
    return ne;
  if (typeof oe != "object") {
    if (isArray$2(ne))
      ne.push(oe);
    else if (ne && typeof ne == "object")
      (pe && (pe.plainObjects || pe.allowPrototypes) || !has$2.call(Object.prototype, oe)) && (ne[oe] = !0);
    else
      return [ne, oe];
    return ne;
  }
  if (!ne || typeof ne != "object")
    return [ne].concat(oe);
  var me = ne;
  return isArray$2(ne) && !isArray$2(oe) && (me = arrayToObject(ne, pe)), isArray$2(ne) && isArray$2(oe) ? (oe.forEach(function(ge, be) {
    if (has$2.call(ne, be)) {
      var Ie = ne[be];
      Ie && typeof Ie == "object" && ge && typeof ge == "object" ? ne[be] = L(Ie, ge, pe) : ne.push(ge);
    } else
      ne[be] = ge;
  }), ne) : Object.keys(oe).reduce(function(ge, be) {
    var Ie = oe[be];
    return has$2.call(ge, be) ? ge[be] = L(ge[be], Ie, pe) : ge[be] = Ie, ge;
  }, me);
}, assign = function L(ne, oe) {
  return Object.keys(oe).reduce(function(pe, me) {
    return pe[me] = oe[me], pe;
  }, ne);
}, decode = function(L, ne, oe) {
  var pe = L.replace(/\+/g, " ");
  if (oe === "iso-8859-1")
    return pe.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(pe);
  } catch {
    return pe;
  }
}, encode = function L(ne, oe, pe, me, ge) {
  if (ne.length === 0)
    return ne;
  var be = ne;
  if (typeof ne == "symbol" ? be = Symbol.prototype.toString.call(ne) : typeof ne != "string" && (be = String(ne)), pe === "iso-8859-1")
    return escape(be).replace(/%u[0-9a-f]{4}/gi, function(st) {
      return "%26%23" + parseInt(st.slice(2), 16) + "%3B";
    });
  for (var Ie = "", Ae = 0; Ae < be.length; ++Ae) {
    var rt = be.charCodeAt(Ae);
    if (rt === 45 || rt === 46 || rt === 95 || rt === 126 || rt >= 48 && rt <= 57 || rt >= 65 && rt <= 90 || rt >= 97 && rt <= 122 || ge === formats$2.RFC1738 && (rt === 40 || rt === 41)) {
      Ie += be.charAt(Ae);
      continue;
    }
    if (rt < 128) {
      Ie = Ie + hexTable[rt];
      continue;
    }
    if (rt < 2048) {
      Ie = Ie + (hexTable[192 | rt >> 6] + hexTable[128 | rt & 63]);
      continue;
    }
    if (rt < 55296 || rt >= 57344) {
      Ie = Ie + (hexTable[224 | rt >> 12] + hexTable[128 | rt >> 6 & 63] + hexTable[128 | rt & 63]);
      continue;
    }
    Ae += 1, rt = 65536 + ((rt & 1023) << 10 | be.charCodeAt(Ae) & 1023), Ie += hexTable[240 | rt >> 18] + hexTable[128 | rt >> 12 & 63] + hexTable[128 | rt >> 6 & 63] + hexTable[128 | rt & 63];
  }
  return Ie;
}, compact = function L(ne) {
  for (var oe = [{ obj: { o: ne }, prop: "o" }], pe = [], me = 0; me < oe.length; ++me)
    for (var ge = oe[me], be = ge.obj[ge.prop], Ie = Object.keys(be), Ae = 0; Ae < Ie.length; ++Ae) {
      var rt = Ie[Ae], st = be[rt];
      typeof st == "object" && st !== null && pe.indexOf(st) === -1 && (oe.push({ obj: be, prop: rt }), pe.push(st));
    }
  return compactQueue(oe), ne;
}, isRegExp = function L(ne) {
  return Object.prototype.toString.call(ne) === "[object RegExp]";
}, isBuffer = function L(ne) {
  return !ne || typeof ne != "object" ? !1 : !!(ne.constructor && ne.constructor.isBuffer && ne.constructor.isBuffer(ne));
}, combine = function L(ne, oe) {
  return [].concat(ne, oe);
}, maybeMap = function L(ne, oe) {
  if (isArray$2(ne)) {
    for (var pe = [], me = 0; me < ne.length; me += 1)
      pe.push(oe(ne[me]));
    return pe;
  }
  return oe(ne);
}, utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge
}, getSideChannel = sideChannel, utils$1 = utils$2, formats$1 = formats$3, has$1 = Object.prototype.hasOwnProperty, arrayPrefixGenerators = {
  brackets: function L(ne) {
    return ne + "[]";
  },
  comma: "comma",
  indices: function L(ne, oe) {
    return ne + "[" + oe + "]";
  },
  repeat: function L(ne) {
    return ne;
  }
}, isArray$1 = Array.isArray, push = Array.prototype.push, pushToArray = function(L, ne) {
  push.apply(L, isArray$1(ne) ? ne : [ne]);
}, toISO = Date.prototype.toISOString, defaultFormat = formats$1.default, defaults$1 = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: utils$1.encode,
  encodeValuesOnly: !1,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: !1,
  serializeDate: function L(ne) {
    return toISO.call(ne);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, isNonNullishPrimitive = function L(ne) {
  return typeof ne == "string" || typeof ne == "number" || typeof ne == "boolean" || typeof ne == "symbol" || typeof ne == "bigint";
}, sentinel = {}, stringify$1 = function L(ne, oe, pe, me, ge, be, Ie, Ae, rt, st, dt, lt, pt, it, ut, St) {
  for (var ot = ne, ht = St, ft = 0, vt = !1; (ht = ht.get(sentinel)) !== void 0 && !vt; ) {
    var Ct = ht.get(ne);
    if (ft += 1, typeof Ct < "u") {
      if (Ct === ft)
        throw new RangeError("Cyclic object value");
      vt = !0;
    }
    typeof ht.get(sentinel) > "u" && (ft = 0);
  }
  if (typeof Ae == "function" ? ot = Ae(oe, ot) : ot instanceof Date ? ot = dt(ot) : pe === "comma" && isArray$1(ot) && (ot = utils$1.maybeMap(ot, function(wt) {
    return wt instanceof Date ? dt(wt) : wt;
  })), ot === null) {
    if (ge)
      return Ie && !it ? Ie(oe, defaults$1.encoder, ut, "key", lt) : oe;
    ot = "";
  }
  if (isNonNullishPrimitive(ot) || utils$1.isBuffer(ot)) {
    if (Ie) {
      var xt = it ? oe : Ie(oe, defaults$1.encoder, ut, "key", lt);
      return [pt(xt) + "=" + pt(Ie(ot, defaults$1.encoder, ut, "value", lt))];
    }
    return [pt(oe) + "=" + pt(String(ot))];
  }
  var At = [];
  if (typeof ot > "u")
    return At;
  var kt;
  if (pe === "comma" && isArray$1(ot))
    it && Ie && (ot = utils$1.maybeMap(ot, Ie)), kt = [{ value: ot.length > 0 ? ot.join(",") || null : void 0 }];
  else if (isArray$1(Ae))
    kt = Ae;
  else {
    var Vt = Object.keys(ot);
    kt = rt ? Vt.sort(rt) : Vt;
  }
  for (var ir = me && isArray$1(ot) && ot.length === 1 ? oe + "[]" : oe, er = 0; er < kt.length; ++er) {
    var Yt = kt[er], Jt = typeof Yt == "object" && typeof Yt.value < "u" ? Yt.value : ot[Yt];
    if (!(be && Jt === null)) {
      var rr = isArray$1(ot) ? typeof pe == "function" ? pe(ir, Yt) : ir : ir + (st ? "." + Yt : "[" + Yt + "]");
      St.set(ne, ft);
      var Qt = getSideChannel();
      Qt.set(sentinel, St), pushToArray(At, L(
        Jt,
        rr,
        pe,
        me,
        ge,
        be,
        pe === "comma" && it && isArray$1(ot) ? null : Ie,
        Ae,
        rt,
        st,
        dt,
        lt,
        pt,
        it,
        ut,
        Qt
      ));
    }
  }
  return At;
}, normalizeStringifyOptions = function L(ne) {
  if (!ne)
    return defaults$1;
  if (ne.encoder !== null && typeof ne.encoder < "u" && typeof ne.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var oe = ne.charset || defaults$1.charset;
  if (typeof ne.charset < "u" && ne.charset !== "utf-8" && ne.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var pe = formats$1.default;
  if (typeof ne.format < "u") {
    if (!has$1.call(formats$1.formatters, ne.format))
      throw new TypeError("Unknown format option provided.");
    pe = ne.format;
  }
  var me = formats$1.formatters[pe], ge = defaults$1.filter;
  return (typeof ne.filter == "function" || isArray$1(ne.filter)) && (ge = ne.filter), {
    addQueryPrefix: typeof ne.addQueryPrefix == "boolean" ? ne.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof ne.allowDots > "u" ? defaults$1.allowDots : !!ne.allowDots,
    charset: oe,
    charsetSentinel: typeof ne.charsetSentinel == "boolean" ? ne.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof ne.delimiter > "u" ? defaults$1.delimiter : ne.delimiter,
    encode: typeof ne.encode == "boolean" ? ne.encode : defaults$1.encode,
    encoder: typeof ne.encoder == "function" ? ne.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof ne.encodeValuesOnly == "boolean" ? ne.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: ge,
    format: pe,
    formatter: me,
    serializeDate: typeof ne.serializeDate == "function" ? ne.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof ne.skipNulls == "boolean" ? ne.skipNulls : defaults$1.skipNulls,
    sort: typeof ne.sort == "function" ? ne.sort : null,
    strictNullHandling: typeof ne.strictNullHandling == "boolean" ? ne.strictNullHandling : defaults$1.strictNullHandling
  };
}, stringify_1 = function(L, ne) {
  var oe = L, pe = normalizeStringifyOptions(ne), me, ge;
  typeof pe.filter == "function" ? (ge = pe.filter, oe = ge("", oe)) : isArray$1(pe.filter) && (ge = pe.filter, me = ge);
  var be = [];
  if (typeof oe != "object" || oe === null)
    return "";
  var Ie;
  ne && ne.arrayFormat in arrayPrefixGenerators ? Ie = ne.arrayFormat : ne && "indices" in ne ? Ie = ne.indices ? "indices" : "repeat" : Ie = "indices";
  var Ae = arrayPrefixGenerators[Ie];
  if (ne && "commaRoundTrip" in ne && typeof ne.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var rt = Ae === "comma" && ne && ne.commaRoundTrip;
  me || (me = Object.keys(oe)), pe.sort && me.sort(pe.sort);
  for (var st = getSideChannel(), dt = 0; dt < me.length; ++dt) {
    var lt = me[dt];
    pe.skipNulls && oe[lt] === null || pushToArray(be, stringify$1(
      oe[lt],
      lt,
      Ae,
      rt,
      pe.strictNullHandling,
      pe.skipNulls,
      pe.encode ? pe.encoder : null,
      pe.filter,
      pe.sort,
      pe.allowDots,
      pe.serializeDate,
      pe.format,
      pe.formatter,
      pe.encodeValuesOnly,
      pe.charset,
      st
    ));
  }
  var pt = be.join(pe.delimiter), it = pe.addQueryPrefix === !0 ? "?" : "";
  return pe.charsetSentinel && (pe.charset === "iso-8859-1" ? it += "utf8=%26%2310003%3B&" : it += "utf8=%E2%9C%93&"), pt.length > 0 ? it + pt : "";
}, utils = utils$2, has = Object.prototype.hasOwnProperty, isArray = Array.isArray, defaults = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, interpretNumericEntities = function(L) {
  return L.replace(/&#(\d+);/g, function(ne, oe) {
    return String.fromCharCode(parseInt(oe, 10));
  });
}, parseArrayValue = function(L, ne) {
  return L && typeof L == "string" && ne.comma && L.indexOf(",") > -1 ? L.split(",") : L;
}, isoSentinel = "utf8=%26%2310003%3B", charsetSentinel = "utf8=%E2%9C%93", parseValues = function L(ne, oe) {
  var pe = { __proto__: null }, me = oe.ignoreQueryPrefix ? ne.replace(/^\?/, "") : ne, ge = oe.parameterLimit === 1 / 0 ? void 0 : oe.parameterLimit, be = me.split(oe.delimiter, ge), Ie = -1, Ae, rt = oe.charset;
  if (oe.charsetSentinel)
    for (Ae = 0; Ae < be.length; ++Ae)
      be[Ae].indexOf("utf8=") === 0 && (be[Ae] === charsetSentinel ? rt = "utf-8" : be[Ae] === isoSentinel && (rt = "iso-8859-1"), Ie = Ae, Ae = be.length);
  for (Ae = 0; Ae < be.length; ++Ae)
    if (Ae !== Ie) {
      var st = be[Ae], dt = st.indexOf("]="), lt = dt === -1 ? st.indexOf("=") : dt + 1, pt, it;
      lt === -1 ? (pt = oe.decoder(st, defaults.decoder, rt, "key"), it = oe.strictNullHandling ? null : "") : (pt = oe.decoder(st.slice(0, lt), defaults.decoder, rt, "key"), it = utils.maybeMap(
        parseArrayValue(st.slice(lt + 1), oe),
        function(ut) {
          return oe.decoder(ut, defaults.decoder, rt, "value");
        }
      )), it && oe.interpretNumericEntities && rt === "iso-8859-1" && (it = interpretNumericEntities(it)), st.indexOf("[]=") > -1 && (it = isArray(it) ? [it] : it), has.call(pe, pt) ? pe[pt] = utils.combine(pe[pt], it) : pe[pt] = it;
    }
  return pe;
}, parseObject = function(L, ne, oe, pe) {
  for (var me = pe ? ne : parseArrayValue(ne, oe), ge = L.length - 1; ge >= 0; --ge) {
    var be, Ie = L[ge];
    if (Ie === "[]" && oe.parseArrays)
      be = [].concat(me);
    else {
      be = oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var Ae = Ie.charAt(0) === "[" && Ie.charAt(Ie.length - 1) === "]" ? Ie.slice(1, -1) : Ie, rt = parseInt(Ae, 10);
      !oe.parseArrays && Ae === "" ? be = { 0: me } : !isNaN(rt) && Ie !== Ae && String(rt) === Ae && rt >= 0 && oe.parseArrays && rt <= oe.arrayLimit ? (be = [], be[rt] = me) : Ae !== "__proto__" && (be[Ae] = me);
    }
    me = be;
  }
  return me;
}, parseKeys = function L(ne, oe, pe, me) {
  if (ne) {
    var ge = pe.allowDots ? ne.replace(/\.([^.[]+)/g, "[$1]") : ne, be = /(\[[^[\]]*])/, Ie = /(\[[^[\]]*])/g, Ae = pe.depth > 0 && be.exec(ge), rt = Ae ? ge.slice(0, Ae.index) : ge, st = [];
    if (rt) {
      if (!pe.plainObjects && has.call(Object.prototype, rt) && !pe.allowPrototypes)
        return;
      st.push(rt);
    }
    for (var dt = 0; pe.depth > 0 && (Ae = Ie.exec(ge)) !== null && dt < pe.depth; ) {
      if (dt += 1, !pe.plainObjects && has.call(Object.prototype, Ae[1].slice(1, -1)) && !pe.allowPrototypes)
        return;
      st.push(Ae[1]);
    }
    return Ae && st.push("[" + ge.slice(Ae.index) + "]"), parseObject(st, oe, pe, me);
  }
}, normalizeParseOptions = function L(ne) {
  if (!ne)
    return defaults;
  if (ne.decoder !== null && ne.decoder !== void 0 && typeof ne.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof ne.charset < "u" && ne.charset !== "utf-8" && ne.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var oe = typeof ne.charset > "u" ? defaults.charset : ne.charset;
  return {
    allowDots: typeof ne.allowDots > "u" ? defaults.allowDots : !!ne.allowDots,
    allowPrototypes: typeof ne.allowPrototypes == "boolean" ? ne.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof ne.allowSparse == "boolean" ? ne.allowSparse : defaults.allowSparse,
    arrayLimit: typeof ne.arrayLimit == "number" ? ne.arrayLimit : defaults.arrayLimit,
    charset: oe,
    charsetSentinel: typeof ne.charsetSentinel == "boolean" ? ne.charsetSentinel : defaults.charsetSentinel,
    comma: typeof ne.comma == "boolean" ? ne.comma : defaults.comma,
    decoder: typeof ne.decoder == "function" ? ne.decoder : defaults.decoder,
    delimiter: typeof ne.delimiter == "string" || utils.isRegExp(ne.delimiter) ? ne.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof ne.depth == "number" || ne.depth === !1 ? +ne.depth : defaults.depth,
    ignoreQueryPrefix: ne.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof ne.interpretNumericEntities == "boolean" ? ne.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof ne.parameterLimit == "number" ? ne.parameterLimit : defaults.parameterLimit,
    parseArrays: ne.parseArrays !== !1,
    plainObjects: typeof ne.plainObjects == "boolean" ? ne.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof ne.strictNullHandling == "boolean" ? ne.strictNullHandling : defaults.strictNullHandling
  };
}, parse$1 = function(L, ne) {
  var oe = normalizeParseOptions(ne);
  if (L === "" || L === null || typeof L > "u")
    return oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var pe = typeof L == "string" ? parseValues(L, oe) : L, me = oe.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, ge = Object.keys(pe), be = 0; be < ge.length; ++be) {
    var Ie = ge[be], Ae = parseKeys(Ie, pe[Ie], oe, typeof L == "string");
    me = utils.merge(me, Ae, oe);
  }
  return oe.allowSparse === !0 ? me : utils.compact(me);
}, stringify = stringify_1, parse = parse$1, formats = formats$3, lib = {
  formats,
  parse,
  stringify
}, nprogress = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(L, ne) {
  (function(oe, pe) {
    L.exports = pe();
  })(commonjsGlobal, function() {
    var oe = {};
    oe.version = "0.2.0";
    var pe = oe.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: !0,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: !0,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    oe.configure = function(it) {
      var ut, St;
      for (ut in it)
        St = it[ut], St !== void 0 && it.hasOwnProperty(ut) && (pe[ut] = St);
      return this;
    }, oe.status = null, oe.set = function(it) {
      var ut = oe.isStarted();
      it = me(it, pe.minimum, 1), oe.status = it === 1 ? null : it;
      var St = oe.render(!ut), ot = St.querySelector(pe.barSelector), ht = pe.speed, ft = pe.easing;
      return St.offsetWidth, Ie(function(vt) {
        pe.positionUsing === "" && (pe.positionUsing = oe.getPositioningCSS()), Ae(ot, be(it, ht, ft)), it === 1 ? (Ae(St, {
          transition: "none",
          opacity: 1
        }), St.offsetWidth, setTimeout(function() {
          Ae(St, {
            transition: "all " + ht + "ms linear",
            opacity: 0
          }), setTimeout(function() {
            oe.remove(), vt();
          }, ht);
        }, ht)) : setTimeout(vt, ht);
      }), this;
    }, oe.isStarted = function() {
      return typeof oe.status == "number";
    }, oe.start = function() {
      oe.status || oe.set(0);
      var it = function() {
        setTimeout(function() {
          oe.status && (oe.trickle(), it());
        }, pe.trickleSpeed);
      };
      return pe.trickle && it(), this;
    }, oe.done = function(it) {
      return !it && !oe.status ? this : oe.inc(0.3 + 0.5 * Math.random()).set(1);
    }, oe.inc = function(it) {
      var ut = oe.status;
      return ut ? (typeof it != "number" && (it = (1 - ut) * me(Math.random() * ut, 0.1, 0.95)), ut = me(ut + it, 0, 0.994), oe.set(ut)) : oe.start();
    }, oe.trickle = function() {
      return oe.inc(Math.random() * pe.trickleRate);
    }, function() {
      var it = 0, ut = 0;
      oe.promise = function(St) {
        return !St || St.state() === "resolved" ? this : (ut === 0 && oe.start(), it++, ut++, St.always(function() {
          ut--, ut === 0 ? (it = 0, oe.done()) : oe.set((it - ut) / it);
        }), this);
      };
    }(), oe.render = function(it) {
      if (oe.isRendered())
        return document.getElementById("nprogress");
      st(document.documentElement, "nprogress-busy");
      var ut = document.createElement("div");
      ut.id = "nprogress", ut.innerHTML = pe.template;
      var St = ut.querySelector(pe.barSelector), ot = it ? "-100" : ge(oe.status || 0), ht = document.querySelector(pe.parent), ft;
      return Ae(St, {
        transition: "all 0 linear",
        transform: "translate3d(" + ot + "%,0,0)"
      }), pe.showSpinner || (ft = ut.querySelector(pe.spinnerSelector), ft && pt(ft)), ht != document.body && st(ht, "nprogress-custom-parent"), ht.appendChild(ut), ut;
    }, oe.remove = function() {
      dt(document.documentElement, "nprogress-busy"), dt(document.querySelector(pe.parent), "nprogress-custom-parent");
      var it = document.getElementById("nprogress");
      it && pt(it);
    }, oe.isRendered = function() {
      return !!document.getElementById("nprogress");
    }, oe.getPositioningCSS = function() {
      var it = document.body.style, ut = "WebkitTransform" in it ? "Webkit" : "MozTransform" in it ? "Moz" : "msTransform" in it ? "ms" : "OTransform" in it ? "O" : "";
      return ut + "Perspective" in it ? "translate3d" : ut + "Transform" in it ? "translate" : "margin";
    };
    function me(it, ut, St) {
      return it < ut ? ut : it > St ? St : it;
    }
    function ge(it) {
      return (-1 + it) * 100;
    }
    function be(it, ut, St) {
      var ot;
      return pe.positionUsing === "translate3d" ? ot = { transform: "translate3d(" + ge(it) + "%,0,0)" } : pe.positionUsing === "translate" ? ot = { transform: "translate(" + ge(it) + "%,0)" } : ot = { "margin-left": ge(it) + "%" }, ot.transition = "all " + ut + "ms " + St, ot;
    }
    var Ie = /* @__PURE__ */ function() {
      var it = [];
      function ut() {
        var St = it.shift();
        St && St(ut);
      }
      return function(St) {
        it.push(St), it.length == 1 && ut();
      };
    }(), Ae = /* @__PURE__ */ function() {
      var it = ["Webkit", "O", "Moz", "ms"], ut = {};
      function St(vt) {
        return vt.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(Ct, xt) {
          return xt.toUpperCase();
        });
      }
      function ot(vt) {
        var Ct = document.body.style;
        if (vt in Ct)
          return vt;
        for (var xt = it.length, At = vt.charAt(0).toUpperCase() + vt.slice(1), kt; xt--; )
          if (kt = it[xt] + At, kt in Ct)
            return kt;
        return vt;
      }
      function ht(vt) {
        return vt = St(vt), ut[vt] || (ut[vt] = ot(vt));
      }
      function ft(vt, Ct, xt) {
        Ct = ht(Ct), vt.style[Ct] = xt;
      }
      return function(vt, Ct) {
        var xt = arguments, At, kt;
        if (xt.length == 2)
          for (At in Ct)
            kt = Ct[At], kt !== void 0 && Ct.hasOwnProperty(At) && ft(vt, At, kt);
        else
          ft(vt, xt[1], xt[2]);
      };
    }();
    function rt(it, ut) {
      var St = typeof it == "string" ? it : lt(it);
      return St.indexOf(" " + ut + " ") >= 0;
    }
    function st(it, ut) {
      var St = lt(it), ot = St + ut;
      rt(St, ut) || (it.className = ot.substring(1));
    }
    function dt(it, ut) {
      var St = lt(it), ot;
      rt(it, ut) && (ot = St.replace(" " + ut + " ", " "), it.className = ot.substring(1, ot.length - 1));
    }
    function lt(it) {
      return (" " + (it.className || "") + " ").replace(/\s+/gi, " ");
    }
    function pt(it) {
      it && it.parentNode && it.parentNode.removeChild(it);
    }
    return oe;
  });
})(nprogress);
function R(L, ne) {
  let oe;
  return function(...pe) {
    clearTimeout(oe), oe = setTimeout(() => L.apply(this, pe), ne);
  };
}
function f(L, ne) {
  return document.dispatchEvent(new CustomEvent(`inertia:${L}`, ne));
}
var M = (L) => f("before", { cancelable: !0, detail: { visit: L } }), j = (L) => f("error", { detail: { errors: L } }), H = (L) => f("exception", { cancelable: !0, detail: { exception: L } }), N$1 = (L) => f("finish", { detail: { visit: L } }), $ = (L) => f("invalid", { cancelable: !0, detail: { response: L } }), S = (L) => f("navigate", { detail: { page: L } }), q = (L) => f("progress", { detail: { progress: L } }), W = (L) => f("start", { detail: { visit: L } }), K = (L) => f("success", { detail: { page: L } });
function I(L) {
  return L instanceof File || L instanceof Blob || L instanceof FileList && L.length > 0 || L instanceof FormData && Array.from(L.values()).some((ne) => I(ne)) || typeof L == "object" && L !== null && Object.values(L).some((ne) => I(ne));
}
function A(L, ne = new FormData(), oe = null) {
  L = L || {};
  for (let pe in L)
    Object.prototype.hasOwnProperty.call(L, pe) && J(ne, X(oe, pe), L[pe]);
  return ne;
}
function X(L, ne) {
  return L ? L + "[" + ne + "]" : ne;
}
function J(L, ne, oe) {
  if (Array.isArray(oe))
    return Array.from(oe.keys()).forEach((pe) => J(L, X(ne, pe.toString()), oe[pe]));
  if (oe instanceof Date)
    return L.append(ne, oe.toISOString());
  if (oe instanceof File)
    return L.append(ne, oe, oe.name);
  if (oe instanceof Blob)
    return L.append(ne, oe);
  if (typeof oe == "boolean")
    return L.append(ne, oe ? "1" : "0");
  if (typeof oe == "string")
    return L.append(ne, oe);
  if (typeof oe == "number")
    return L.append(ne, `${oe}`);
  if (oe == null)
    return L.append(ne, "");
  A(oe, L, ne);
}
var z = { modal: null, listener: null, show(L) {
  typeof L == "object" && (L = `All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>${JSON.stringify(L)}`);
  let ne = document.createElement("html");
  ne.innerHTML = L, ne.querySelectorAll("a").forEach((pe) => pe.setAttribute("target", "_top")), this.modal = document.createElement("div"), this.modal.style.position = "fixed", this.modal.style.width = "100vw", this.modal.style.height = "100vh", this.modal.style.padding = "50px", this.modal.style.boxSizing = "border-box", this.modal.style.backgroundColor = "rgba(0, 0, 0, .6)", this.modal.style.zIndex = 2e5, this.modal.addEventListener("click", () => this.hide());
  let oe = document.createElement("iframe");
  if (oe.style.backgroundColor = "white", oe.style.borderRadius = "5px", oe.style.width = "100%", oe.style.height = "100%", this.modal.appendChild(oe), document.body.prepend(this.modal), document.body.style.overflow = "hidden", !oe.contentWindow)
    throw new Error("iframe not yet ready.");
  oe.contentWindow.document.open(), oe.contentWindow.document.write(ne.outerHTML), oe.contentWindow.document.close(), this.listener = this.hideOnEscape.bind(this), document.addEventListener("keydown", this.listener);
}, hide() {
  this.modal.outerHTML = "", this.modal = null, document.body.style.overflow = "visible", document.removeEventListener("keydown", this.listener);
}, hideOnEscape(L) {
  L.keyCode === 27 && this.hide();
} };
function v(L) {
  return new URL(L.toString(), window.location.toString());
}
function k(L, ne, oe, pe = "brackets") {
  let me = /^https?:\/\//.test(ne.toString()), ge = me || ne.toString().startsWith("/"), be = !ge && !ne.toString().startsWith("#") && !ne.toString().startsWith("?"), Ie = ne.toString().includes("?") || L === "get" && Object.keys(oe).length, Ae = ne.toString().includes("#"), rt = new URL(ne.toString(), "http://localhost");
  return L === "get" && Object.keys(oe).length && (rt.search = lib.stringify(te(lib.parse(rt.search, { ignoreQueryPrefix: !0 }), oe), { encodeValuesOnly: !0, arrayFormat: pe }), oe = {}), [[me ? `${rt.protocol}//${rt.host}` : "", ge ? rt.pathname : "", be ? rt.pathname.substring(1) : "", Ie ? rt.search : "", Ae ? rt.hash : ""].join(""), oe];
}
function w(L) {
  return L = new URL(L.href), L.hash = "", L;
}
var _ = typeof window > "u", C = class {
  constructor() {
    this.visitId = null;
  }
  init({ initialPage: L, resolveComponent: ne, swapComponent: oe }) {
    this.page = L, this.resolveComponent = ne, this.swapComponent = oe, this.setNavigationType(), this.clearRememberedStateOnReload(), this.isBackForwardVisit() ? this.handleBackForwardVisit(this.page) : this.isLocationVisit() ? this.handleLocationVisit(this.page) : this.handleInitialPageVisit(this.page), this.setupEventListeners();
  }
  setNavigationType() {
    this.navigationType = window.performance && window.performance.getEntriesByType("navigation").length > 0 ? window.performance.getEntriesByType("navigation")[0].type : "navigate";
  }
  clearRememberedStateOnReload() {
    var L;
    this.navigationType === "reload" && ((L = window.history.state) != null && L.rememberedState) && delete window.history.state.rememberedState;
  }
  handleInitialPageVisit(L) {
    this.page.url += window.location.hash, this.setPage(L, { preserveState: !0 }).then(() => S(L));
  }
  setupEventListeners() {
    window.addEventListener("popstate", this.handlePopstateEvent.bind(this)), document.addEventListener("scroll", R(this.handleScrollEvent.bind(this), 100), !0);
  }
  scrollRegions() {
    return document.querySelectorAll("[scroll-region]");
  }
  handleScrollEvent(L) {
    typeof L.target.hasAttribute == "function" && L.target.hasAttribute("scroll-region") && this.saveScrollPositions();
  }
  saveScrollPositions() {
    this.replaceState({ ...this.page, scrollRegions: Array.from(this.scrollRegions()).map((L) => ({ top: L.scrollTop, left: L.scrollLeft })) });
  }
  resetScrollPositions() {
    window.scrollTo(0, 0), this.scrollRegions().forEach((L) => {
      typeof L.scrollTo == "function" ? L.scrollTo(0, 0) : (L.scrollTop = 0, L.scrollLeft = 0);
    }), this.saveScrollPositions(), window.location.hash && setTimeout(() => {
      var L;
      return (L = document.getElementById(window.location.hash.slice(1))) == null ? void 0 : L.scrollIntoView();
    });
  }
  restoreScrollPositions() {
    this.page.scrollRegions && this.scrollRegions().forEach((L, ne) => {
      let oe = this.page.scrollRegions[ne];
      if (oe)
        typeof L.scrollTo == "function" ? L.scrollTo(oe.left, oe.top) : (L.scrollTop = oe.top, L.scrollLeft = oe.left);
      else
        return;
    });
  }
  isBackForwardVisit() {
    return window.history.state && this.navigationType === "back_forward";
  }
  handleBackForwardVisit(L) {
    window.history.state.version = L.version, this.setPage(window.history.state, { preserveScroll: !0, preserveState: !0 }).then(() => {
      this.restoreScrollPositions(), S(L);
    });
  }
  locationVisit(L, ne) {
    try {
      let oe = { preserveScroll: ne };
      window.sessionStorage.setItem("inertiaLocationVisit", JSON.stringify(oe)), window.location.href = L.href, w(window.location).href === w(L).href && window.location.reload();
    } catch {
      return !1;
    }
  }
  isLocationVisit() {
    try {
      return window.sessionStorage.getItem("inertiaLocationVisit") !== null;
    } catch {
      return !1;
    }
  }
  handleLocationVisit(L) {
    var oe, pe;
    let ne = JSON.parse(window.sessionStorage.getItem("inertiaLocationVisit") || "");
    window.sessionStorage.removeItem("inertiaLocationVisit"), L.url += window.location.hash, L.rememberedState = ((oe = window.history.state) == null ? void 0 : oe.rememberedState) ?? {}, L.scrollRegions = ((pe = window.history.state) == null ? void 0 : pe.scrollRegions) ?? [], this.setPage(L, { preserveScroll: ne.preserveScroll, preserveState: !0 }).then(() => {
      ne.preserveScroll && this.restoreScrollPositions(), S(L);
    });
  }
  isLocationVisitResponse(L) {
    return !!(L && L.status === 409 && L.headers["x-inertia-location"]);
  }
  isInertiaResponse(L) {
    return !!(L != null && L.headers["x-inertia"]);
  }
  createVisitId() {
    return this.visitId = {}, this.visitId;
  }
  cancelVisit(L, { cancelled: ne = !1, interrupted: oe = !1 }) {
    L && !L.completed && !L.cancelled && !L.interrupted && (L.cancelToken.abort(), L.onCancel(), L.completed = !1, L.cancelled = ne, L.interrupted = oe, N$1(L), L.onFinish(L));
  }
  finishVisit(L) {
    !L.cancelled && !L.interrupted && (L.completed = !0, L.cancelled = !1, L.interrupted = !1, N$1(L), L.onFinish(L));
  }
  resolvePreserveOption(L, ne) {
    return typeof L == "function" ? L(ne) : L === "errors" ? Object.keys(ne.props.errors || {}).length > 0 : L;
  }
  cancel() {
    this.activeVisit && this.cancelVisit(this.activeVisit, { cancelled: !0 });
  }
  visit(L, { method: ne = "get", data: oe = {}, replace: pe = !1, preserveScroll: me = !1, preserveState: ge = !1, only: be = [], headers: Ie = {}, errorBag: Ae = "", forceFormData: rt = !1, onCancelToken: st = () => {
  }, onBefore: dt = () => {
  }, onStart: lt = () => {
  }, onProgress: pt = () => {
  }, onFinish: it = () => {
  }, onCancel: ut = () => {
  }, onSuccess: St = () => {
  }, onError: ot = () => {
  }, queryStringArrayFormat: ht = "brackets" } = {}) {
    let ft = typeof L == "string" ? v(L) : L;
    if ((I(oe) || rt) && !(oe instanceof FormData) && (oe = A(oe)), !(oe instanceof FormData)) {
      let [xt, At] = k(ne, ft, oe, ht);
      ft = v(xt), oe = At;
    }
    let vt = { url: ft, method: ne, data: oe, replace: pe, preserveScroll: me, preserveState: ge, only: be, headers: Ie, errorBag: Ae, forceFormData: rt, queryStringArrayFormat: ht, cancelled: !1, completed: !1, interrupted: !1 };
    if (dt(vt) === !1 || !M(vt))
      return;
    this.activeVisit && this.cancelVisit(this.activeVisit, { interrupted: !0 }), this.saveScrollPositions();
    let Ct = this.createVisitId();
    this.activeVisit = { ...vt, onCancelToken: st, onBefore: dt, onStart: lt, onProgress: pt, onFinish: it, onCancel: ut, onSuccess: St, onError: ot, queryStringArrayFormat: ht, cancelToken: new AbortController() }, st({ cancel: () => {
      this.activeVisit && this.cancelVisit(this.activeVisit, { cancelled: !0 });
    } }), W(vt), lt(vt), axios({ method: ne, url: w(ft).href, data: ne === "get" ? {} : oe, params: ne === "get" ? oe : {}, signal: this.activeVisit.cancelToken.signal, headers: { ...Ie, Accept: "text/html, application/xhtml+xml", "X-Requested-With": "XMLHttpRequest", "X-Inertia": !0, ...be.length ? { "X-Inertia-Partial-Component": this.page.component, "X-Inertia-Partial-Data": be.join(",") } : {}, ...Ae && Ae.length ? { "X-Inertia-Error-Bag": Ae } : {}, ...this.page.version ? { "X-Inertia-Version": this.page.version } : {} }, onUploadProgress: (xt) => {
      oe instanceof FormData && (xt.percentage = xt.progress ? Math.round(xt.progress * 100) : 0, q(xt), pt(xt));
    } }).then((xt) => {
      var ir;
      if (!this.isInertiaResponse(xt))
        return Promise.reject({ response: xt });
      let At = xt.data;
      be.length && At.component === this.page.component && (At.props = { ...this.page.props, ...At.props }), me = this.resolvePreserveOption(me, At), ge = this.resolvePreserveOption(ge, At), ge && ((ir = window.history.state) != null && ir.rememberedState) && At.component === this.page.component && (At.rememberedState = window.history.state.rememberedState);
      let kt = ft, Vt = v(At.url);
      return kt.hash && !Vt.hash && w(kt).href === Vt.href && (Vt.hash = kt.hash, At.url = Vt.href), this.setPage(At, { visitId: Ct, replace: pe, preserveScroll: me, preserveState: ge });
    }).then(() => {
      let xt = this.page.props.errors || {};
      if (Object.keys(xt).length > 0) {
        let At = Ae ? xt[Ae] ? xt[Ae] : {} : xt;
        return j(At), ot(At);
      }
      return K(this.page), St(this.page);
    }).catch((xt) => {
      if (this.isInertiaResponse(xt.response))
        return this.setPage(xt.response.data, { visitId: Ct });
      if (this.isLocationVisitResponse(xt.response)) {
        let At = v(xt.response.headers["x-inertia-location"]), kt = ft;
        kt.hash && !At.hash && w(kt).href === At.href && (At.hash = kt.hash), this.locationVisit(At, me === !0);
      } else if (xt.response)
        $(xt.response) && z.show(xt.response.data);
      else
        return Promise.reject(xt);
    }).then(() => {
      this.activeVisit && this.finishVisit(this.activeVisit);
    }).catch((xt) => {
      if (!axios.isCancel(xt)) {
        let At = H(xt);
        if (this.activeVisit && this.finishVisit(this.activeVisit), At)
          return Promise.reject(xt);
      }
    });
  }
  setPage(L, { visitId: ne = this.createVisitId(), replace: oe = !1, preserveScroll: pe = !1, preserveState: me = !1 } = {}) {
    return Promise.resolve(this.resolveComponent(L.component)).then((ge) => {
      ne === this.visitId && (L.scrollRegions = L.scrollRegions || [], L.rememberedState = L.rememberedState || {}, oe = oe || v(L.url).href === window.location.href, oe ? this.replaceState(L) : this.pushState(L), this.swapComponent({ component: ge, page: L, preserveState: me }).then(() => {
        pe || this.resetScrollPositions(), oe || S(L);
      }));
    });
  }
  pushState(L) {
    this.page = L, window.history.pushState(L, "", L.url);
  }
  replaceState(L) {
    this.page = L, window.history.replaceState(L, "", L.url);
  }
  handlePopstateEvent(L) {
    if (L.state !== null) {
      let ne = L.state, oe = this.createVisitId();
      Promise.resolve(this.resolveComponent(ne.component)).then((pe) => {
        oe === this.visitId && (this.page = ne, this.swapComponent({ component: pe, page: ne, preserveState: !1 }).then(() => {
          this.restoreScrollPositions(), S(ne);
        }));
      });
    } else {
      let ne = v(this.page.url);
      ne.hash = window.location.hash, this.replaceState({ ...this.page, url: ne.href }), this.resetScrollPositions();
    }
  }
  get(L, ne = {}, oe = {}) {
    return this.visit(L, { ...oe, method: "get", data: ne });
  }
  reload(L = {}) {
    return this.visit(window.location.href, { ...L, preserveScroll: !0, preserveState: !0 });
  }
  replace(L, ne = {}) {
    return console.warn(`Inertia.replace() has been deprecated and will be removed in a future release. Please use Inertia.${ne.method ?? "get"}() instead.`), this.visit(L, { preserveState: !0, ...ne, replace: !0 });
  }
  post(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "post", data: ne });
  }
  put(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "put", data: ne });
  }
  patch(L, ne = {}, oe = {}) {
    return this.visit(L, { preserveState: !0, ...oe, method: "patch", data: ne });
  }
  delete(L, ne = {}) {
    return this.visit(L, { preserveState: !0, ...ne, method: "delete" });
  }
  remember(L, ne = "default") {
    var oe;
    _ || this.replaceState({ ...this.page, rememberedState: { ...(oe = this.page) == null ? void 0 : oe.rememberedState, [ne]: L } });
  }
  restore(L = "default") {
    var ne, oe;
    if (!_)
      return (oe = (ne = window.history.state) == null ? void 0 : ne.rememberedState) == null ? void 0 : oe[L];
  }
  on(L, ne) {
    let oe = (pe) => {
      let me = ne(pe);
      pe.cancelable && !pe.defaultPrevented && me === !1 && pe.preventDefault();
    };
    return document.addEventListener(`inertia:${L}`, oe), () => document.removeEventListener(`inertia:${L}`, oe);
  }
};
function ee(L) {
  let ne = L.currentTarget.tagName.toLowerCase() === "a";
  return !(L.target && (L == null ? void 0 : L.target).isContentEditable || L.defaultPrevented || ne && L.which > 1 || ne && L.altKey || ne && L.ctrlKey || ne && L.metaKey || ne && L.shiftKey);
}
var Oe = new C(), lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(L, ne) {
  var oe = 200, pe = "__lodash_hash_undefined__", me = 1, ge = 2, be = 9007199254740991, Ie = "[object Arguments]", Ae = "[object Array]", rt = "[object AsyncFunction]", st = "[object Boolean]", dt = "[object Date]", lt = "[object Error]", pt = "[object Function]", it = "[object GeneratorFunction]", ut = "[object Map]", St = "[object Number]", ot = "[object Null]", ht = "[object Object]", ft = "[object Promise]", vt = "[object Proxy]", Ct = "[object RegExp]", xt = "[object Set]", At = "[object String]", kt = "[object Symbol]", Vt = "[object Undefined]", ir = "[object WeakMap]", er = "[object ArrayBuffer]", Yt = "[object DataView]", Jt = "[object Float32Array]", rr = "[object Float64Array]", Qt = "[object Int8Array]", wt = "[object Int16Array]", Ft = "[object Int32Array]", yt = "[object Uint8Array]", Et = "[object Uint8ClampedArray]", Dt = "[object Uint16Array]", Ot = "[object Uint32Array]", nr = /[\\^$.*+?()[\]{}|]/g, vr = /^\[object .+?Constructor\]$/, pr = /^(?:0|[1-9]\d*)$/, xr = {};
  xr[Jt] = xr[rr] = xr[Qt] = xr[wt] = xr[Ft] = xr[yt] = xr[Et] = xr[Dt] = xr[Ot] = !0, xr[Ie] = xr[Ae] = xr[er] = xr[st] = xr[Yt] = xr[dt] = xr[lt] = xr[pt] = xr[ut] = xr[St] = xr[ht] = xr[Ct] = xr[xt] = xr[At] = xr[ir] = !1;
  var Ir = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, fn = typeof self == "object" && self && self.Object === Object && self, Zr = Ir || fn || Function("return this")(), xn = ne && !ne.nodeType && ne, kn = xn && !0 && L && !L.nodeType && L, Lr = kn && kn.exports === xn, en = Lr && Ir.process, Rr = function() {
    try {
      return en && en.binding && en.binding("util");
    } catch {
    }
  }(), cr = Rr && Rr.isTypedArray;
  function Nn(Rt, zt) {
    for (var ar = -1, gr = Rt == null ? 0 : Rt.length, yn = 0, jr = []; ++ar < gr; ) {
      var wn = Rt[ar];
      zt(wn, ar, Rt) && (jr[yn++] = wn);
    }
    return jr;
  }
  function Xn(Rt, zt) {
    for (var ar = -1, gr = zt.length, yn = Rt.length; ++ar < gr; )
      Rt[yn + ar] = zt[ar];
    return Rt;
  }
  function Mn(Rt, zt) {
    for (var ar = -1, gr = Rt == null ? 0 : Rt.length; ++ar < gr; )
      if (zt(Rt[ar], ar, Rt))
        return !0;
    return !1;
  }
  function Kn(Rt, zt) {
    for (var ar = -1, gr = Array(Rt); ++ar < Rt; )
      gr[ar] = zt(ar);
    return gr;
  }
  function Ri(Rt) {
    return function(zt) {
      return Rt(zt);
    };
  }
  function Si(Rt, zt) {
    return Rt.has(zt);
  }
  function Fn(Rt, zt) {
    return Rt == null ? void 0 : Rt[zt];
  }
  function ki(Rt) {
    var zt = -1, ar = Array(Rt.size);
    return Rt.forEach(function(gr, yn) {
      ar[++zt] = [yn, gr];
    }), ar;
  }
  function Jn(Rt, zt) {
    return function(ar) {
      return Rt(zt(ar));
    };
  }
  function Zn(Rt) {
    var zt = -1, ar = Array(Rt.size);
    return Rt.forEach(function(gr) {
      ar[++zt] = gr;
    }), ar;
  }
  var ui = Array.prototype, ei = Function.prototype, Tn = Object.prototype, hi = Zr["__core-js_shared__"], za = ei.toString, zn = Tn.hasOwnProperty, mr = function() {
    var Rt = /[^.]+$/.exec(hi && hi.keys && hi.keys.IE_PROTO || "");
    return Rt ? "Symbol(src)_1." + Rt : "";
  }(), Fr = Tn.toString, Kr = RegExp(
    "^" + za.call(zn).replace(nr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), pn = Lr ? Zr.Buffer : void 0, Rn = Zr.Symbol, Ei = Zr.Uint8Array, ti = Tn.propertyIsEnumerable, Ea = ui.splice, mn = Rn ? Rn.toStringTag : void 0, Va = Object.getOwnPropertySymbols, ri = pn ? pn.isBuffer : void 0, Vn = Jn(Object.keys, Object), ou = zo(Zr, "DataView"), Oo = zo(Zr, "Map"), ks = zo(Zr, "Promise"), su = zo(Zr, "Set"), lu = zo(Zr, "WeakMap"), Lo = zo(Object, "create"), cf = pi(ou), dl = pi(Oo), uu = pi(ks), es = pi(su), Ms = pi(lu), ba = Rn ? Rn.prototype : void 0, Ba = ba ? ba.valueOf : void 0;
  function Ca(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var gr = Rt[zt];
      this.set(gr[0], gr[1]);
    }
  }
  function hl() {
    this.__data__ = Lo ? Lo(null) : {}, this.size = 0;
  }
  function df(Rt) {
    var zt = this.has(Rt) && delete this.__data__[Rt];
    return this.size -= zt ? 1 : 0, zt;
  }
  function hf(Rt) {
    var zt = this.__data__;
    if (Lo) {
      var ar = zt[Rt];
      return ar === pe ? void 0 : ar;
    }
    return zn.call(zt, Rt) ? zt[Rt] : void 0;
  }
  function Fs(Rt) {
    var zt = this.__data__;
    return Lo ? zt[Rt] !== void 0 : zn.call(zt, Rt);
  }
  function to(Rt, zt) {
    var ar = this.__data__;
    return this.size += this.has(Rt) ? 0 : 1, ar[Rt] = Lo && zt === void 0 ? pe : zt, this;
  }
  Ca.prototype.clear = hl, Ca.prototype.delete = df, Ca.prototype.get = hf, Ca.prototype.has = Fs, Ca.prototype.set = to;
  function oa(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var gr = Rt[zt];
      this.set(gr[0], gr[1]);
    }
  }
  function Ds() {
    this.__data__ = [], this.size = 0;
  }
  function Bi(Rt) {
    var zt = this.__data__, ar = fu(zt, Rt);
    if (ar < 0)
      return !1;
    var gr = zt.length - 1;
    return ar == gr ? zt.pop() : Ea.call(zt, ar, 1), --this.size, !0;
  }
  function gc(Rt) {
    var zt = this.__data__, ar = fu(zt, Rt);
    return ar < 0 ? void 0 : zt[ar][1];
  }
  function Sc(Rt) {
    return fu(this.__data__, Rt) > -1;
  }
  function pf(Rt, zt) {
    var ar = this.__data__, gr = fu(ar, Rt);
    return gr < 0 ? (++this.size, ar.push([Rt, zt])) : ar[gr][1] = zt, this;
  }
  oa.prototype.clear = Ds, oa.prototype.delete = Bi, oa.prototype.get = gc, oa.prototype.has = Sc, oa.prototype.set = pf;
  function $o(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.clear(); ++zt < ar; ) {
      var gr = Rt[zt];
      this.set(gr[0], gr[1]);
    }
  }
  function fh() {
    this.size = 0, this.__data__ = {
      hash: new Ca(),
      map: new (Oo || oa)(),
      string: new Ca()
    };
  }
  function ch(Rt) {
    var zt = ln(this, Rt).delete(Rt);
    return this.size -= zt ? 1 : 0, zt;
  }
  function Bn(Rt) {
    return ln(this, Rt).get(Rt);
  }
  function dh(Rt) {
    return ln(this, Rt).has(Rt);
  }
  function To(Rt, zt) {
    var ar = ln(this, Rt), gr = ar.size;
    return ar.set(Rt, zt), this.size += ar.size == gr ? 0 : 1, this;
  }
  $o.prototype.clear = fh, $o.prototype.delete = ch, $o.prototype.get = Bn, $o.prototype.has = dh, $o.prototype.set = To;
  function Xr(Rt) {
    var zt = -1, ar = Rt == null ? 0 : Rt.length;
    for (this.__data__ = new $o(); ++zt < ar; )
      this.add(Rt[zt]);
  }
  function Io(Rt) {
    return this.__data__.set(Rt, pe), this;
  }
  function Ec(Rt) {
    return this.__data__.has(Rt);
  }
  Xr.prototype.add = Xr.prototype.push = Io, Xr.prototype.has = Ec;
  function ro(Rt) {
    var zt = this.__data__ = new oa(Rt);
    this.size = zt.size;
  }
  function pl() {
    this.__data__ = new oa(), this.size = 0;
  }
  function Ha(Rt) {
    var zt = this.__data__, ar = zt.delete(Rt);
    return this.size = zt.size, ar;
  }
  function bc(Rt) {
    return this.__data__.get(Rt);
  }
  function xa(Rt) {
    return this.__data__.has(Rt);
  }
  function Cc(Rt, zt) {
    var ar = this.__data__;
    if (ar instanceof oa) {
      var gr = ar.__data__;
      if (!Oo || gr.length < oe - 1)
        return gr.push([Rt, zt]), this.size = ++ar.size, this;
      ar = this.__data__ = new $o(gr);
    }
    return ar.set(Rt, zt), this.size = ar.size, this;
  }
  ro.prototype.clear = pl, ro.prototype.delete = Ha, ro.prototype.get = bc, ro.prototype.has = xa, ro.prototype.set = Cc;
  function xc(Rt, zt) {
    var ar = Hn(Rt), gr = !ar && vl(Rt), yn = !ar && !gr && gf(Rt), jr = !ar && !gr && !yn && vu(Rt), wn = ar || gr || yn || jr, ii = wn ? Kn(Rt.length, String) : [], _n = ii.length;
    for (var En in Rt)
      (zt || zn.call(Rt, En)) && !(wn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (En == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      yn && (En == "offset" || En == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      jr && (En == "buffer" || En == "byteLength" || En == "byteOffset") || // Skip index properties.
      wc(En, _n))) && ii.push(En);
    return ii;
  }
  function fu(Rt, zt) {
    for (var ar = Rt.length; ar--; )
      if (sa(Rt[ar][0], zt))
        return ar;
    return -1;
  }
  function cu(Rt, zt, ar) {
    var gr = zt(Rt);
    return Hn(Rt) ? gr : Xn(gr, ar(Rt));
  }
  function no(Rt) {
    return Rt == null ? Rt === void 0 ? Vt : ot : mn && mn in Object(Rt) ? Tc(Rt) : ni(Rt);
  }
  function No(Rt) {
    return io(Rt) && no(Rt) == Ie;
  }
  function Ta(Rt, zt, ar, gr, yn) {
    return Rt === zt ? !0 : Rt == null || zt == null || !io(Rt) && !io(zt) ? Rt !== Rt && zt !== zt : mf(Rt, zt, ar, gr, Ta, yn);
  }
  function mf(Rt, zt, ar, gr, yn, jr) {
    var wn = Hn(Rt), ii = Hn(zt), _n = wn ? Ae : nn(Rt), En = ii ? Ae : nn(zt);
    _n = _n == Ie ? ht : _n, En = En == Ie ? ht : En;
    var Ci = _n == ht, la = En == ht, Gn = _n == En;
    if (Gn && gf(Rt)) {
      if (!gf(zt))
        return !1;
      wn = !0, Ci = !1;
    }
    if (Gn && !Ci)
      return jr || (jr = new ro()), wn || vu(Rt) ? pu(Rt, zt, ar, gr, yn, jr) : ts(Rt, zt, _n, ar, gr, yn, jr);
    if (!(ar & me)) {
      var Mi = Ci && zn.call(Rt, "__wrapped__"), ua = la && zn.call(zt, "__wrapped__");
      if (Mi || ua) {
        var ai = Mi ? Rt.value() : Rt, Fi = ua ? zt.value() : zt;
        return jr || (jr = new ro()), yn(ai, Fi, ar, gr, jr);
      }
    }
    return Gn ? (jr || (jr = new ro()), hh(Rt, zt, ar, gr, yn, jr)) : !1;
  }
  function du(Rt) {
    if (!Sf(Rt) || Gr(Rt))
      return !1;
    var zt = bi(Rt) ? Kr : vr;
    return zt.test(pi(Rt));
  }
  function vf(Rt) {
    return io(Rt) && wo(Rt.length) && !!xr[no(Rt)];
  }
  function hu(Rt) {
    if (!ml(Rt))
      return Vn(Rt);
    var zt = [];
    for (var ar in Object(Rt))
      zn.call(Rt, ar) && ar != "constructor" && zt.push(ar);
    return zt;
  }
  function pu(Rt, zt, ar, gr, yn, jr) {
    var wn = ar & me, ii = Rt.length, _n = zt.length;
    if (ii != _n && !(wn && _n > ii))
      return !1;
    var En = jr.get(Rt);
    if (En && jr.get(zt))
      return En == zt;
    var Ci = -1, la = !0, Gn = ar & ge ? new Xr() : void 0;
    for (jr.set(Rt, zt), jr.set(zt, Rt); ++Ci < ii; ) {
      var Mi = Rt[Ci], ua = zt[Ci];
      if (gr)
        var ai = wn ? gr(ua, Mi, Ci, zt, Rt, jr) : gr(Mi, ua, Ci, Rt, zt, jr);
      if (ai !== void 0) {
        if (ai)
          continue;
        la = !1;
        break;
      }
      if (Gn) {
        if (!Mn(zt, function(Fi, ao) {
          if (!Si(Gn, ao) && (Mi === Fi || yn(Mi, Fi, ar, gr, jr)))
            return Gn.push(ao);
        })) {
          la = !1;
          break;
        }
      } else if (!(Mi === ua || yn(Mi, ua, ar, gr, jr))) {
        la = !1;
        break;
      }
    }
    return jr.delete(Rt), jr.delete(zt), la;
  }
  function ts(Rt, zt, ar, gr, yn, jr, wn) {
    switch (ar) {
      case Yt:
        if (Rt.byteLength != zt.byteLength || Rt.byteOffset != zt.byteOffset)
          return !1;
        Rt = Rt.buffer, zt = zt.buffer;
      case er:
        return !(Rt.byteLength != zt.byteLength || !jr(new Ei(Rt), new Ei(zt)));
      case st:
      case dt:
      case St:
        return sa(+Rt, +zt);
      case lt:
        return Rt.name == zt.name && Rt.message == zt.message;
      case Ct:
      case At:
        return Rt == zt + "";
      case ut:
        var ii = ki;
      case xt:
        var _n = gr & me;
        if (ii || (ii = Zn), Rt.size != zt.size && !_n)
          return !1;
        var En = wn.get(Rt);
        if (En)
          return En == zt;
        gr |= ge, wn.set(Rt, zt);
        var Ci = pu(ii(Rt), ii(zt), gr, yn, jr, wn);
        return wn.delete(Rt), Ci;
      case kt:
        if (Ba)
          return Ba.call(Rt) == Ba.call(zt);
    }
    return !1;
  }
  function hh(Rt, zt, ar, gr, yn, jr) {
    var wn = ar & me, ii = Os(Rt), _n = ii.length, En = Os(zt), Ci = En.length;
    if (_n != Ci && !wn)
      return !1;
    for (var la = _n; la--; ) {
      var Gn = ii[la];
      if (!(wn ? Gn in zt : zn.call(zt, Gn)))
        return !1;
    }
    var Mi = jr.get(Rt);
    if (Mi && jr.get(zt))
      return Mi == zt;
    var ua = !0;
    jr.set(Rt, zt), jr.set(zt, Rt);
    for (var ai = wn; ++la < _n; ) {
      Gn = ii[la];
      var Fi = Rt[Gn], ao = zt[Gn];
      if (gr)
        var rs = wn ? gr(ao, Fi, Gn, zt, Rt, jr) : gr(Fi, ao, Gn, Rt, zt, jr);
      if (!(rs === void 0 ? Fi === ao || yn(Fi, ao, ar, gr, jr) : rs)) {
        ua = !1;
        break;
      }
      ai || (ai = Gn == "constructor");
    }
    if (ua && !ai) {
      var Sl = Rt.constructor, ns = zt.constructor;
      Sl != ns && "constructor" in Rt && "constructor" in zt && !(typeof Sl == "function" && Sl instanceof Sl && typeof ns == "function" && ns instanceof ns) && (ua = !1);
    }
    return jr.delete(Rt), jr.delete(zt), ua;
  }
  function Os(Rt) {
    return cu(Rt, _c, mu);
  }
  function ln(Rt, zt) {
    var ar = Rt.__data__;
    return yf(zt) ? ar[typeof zt == "string" ? "string" : "hash"] : ar.map;
  }
  function zo(Rt, zt) {
    var ar = Fn(Rt, zt);
    return du(ar) ? ar : void 0;
  }
  function Tc(Rt) {
    var zt = zn.call(Rt, mn), ar = Rt[mn];
    try {
      Rt[mn] = void 0;
      var gr = !0;
    } catch {
    }
    var yn = Fr.call(Rt);
    return gr && (zt ? Rt[mn] = ar : delete Rt[mn]), yn;
  }
  var mu = Va ? function(Rt) {
    return Rt == null ? [] : (Rt = Object(Rt), Nn(Va(Rt), function(zt) {
      return ti.call(Rt, zt);
    }));
  } : yl, nn = no;
  (ou && nn(new ou(new ArrayBuffer(1))) != Yt || Oo && nn(new Oo()) != ut || ks && nn(ks.resolve()) != ft || su && nn(new su()) != xt || lu && nn(new lu()) != ir) && (nn = function(Rt) {
    var zt = no(Rt), ar = zt == ht ? Rt.constructor : void 0, gr = ar ? pi(ar) : "";
    if (gr)
      switch (gr) {
        case cf:
          return Yt;
        case dl:
          return ut;
        case uu:
          return ft;
        case es:
          return xt;
        case Ms:
          return ir;
      }
    return zt;
  });
  function wc(Rt, zt) {
    return zt = zt ?? be, !!zt && (typeof Rt == "number" || pr.test(Rt)) && Rt > -1 && Rt % 1 == 0 && Rt < zt;
  }
  function yf(Rt) {
    var zt = typeof Rt;
    return zt == "string" || zt == "number" || zt == "symbol" || zt == "boolean" ? Rt !== "__proto__" : Rt === null;
  }
  function Gr(Rt) {
    return !!mr && mr in Rt;
  }
  function ml(Rt) {
    var zt = Rt && Rt.constructor, ar = typeof zt == "function" && zt.prototype || Tn;
    return Rt === ar;
  }
  function ni(Rt) {
    return Fr.call(Rt);
  }
  function pi(Rt) {
    if (Rt != null) {
      try {
        return za.call(Rt);
      } catch {
      }
      try {
        return Rt + "";
      } catch {
      }
    }
    return "";
  }
  function sa(Rt, zt) {
    return Rt === zt || Rt !== Rt && zt !== zt;
  }
  var vl = No(/* @__PURE__ */ function() {
    return arguments;
  }()) ? No : function(Rt) {
    return io(Rt) && zn.call(Rt, "callee") && !ti.call(Rt, "callee");
  }, Hn = Array.isArray;
  function vn(Rt) {
    return Rt != null && wo(Rt.length) && !bi(Rt);
  }
  var gf = ri || gl;
  function Ua(Rt, zt) {
    return Ta(Rt, zt);
  }
  function bi(Rt) {
    if (!Sf(Rt))
      return !1;
    var zt = no(Rt);
    return zt == pt || zt == it || zt == rt || zt == vt;
  }
  function wo(Rt) {
    return typeof Rt == "number" && Rt > -1 && Rt % 1 == 0 && Rt <= be;
  }
  function Sf(Rt) {
    var zt = typeof Rt;
    return Rt != null && (zt == "object" || zt == "function");
  }
  function io(Rt) {
    return Rt != null && typeof Rt == "object";
  }
  var vu = cr ? Ri(cr) : vf;
  function _c(Rt) {
    return vn(Rt) ? xc(Rt) : hu(Rt);
  }
  function yl() {
    return [];
  }
  function gl() {
    return !1;
  }
  L.exports = Ua;
})(lodash_isequal, lodash_isequal.exports);
lodash_isequal.exports;
var B = createContext(void 0);
B.displayName = "InertiaHeadContext";
var N = createContext(void 0);
N.displayName = "InertiaPageContext";
var F = () => {
}, V = forwardRef(({ children: L, as: ne = "a", data: oe = {}, href: pe, method: me = "get", preserveScroll: ge = !1, preserveState: be = null, replace: Ie = !1, only: Ae = [], headers: rt = {}, queryStringArrayFormat: st = "brackets", onClick: dt = F, onCancelToken: lt = F, onBefore: pt = F, onStart: it = F, onProgress: ut = F, onFinish: St = F, onCancel: ot = F, onSuccess: ht = F, onError: ft = F, ...vt }, Ct) => {
  let xt = useCallback((Vt) => {
    dt(Vt), ee(Vt) && (Vt.preventDefault(), Oe.visit(pe, { data: oe, method: me, preserveScroll: ge, preserveState: be ?? me !== "get", replace: Ie, only: Ae, headers: rt, onCancelToken: lt, onBefore: pt, onStart: it, onProgress: ut, onFinish: St, onCancel: ot, onSuccess: ht, onError: ft }));
  }, [oe, pe, me, ge, be, Ie, Ae, rt, dt, lt, pt, it, ut, St, ot, ht, ft]);
  ne = ne.toLowerCase(), me = me.toLowerCase();
  let [At, kt] = k(me, pe || "", oe, st);
  return pe = At, oe = kt, ne === "a" && me !== "get" && console.warn(`Creating POST/PUT/PATCH/DELETE <a> links is discouraged as it causes "Open Link in New Tab/Window" accessibility issues.

Please specify a more appropriate element using the "as" attribute. For example:

<Link href="${pe}" method="${me}" as="button">...</Link>`), createElement(ne, { ...vt, ...ne === "a" ? { href: pe } : {}, ref: Ct, onClick: xt }, L);
});
V.displayName = "InertiaLink";
export {
  MainNavbar,
  MainSidebar
};
